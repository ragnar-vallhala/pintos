/* AUTOMATICALLY GENERATED by qapi-gen.py DO NOT MODIFY */

/*
 * Schema-defined QAPI types
 *
 * Copyright IBM, Corp. 2011
 * Copyright (c) 2013-2018 Red Hat Inc.
 *
 * This work is licensed under the terms of the GNU LGPL, version 2.1 or later.
 * See the COPYING.LIB file in the top-level directory.
 */

#ifndef QAPI_TYPES_CXL_H
#define QAPI_TYPES_CXL_H

#include "qapi/qapi-builtin-types.h"

typedef enum CxlEventLog {
    CXL_EVENT_LOG_INFORMATIONAL,
    CXL_EVENT_LOG_WARNING,
    CXL_EVENT_LOG_FAILURE,
    CXL_EVENT_LOG_FATAL,
    CXL_EVENT_LOG__MAX,
} CxlEventLog;

#define CxlEventLog_str(val) \
    qapi_enum_lookup(&CxlEventLog_lookup, (val))

extern const QEnumLookup CxlEventLog_lookup;

typedef struct q_obj_cxl_inject_general_media_event_arg q_obj_cxl_inject_general_media_event_arg;

typedef struct q_obj_cxl_inject_dram_event_arg q_obj_cxl_inject_dram_event_arg;

typedef struct q_obj_cxl_inject_memory_module_event_arg q_obj_cxl_inject_memory_module_event_arg;

typedef struct q_obj_cxl_inject_poison_arg q_obj_cxl_inject_poison_arg;

typedef enum CxlUncorErrorType {
    CXL_UNCOR_ERROR_TYPE_CACHE_DATA_PARITY,
    CXL_UNCOR_ERROR_TYPE_CACHE_ADDRESS_PARITY,
    CXL_UNCOR_ERROR_TYPE_CACHE_BE_PARITY,
    CXL_UNCOR_ERROR_TYPE_CACHE_DATA_ECC,
    CXL_UNCOR_ERROR_TYPE_MEM_DATA_PARITY,
    CXL_UNCOR_ERROR_TYPE_MEM_ADDRESS_PARITY,
    CXL_UNCOR_ERROR_TYPE_MEM_BE_PARITY,
    CXL_UNCOR_ERROR_TYPE_MEM_DATA_ECC,
    CXL_UNCOR_ERROR_TYPE_REINIT_THRESHOLD,
    CXL_UNCOR_ERROR_TYPE_RSVD_ENCODING,
    CXL_UNCOR_ERROR_TYPE_POISON_RECEIVED,
    CXL_UNCOR_ERROR_TYPE_RECEIVER_OVERFLOW,
    CXL_UNCOR_ERROR_TYPE_INTERNAL,
    CXL_UNCOR_ERROR_TYPE_CXL_IDE_TX,
    CXL_UNCOR_ERROR_TYPE_CXL_IDE_RX,
    CXL_UNCOR_ERROR_TYPE__MAX,
} CxlUncorErrorType;

#define CxlUncorErrorType_str(val) \
    qapi_enum_lookup(&CxlUncorErrorType_lookup, (val))

extern const QEnumLookup CxlUncorErrorType_lookup;

typedef struct CXLUncorErrorRecord CXLUncorErrorRecord;

typedef struct CXLUncorErrorRecordList CXLUncorErrorRecordList;

typedef struct q_obj_cxl_inject_uncorrectable_errors_arg q_obj_cxl_inject_uncorrectable_errors_arg;

typedef enum CxlCorErrorType {
    CXL_COR_ERROR_TYPE_CACHE_DATA_ECC,
    CXL_COR_ERROR_TYPE_MEM_DATA_ECC,
    CXL_COR_ERROR_TYPE_CRC_THRESHOLD,
    CXL_COR_ERROR_TYPE_RETRY_THRESHOLD,
    CXL_COR_ERROR_TYPE_CACHE_POISON_RECEIVED,
    CXL_COR_ERROR_TYPE_MEM_POISON_RECEIVED,
    CXL_COR_ERROR_TYPE_PHYSICAL,
    CXL_COR_ERROR_TYPE__MAX,
} CxlCorErrorType;

#define CxlCorErrorType_str(val) \
    qapi_enum_lookup(&CxlCorErrorType_lookup, (val))

extern const QEnumLookup CxlCorErrorType_lookup;

typedef struct q_obj_cxl_inject_correctable_error_arg q_obj_cxl_inject_correctable_error_arg;

typedef struct CxlDynamicCapacityExtent CxlDynamicCapacityExtent;

typedef enum CxlExtentSelectionPolicy {
    CXL_EXTENT_SELECTION_POLICY_FREE,
    CXL_EXTENT_SELECTION_POLICY_CONTIGUOUS,
    CXL_EXTENT_SELECTION_POLICY_PRESCRIPTIVE,
    CXL_EXTENT_SELECTION_POLICY_ENABLE_SHARED_ACCESS,
    CXL_EXTENT_SELECTION_POLICY__MAX,
} CxlExtentSelectionPolicy;

#define CxlExtentSelectionPolicy_str(val) \
    qapi_enum_lookup(&CxlExtentSelectionPolicy_lookup, (val))

extern const QEnumLookup CxlExtentSelectionPolicy_lookup;

typedef struct CxlDynamicCapacityExtentList CxlDynamicCapacityExtentList;

typedef struct q_obj_cxl_add_dynamic_capacity_arg q_obj_cxl_add_dynamic_capacity_arg;

typedef enum CxlExtentRemovalPolicy {
    CXL_EXTENT_REMOVAL_POLICY_TAG_BASED,
    CXL_EXTENT_REMOVAL_POLICY_PRESCRIPTIVE,
    CXL_EXTENT_REMOVAL_POLICY__MAX,
} CxlExtentRemovalPolicy;

#define CxlExtentRemovalPolicy_str(val) \
    qapi_enum_lookup(&CxlExtentRemovalPolicy_lookup, (val))

extern const QEnumLookup CxlExtentRemovalPolicy_lookup;

typedef struct q_obj_cxl_release_dynamic_capacity_arg q_obj_cxl_release_dynamic_capacity_arg;

struct q_obj_cxl_inject_general_media_event_arg {
    char *path;
    CxlEventLog log;
    uint8_t flags;
    uint64_t dpa;
    uint8_t descriptor;
    uint8_t type;
    uint8_t transaction_type;
    bool has_channel;
    uint8_t channel;
    bool has_rank;
    uint8_t rank;
    bool has_device;
    uint32_t device;
    char *component_id;
};

struct q_obj_cxl_inject_dram_event_arg {
    char *path;
    CxlEventLog log;
    uint8_t flags;
    uint64_t dpa;
    uint8_t descriptor;
    uint8_t type;
    uint8_t transaction_type;
    bool has_channel;
    uint8_t channel;
    bool has_rank;
    uint8_t rank;
    bool has_nibble_mask;
    uint32_t nibble_mask;
    bool has_bank_group;
    uint8_t bank_group;
    bool has_bank;
    uint8_t bank;
    bool has_row;
    uint32_t row;
    bool has_column;
    uint16_t column;
    bool has_correction_mask;
    uint64List *correction_mask;
};

struct q_obj_cxl_inject_memory_module_event_arg {
    char *path;
    CxlEventLog log;
    uint8_t flags;
    uint8_t type;
    uint8_t health_status;
    uint8_t media_status;
    uint8_t additional_status;
    uint8_t life_used;
    int16_t temperature;
    uint32_t dirty_shutdown_count;
    uint32_t corrected_volatile_error_count;
    uint32_t corrected_persistent_error_count;
};

struct q_obj_cxl_inject_poison_arg {
    char *path;
    uint64_t start;
    uint64_t length;
};

struct CXLUncorErrorRecord {
    CxlUncorErrorType type;
    uint32List *header;
};

void qapi_free_CXLUncorErrorRecord(CXLUncorErrorRecord *obj);
G_DEFINE_AUTOPTR_CLEANUP_FUNC(CXLUncorErrorRecord, qapi_free_CXLUncorErrorRecord)

struct CXLUncorErrorRecordList {
    CXLUncorErrorRecordList *next;
    CXLUncorErrorRecord *value;
};

void qapi_free_CXLUncorErrorRecordList(CXLUncorErrorRecordList *obj);
G_DEFINE_AUTOPTR_CLEANUP_FUNC(CXLUncorErrorRecordList, qapi_free_CXLUncorErrorRecordList)

struct q_obj_cxl_inject_uncorrectable_errors_arg {
    char *path;
    CXLUncorErrorRecordList *errors;
};

struct q_obj_cxl_inject_correctable_error_arg {
    char *path;
    CxlCorErrorType type;
};

struct CxlDynamicCapacityExtent {
    uint64_t offset;
    uint64_t len;
};

void qapi_free_CxlDynamicCapacityExtent(CxlDynamicCapacityExtent *obj);
G_DEFINE_AUTOPTR_CLEANUP_FUNC(CxlDynamicCapacityExtent, qapi_free_CxlDynamicCapacityExtent)

struct CxlDynamicCapacityExtentList {
    CxlDynamicCapacityExtentList *next;
    CxlDynamicCapacityExtent *value;
};

void qapi_free_CxlDynamicCapacityExtentList(CxlDynamicCapacityExtentList *obj);
G_DEFINE_AUTOPTR_CLEANUP_FUNC(CxlDynamicCapacityExtentList, qapi_free_CxlDynamicCapacityExtentList)

struct q_obj_cxl_add_dynamic_capacity_arg {
    char *path;
    uint16_t host_id;
    CxlExtentSelectionPolicy selection_policy;
    uint8_t region;
    char *tag;
    CxlDynamicCapacityExtentList *extents;
};

struct q_obj_cxl_release_dynamic_capacity_arg {
    char *path;
    uint16_t host_id;
    CxlExtentRemovalPolicy removal_policy;
    bool has_forced_removal;
    bool forced_removal;
    bool has_sanitize_on_release;
    bool sanitize_on_release;
    uint8_t region;
    char *tag;
    CxlDynamicCapacityExtentList *extents;
};

#endif /* QAPI_TYPES_CXL_H */
