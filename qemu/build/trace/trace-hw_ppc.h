/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_PPC_GENERATED_TRACERS_H
#define TRACE_HW_PPC_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_SPAPR_PCI_MSI_EVENT;
extern TraceEvent _TRACE_SPAPR_PCI_MSI_SETUP_EVENT;
extern TraceEvent _TRACE_SPAPR_PCI_RTAS_IBM_CHANGE_MSI_EVENT;
extern TraceEvent _TRACE_SPAPR_PCI_RTAS_IBM_QUERY_INTERRUPT_SOURCE_NUMBER_EVENT;
extern TraceEvent _TRACE_SPAPR_PCI_MSI_WRITE_EVENT;
extern TraceEvent _TRACE_SPAPR_PCI_LSI_SET_EVENT;
extern TraceEvent _TRACE_SPAPR_PCI_MSI_RETRY_EVENT;
extern TraceEvent _TRACE_SPAPR_CAS_CONTINUE_EVENT;
extern TraceEvent _TRACE_SPAPR_CAS_PVR_EVENT;
extern TraceEvent _TRACE_SPAPR_H_RESIZE_HPT_PREPARE_EVENT;
extern TraceEvent _TRACE_SPAPR_H_RESIZE_HPT_COMMIT_EVENT;
extern TraceEvent _TRACE_SPAPR_UPDATE_DT_EVENT;
extern TraceEvent _TRACE_SPAPR_UPDATE_DT_FAILED_SIZE_EVENT;
extern TraceEvent _TRACE_SPAPR_UPDATE_DT_FAILED_CHECK_EVENT;
extern TraceEvent _TRACE_SPAPR_H_TPM_COMM_EVENT;
extern TraceEvent _TRACE_SPAPR_TPM_EXECUTE_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_PUT_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_GET_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_INDIRECT_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_STUFF_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_PCI_PUT_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_PCI_GET_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_PCI_INDIRECT_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_PCI_STUFF_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_XLATE_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_NEW_TABLE_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_PRE_SAVE_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_POST_LOAD_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_DDW_QUERY_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_DDW_CREATE_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_DDW_REMOVE_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_DDW_RESET_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_SET_ISOLATION_STATE_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_SET_ISOLATION_STATE_FINALIZING_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_SET_DR_INDICATOR_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_SET_ALLOCATION_STATE_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_SET_ALLOCATION_STATE_FINALIZING_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_SET_CONFIGURED_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_ATTACH_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_UNPLUG_REQUEST_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_AWAITING_QUIESCE_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_RESET_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_REALIZE_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_REALIZE_CHILD_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_REALIZE_COMPLETE_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_UNREALIZE_EVENT;
extern TraceEvent _TRACE_SPAPR_OVEC_PARSE_VECTOR_EVENT;
extern TraceEvent _TRACE_SPAPR_OVEC_POPULATE_DT_EVENT;
extern TraceEvent _TRACE_SPAPR_RTAS_GET_SENSOR_STATE_NOT_SUPPORTED_EVENT;
extern TraceEvent _TRACE_SPAPR_RTAS_GET_SENSOR_STATE_INVALID_EVENT;
extern TraceEvent _TRACE_SPAPR_RTAS_IBM_CONFIGURE_CONNECTOR_INVALID_EVENT;
extern TraceEvent _TRACE_SPAPR_VIO_H_REG_CRQ_EVENT;
extern TraceEvent _TRACE_SPAPR_VIO_FREE_CRQ_EVENT;
extern TraceEvent _TRACE_VOF_ERROR_STR_TRUNCATED_EVENT;
extern TraceEvent _TRACE_VOF_ERROR_PARAM_EVENT;
extern TraceEvent _TRACE_VOF_ERROR_UNKNOWN_SERVICE_EVENT;
extern TraceEvent _TRACE_VOF_ERROR_UNKNOWN_METHOD_EVENT;
extern TraceEvent _TRACE_VOF_ERROR_UNKNOWN_IHANDLE_CLOSE_EVENT;
extern TraceEvent _TRACE_VOF_ERROR_UNKNOWN_PATH_EVENT;
extern TraceEvent _TRACE_VOF_ERROR_WRITE_EVENT;
extern TraceEvent _TRACE_VOF_FINDDEVICE_EVENT;
extern TraceEvent _TRACE_VOF_CLAIM_EVENT;
extern TraceEvent _TRACE_VOF_RELEASE_EVENT;
extern TraceEvent _TRACE_VOF_METHOD_EVENT;
extern TraceEvent _TRACE_VOF_GETPROP_EVENT;
extern TraceEvent _TRACE_VOF_GETPROPLEN_EVENT;
extern TraceEvent _TRACE_VOF_SETPROP_EVENT;
extern TraceEvent _TRACE_VOF_OPEN_EVENT;
extern TraceEvent _TRACE_VOF_INTERPRET_EVENT;
extern TraceEvent _TRACE_VOF_PACKAGE_TO_PATH_EVENT;
extern TraceEvent _TRACE_VOF_INSTANCE_TO_PATH_EVENT;
extern TraceEvent _TRACE_VOF_INSTANCE_TO_PACKAGE_EVENT;
extern TraceEvent _TRACE_VOF_WRITE_EVENT;
extern TraceEvent _TRACE_VOF_AVAIL_EVENT;
extern TraceEvent _TRACE_VOF_CLAIMED_EVENT;
extern TraceEvent _TRACE_PNV_ADU_XSCOM_READ_EVENT;
extern TraceEvent _TRACE_PNV_ADU_XSCOM_WRITE_EVENT;
extern TraceEvent _TRACE_PNV_CHIPTOD_XSCOM_READ_EVENT;
extern TraceEvent _TRACE_PNV_CHIPTOD_XSCOM_WRITE_EVENT;
extern TraceEvent _TRACE_PNV_SBE_XSCOM_CTRL_READ_EVENT;
extern TraceEvent _TRACE_PNV_SBE_XSCOM_CTRL_WRITE_EVENT;
extern TraceEvent _TRACE_PNV_SBE_XSCOM_MBOX_READ_EVENT;
extern TraceEvent _TRACE_PNV_SBE_XSCOM_MBOX_WRITE_EVENT;
extern TraceEvent _TRACE_PNV_SBE_REG_SET_HOST_DOORBELL_EVENT;
extern TraceEvent _TRACE_PNV_SBE_CMD_TIMER_START_EVENT;
extern TraceEvent _TRACE_PNV_SBE_CMD_TIMER_STOP_EVENT;
extern TraceEvent _TRACE_PNV_SBE_CMD_TIMER_EXPIRED_EVENT;
extern TraceEvent _TRACE_PNV_SBE_MSG_RECV_EVENT;
extern TraceEvent _TRACE_PPC_TB_ADJUST_EVENT;
extern TraceEvent _TRACE_PPC_TB_LOAD_EVENT;
extern TraceEvent _TRACE_PPC_TB_STORE_EVENT;
extern TraceEvent _TRACE_PPC_DECR_LOAD_EVENT;
extern TraceEvent _TRACE_PPC_DECR_EXCP_EVENT;
extern TraceEvent _TRACE_PPC_DECR_STORE_EVENT;
extern TraceEvent _TRACE_PPC4XX_FIT_EVENT;
extern TraceEvent _TRACE_PPC4XX_PIT_STOP_EVENT;
extern TraceEvent _TRACE_PPC4XX_PIT_START_EVENT;
extern TraceEvent _TRACE_PPC4XX_PIT_EVENT;
extern TraceEvent _TRACE_PPC4XX_WDT_EVENT;
extern TraceEvent _TRACE_PPC40X_STORE_PIT_EVENT;
extern TraceEvent _TRACE_PPC40X_STORE_TCR_EVENT;
extern TraceEvent _TRACE_PPC40X_STORE_TSR_EVENT;
extern TraceEvent _TRACE_PPC40X_SET_TB_CLK_EVENT;
extern TraceEvent _TRACE_PPC40X_TIMERS_INIT_EVENT;
extern TraceEvent _TRACE_PPC_IRQ_SET_EVENT;
extern TraceEvent _TRACE_PPC_IRQ_SET_EXIT_EVENT;
extern TraceEvent _TRACE_PPC_IRQ_SET_STATE_EVENT;
extern TraceEvent _TRACE_PPC_IRQ_RESET_EVENT;
extern TraceEvent _TRACE_PPC_IRQ_CPU_EVENT;
extern TraceEvent _TRACE_PPC_DCR_READ_EVENT;
extern TraceEvent _TRACE_PPC_DCR_WRITE_EVENT;
extern TraceEvent _TRACE_PREP_SYSTEMIO_READ_EVENT;
extern TraceEvent _TRACE_PREP_SYSTEMIO_WRITE_EVENT;
extern TraceEvent _TRACE_RS6000MC_ID_READ_EVENT;
extern TraceEvent _TRACE_RS6000MC_PRESENCE_READ_EVENT;
extern TraceEvent _TRACE_RS6000MC_SIZE_READ_EVENT;
extern TraceEvent _TRACE_RS6000MC_SIZE_WRITE_EVENT;
extern TraceEvent _TRACE_RS6000MC_PARITY_READ_EVENT;
extern TraceEvent _TRACE_OPBA_READB_EVENT;
extern TraceEvent _TRACE_OPBA_WRITEB_EVENT;
extern TraceEvent _TRACE_PPC405_GPIO_READ_EVENT;
extern TraceEvent _TRACE_PPC405_GPIO_WRITE_EVENT;
extern TraceEvent _TRACE_OCM_UPDATE_MAPPINGS_EVENT;
extern TraceEvent _TRACE_OCM_MAP_EVENT;
extern TraceEvent _TRACE_OCM_UNMAP_EVENT;
extern TraceEvent _TRACE_PPC4XX_GPT_READ_EVENT;
extern TraceEvent _TRACE_PPC4XX_GPT_WRITE_EVENT;
extern TraceEvent _TRACE_PPC405EP_CLOCKS_COMPUTE_EVENT;
extern TraceEvent _TRACE_PPC405EP_CLOCKS_SETUP_EVENT;
extern TraceEvent _TRACE_PPC4XX_SDRAM_ENABLE_EVENT;
extern TraceEvent _TRACE_PPC4XX_SDRAM_UNMAP_EVENT;
extern TraceEvent _TRACE_PPC4XX_SDRAM_MAP_EVENT;
extern TraceEvent _TRACE_PPC4XX_SDRAM_INIT_EVENT;
extern uint16_t _TRACE_SPAPR_PCI_MSI_DSTATE;
extern uint16_t _TRACE_SPAPR_PCI_MSI_SETUP_DSTATE;
extern uint16_t _TRACE_SPAPR_PCI_RTAS_IBM_CHANGE_MSI_DSTATE;
extern uint16_t _TRACE_SPAPR_PCI_RTAS_IBM_QUERY_INTERRUPT_SOURCE_NUMBER_DSTATE;
extern uint16_t _TRACE_SPAPR_PCI_MSI_WRITE_DSTATE;
extern uint16_t _TRACE_SPAPR_PCI_LSI_SET_DSTATE;
extern uint16_t _TRACE_SPAPR_PCI_MSI_RETRY_DSTATE;
extern uint16_t _TRACE_SPAPR_CAS_CONTINUE_DSTATE;
extern uint16_t _TRACE_SPAPR_CAS_PVR_DSTATE;
extern uint16_t _TRACE_SPAPR_H_RESIZE_HPT_PREPARE_DSTATE;
extern uint16_t _TRACE_SPAPR_H_RESIZE_HPT_COMMIT_DSTATE;
extern uint16_t _TRACE_SPAPR_UPDATE_DT_DSTATE;
extern uint16_t _TRACE_SPAPR_UPDATE_DT_FAILED_SIZE_DSTATE;
extern uint16_t _TRACE_SPAPR_UPDATE_DT_FAILED_CHECK_DSTATE;
extern uint16_t _TRACE_SPAPR_H_TPM_COMM_DSTATE;
extern uint16_t _TRACE_SPAPR_TPM_EXECUTE_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_PUT_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_GET_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_INDIRECT_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_STUFF_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_PCI_PUT_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_PCI_GET_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_PCI_INDIRECT_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_PCI_STUFF_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_XLATE_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_NEW_TABLE_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_PRE_SAVE_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_POST_LOAD_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_DDW_QUERY_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_DDW_CREATE_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_DDW_REMOVE_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_DDW_RESET_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_SET_ISOLATION_STATE_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_SET_ISOLATION_STATE_FINALIZING_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_SET_DR_INDICATOR_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_SET_ALLOCATION_STATE_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_SET_ALLOCATION_STATE_FINALIZING_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_SET_CONFIGURED_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_ATTACH_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_UNPLUG_REQUEST_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_AWAITING_QUIESCE_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_RESET_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_REALIZE_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_REALIZE_CHILD_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_REALIZE_COMPLETE_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_UNREALIZE_DSTATE;
extern uint16_t _TRACE_SPAPR_OVEC_PARSE_VECTOR_DSTATE;
extern uint16_t _TRACE_SPAPR_OVEC_POPULATE_DT_DSTATE;
extern uint16_t _TRACE_SPAPR_RTAS_GET_SENSOR_STATE_NOT_SUPPORTED_DSTATE;
extern uint16_t _TRACE_SPAPR_RTAS_GET_SENSOR_STATE_INVALID_DSTATE;
extern uint16_t _TRACE_SPAPR_RTAS_IBM_CONFIGURE_CONNECTOR_INVALID_DSTATE;
extern uint16_t _TRACE_SPAPR_VIO_H_REG_CRQ_DSTATE;
extern uint16_t _TRACE_SPAPR_VIO_FREE_CRQ_DSTATE;
extern uint16_t _TRACE_VOF_ERROR_STR_TRUNCATED_DSTATE;
extern uint16_t _TRACE_VOF_ERROR_PARAM_DSTATE;
extern uint16_t _TRACE_VOF_ERROR_UNKNOWN_SERVICE_DSTATE;
extern uint16_t _TRACE_VOF_ERROR_UNKNOWN_METHOD_DSTATE;
extern uint16_t _TRACE_VOF_ERROR_UNKNOWN_IHANDLE_CLOSE_DSTATE;
extern uint16_t _TRACE_VOF_ERROR_UNKNOWN_PATH_DSTATE;
extern uint16_t _TRACE_VOF_ERROR_WRITE_DSTATE;
extern uint16_t _TRACE_VOF_FINDDEVICE_DSTATE;
extern uint16_t _TRACE_VOF_CLAIM_DSTATE;
extern uint16_t _TRACE_VOF_RELEASE_DSTATE;
extern uint16_t _TRACE_VOF_METHOD_DSTATE;
extern uint16_t _TRACE_VOF_GETPROP_DSTATE;
extern uint16_t _TRACE_VOF_GETPROPLEN_DSTATE;
extern uint16_t _TRACE_VOF_SETPROP_DSTATE;
extern uint16_t _TRACE_VOF_OPEN_DSTATE;
extern uint16_t _TRACE_VOF_INTERPRET_DSTATE;
extern uint16_t _TRACE_VOF_PACKAGE_TO_PATH_DSTATE;
extern uint16_t _TRACE_VOF_INSTANCE_TO_PATH_DSTATE;
extern uint16_t _TRACE_VOF_INSTANCE_TO_PACKAGE_DSTATE;
extern uint16_t _TRACE_VOF_WRITE_DSTATE;
extern uint16_t _TRACE_VOF_AVAIL_DSTATE;
extern uint16_t _TRACE_VOF_CLAIMED_DSTATE;
extern uint16_t _TRACE_PNV_ADU_XSCOM_READ_DSTATE;
extern uint16_t _TRACE_PNV_ADU_XSCOM_WRITE_DSTATE;
extern uint16_t _TRACE_PNV_CHIPTOD_XSCOM_READ_DSTATE;
extern uint16_t _TRACE_PNV_CHIPTOD_XSCOM_WRITE_DSTATE;
extern uint16_t _TRACE_PNV_SBE_XSCOM_CTRL_READ_DSTATE;
extern uint16_t _TRACE_PNV_SBE_XSCOM_CTRL_WRITE_DSTATE;
extern uint16_t _TRACE_PNV_SBE_XSCOM_MBOX_READ_DSTATE;
extern uint16_t _TRACE_PNV_SBE_XSCOM_MBOX_WRITE_DSTATE;
extern uint16_t _TRACE_PNV_SBE_REG_SET_HOST_DOORBELL_DSTATE;
extern uint16_t _TRACE_PNV_SBE_CMD_TIMER_START_DSTATE;
extern uint16_t _TRACE_PNV_SBE_CMD_TIMER_STOP_DSTATE;
extern uint16_t _TRACE_PNV_SBE_CMD_TIMER_EXPIRED_DSTATE;
extern uint16_t _TRACE_PNV_SBE_MSG_RECV_DSTATE;
extern uint16_t _TRACE_PPC_TB_ADJUST_DSTATE;
extern uint16_t _TRACE_PPC_TB_LOAD_DSTATE;
extern uint16_t _TRACE_PPC_TB_STORE_DSTATE;
extern uint16_t _TRACE_PPC_DECR_LOAD_DSTATE;
extern uint16_t _TRACE_PPC_DECR_EXCP_DSTATE;
extern uint16_t _TRACE_PPC_DECR_STORE_DSTATE;
extern uint16_t _TRACE_PPC4XX_FIT_DSTATE;
extern uint16_t _TRACE_PPC4XX_PIT_STOP_DSTATE;
extern uint16_t _TRACE_PPC4XX_PIT_START_DSTATE;
extern uint16_t _TRACE_PPC4XX_PIT_DSTATE;
extern uint16_t _TRACE_PPC4XX_WDT_DSTATE;
extern uint16_t _TRACE_PPC40X_STORE_PIT_DSTATE;
extern uint16_t _TRACE_PPC40X_STORE_TCR_DSTATE;
extern uint16_t _TRACE_PPC40X_STORE_TSR_DSTATE;
extern uint16_t _TRACE_PPC40X_SET_TB_CLK_DSTATE;
extern uint16_t _TRACE_PPC40X_TIMERS_INIT_DSTATE;
extern uint16_t _TRACE_PPC_IRQ_SET_DSTATE;
extern uint16_t _TRACE_PPC_IRQ_SET_EXIT_DSTATE;
extern uint16_t _TRACE_PPC_IRQ_SET_STATE_DSTATE;
extern uint16_t _TRACE_PPC_IRQ_RESET_DSTATE;
extern uint16_t _TRACE_PPC_IRQ_CPU_DSTATE;
extern uint16_t _TRACE_PPC_DCR_READ_DSTATE;
extern uint16_t _TRACE_PPC_DCR_WRITE_DSTATE;
extern uint16_t _TRACE_PREP_SYSTEMIO_READ_DSTATE;
extern uint16_t _TRACE_PREP_SYSTEMIO_WRITE_DSTATE;
extern uint16_t _TRACE_RS6000MC_ID_READ_DSTATE;
extern uint16_t _TRACE_RS6000MC_PRESENCE_READ_DSTATE;
extern uint16_t _TRACE_RS6000MC_SIZE_READ_DSTATE;
extern uint16_t _TRACE_RS6000MC_SIZE_WRITE_DSTATE;
extern uint16_t _TRACE_RS6000MC_PARITY_READ_DSTATE;
extern uint16_t _TRACE_OPBA_READB_DSTATE;
extern uint16_t _TRACE_OPBA_WRITEB_DSTATE;
extern uint16_t _TRACE_PPC405_GPIO_READ_DSTATE;
extern uint16_t _TRACE_PPC405_GPIO_WRITE_DSTATE;
extern uint16_t _TRACE_OCM_UPDATE_MAPPINGS_DSTATE;
extern uint16_t _TRACE_OCM_MAP_DSTATE;
extern uint16_t _TRACE_OCM_UNMAP_DSTATE;
extern uint16_t _TRACE_PPC4XX_GPT_READ_DSTATE;
extern uint16_t _TRACE_PPC4XX_GPT_WRITE_DSTATE;
extern uint16_t _TRACE_PPC405EP_CLOCKS_COMPUTE_DSTATE;
extern uint16_t _TRACE_PPC405EP_CLOCKS_SETUP_DSTATE;
extern uint16_t _TRACE_PPC4XX_SDRAM_ENABLE_DSTATE;
extern uint16_t _TRACE_PPC4XX_SDRAM_UNMAP_DSTATE;
extern uint16_t _TRACE_PPC4XX_SDRAM_MAP_DSTATE;
extern uint16_t _TRACE_PPC4XX_SDRAM_INIT_DSTATE;
#define TRACE_SPAPR_PCI_MSI_ENABLED 1
#define TRACE_SPAPR_PCI_MSI_SETUP_ENABLED 1
#define TRACE_SPAPR_PCI_RTAS_IBM_CHANGE_MSI_ENABLED 1
#define TRACE_SPAPR_PCI_RTAS_IBM_QUERY_INTERRUPT_SOURCE_NUMBER_ENABLED 1
#define TRACE_SPAPR_PCI_MSI_WRITE_ENABLED 1
#define TRACE_SPAPR_PCI_LSI_SET_ENABLED 1
#define TRACE_SPAPR_PCI_MSI_RETRY_ENABLED 1
#define TRACE_SPAPR_CAS_CONTINUE_ENABLED 1
#define TRACE_SPAPR_CAS_PVR_ENABLED 1
#define TRACE_SPAPR_H_RESIZE_HPT_PREPARE_ENABLED 1
#define TRACE_SPAPR_H_RESIZE_HPT_COMMIT_ENABLED 1
#define TRACE_SPAPR_UPDATE_DT_ENABLED 1
#define TRACE_SPAPR_UPDATE_DT_FAILED_SIZE_ENABLED 1
#define TRACE_SPAPR_UPDATE_DT_FAILED_CHECK_ENABLED 1
#define TRACE_SPAPR_H_TPM_COMM_ENABLED 1
#define TRACE_SPAPR_TPM_EXECUTE_ENABLED 1
#define TRACE_SPAPR_IOMMU_PUT_ENABLED 1
#define TRACE_SPAPR_IOMMU_GET_ENABLED 1
#define TRACE_SPAPR_IOMMU_INDIRECT_ENABLED 1
#define TRACE_SPAPR_IOMMU_STUFF_ENABLED 1
#define TRACE_SPAPR_IOMMU_PCI_PUT_ENABLED 1
#define TRACE_SPAPR_IOMMU_PCI_GET_ENABLED 1
#define TRACE_SPAPR_IOMMU_PCI_INDIRECT_ENABLED 1
#define TRACE_SPAPR_IOMMU_PCI_STUFF_ENABLED 1
#define TRACE_SPAPR_IOMMU_XLATE_ENABLED 1
#define TRACE_SPAPR_IOMMU_NEW_TABLE_ENABLED 1
#define TRACE_SPAPR_IOMMU_PRE_SAVE_ENABLED 1
#define TRACE_SPAPR_IOMMU_POST_LOAD_ENABLED 1
#define TRACE_SPAPR_IOMMU_DDW_QUERY_ENABLED 1
#define TRACE_SPAPR_IOMMU_DDW_CREATE_ENABLED 1
#define TRACE_SPAPR_IOMMU_DDW_REMOVE_ENABLED 1
#define TRACE_SPAPR_IOMMU_DDW_RESET_ENABLED 1
#define TRACE_SPAPR_DRC_SET_ISOLATION_STATE_ENABLED 1
#define TRACE_SPAPR_DRC_SET_ISOLATION_STATE_FINALIZING_ENABLED 1
#define TRACE_SPAPR_DRC_SET_DR_INDICATOR_ENABLED 1
#define TRACE_SPAPR_DRC_SET_ALLOCATION_STATE_ENABLED 1
#define TRACE_SPAPR_DRC_SET_ALLOCATION_STATE_FINALIZING_ENABLED 1
#define TRACE_SPAPR_DRC_SET_CONFIGURED_ENABLED 1
#define TRACE_SPAPR_DRC_ATTACH_ENABLED 1
#define TRACE_SPAPR_DRC_UNPLUG_REQUEST_ENABLED 1
#define TRACE_SPAPR_DRC_AWAITING_QUIESCE_ENABLED 1
#define TRACE_SPAPR_DRC_RESET_ENABLED 1
#define TRACE_SPAPR_DRC_REALIZE_ENABLED 1
#define TRACE_SPAPR_DRC_REALIZE_CHILD_ENABLED 1
#define TRACE_SPAPR_DRC_REALIZE_COMPLETE_ENABLED 1
#define TRACE_SPAPR_DRC_UNREALIZE_ENABLED 1
#define TRACE_SPAPR_OVEC_PARSE_VECTOR_ENABLED 1
#define TRACE_SPAPR_OVEC_POPULATE_DT_ENABLED 1
#define TRACE_SPAPR_RTAS_GET_SENSOR_STATE_NOT_SUPPORTED_ENABLED 1
#define TRACE_SPAPR_RTAS_GET_SENSOR_STATE_INVALID_ENABLED 1
#define TRACE_SPAPR_RTAS_IBM_CONFIGURE_CONNECTOR_INVALID_ENABLED 1
#define TRACE_SPAPR_VIO_H_REG_CRQ_ENABLED 1
#define TRACE_SPAPR_VIO_FREE_CRQ_ENABLED 1
#define TRACE_VOF_ERROR_STR_TRUNCATED_ENABLED 1
#define TRACE_VOF_ERROR_PARAM_ENABLED 1
#define TRACE_VOF_ERROR_UNKNOWN_SERVICE_ENABLED 1
#define TRACE_VOF_ERROR_UNKNOWN_METHOD_ENABLED 1
#define TRACE_VOF_ERROR_UNKNOWN_IHANDLE_CLOSE_ENABLED 1
#define TRACE_VOF_ERROR_UNKNOWN_PATH_ENABLED 1
#define TRACE_VOF_ERROR_WRITE_ENABLED 1
#define TRACE_VOF_FINDDEVICE_ENABLED 1
#define TRACE_VOF_CLAIM_ENABLED 1
#define TRACE_VOF_RELEASE_ENABLED 1
#define TRACE_VOF_METHOD_ENABLED 1
#define TRACE_VOF_GETPROP_ENABLED 1
#define TRACE_VOF_GETPROPLEN_ENABLED 1
#define TRACE_VOF_SETPROP_ENABLED 1
#define TRACE_VOF_OPEN_ENABLED 1
#define TRACE_VOF_INTERPRET_ENABLED 1
#define TRACE_VOF_PACKAGE_TO_PATH_ENABLED 1
#define TRACE_VOF_INSTANCE_TO_PATH_ENABLED 1
#define TRACE_VOF_INSTANCE_TO_PACKAGE_ENABLED 1
#define TRACE_VOF_WRITE_ENABLED 1
#define TRACE_VOF_AVAIL_ENABLED 1
#define TRACE_VOF_CLAIMED_ENABLED 1
#define TRACE_PNV_ADU_XSCOM_READ_ENABLED 1
#define TRACE_PNV_ADU_XSCOM_WRITE_ENABLED 1
#define TRACE_PNV_CHIPTOD_XSCOM_READ_ENABLED 1
#define TRACE_PNV_CHIPTOD_XSCOM_WRITE_ENABLED 1
#define TRACE_PNV_SBE_XSCOM_CTRL_READ_ENABLED 1
#define TRACE_PNV_SBE_XSCOM_CTRL_WRITE_ENABLED 1
#define TRACE_PNV_SBE_XSCOM_MBOX_READ_ENABLED 1
#define TRACE_PNV_SBE_XSCOM_MBOX_WRITE_ENABLED 1
#define TRACE_PNV_SBE_REG_SET_HOST_DOORBELL_ENABLED 1
#define TRACE_PNV_SBE_CMD_TIMER_START_ENABLED 1
#define TRACE_PNV_SBE_CMD_TIMER_STOP_ENABLED 1
#define TRACE_PNV_SBE_CMD_TIMER_EXPIRED_ENABLED 1
#define TRACE_PNV_SBE_MSG_RECV_ENABLED 1
#define TRACE_PPC_TB_ADJUST_ENABLED 1
#define TRACE_PPC_TB_LOAD_ENABLED 1
#define TRACE_PPC_TB_STORE_ENABLED 1
#define TRACE_PPC_DECR_LOAD_ENABLED 1
#define TRACE_PPC_DECR_EXCP_ENABLED 1
#define TRACE_PPC_DECR_STORE_ENABLED 1
#define TRACE_PPC4XX_FIT_ENABLED 1
#define TRACE_PPC4XX_PIT_STOP_ENABLED 1
#define TRACE_PPC4XX_PIT_START_ENABLED 1
#define TRACE_PPC4XX_PIT_ENABLED 1
#define TRACE_PPC4XX_WDT_ENABLED 1
#define TRACE_PPC40X_STORE_PIT_ENABLED 1
#define TRACE_PPC40X_STORE_TCR_ENABLED 1
#define TRACE_PPC40X_STORE_TSR_ENABLED 1
#define TRACE_PPC40X_SET_TB_CLK_ENABLED 1
#define TRACE_PPC40X_TIMERS_INIT_ENABLED 1
#define TRACE_PPC_IRQ_SET_ENABLED 1
#define TRACE_PPC_IRQ_SET_EXIT_ENABLED 1
#define TRACE_PPC_IRQ_SET_STATE_ENABLED 1
#define TRACE_PPC_IRQ_RESET_ENABLED 1
#define TRACE_PPC_IRQ_CPU_ENABLED 1
#define TRACE_PPC_DCR_READ_ENABLED 1
#define TRACE_PPC_DCR_WRITE_ENABLED 1
#define TRACE_PREP_SYSTEMIO_READ_ENABLED 1
#define TRACE_PREP_SYSTEMIO_WRITE_ENABLED 1
#define TRACE_RS6000MC_ID_READ_ENABLED 1
#define TRACE_RS6000MC_PRESENCE_READ_ENABLED 1
#define TRACE_RS6000MC_SIZE_READ_ENABLED 1
#define TRACE_RS6000MC_SIZE_WRITE_ENABLED 1
#define TRACE_RS6000MC_PARITY_READ_ENABLED 1
#define TRACE_OPBA_READB_ENABLED 1
#define TRACE_OPBA_WRITEB_ENABLED 1
#define TRACE_PPC405_GPIO_READ_ENABLED 1
#define TRACE_PPC405_GPIO_WRITE_ENABLED 1
#define TRACE_OCM_UPDATE_MAPPINGS_ENABLED 1
#define TRACE_OCM_MAP_ENABLED 1
#define TRACE_OCM_UNMAP_ENABLED 1
#define TRACE_PPC4XX_GPT_READ_ENABLED 1
#define TRACE_PPC4XX_GPT_WRITE_ENABLED 1
#define TRACE_PPC405EP_CLOCKS_COMPUTE_ENABLED 1
#define TRACE_PPC405EP_CLOCKS_SETUP_ENABLED 1
#define TRACE_PPC4XX_SDRAM_ENABLE_ENABLED 1
#define TRACE_PPC4XX_SDRAM_UNMAP_ENABLED 1
#define TRACE_PPC4XX_SDRAM_MAP_ENABLED 1
#define TRACE_PPC4XX_SDRAM_INIT_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_SPAPR_PCI_MSI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_PCI_MSI) || \
    false)

static inline void _nocheck__trace_spapr_pci_msi(const char * msg, uint32_t ca)
{
    if (trace_event_get_state(TRACE_SPAPR_PCI_MSI) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 4 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_pci_msi " "%s (cfg=0x%x)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , msg, ca);
#line 427 "trace/trace-hw_ppc.h"
        } else {
#line 4 "../hw/ppc/trace-events"
            qemu_log("spapr_pci_msi " "%s (cfg=0x%x)" "\n", msg, ca);
#line 431 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_pci_msi(const char * msg, uint32_t ca)
{
    if (true) {
        _nocheck__trace_spapr_pci_msi(msg, ca);
    }
}

#define TRACE_SPAPR_PCI_MSI_SETUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_PCI_MSI_SETUP) || \
    false)

static inline void _nocheck__trace_spapr_pci_msi_setup(const char * name, unsigned vector, uint64_t addr)
{
    if (trace_event_get_state(TRACE_SPAPR_PCI_MSI_SETUP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 5 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_pci_msi_setup " "dev\"%s\" vector %u, addr=0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, vector, addr);
#line 458 "trace/trace-hw_ppc.h"
        } else {
#line 5 "../hw/ppc/trace-events"
            qemu_log("spapr_pci_msi_setup " "dev\"%s\" vector %u, addr=0x%"PRIx64 "\n", name, vector, addr);
#line 462 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_pci_msi_setup(const char * name, unsigned vector, uint64_t addr)
{
    if (true) {
        _nocheck__trace_spapr_pci_msi_setup(name, vector, addr);
    }
}

#define TRACE_SPAPR_PCI_RTAS_IBM_CHANGE_MSI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_PCI_RTAS_IBM_CHANGE_MSI) || \
    false)

static inline void _nocheck__trace_spapr_pci_rtas_ibm_change_msi(unsigned cfg, unsigned func, unsigned req, unsigned first)
{
    if (trace_event_get_state(TRACE_SPAPR_PCI_RTAS_IBM_CHANGE_MSI) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 6 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_pci_rtas_ibm_change_msi " "cfgaddr 0x%x func %u, requested %u, first irq %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cfg, func, req, first);
#line 489 "trace/trace-hw_ppc.h"
        } else {
#line 6 "../hw/ppc/trace-events"
            qemu_log("spapr_pci_rtas_ibm_change_msi " "cfgaddr 0x%x func %u, requested %u, first irq %u" "\n", cfg, func, req, first);
#line 493 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_pci_rtas_ibm_change_msi(unsigned cfg, unsigned func, unsigned req, unsigned first)
{
    if (true) {
        _nocheck__trace_spapr_pci_rtas_ibm_change_msi(cfg, func, req, first);
    }
}

#define TRACE_SPAPR_PCI_RTAS_IBM_QUERY_INTERRUPT_SOURCE_NUMBER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_PCI_RTAS_IBM_QUERY_INTERRUPT_SOURCE_NUMBER) || \
    false)

static inline void _nocheck__trace_spapr_pci_rtas_ibm_query_interrupt_source_number(unsigned ioa, unsigned intr)
{
    if (trace_event_get_state(TRACE_SPAPR_PCI_RTAS_IBM_QUERY_INTERRUPT_SOURCE_NUMBER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 7 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_pci_rtas_ibm_query_interrupt_source_number " "queries for #%u, IRQ%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioa, intr);
#line 520 "trace/trace-hw_ppc.h"
        } else {
#line 7 "../hw/ppc/trace-events"
            qemu_log("spapr_pci_rtas_ibm_query_interrupt_source_number " "queries for #%u, IRQ%u" "\n", ioa, intr);
#line 524 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_pci_rtas_ibm_query_interrupt_source_number(unsigned ioa, unsigned intr)
{
    if (true) {
        _nocheck__trace_spapr_pci_rtas_ibm_query_interrupt_source_number(ioa, intr);
    }
}

#define TRACE_SPAPR_PCI_MSI_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_PCI_MSI_WRITE) || \
    false)

static inline void _nocheck__trace_spapr_pci_msi_write(uint64_t addr, uint64_t data, uint32_t dt_irq)
{
    if (trace_event_get_state(TRACE_SPAPR_PCI_MSI_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 8 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_pci_msi_write " "@0x%"PRIx64"<=0x%"PRIx64" IRQ %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, data, dt_irq);
#line 551 "trace/trace-hw_ppc.h"
        } else {
#line 8 "../hw/ppc/trace-events"
            qemu_log("spapr_pci_msi_write " "@0x%"PRIx64"<=0x%"PRIx64" IRQ %u" "\n", addr, data, dt_irq);
#line 555 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_pci_msi_write(uint64_t addr, uint64_t data, uint32_t dt_irq)
{
    if (true) {
        _nocheck__trace_spapr_pci_msi_write(addr, data, dt_irq);
    }
}

#define TRACE_SPAPR_PCI_LSI_SET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_PCI_LSI_SET) || \
    false)

static inline void _nocheck__trace_spapr_pci_lsi_set(const char * busname, int pin, uint32_t irq)
{
    if (trace_event_get_state(TRACE_SPAPR_PCI_LSI_SET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 9 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_pci_lsi_set " "%s PIN%d IRQ %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , busname, pin, irq);
#line 582 "trace/trace-hw_ppc.h"
        } else {
#line 9 "../hw/ppc/trace-events"
            qemu_log("spapr_pci_lsi_set " "%s PIN%d IRQ %u" "\n", busname, pin, irq);
#line 586 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_pci_lsi_set(const char * busname, int pin, uint32_t irq)
{
    if (true) {
        _nocheck__trace_spapr_pci_lsi_set(busname, pin, irq);
    }
}

#define TRACE_SPAPR_PCI_MSI_RETRY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_PCI_MSI_RETRY) || \
    false)

static inline void _nocheck__trace_spapr_pci_msi_retry(unsigned config_addr, unsigned req_num, unsigned max_irqs)
{
    if (trace_event_get_state(TRACE_SPAPR_PCI_MSI_RETRY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 10 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_pci_msi_retry " "Guest device at 0x%x asked %u, have only %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , config_addr, req_num, max_irqs);
#line 613 "trace/trace-hw_ppc.h"
        } else {
#line 10 "../hw/ppc/trace-events"
            qemu_log("spapr_pci_msi_retry " "Guest device at 0x%x asked %u, have only %u" "\n", config_addr, req_num, max_irqs);
#line 617 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_pci_msi_retry(unsigned config_addr, unsigned req_num, unsigned max_irqs)
{
    if (true) {
        _nocheck__trace_spapr_pci_msi_retry(config_addr, req_num, max_irqs);
    }
}

#define TRACE_SPAPR_CAS_CONTINUE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_CAS_CONTINUE) || \
    false)

static inline void _nocheck__trace_spapr_cas_continue(unsigned long n)
{
    if (trace_event_get_state(TRACE_SPAPR_CAS_CONTINUE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 13 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_cas_continue " "Copy changes to the guest: %ld bytes" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , n);
#line 644 "trace/trace-hw_ppc.h"
        } else {
#line 13 "../hw/ppc/trace-events"
            qemu_log("spapr_cas_continue " "Copy changes to the guest: %ld bytes" "\n", n);
#line 648 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_cas_continue(unsigned long n)
{
    if (true) {
        _nocheck__trace_spapr_cas_continue(n);
    }
}

#define TRACE_SPAPR_CAS_PVR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_CAS_PVR) || \
    false)

static inline void _nocheck__trace_spapr_cas_pvr(uint32_t cur_pvr, bool explicit_match, uint32_t new_pvr)
{
    if (trace_event_get_state(TRACE_SPAPR_CAS_PVR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 14 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_cas_pvr " "current=0x%x, explicit_match=%u, new=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cur_pvr, explicit_match, new_pvr);
#line 675 "trace/trace-hw_ppc.h"
        } else {
#line 14 "../hw/ppc/trace-events"
            qemu_log("spapr_cas_pvr " "current=0x%x, explicit_match=%u, new=0x%x" "\n", cur_pvr, explicit_match, new_pvr);
#line 679 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_cas_pvr(uint32_t cur_pvr, bool explicit_match, uint32_t new_pvr)
{
    if (true) {
        _nocheck__trace_spapr_cas_pvr(cur_pvr, explicit_match, new_pvr);
    }
}

#define TRACE_SPAPR_H_RESIZE_HPT_PREPARE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_H_RESIZE_HPT_PREPARE) || \
    false)

static inline void _nocheck__trace_spapr_h_resize_hpt_prepare(uint64_t flags, uint64_t shift)
{
    if (trace_event_get_state(TRACE_SPAPR_H_RESIZE_HPT_PREPARE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 15 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_h_resize_hpt_prepare " "flags=0x%"PRIx64", shift=%"PRIu64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , flags, shift);
#line 706 "trace/trace-hw_ppc.h"
        } else {
#line 15 "../hw/ppc/trace-events"
            qemu_log("spapr_h_resize_hpt_prepare " "flags=0x%"PRIx64", shift=%"PRIu64 "\n", flags, shift);
#line 710 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_h_resize_hpt_prepare(uint64_t flags, uint64_t shift)
{
    if (true) {
        _nocheck__trace_spapr_h_resize_hpt_prepare(flags, shift);
    }
}

#define TRACE_SPAPR_H_RESIZE_HPT_COMMIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_H_RESIZE_HPT_COMMIT) || \
    false)

static inline void _nocheck__trace_spapr_h_resize_hpt_commit(uint64_t flags, uint64_t shift)
{
    if (trace_event_get_state(TRACE_SPAPR_H_RESIZE_HPT_COMMIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 16 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_h_resize_hpt_commit " "flags=0x%"PRIx64", shift=%"PRIu64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , flags, shift);
#line 737 "trace/trace-hw_ppc.h"
        } else {
#line 16 "../hw/ppc/trace-events"
            qemu_log("spapr_h_resize_hpt_commit " "flags=0x%"PRIx64", shift=%"PRIu64 "\n", flags, shift);
#line 741 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_h_resize_hpt_commit(uint64_t flags, uint64_t shift)
{
    if (true) {
        _nocheck__trace_spapr_h_resize_hpt_commit(flags, shift);
    }
}

#define TRACE_SPAPR_UPDATE_DT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_UPDATE_DT) || \
    false)

static inline void _nocheck__trace_spapr_update_dt(unsigned cb)
{
    if (trace_event_get_state(TRACE_SPAPR_UPDATE_DT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 17 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_update_dt " "New blob %u bytes" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cb);
#line 768 "trace/trace-hw_ppc.h"
        } else {
#line 17 "../hw/ppc/trace-events"
            qemu_log("spapr_update_dt " "New blob %u bytes" "\n", cb);
#line 772 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_update_dt(unsigned cb)
{
    if (true) {
        _nocheck__trace_spapr_update_dt(cb);
    }
}

#define TRACE_SPAPR_UPDATE_DT_FAILED_SIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_UPDATE_DT_FAILED_SIZE) || \
    false)

static inline void _nocheck__trace_spapr_update_dt_failed_size(unsigned cbold, unsigned cbnew, unsigned magic)
{
    if (trace_event_get_state(TRACE_SPAPR_UPDATE_DT_FAILED_SIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 18 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_update_dt_failed_size " "Old blob %u bytes, new blob %u bytes, magic 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cbold, cbnew, magic);
#line 799 "trace/trace-hw_ppc.h"
        } else {
#line 18 "../hw/ppc/trace-events"
            qemu_log("spapr_update_dt_failed_size " "Old blob %u bytes, new blob %u bytes, magic 0x%x" "\n", cbold, cbnew, magic);
#line 803 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_update_dt_failed_size(unsigned cbold, unsigned cbnew, unsigned magic)
{
    if (true) {
        _nocheck__trace_spapr_update_dt_failed_size(cbold, cbnew, magic);
    }
}

#define TRACE_SPAPR_UPDATE_DT_FAILED_CHECK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_UPDATE_DT_FAILED_CHECK) || \
    false)

static inline void _nocheck__trace_spapr_update_dt_failed_check(unsigned cbold, unsigned cbnew, unsigned magic)
{
    if (trace_event_get_state(TRACE_SPAPR_UPDATE_DT_FAILED_CHECK) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 19 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_update_dt_failed_check " "Old blob %u bytes, new blob %u bytes, magic 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cbold, cbnew, magic);
#line 830 "trace/trace-hw_ppc.h"
        } else {
#line 19 "../hw/ppc/trace-events"
            qemu_log("spapr_update_dt_failed_check " "Old blob %u bytes, new blob %u bytes, magic 0x%x" "\n", cbold, cbnew, magic);
#line 834 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_update_dt_failed_check(unsigned cbold, unsigned cbnew, unsigned magic)
{
    if (true) {
        _nocheck__trace_spapr_update_dt_failed_check(cbold, cbnew, magic);
    }
}

#define TRACE_SPAPR_H_TPM_COMM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_H_TPM_COMM) || \
    false)

static inline void _nocheck__trace_spapr_h_tpm_comm(const char * device_path, uint64_t operation)
{
    if (trace_event_get_state(TRACE_SPAPR_H_TPM_COMM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 22 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_h_tpm_comm " "tpm_device_path=%s operation=0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , device_path, operation);
#line 861 "trace/trace-hw_ppc.h"
        } else {
#line 22 "../hw/ppc/trace-events"
            qemu_log("spapr_h_tpm_comm " "tpm_device_path=%s operation=0x%"PRIx64 "\n", device_path, operation);
#line 865 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_h_tpm_comm(const char * device_path, uint64_t operation)
{
    if (true) {
        _nocheck__trace_spapr_h_tpm_comm(device_path, operation);
    }
}

#define TRACE_SPAPR_TPM_EXECUTE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_TPM_EXECUTE) || \
    false)

static inline void _nocheck__trace_spapr_tpm_execute(uint64_t data_in, uint64_t data_in_sz, uint64_t data_out, uint64_t data_out_sz)
{
    if (trace_event_get_state(TRACE_SPAPR_TPM_EXECUTE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 23 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_tpm_execute " "data_in=0x%"PRIx64", data_in_sz=%"PRIu64", data_out=0x%"PRIx64", data_out_sz=%"PRIu64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , data_in, data_in_sz, data_out, data_out_sz);
#line 892 "trace/trace-hw_ppc.h"
        } else {
#line 23 "../hw/ppc/trace-events"
            qemu_log("spapr_tpm_execute " "data_in=0x%"PRIx64", data_in_sz=%"PRIu64", data_out=0x%"PRIx64", data_out_sz=%"PRIu64 "\n", data_in, data_in_sz, data_out, data_out_sz);
#line 896 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_tpm_execute(uint64_t data_in, uint64_t data_in_sz, uint64_t data_out, uint64_t data_out_sz)
{
    if (true) {
        _nocheck__trace_spapr_tpm_execute(data_in, data_in_sz, data_out, data_out_sz);
    }
}

#define TRACE_SPAPR_IOMMU_PUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_IOMMU_PUT) || \
    false)

static inline void _nocheck__trace_spapr_iommu_put(uint64_t liobn, uint64_t ioba, uint64_t tce, uint64_t ret)
{
    if (trace_event_get_state(TRACE_SPAPR_IOMMU_PUT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 26 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_iommu_put " "liobn=0x%"PRIx64" ioba=0x%"PRIx64" tce=0x%"PRIx64" ret=%"PRId64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , liobn, ioba, tce, ret);
#line 923 "trace/trace-hw_ppc.h"
        } else {
#line 26 "../hw/ppc/trace-events"
            qemu_log("spapr_iommu_put " "liobn=0x%"PRIx64" ioba=0x%"PRIx64" tce=0x%"PRIx64" ret=%"PRId64 "\n", liobn, ioba, tce, ret);
#line 927 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_iommu_put(uint64_t liobn, uint64_t ioba, uint64_t tce, uint64_t ret)
{
    if (true) {
        _nocheck__trace_spapr_iommu_put(liobn, ioba, tce, ret);
    }
}

#define TRACE_SPAPR_IOMMU_GET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_IOMMU_GET) || \
    false)

static inline void _nocheck__trace_spapr_iommu_get(uint64_t liobn, uint64_t ioba, uint64_t ret, uint64_t tce)
{
    if (trace_event_get_state(TRACE_SPAPR_IOMMU_GET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 27 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_iommu_get " "liobn=0x%"PRIx64" ioba=0x%"PRIx64" ret=%"PRId64" tce=0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , liobn, ioba, ret, tce);
#line 954 "trace/trace-hw_ppc.h"
        } else {
#line 27 "../hw/ppc/trace-events"
            qemu_log("spapr_iommu_get " "liobn=0x%"PRIx64" ioba=0x%"PRIx64" ret=%"PRId64" tce=0x%"PRIx64 "\n", liobn, ioba, ret, tce);
#line 958 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_iommu_get(uint64_t liobn, uint64_t ioba, uint64_t ret, uint64_t tce)
{
    if (true) {
        _nocheck__trace_spapr_iommu_get(liobn, ioba, ret, tce);
    }
}

#define TRACE_SPAPR_IOMMU_INDIRECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_IOMMU_INDIRECT) || \
    false)

static inline void _nocheck__trace_spapr_iommu_indirect(uint64_t liobn, uint64_t ioba, uint64_t tce, uint64_t iobaN, uint64_t tceN, uint64_t ret)
{
    if (trace_event_get_state(TRACE_SPAPR_IOMMU_INDIRECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 28 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_iommu_indirect " "liobn=0x%"PRIx64" ioba=0x%"PRIx64" tcelist=0x%"PRIx64" iobaN=0x%"PRIx64" tceN=0x%"PRIx64" ret=%"PRId64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , liobn, ioba, tce, iobaN, tceN, ret);
#line 985 "trace/trace-hw_ppc.h"
        } else {
#line 28 "../hw/ppc/trace-events"
            qemu_log("spapr_iommu_indirect " "liobn=0x%"PRIx64" ioba=0x%"PRIx64" tcelist=0x%"PRIx64" iobaN=0x%"PRIx64" tceN=0x%"PRIx64" ret=%"PRId64 "\n", liobn, ioba, tce, iobaN, tceN, ret);
#line 989 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_iommu_indirect(uint64_t liobn, uint64_t ioba, uint64_t tce, uint64_t iobaN, uint64_t tceN, uint64_t ret)
{
    if (true) {
        _nocheck__trace_spapr_iommu_indirect(liobn, ioba, tce, iobaN, tceN, ret);
    }
}

#define TRACE_SPAPR_IOMMU_STUFF_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_IOMMU_STUFF) || \
    false)

static inline void _nocheck__trace_spapr_iommu_stuff(uint64_t liobn, uint64_t ioba, uint64_t tce_value, uint64_t npages, uint64_t ret)
{
    if (trace_event_get_state(TRACE_SPAPR_IOMMU_STUFF) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 29 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_iommu_stuff " "liobn=0x%"PRIx64" ioba=0x%"PRIx64" tcevalue=0x%"PRIx64" npages=%"PRId64" ret=%"PRId64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , liobn, ioba, tce_value, npages, ret);
#line 1016 "trace/trace-hw_ppc.h"
        } else {
#line 29 "../hw/ppc/trace-events"
            qemu_log("spapr_iommu_stuff " "liobn=0x%"PRIx64" ioba=0x%"PRIx64" tcevalue=0x%"PRIx64" npages=%"PRId64" ret=%"PRId64 "\n", liobn, ioba, tce_value, npages, ret);
#line 1020 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_iommu_stuff(uint64_t liobn, uint64_t ioba, uint64_t tce_value, uint64_t npages, uint64_t ret)
{
    if (true) {
        _nocheck__trace_spapr_iommu_stuff(liobn, ioba, tce_value, npages, ret);
    }
}

#define TRACE_SPAPR_IOMMU_PCI_PUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_IOMMU_PCI_PUT) || \
    false)

static inline void _nocheck__trace_spapr_iommu_pci_put(uint64_t liobn, uint64_t ioba, uint64_t tce, uint64_t ret)
{
    if (trace_event_get_state(TRACE_SPAPR_IOMMU_PCI_PUT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 30 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_iommu_pci_put " "liobn=0x%"PRIx64" ioba=0x%"PRIx64" tce=0x%"PRIx64" ret=%"PRId64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , liobn, ioba, tce, ret);
#line 1047 "trace/trace-hw_ppc.h"
        } else {
#line 30 "../hw/ppc/trace-events"
            qemu_log("spapr_iommu_pci_put " "liobn=0x%"PRIx64" ioba=0x%"PRIx64" tce=0x%"PRIx64" ret=%"PRId64 "\n", liobn, ioba, tce, ret);
#line 1051 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_iommu_pci_put(uint64_t liobn, uint64_t ioba, uint64_t tce, uint64_t ret)
{
    if (true) {
        _nocheck__trace_spapr_iommu_pci_put(liobn, ioba, tce, ret);
    }
}

#define TRACE_SPAPR_IOMMU_PCI_GET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_IOMMU_PCI_GET) || \
    false)

static inline void _nocheck__trace_spapr_iommu_pci_get(uint64_t liobn, uint64_t ioba, uint64_t ret, uint64_t tce)
{
    if (trace_event_get_state(TRACE_SPAPR_IOMMU_PCI_GET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 31 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_iommu_pci_get " "liobn=0x%"PRIx64" ioba=0x%"PRIx64" ret=%"PRId64" tce=0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , liobn, ioba, ret, tce);
#line 1078 "trace/trace-hw_ppc.h"
        } else {
#line 31 "../hw/ppc/trace-events"
            qemu_log("spapr_iommu_pci_get " "liobn=0x%"PRIx64" ioba=0x%"PRIx64" ret=%"PRId64" tce=0x%"PRIx64 "\n", liobn, ioba, ret, tce);
#line 1082 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_iommu_pci_get(uint64_t liobn, uint64_t ioba, uint64_t ret, uint64_t tce)
{
    if (true) {
        _nocheck__trace_spapr_iommu_pci_get(liobn, ioba, ret, tce);
    }
}

#define TRACE_SPAPR_IOMMU_PCI_INDIRECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_IOMMU_PCI_INDIRECT) || \
    false)

static inline void _nocheck__trace_spapr_iommu_pci_indirect(uint64_t liobn, uint64_t ioba, uint64_t tce, uint64_t iobaN, uint64_t tceN, uint64_t ret)
{
    if (trace_event_get_state(TRACE_SPAPR_IOMMU_PCI_INDIRECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 32 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_iommu_pci_indirect " "liobn=0x%"PRIx64" ioba=0x%"PRIx64" tcelist=0x%"PRIx64" iobaN=0x%"PRIx64" tceN=0x%"PRIx64" ret=%"PRId64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , liobn, ioba, tce, iobaN, tceN, ret);
#line 1109 "trace/trace-hw_ppc.h"
        } else {
#line 32 "../hw/ppc/trace-events"
            qemu_log("spapr_iommu_pci_indirect " "liobn=0x%"PRIx64" ioba=0x%"PRIx64" tcelist=0x%"PRIx64" iobaN=0x%"PRIx64" tceN=0x%"PRIx64" ret=%"PRId64 "\n", liobn, ioba, tce, iobaN, tceN, ret);
#line 1113 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_iommu_pci_indirect(uint64_t liobn, uint64_t ioba, uint64_t tce, uint64_t iobaN, uint64_t tceN, uint64_t ret)
{
    if (true) {
        _nocheck__trace_spapr_iommu_pci_indirect(liobn, ioba, tce, iobaN, tceN, ret);
    }
}

#define TRACE_SPAPR_IOMMU_PCI_STUFF_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_IOMMU_PCI_STUFF) || \
    false)

static inline void _nocheck__trace_spapr_iommu_pci_stuff(uint64_t liobn, uint64_t ioba, uint64_t tce_value, uint64_t npages, uint64_t ret)
{
    if (trace_event_get_state(TRACE_SPAPR_IOMMU_PCI_STUFF) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 33 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_iommu_pci_stuff " "liobn=0x%"PRIx64" ioba=0x%"PRIx64" tcevalue=0x%"PRIx64" npages=%"PRId64" ret=%"PRId64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , liobn, ioba, tce_value, npages, ret);
#line 1140 "trace/trace-hw_ppc.h"
        } else {
#line 33 "../hw/ppc/trace-events"
            qemu_log("spapr_iommu_pci_stuff " "liobn=0x%"PRIx64" ioba=0x%"PRIx64" tcevalue=0x%"PRIx64" npages=%"PRId64" ret=%"PRId64 "\n", liobn, ioba, tce_value, npages, ret);
#line 1144 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_iommu_pci_stuff(uint64_t liobn, uint64_t ioba, uint64_t tce_value, uint64_t npages, uint64_t ret)
{
    if (true) {
        _nocheck__trace_spapr_iommu_pci_stuff(liobn, ioba, tce_value, npages, ret);
    }
}

#define TRACE_SPAPR_IOMMU_XLATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_IOMMU_XLATE) || \
    false)

static inline void _nocheck__trace_spapr_iommu_xlate(uint64_t liobn, uint64_t ioba, uint64_t tce, unsigned perm, unsigned pgsize)
{
    if (trace_event_get_state(TRACE_SPAPR_IOMMU_XLATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 34 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_iommu_xlate " "liobn=0x%"PRIx64" 0x%"PRIx64" -> 0x%"PRIx64" perm=%u mask=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , liobn, ioba, tce, perm, pgsize);
#line 1171 "trace/trace-hw_ppc.h"
        } else {
#line 34 "../hw/ppc/trace-events"
            qemu_log("spapr_iommu_xlate " "liobn=0x%"PRIx64" 0x%"PRIx64" -> 0x%"PRIx64" perm=%u mask=0x%x" "\n", liobn, ioba, tce, perm, pgsize);
#line 1175 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_iommu_xlate(uint64_t liobn, uint64_t ioba, uint64_t tce, unsigned perm, unsigned pgsize)
{
    if (true) {
        _nocheck__trace_spapr_iommu_xlate(liobn, ioba, tce, perm, pgsize);
    }
}

#define TRACE_SPAPR_IOMMU_NEW_TABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_IOMMU_NEW_TABLE) || \
    false)

static inline void _nocheck__trace_spapr_iommu_new_table(uint64_t liobn, void * table, int fd)
{
    if (trace_event_get_state(TRACE_SPAPR_IOMMU_NEW_TABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 35 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_iommu_new_table " "liobn=0x%"PRIx64" table=%p fd=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , liobn, table, fd);
#line 1202 "trace/trace-hw_ppc.h"
        } else {
#line 35 "../hw/ppc/trace-events"
            qemu_log("spapr_iommu_new_table " "liobn=0x%"PRIx64" table=%p fd=%d" "\n", liobn, table, fd);
#line 1206 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_iommu_new_table(uint64_t liobn, void * table, int fd)
{
    if (true) {
        _nocheck__trace_spapr_iommu_new_table(liobn, table, fd);
    }
}

#define TRACE_SPAPR_IOMMU_PRE_SAVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_IOMMU_PRE_SAVE) || \
    false)

static inline void _nocheck__trace_spapr_iommu_pre_save(uint64_t liobn, uint32_t nb, uint64_t offs, uint32_t ps)
{
    if (trace_event_get_state(TRACE_SPAPR_IOMMU_PRE_SAVE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 36 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_iommu_pre_save " "liobn=%"PRIx64" %"PRIx32" bus_offset=0x%"PRIx64" ps=%"PRIu32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , liobn, nb, offs, ps);
#line 1233 "trace/trace-hw_ppc.h"
        } else {
#line 36 "../hw/ppc/trace-events"
            qemu_log("spapr_iommu_pre_save " "liobn=%"PRIx64" %"PRIx32" bus_offset=0x%"PRIx64" ps=%"PRIu32 "\n", liobn, nb, offs, ps);
#line 1237 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_iommu_pre_save(uint64_t liobn, uint32_t nb, uint64_t offs, uint32_t ps)
{
    if (true) {
        _nocheck__trace_spapr_iommu_pre_save(liobn, nb, offs, ps);
    }
}

#define TRACE_SPAPR_IOMMU_POST_LOAD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_IOMMU_POST_LOAD) || \
    false)

static inline void _nocheck__trace_spapr_iommu_post_load(uint64_t liobn, uint32_t pre_nb, uint32_t post_nb, uint64_t offs, uint32_t ps)
{
    if (trace_event_get_state(TRACE_SPAPR_IOMMU_POST_LOAD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 37 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_iommu_post_load " "liobn=%"PRIx64" %"PRIx32" => 0x%"PRIx32" bus_offset=0x%"PRIx64" ps=%"PRIu32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , liobn, pre_nb, post_nb, offs, ps);
#line 1264 "trace/trace-hw_ppc.h"
        } else {
#line 37 "../hw/ppc/trace-events"
            qemu_log("spapr_iommu_post_load " "liobn=%"PRIx64" %"PRIx32" => 0x%"PRIx32" bus_offset=0x%"PRIx64" ps=%"PRIu32 "\n", liobn, pre_nb, post_nb, offs, ps);
#line 1268 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_iommu_post_load(uint64_t liobn, uint32_t pre_nb, uint32_t post_nb, uint64_t offs, uint32_t ps)
{
    if (true) {
        _nocheck__trace_spapr_iommu_post_load(liobn, pre_nb, post_nb, offs, ps);
    }
}

#define TRACE_SPAPR_IOMMU_DDW_QUERY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_IOMMU_DDW_QUERY) || \
    false)

static inline void _nocheck__trace_spapr_iommu_ddw_query(uint64_t buid, uint32_t cfgaddr, unsigned wa, uint64_t win_size, uint32_t pgmask)
{
    if (trace_event_get_state(TRACE_SPAPR_IOMMU_DDW_QUERY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 40 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_iommu_ddw_query " "buid=0x%"PRIx64" addr=0x%"PRIx32", %u windows available, max window size=0x%"PRIx64", mask=0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , buid, cfgaddr, wa, win_size, pgmask);
#line 1295 "trace/trace-hw_ppc.h"
        } else {
#line 40 "../hw/ppc/trace-events"
            qemu_log("spapr_iommu_ddw_query " "buid=0x%"PRIx64" addr=0x%"PRIx32", %u windows available, max window size=0x%"PRIx64", mask=0x%"PRIx32 "\n", buid, cfgaddr, wa, win_size, pgmask);
#line 1299 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_iommu_ddw_query(uint64_t buid, uint32_t cfgaddr, unsigned wa, uint64_t win_size, uint32_t pgmask)
{
    if (true) {
        _nocheck__trace_spapr_iommu_ddw_query(buid, cfgaddr, wa, win_size, pgmask);
    }
}

#define TRACE_SPAPR_IOMMU_DDW_CREATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_IOMMU_DDW_CREATE) || \
    false)

static inline void _nocheck__trace_spapr_iommu_ddw_create(uint64_t buid, uint32_t cfgaddr, uint64_t pg_size, uint64_t req_size, uint64_t start, uint32_t liobn)
{
    if (trace_event_get_state(TRACE_SPAPR_IOMMU_DDW_CREATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 41 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_iommu_ddw_create " "buid=0x%"PRIx64" addr=0x%"PRIx32", page size=0x%"PRIx64", requested=0x%"PRIx64", start addr=0x%"PRIx64", liobn=0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , buid, cfgaddr, pg_size, req_size, start, liobn);
#line 1326 "trace/trace-hw_ppc.h"
        } else {
#line 41 "../hw/ppc/trace-events"
            qemu_log("spapr_iommu_ddw_create " "buid=0x%"PRIx64" addr=0x%"PRIx32", page size=0x%"PRIx64", requested=0x%"PRIx64", start addr=0x%"PRIx64", liobn=0x%"PRIx32 "\n", buid, cfgaddr, pg_size, req_size, start, liobn);
#line 1330 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_iommu_ddw_create(uint64_t buid, uint32_t cfgaddr, uint64_t pg_size, uint64_t req_size, uint64_t start, uint32_t liobn)
{
    if (true) {
        _nocheck__trace_spapr_iommu_ddw_create(buid, cfgaddr, pg_size, req_size, start, liobn);
    }
}

#define TRACE_SPAPR_IOMMU_DDW_REMOVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_IOMMU_DDW_REMOVE) || \
    false)

static inline void _nocheck__trace_spapr_iommu_ddw_remove(uint32_t liobn)
{
    if (trace_event_get_state(TRACE_SPAPR_IOMMU_DDW_REMOVE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 42 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_iommu_ddw_remove " "liobn=0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , liobn);
#line 1357 "trace/trace-hw_ppc.h"
        } else {
#line 42 "../hw/ppc/trace-events"
            qemu_log("spapr_iommu_ddw_remove " "liobn=0x%"PRIx32 "\n", liobn);
#line 1361 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_iommu_ddw_remove(uint32_t liobn)
{
    if (true) {
        _nocheck__trace_spapr_iommu_ddw_remove(liobn);
    }
}

#define TRACE_SPAPR_IOMMU_DDW_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_IOMMU_DDW_RESET) || \
    false)

static inline void _nocheck__trace_spapr_iommu_ddw_reset(uint64_t buid, uint32_t cfgaddr)
{
    if (trace_event_get_state(TRACE_SPAPR_IOMMU_DDW_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 43 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_iommu_ddw_reset " "buid=0x%"PRIx64" addr=0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , buid, cfgaddr);
#line 1388 "trace/trace-hw_ppc.h"
        } else {
#line 43 "../hw/ppc/trace-events"
            qemu_log("spapr_iommu_ddw_reset " "buid=0x%"PRIx64" addr=0x%"PRIx32 "\n", buid, cfgaddr);
#line 1392 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_iommu_ddw_reset(uint64_t buid, uint32_t cfgaddr)
{
    if (true) {
        _nocheck__trace_spapr_iommu_ddw_reset(buid, cfgaddr);
    }
}

#define TRACE_SPAPR_DRC_SET_ISOLATION_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_DRC_SET_ISOLATION_STATE) || \
    false)

static inline void _nocheck__trace_spapr_drc_set_isolation_state(uint32_t index, int state)
{
    if (trace_event_get_state(TRACE_SPAPR_DRC_SET_ISOLATION_STATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 46 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_drc_set_isolation_state " "drc: 0x%"PRIx32", state: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index, state);
#line 1419 "trace/trace-hw_ppc.h"
        } else {
#line 46 "../hw/ppc/trace-events"
            qemu_log("spapr_drc_set_isolation_state " "drc: 0x%"PRIx32", state: 0x%"PRIx32 "\n", index, state);
#line 1423 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_drc_set_isolation_state(uint32_t index, int state)
{
    if (true) {
        _nocheck__trace_spapr_drc_set_isolation_state(index, state);
    }
}

#define TRACE_SPAPR_DRC_SET_ISOLATION_STATE_FINALIZING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_DRC_SET_ISOLATION_STATE_FINALIZING) || \
    false)

static inline void _nocheck__trace_spapr_drc_set_isolation_state_finalizing(uint32_t index)
{
    if (trace_event_get_state(TRACE_SPAPR_DRC_SET_ISOLATION_STATE_FINALIZING) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 47 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_drc_set_isolation_state_finalizing " "drc: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index);
#line 1450 "trace/trace-hw_ppc.h"
        } else {
#line 47 "../hw/ppc/trace-events"
            qemu_log("spapr_drc_set_isolation_state_finalizing " "drc: 0x%"PRIx32 "\n", index);
#line 1454 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_drc_set_isolation_state_finalizing(uint32_t index)
{
    if (true) {
        _nocheck__trace_spapr_drc_set_isolation_state_finalizing(index);
    }
}

#define TRACE_SPAPR_DRC_SET_DR_INDICATOR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_DRC_SET_DR_INDICATOR) || \
    false)

static inline void _nocheck__trace_spapr_drc_set_dr_indicator(uint32_t index, int state)
{
    if (trace_event_get_state(TRACE_SPAPR_DRC_SET_DR_INDICATOR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 48 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_drc_set_dr_indicator " "drc: 0x%"PRIx32", state: 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index, state);
#line 1481 "trace/trace-hw_ppc.h"
        } else {
#line 48 "../hw/ppc/trace-events"
            qemu_log("spapr_drc_set_dr_indicator " "drc: 0x%"PRIx32", state: 0x%x" "\n", index, state);
#line 1485 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_drc_set_dr_indicator(uint32_t index, int state)
{
    if (true) {
        _nocheck__trace_spapr_drc_set_dr_indicator(index, state);
    }
}

#define TRACE_SPAPR_DRC_SET_ALLOCATION_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_DRC_SET_ALLOCATION_STATE) || \
    false)

static inline void _nocheck__trace_spapr_drc_set_allocation_state(uint32_t index, int state)
{
    if (trace_event_get_state(TRACE_SPAPR_DRC_SET_ALLOCATION_STATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 49 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_drc_set_allocation_state " "drc: 0x%"PRIx32", state: 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index, state);
#line 1512 "trace/trace-hw_ppc.h"
        } else {
#line 49 "../hw/ppc/trace-events"
            qemu_log("spapr_drc_set_allocation_state " "drc: 0x%"PRIx32", state: 0x%x" "\n", index, state);
#line 1516 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_drc_set_allocation_state(uint32_t index, int state)
{
    if (true) {
        _nocheck__trace_spapr_drc_set_allocation_state(index, state);
    }
}

#define TRACE_SPAPR_DRC_SET_ALLOCATION_STATE_FINALIZING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_DRC_SET_ALLOCATION_STATE_FINALIZING) || \
    false)

static inline void _nocheck__trace_spapr_drc_set_allocation_state_finalizing(uint32_t index)
{
    if (trace_event_get_state(TRACE_SPAPR_DRC_SET_ALLOCATION_STATE_FINALIZING) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 50 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_drc_set_allocation_state_finalizing " "drc: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index);
#line 1543 "trace/trace-hw_ppc.h"
        } else {
#line 50 "../hw/ppc/trace-events"
            qemu_log("spapr_drc_set_allocation_state_finalizing " "drc: 0x%"PRIx32 "\n", index);
#line 1547 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_drc_set_allocation_state_finalizing(uint32_t index)
{
    if (true) {
        _nocheck__trace_spapr_drc_set_allocation_state_finalizing(index);
    }
}

#define TRACE_SPAPR_DRC_SET_CONFIGURED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_DRC_SET_CONFIGURED) || \
    false)

static inline void _nocheck__trace_spapr_drc_set_configured(uint32_t index)
{
    if (trace_event_get_state(TRACE_SPAPR_DRC_SET_CONFIGURED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 51 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_drc_set_configured " "drc: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index);
#line 1574 "trace/trace-hw_ppc.h"
        } else {
#line 51 "../hw/ppc/trace-events"
            qemu_log("spapr_drc_set_configured " "drc: 0x%"PRIx32 "\n", index);
#line 1578 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_drc_set_configured(uint32_t index)
{
    if (true) {
        _nocheck__trace_spapr_drc_set_configured(index);
    }
}

#define TRACE_SPAPR_DRC_ATTACH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_DRC_ATTACH) || \
    false)

static inline void _nocheck__trace_spapr_drc_attach(uint32_t index)
{
    if (trace_event_get_state(TRACE_SPAPR_DRC_ATTACH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 52 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_drc_attach " "drc: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index);
#line 1605 "trace/trace-hw_ppc.h"
        } else {
#line 52 "../hw/ppc/trace-events"
            qemu_log("spapr_drc_attach " "drc: 0x%"PRIx32 "\n", index);
#line 1609 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_drc_attach(uint32_t index)
{
    if (true) {
        _nocheck__trace_spapr_drc_attach(index);
    }
}

#define TRACE_SPAPR_DRC_UNPLUG_REQUEST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_DRC_UNPLUG_REQUEST) || \
    false)

static inline void _nocheck__trace_spapr_drc_unplug_request(uint32_t index)
{
    if (trace_event_get_state(TRACE_SPAPR_DRC_UNPLUG_REQUEST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 53 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_drc_unplug_request " "drc: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index);
#line 1636 "trace/trace-hw_ppc.h"
        } else {
#line 53 "../hw/ppc/trace-events"
            qemu_log("spapr_drc_unplug_request " "drc: 0x%"PRIx32 "\n", index);
#line 1640 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_drc_unplug_request(uint32_t index)
{
    if (true) {
        _nocheck__trace_spapr_drc_unplug_request(index);
    }
}

#define TRACE_SPAPR_DRC_AWAITING_QUIESCE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_DRC_AWAITING_QUIESCE) || \
    false)

static inline void _nocheck__trace_spapr_drc_awaiting_quiesce(uint32_t index)
{
    if (trace_event_get_state(TRACE_SPAPR_DRC_AWAITING_QUIESCE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 54 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_drc_awaiting_quiesce " "drc: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index);
#line 1667 "trace/trace-hw_ppc.h"
        } else {
#line 54 "../hw/ppc/trace-events"
            qemu_log("spapr_drc_awaiting_quiesce " "drc: 0x%"PRIx32 "\n", index);
#line 1671 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_drc_awaiting_quiesce(uint32_t index)
{
    if (true) {
        _nocheck__trace_spapr_drc_awaiting_quiesce(index);
    }
}

#define TRACE_SPAPR_DRC_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_DRC_RESET) || \
    false)

static inline void _nocheck__trace_spapr_drc_reset(uint32_t index)
{
    if (trace_event_get_state(TRACE_SPAPR_DRC_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 55 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_drc_reset " "drc: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index);
#line 1698 "trace/trace-hw_ppc.h"
        } else {
#line 55 "../hw/ppc/trace-events"
            qemu_log("spapr_drc_reset " "drc: 0x%"PRIx32 "\n", index);
#line 1702 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_drc_reset(uint32_t index)
{
    if (true) {
        _nocheck__trace_spapr_drc_reset(index);
    }
}

#define TRACE_SPAPR_DRC_REALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_DRC_REALIZE) || \
    false)

static inline void _nocheck__trace_spapr_drc_realize(uint32_t index)
{
    if (trace_event_get_state(TRACE_SPAPR_DRC_REALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 56 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_drc_realize " "drc: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index);
#line 1729 "trace/trace-hw_ppc.h"
        } else {
#line 56 "../hw/ppc/trace-events"
            qemu_log("spapr_drc_realize " "drc: 0x%"PRIx32 "\n", index);
#line 1733 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_drc_realize(uint32_t index)
{
    if (true) {
        _nocheck__trace_spapr_drc_realize(index);
    }
}

#define TRACE_SPAPR_DRC_REALIZE_CHILD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_DRC_REALIZE_CHILD) || \
    false)

static inline void _nocheck__trace_spapr_drc_realize_child(uint32_t index, const char * childname)
{
    if (trace_event_get_state(TRACE_SPAPR_DRC_REALIZE_CHILD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 57 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_drc_realize_child " "drc: 0x%"PRIx32", child name: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index, childname);
#line 1760 "trace/trace-hw_ppc.h"
        } else {
#line 57 "../hw/ppc/trace-events"
            qemu_log("spapr_drc_realize_child " "drc: 0x%"PRIx32", child name: %s" "\n", index, childname);
#line 1764 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_drc_realize_child(uint32_t index, const char * childname)
{
    if (true) {
        _nocheck__trace_spapr_drc_realize_child(index, childname);
    }
}

#define TRACE_SPAPR_DRC_REALIZE_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_DRC_REALIZE_COMPLETE) || \
    false)

static inline void _nocheck__trace_spapr_drc_realize_complete(uint32_t index)
{
    if (trace_event_get_state(TRACE_SPAPR_DRC_REALIZE_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 58 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_drc_realize_complete " "drc: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index);
#line 1791 "trace/trace-hw_ppc.h"
        } else {
#line 58 "../hw/ppc/trace-events"
            qemu_log("spapr_drc_realize_complete " "drc: 0x%"PRIx32 "\n", index);
#line 1795 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_drc_realize_complete(uint32_t index)
{
    if (true) {
        _nocheck__trace_spapr_drc_realize_complete(index);
    }
}

#define TRACE_SPAPR_DRC_UNREALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_DRC_UNREALIZE) || \
    false)

static inline void _nocheck__trace_spapr_drc_unrealize(uint32_t index)
{
    if (trace_event_get_state(TRACE_SPAPR_DRC_UNREALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 59 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_drc_unrealize " "drc: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index);
#line 1822 "trace/trace-hw_ppc.h"
        } else {
#line 59 "../hw/ppc/trace-events"
            qemu_log("spapr_drc_unrealize " "drc: 0x%"PRIx32 "\n", index);
#line 1826 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_drc_unrealize(uint32_t index)
{
    if (true) {
        _nocheck__trace_spapr_drc_unrealize(index);
    }
}

#define TRACE_SPAPR_OVEC_PARSE_VECTOR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_OVEC_PARSE_VECTOR) || \
    false)

static inline void _nocheck__trace_spapr_ovec_parse_vector(int vector, int byte, uint16_t vec_len, uint8_t entry)
{
    if (trace_event_get_state(TRACE_SPAPR_OVEC_PARSE_VECTOR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 62 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_ovec_parse_vector " "read guest vector %2d, byte %3d / %3d: 0x%.2x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vector, byte, vec_len, entry);
#line 1853 "trace/trace-hw_ppc.h"
        } else {
#line 62 "../hw/ppc/trace-events"
            qemu_log("spapr_ovec_parse_vector " "read guest vector %2d, byte %3d / %3d: 0x%.2x" "\n", vector, byte, vec_len, entry);
#line 1857 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_ovec_parse_vector(int vector, int byte, uint16_t vec_len, uint8_t entry)
{
    if (true) {
        _nocheck__trace_spapr_ovec_parse_vector(vector, byte, vec_len, entry);
    }
}

#define TRACE_SPAPR_OVEC_POPULATE_DT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_OVEC_POPULATE_DT) || \
    false)

static inline void _nocheck__trace_spapr_ovec_populate_dt(int byte, uint16_t vec_len, uint8_t entry)
{
    if (trace_event_get_state(TRACE_SPAPR_OVEC_POPULATE_DT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 63 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_ovec_populate_dt " "encoding guest vector byte %3d / %3d: 0x%.2x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , byte, vec_len, entry);
#line 1884 "trace/trace-hw_ppc.h"
        } else {
#line 63 "../hw/ppc/trace-events"
            qemu_log("spapr_ovec_populate_dt " "encoding guest vector byte %3d / %3d: 0x%.2x" "\n", byte, vec_len, entry);
#line 1888 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_ovec_populate_dt(int byte, uint16_t vec_len, uint8_t entry)
{
    if (true) {
        _nocheck__trace_spapr_ovec_populate_dt(byte, vec_len, entry);
    }
}

#define TRACE_SPAPR_RTAS_GET_SENSOR_STATE_NOT_SUPPORTED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_RTAS_GET_SENSOR_STATE_NOT_SUPPORTED) || \
    false)

static inline void _nocheck__trace_spapr_rtas_get_sensor_state_not_supported(uint32_t index, uint32_t type)
{
    if (trace_event_get_state(TRACE_SPAPR_RTAS_GET_SENSOR_STATE_NOT_SUPPORTED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 66 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_rtas_get_sensor_state_not_supported " "sensor index: 0x%"PRIx32", type: %"PRIu32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index, type);
#line 1915 "trace/trace-hw_ppc.h"
        } else {
#line 66 "../hw/ppc/trace-events"
            qemu_log("spapr_rtas_get_sensor_state_not_supported " "sensor index: 0x%"PRIx32", type: %"PRIu32 "\n", index, type);
#line 1919 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_rtas_get_sensor_state_not_supported(uint32_t index, uint32_t type)
{
    if (true) {
        _nocheck__trace_spapr_rtas_get_sensor_state_not_supported(index, type);
    }
}

#define TRACE_SPAPR_RTAS_GET_SENSOR_STATE_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_RTAS_GET_SENSOR_STATE_INVALID) || \
    false)

static inline void _nocheck__trace_spapr_rtas_get_sensor_state_invalid(uint32_t index)
{
    if (trace_event_get_state(TRACE_SPAPR_RTAS_GET_SENSOR_STATE_INVALID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 67 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_rtas_get_sensor_state_invalid " "sensor index: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index);
#line 1946 "trace/trace-hw_ppc.h"
        } else {
#line 67 "../hw/ppc/trace-events"
            qemu_log("spapr_rtas_get_sensor_state_invalid " "sensor index: 0x%"PRIx32 "\n", index);
#line 1950 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_rtas_get_sensor_state_invalid(uint32_t index)
{
    if (true) {
        _nocheck__trace_spapr_rtas_get_sensor_state_invalid(index);
    }
}

#define TRACE_SPAPR_RTAS_IBM_CONFIGURE_CONNECTOR_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_RTAS_IBM_CONFIGURE_CONNECTOR_INVALID) || \
    false)

static inline void _nocheck__trace_spapr_rtas_ibm_configure_connector_invalid(uint32_t index)
{
    if (trace_event_get_state(TRACE_SPAPR_RTAS_IBM_CONFIGURE_CONNECTOR_INVALID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 68 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_rtas_ibm_configure_connector_invalid " "DRC index: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index);
#line 1977 "trace/trace-hw_ppc.h"
        } else {
#line 68 "../hw/ppc/trace-events"
            qemu_log("spapr_rtas_ibm_configure_connector_invalid " "DRC index: 0x%"PRIx32 "\n", index);
#line 1981 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_rtas_ibm_configure_connector_invalid(uint32_t index)
{
    if (true) {
        _nocheck__trace_spapr_rtas_ibm_configure_connector_invalid(index);
    }
}

#define TRACE_SPAPR_VIO_H_REG_CRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_VIO_H_REG_CRQ) || \
    false)

static inline void _nocheck__trace_spapr_vio_h_reg_crq(uint64_t reg, uint64_t queue_addr, uint64_t queue_len)
{
    if (trace_event_get_state(TRACE_SPAPR_VIO_H_REG_CRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 71 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_vio_h_reg_crq " "CRQ for dev 0x%" PRIx64 " registered at 0x%" PRIx64 "/0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reg, queue_addr, queue_len);
#line 2008 "trace/trace-hw_ppc.h"
        } else {
#line 71 "../hw/ppc/trace-events"
            qemu_log("spapr_vio_h_reg_crq " "CRQ for dev 0x%" PRIx64 " registered at 0x%" PRIx64 "/0x%" PRIx64 "\n", reg, queue_addr, queue_len);
#line 2012 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_vio_h_reg_crq(uint64_t reg, uint64_t queue_addr, uint64_t queue_len)
{
    if (true) {
        _nocheck__trace_spapr_vio_h_reg_crq(reg, queue_addr, queue_len);
    }
}

#define TRACE_SPAPR_VIO_FREE_CRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_VIO_FREE_CRQ) || \
    false)

static inline void _nocheck__trace_spapr_vio_free_crq(uint32_t reg)
{
    if (trace_event_get_state(TRACE_SPAPR_VIO_FREE_CRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 72 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_vio_free_crq " "CRQ for dev 0x%" PRIx32 " freed" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reg);
#line 2039 "trace/trace-hw_ppc.h"
        } else {
#line 72 "../hw/ppc/trace-events"
            qemu_log("spapr_vio_free_crq " "CRQ for dev 0x%" PRIx32 " freed" "\n", reg);
#line 2043 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_vio_free_crq(uint32_t reg)
{
    if (true) {
        _nocheck__trace_spapr_vio_free_crq(reg);
    }
}

#define TRACE_VOF_ERROR_STR_TRUNCATED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VOF_ERROR_STR_TRUNCATED) || \
    false)

static inline void _nocheck__trace_vof_error_str_truncated(const char * s, int len)
{
    if (trace_event_get_state(TRACE_VOF_ERROR_STR_TRUNCATED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 75 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:vof_error_str_truncated " "%s truncated to %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, len);
#line 2070 "trace/trace-hw_ppc.h"
        } else {
#line 75 "../hw/ppc/trace-events"
            qemu_log("vof_error_str_truncated " "%s truncated to %d" "\n", s, len);
#line 2074 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_vof_error_str_truncated(const char * s, int len)
{
    if (true) {
        _nocheck__trace_vof_error_str_truncated(s, len);
    }
}

#define TRACE_VOF_ERROR_PARAM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VOF_ERROR_PARAM) || \
    false)

static inline void _nocheck__trace_vof_error_param(const char * method, int nargscheck, int nretcheck, int nargs, int nret)
{
    if (trace_event_get_state(TRACE_VOF_ERROR_PARAM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 76 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:vof_error_param " "%s takes/returns %d/%d, not %d/%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , method, nargscheck, nretcheck, nargs, nret);
#line 2101 "trace/trace-hw_ppc.h"
        } else {
#line 76 "../hw/ppc/trace-events"
            qemu_log("vof_error_param " "%s takes/returns %d/%d, not %d/%d" "\n", method, nargscheck, nretcheck, nargs, nret);
#line 2105 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_vof_error_param(const char * method, int nargscheck, int nretcheck, int nargs, int nret)
{
    if (true) {
        _nocheck__trace_vof_error_param(method, nargscheck, nretcheck, nargs, nret);
    }
}

#define TRACE_VOF_ERROR_UNKNOWN_SERVICE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VOF_ERROR_UNKNOWN_SERVICE) || \
    false)

static inline void _nocheck__trace_vof_error_unknown_service(const char * service, int nargs, int nret)
{
    if (trace_event_get_state(TRACE_VOF_ERROR_UNKNOWN_SERVICE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 77 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:vof_error_unknown_service " "\"%s\" args=%d rets=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , service, nargs, nret);
#line 2132 "trace/trace-hw_ppc.h"
        } else {
#line 77 "../hw/ppc/trace-events"
            qemu_log("vof_error_unknown_service " "\"%s\" args=%d rets=%d" "\n", service, nargs, nret);
#line 2136 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_vof_error_unknown_service(const char * service, int nargs, int nret)
{
    if (true) {
        _nocheck__trace_vof_error_unknown_service(service, nargs, nret);
    }
}

#define TRACE_VOF_ERROR_UNKNOWN_METHOD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VOF_ERROR_UNKNOWN_METHOD) || \
    false)

static inline void _nocheck__trace_vof_error_unknown_method(const char * method)
{
    if (trace_event_get_state(TRACE_VOF_ERROR_UNKNOWN_METHOD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 78 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:vof_error_unknown_method " "\"%s\"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , method);
#line 2163 "trace/trace-hw_ppc.h"
        } else {
#line 78 "../hw/ppc/trace-events"
            qemu_log("vof_error_unknown_method " "\"%s\"" "\n", method);
#line 2167 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_vof_error_unknown_method(const char * method)
{
    if (true) {
        _nocheck__trace_vof_error_unknown_method(method);
    }
}

#define TRACE_VOF_ERROR_UNKNOWN_IHANDLE_CLOSE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VOF_ERROR_UNKNOWN_IHANDLE_CLOSE) || \
    false)

static inline void _nocheck__trace_vof_error_unknown_ihandle_close(uint32_t ih)
{
    if (trace_event_get_state(TRACE_VOF_ERROR_UNKNOWN_IHANDLE_CLOSE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 79 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:vof_error_unknown_ihandle_close " "ih=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ih);
#line 2194 "trace/trace-hw_ppc.h"
        } else {
#line 79 "../hw/ppc/trace-events"
            qemu_log("vof_error_unknown_ihandle_close " "ih=0x%x" "\n", ih);
#line 2198 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_vof_error_unknown_ihandle_close(uint32_t ih)
{
    if (true) {
        _nocheck__trace_vof_error_unknown_ihandle_close(ih);
    }
}

#define TRACE_VOF_ERROR_UNKNOWN_PATH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VOF_ERROR_UNKNOWN_PATH) || \
    false)

static inline void _nocheck__trace_vof_error_unknown_path(const char * path)
{
    if (trace_event_get_state(TRACE_VOF_ERROR_UNKNOWN_PATH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 80 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:vof_error_unknown_path " "\"%s\"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , path);
#line 2225 "trace/trace-hw_ppc.h"
        } else {
#line 80 "../hw/ppc/trace-events"
            qemu_log("vof_error_unknown_path " "\"%s\"" "\n", path);
#line 2229 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_vof_error_unknown_path(const char * path)
{
    if (true) {
        _nocheck__trace_vof_error_unknown_path(path);
    }
}

#define TRACE_VOF_ERROR_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VOF_ERROR_WRITE) || \
    false)

static inline void _nocheck__trace_vof_error_write(uint32_t ih)
{
    if (trace_event_get_state(TRACE_VOF_ERROR_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 81 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:vof_error_write " "ih=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ih);
#line 2256 "trace/trace-hw_ppc.h"
        } else {
#line 81 "../hw/ppc/trace-events"
            qemu_log("vof_error_write " "ih=0x%x" "\n", ih);
#line 2260 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_vof_error_write(uint32_t ih)
{
    if (true) {
        _nocheck__trace_vof_error_write(ih);
    }
}

#define TRACE_VOF_FINDDEVICE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VOF_FINDDEVICE) || \
    false)

static inline void _nocheck__trace_vof_finddevice(const char * path, uint32_t ph)
{
    if (trace_event_get_state(TRACE_VOF_FINDDEVICE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 82 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:vof_finddevice " "\"%s\" => ph=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , path, ph);
#line 2287 "trace/trace-hw_ppc.h"
        } else {
#line 82 "../hw/ppc/trace-events"
            qemu_log("vof_finddevice " "\"%s\" => ph=0x%x" "\n", path, ph);
#line 2291 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_vof_finddevice(const char * path, uint32_t ph)
{
    if (true) {
        _nocheck__trace_vof_finddevice(path, ph);
    }
}

#define TRACE_VOF_CLAIM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VOF_CLAIM) || \
    false)

static inline void _nocheck__trace_vof_claim(uint32_t virt, uint32_t size, uint32_t align, uint32_t ret)
{
    if (trace_event_get_state(TRACE_VOF_CLAIM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 83 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:vof_claim " "virt=0x%x size=0x%x align=0x%x => 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , virt, size, align, ret);
#line 2318 "trace/trace-hw_ppc.h"
        } else {
#line 83 "../hw/ppc/trace-events"
            qemu_log("vof_claim " "virt=0x%x size=0x%x align=0x%x => 0x%x" "\n", virt, size, align, ret);
#line 2322 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_vof_claim(uint32_t virt, uint32_t size, uint32_t align, uint32_t ret)
{
    if (true) {
        _nocheck__trace_vof_claim(virt, size, align, ret);
    }
}

#define TRACE_VOF_RELEASE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VOF_RELEASE) || \
    false)

static inline void _nocheck__trace_vof_release(uint32_t virt, uint32_t size, uint32_t ret)
{
    if (trace_event_get_state(TRACE_VOF_RELEASE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 84 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:vof_release " "virt=0x%x size=0x%x => 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , virt, size, ret);
#line 2349 "trace/trace-hw_ppc.h"
        } else {
#line 84 "../hw/ppc/trace-events"
            qemu_log("vof_release " "virt=0x%x size=0x%x => 0x%x" "\n", virt, size, ret);
#line 2353 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_vof_release(uint32_t virt, uint32_t size, uint32_t ret)
{
    if (true) {
        _nocheck__trace_vof_release(virt, size, ret);
    }
}

#define TRACE_VOF_METHOD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VOF_METHOD) || \
    false)

static inline void _nocheck__trace_vof_method(uint32_t ihandle, const char * method, uint32_t param, uint32_t ret, uint32_t ret2)
{
    if (trace_event_get_state(TRACE_VOF_METHOD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 85 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:vof_method " "ih=0x%x \"%s\"(0x%x) => 0x%x 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ihandle, method, param, ret, ret2);
#line 2380 "trace/trace-hw_ppc.h"
        } else {
#line 85 "../hw/ppc/trace-events"
            qemu_log("vof_method " "ih=0x%x \"%s\"(0x%x) => 0x%x 0x%x" "\n", ihandle, method, param, ret, ret2);
#line 2384 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_vof_method(uint32_t ihandle, const char * method, uint32_t param, uint32_t ret, uint32_t ret2)
{
    if (true) {
        _nocheck__trace_vof_method(ihandle, method, param, ret, ret2);
    }
}

#define TRACE_VOF_GETPROP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VOF_GETPROP) || \
    false)

static inline void _nocheck__trace_vof_getprop(uint32_t ph, const char * prop, uint32_t ret, const char * val)
{
    if (trace_event_get_state(TRACE_VOF_GETPROP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 86 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:vof_getprop " "ph=0x%x \"%s\" => len=%d [%s]" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ph, prop, ret, val);
#line 2411 "trace/trace-hw_ppc.h"
        } else {
#line 86 "../hw/ppc/trace-events"
            qemu_log("vof_getprop " "ph=0x%x \"%s\" => len=%d [%s]" "\n", ph, prop, ret, val);
#line 2415 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_vof_getprop(uint32_t ph, const char * prop, uint32_t ret, const char * val)
{
    if (true) {
        _nocheck__trace_vof_getprop(ph, prop, ret, val);
    }
}

#define TRACE_VOF_GETPROPLEN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VOF_GETPROPLEN) || \
    false)

static inline void _nocheck__trace_vof_getproplen(uint32_t ph, const char * prop, uint32_t ret)
{
    if (trace_event_get_state(TRACE_VOF_GETPROPLEN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 87 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:vof_getproplen " "ph=0x%x \"%s\" => len=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ph, prop, ret);
#line 2442 "trace/trace-hw_ppc.h"
        } else {
#line 87 "../hw/ppc/trace-events"
            qemu_log("vof_getproplen " "ph=0x%x \"%s\" => len=%d" "\n", ph, prop, ret);
#line 2446 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_vof_getproplen(uint32_t ph, const char * prop, uint32_t ret)
{
    if (true) {
        _nocheck__trace_vof_getproplen(ph, prop, ret);
    }
}

#define TRACE_VOF_SETPROP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VOF_SETPROP) || \
    false)

static inline void _nocheck__trace_vof_setprop(uint32_t ph, const char * prop, const char * val, uint32_t vallen, uint32_t ret)
{
    if (trace_event_get_state(TRACE_VOF_SETPROP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 88 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:vof_setprop " "ph=0x%x \"%s\" [%s] len=%d => ret=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ph, prop, val, vallen, ret);
#line 2473 "trace/trace-hw_ppc.h"
        } else {
#line 88 "../hw/ppc/trace-events"
            qemu_log("vof_setprop " "ph=0x%x \"%s\" [%s] len=%d => ret=%d" "\n", ph, prop, val, vallen, ret);
#line 2477 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_vof_setprop(uint32_t ph, const char * prop, const char * val, uint32_t vallen, uint32_t ret)
{
    if (true) {
        _nocheck__trace_vof_setprop(ph, prop, val, vallen, ret);
    }
}

#define TRACE_VOF_OPEN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VOF_OPEN) || \
    false)

static inline void _nocheck__trace_vof_open(const char * path, uint32_t ph, uint32_t ih)
{
    if (trace_event_get_state(TRACE_VOF_OPEN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 89 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:vof_open " "%s ph=0x%x => ih=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , path, ph, ih);
#line 2504 "trace/trace-hw_ppc.h"
        } else {
#line 89 "../hw/ppc/trace-events"
            qemu_log("vof_open " "%s ph=0x%x => ih=0x%x" "\n", path, ph, ih);
#line 2508 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_vof_open(const char * path, uint32_t ph, uint32_t ih)
{
    if (true) {
        _nocheck__trace_vof_open(path, ph, ih);
    }
}

#define TRACE_VOF_INTERPRET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VOF_INTERPRET) || \
    false)

static inline void _nocheck__trace_vof_interpret(const char * cmd, uint32_t param1, uint32_t param2, uint32_t ret, uint32_t ret2)
{
    if (trace_event_get_state(TRACE_VOF_INTERPRET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 90 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:vof_interpret " "[%s] 0x%x 0x%x => 0x%x 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, param1, param2, ret, ret2);
#line 2535 "trace/trace-hw_ppc.h"
        } else {
#line 90 "../hw/ppc/trace-events"
            qemu_log("vof_interpret " "[%s] 0x%x 0x%x => 0x%x 0x%x" "\n", cmd, param1, param2, ret, ret2);
#line 2539 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_vof_interpret(const char * cmd, uint32_t param1, uint32_t param2, uint32_t ret, uint32_t ret2)
{
    if (true) {
        _nocheck__trace_vof_interpret(cmd, param1, param2, ret, ret2);
    }
}

#define TRACE_VOF_PACKAGE_TO_PATH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VOF_PACKAGE_TO_PATH) || \
    false)

static inline void _nocheck__trace_vof_package_to_path(uint32_t ph, const char * tmp, int ret)
{
    if (trace_event_get_state(TRACE_VOF_PACKAGE_TO_PATH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 91 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:vof_package_to_path " "ph=0x%x => %s len=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ph, tmp, ret);
#line 2566 "trace/trace-hw_ppc.h"
        } else {
#line 91 "../hw/ppc/trace-events"
            qemu_log("vof_package_to_path " "ph=0x%x => %s len=%d" "\n", ph, tmp, ret);
#line 2570 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_vof_package_to_path(uint32_t ph, const char * tmp, int ret)
{
    if (true) {
        _nocheck__trace_vof_package_to_path(ph, tmp, ret);
    }
}

#define TRACE_VOF_INSTANCE_TO_PATH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VOF_INSTANCE_TO_PATH) || \
    false)

static inline void _nocheck__trace_vof_instance_to_path(uint32_t ih, uint32_t ph, const char * tmp, int ret)
{
    if (trace_event_get_state(TRACE_VOF_INSTANCE_TO_PATH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 92 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:vof_instance_to_path " "ih=0x%x ph=0x%x => %s len=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ih, ph, tmp, ret);
#line 2597 "trace/trace-hw_ppc.h"
        } else {
#line 92 "../hw/ppc/trace-events"
            qemu_log("vof_instance_to_path " "ih=0x%x ph=0x%x => %s len=%d" "\n", ih, ph, tmp, ret);
#line 2601 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_vof_instance_to_path(uint32_t ih, uint32_t ph, const char * tmp, int ret)
{
    if (true) {
        _nocheck__trace_vof_instance_to_path(ih, ph, tmp, ret);
    }
}

#define TRACE_VOF_INSTANCE_TO_PACKAGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VOF_INSTANCE_TO_PACKAGE) || \
    false)

static inline void _nocheck__trace_vof_instance_to_package(uint32_t ih, uint32_t ph)
{
    if (trace_event_get_state(TRACE_VOF_INSTANCE_TO_PACKAGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 93 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:vof_instance_to_package " "ih=0x%x => ph=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ih, ph);
#line 2628 "trace/trace-hw_ppc.h"
        } else {
#line 93 "../hw/ppc/trace-events"
            qemu_log("vof_instance_to_package " "ih=0x%x => ph=0x%x" "\n", ih, ph);
#line 2632 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_vof_instance_to_package(uint32_t ih, uint32_t ph)
{
    if (true) {
        _nocheck__trace_vof_instance_to_package(ih, ph);
    }
}

#define TRACE_VOF_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VOF_WRITE) || \
    false)

static inline void _nocheck__trace_vof_write(uint32_t ih, unsigned cb, const char * msg)
{
    if (trace_event_get_state(TRACE_VOF_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 94 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:vof_write " "ih=0x%x [%u] \"%s\"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ih, cb, msg);
#line 2659 "trace/trace-hw_ppc.h"
        } else {
#line 94 "../hw/ppc/trace-events"
            qemu_log("vof_write " "ih=0x%x [%u] \"%s\"" "\n", ih, cb, msg);
#line 2663 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_vof_write(uint32_t ih, unsigned cb, const char * msg)
{
    if (true) {
        _nocheck__trace_vof_write(ih, cb, msg);
    }
}

#define TRACE_VOF_AVAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VOF_AVAIL) || \
    false)

static inline void _nocheck__trace_vof_avail(uint64_t start, uint64_t end, uint64_t size)
{
    if (trace_event_get_state(TRACE_VOF_AVAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 95 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:vof_avail " "0x%"PRIx64"..0x%"PRIx64" size=0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , start, end, size);
#line 2690 "trace/trace-hw_ppc.h"
        } else {
#line 95 "../hw/ppc/trace-events"
            qemu_log("vof_avail " "0x%"PRIx64"..0x%"PRIx64" size=0x%"PRIx64 "\n", start, end, size);
#line 2694 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_vof_avail(uint64_t start, uint64_t end, uint64_t size)
{
    if (true) {
        _nocheck__trace_vof_avail(start, end, size);
    }
}

#define TRACE_VOF_CLAIMED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VOF_CLAIMED) || \
    false)

static inline void _nocheck__trace_vof_claimed(uint64_t start, uint64_t end, uint64_t size)
{
    if (trace_event_get_state(TRACE_VOF_CLAIMED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 96 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:vof_claimed " "0x%"PRIx64"..0x%"PRIx64" size=0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , start, end, size);
#line 2721 "trace/trace-hw_ppc.h"
        } else {
#line 96 "../hw/ppc/trace-events"
            qemu_log("vof_claimed " "0x%"PRIx64"..0x%"PRIx64" size=0x%"PRIx64 "\n", start, end, size);
#line 2725 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_vof_claimed(uint64_t start, uint64_t end, uint64_t size)
{
    if (true) {
        _nocheck__trace_vof_claimed(start, end, size);
    }
}

#define TRACE_PNV_ADU_XSCOM_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PNV_ADU_XSCOM_READ) || \
    false)

static inline void _nocheck__trace_pnv_adu_xscom_read(uint64_t addr, uint64_t val)
{
    if (trace_event_get_state(TRACE_PNV_ADU_XSCOM_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 99 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:pnv_adu_xscom_read " "addr 0x%" PRIx64 " val 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 2752 "trace/trace-hw_ppc.h"
        } else {
#line 99 "../hw/ppc/trace-events"
            qemu_log("pnv_adu_xscom_read " "addr 0x%" PRIx64 " val 0x%" PRIx64 "\n", addr, val);
#line 2756 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_pnv_adu_xscom_read(uint64_t addr, uint64_t val)
{
    if (true) {
        _nocheck__trace_pnv_adu_xscom_read(addr, val);
    }
}

#define TRACE_PNV_ADU_XSCOM_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PNV_ADU_XSCOM_WRITE) || \
    false)

static inline void _nocheck__trace_pnv_adu_xscom_write(uint64_t addr, uint64_t val)
{
    if (trace_event_get_state(TRACE_PNV_ADU_XSCOM_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 100 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:pnv_adu_xscom_write " "addr 0x%" PRIx64 " val 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 2783 "trace/trace-hw_ppc.h"
        } else {
#line 100 "../hw/ppc/trace-events"
            qemu_log("pnv_adu_xscom_write " "addr 0x%" PRIx64 " val 0x%" PRIx64 "\n", addr, val);
#line 2787 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_pnv_adu_xscom_write(uint64_t addr, uint64_t val)
{
    if (true) {
        _nocheck__trace_pnv_adu_xscom_write(addr, val);
    }
}

#define TRACE_PNV_CHIPTOD_XSCOM_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PNV_CHIPTOD_XSCOM_READ) || \
    false)

static inline void _nocheck__trace_pnv_chiptod_xscom_read(uint64_t addr, uint64_t val)
{
    if (trace_event_get_state(TRACE_PNV_CHIPTOD_XSCOM_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 103 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:pnv_chiptod_xscom_read " "addr 0x%" PRIx64 " val 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 2814 "trace/trace-hw_ppc.h"
        } else {
#line 103 "../hw/ppc/trace-events"
            qemu_log("pnv_chiptod_xscom_read " "addr 0x%" PRIx64 " val 0x%" PRIx64 "\n", addr, val);
#line 2818 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_pnv_chiptod_xscom_read(uint64_t addr, uint64_t val)
{
    if (true) {
        _nocheck__trace_pnv_chiptod_xscom_read(addr, val);
    }
}

#define TRACE_PNV_CHIPTOD_XSCOM_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PNV_CHIPTOD_XSCOM_WRITE) || \
    false)

static inline void _nocheck__trace_pnv_chiptod_xscom_write(uint64_t addr, uint64_t val)
{
    if (trace_event_get_state(TRACE_PNV_CHIPTOD_XSCOM_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 104 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:pnv_chiptod_xscom_write " "addr 0x%" PRIx64 " val 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 2845 "trace/trace-hw_ppc.h"
        } else {
#line 104 "../hw/ppc/trace-events"
            qemu_log("pnv_chiptod_xscom_write " "addr 0x%" PRIx64 " val 0x%" PRIx64 "\n", addr, val);
#line 2849 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_pnv_chiptod_xscom_write(uint64_t addr, uint64_t val)
{
    if (true) {
        _nocheck__trace_pnv_chiptod_xscom_write(addr, val);
    }
}

#define TRACE_PNV_SBE_XSCOM_CTRL_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PNV_SBE_XSCOM_CTRL_READ) || \
    false)

static inline void _nocheck__trace_pnv_sbe_xscom_ctrl_read(uint64_t addr, uint64_t val)
{
    if (trace_event_get_state(TRACE_PNV_SBE_XSCOM_CTRL_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 107 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:pnv_sbe_xscom_ctrl_read " "addr 0x%" PRIx64 " val 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 2876 "trace/trace-hw_ppc.h"
        } else {
#line 107 "../hw/ppc/trace-events"
            qemu_log("pnv_sbe_xscom_ctrl_read " "addr 0x%" PRIx64 " val 0x%" PRIx64 "\n", addr, val);
#line 2880 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_pnv_sbe_xscom_ctrl_read(uint64_t addr, uint64_t val)
{
    if (true) {
        _nocheck__trace_pnv_sbe_xscom_ctrl_read(addr, val);
    }
}

#define TRACE_PNV_SBE_XSCOM_CTRL_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PNV_SBE_XSCOM_CTRL_WRITE) || \
    false)

static inline void _nocheck__trace_pnv_sbe_xscom_ctrl_write(uint64_t addr, uint64_t val)
{
    if (trace_event_get_state(TRACE_PNV_SBE_XSCOM_CTRL_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 108 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:pnv_sbe_xscom_ctrl_write " "addr 0x%" PRIx64 " val 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 2907 "trace/trace-hw_ppc.h"
        } else {
#line 108 "../hw/ppc/trace-events"
            qemu_log("pnv_sbe_xscom_ctrl_write " "addr 0x%" PRIx64 " val 0x%" PRIx64 "\n", addr, val);
#line 2911 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_pnv_sbe_xscom_ctrl_write(uint64_t addr, uint64_t val)
{
    if (true) {
        _nocheck__trace_pnv_sbe_xscom_ctrl_write(addr, val);
    }
}

#define TRACE_PNV_SBE_XSCOM_MBOX_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PNV_SBE_XSCOM_MBOX_READ) || \
    false)

static inline void _nocheck__trace_pnv_sbe_xscom_mbox_read(uint64_t addr, uint64_t val)
{
    if (trace_event_get_state(TRACE_PNV_SBE_XSCOM_MBOX_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 109 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:pnv_sbe_xscom_mbox_read " "addr 0x%" PRIx64 " val 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 2938 "trace/trace-hw_ppc.h"
        } else {
#line 109 "../hw/ppc/trace-events"
            qemu_log("pnv_sbe_xscom_mbox_read " "addr 0x%" PRIx64 " val 0x%" PRIx64 "\n", addr, val);
#line 2942 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_pnv_sbe_xscom_mbox_read(uint64_t addr, uint64_t val)
{
    if (true) {
        _nocheck__trace_pnv_sbe_xscom_mbox_read(addr, val);
    }
}

#define TRACE_PNV_SBE_XSCOM_MBOX_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PNV_SBE_XSCOM_MBOX_WRITE) || \
    false)

static inline void _nocheck__trace_pnv_sbe_xscom_mbox_write(uint64_t addr, uint64_t val)
{
    if (trace_event_get_state(TRACE_PNV_SBE_XSCOM_MBOX_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 110 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:pnv_sbe_xscom_mbox_write " "addr 0x%" PRIx64 " val 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 2969 "trace/trace-hw_ppc.h"
        } else {
#line 110 "../hw/ppc/trace-events"
            qemu_log("pnv_sbe_xscom_mbox_write " "addr 0x%" PRIx64 " val 0x%" PRIx64 "\n", addr, val);
#line 2973 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_pnv_sbe_xscom_mbox_write(uint64_t addr, uint64_t val)
{
    if (true) {
        _nocheck__trace_pnv_sbe_xscom_mbox_write(addr, val);
    }
}

#define TRACE_PNV_SBE_REG_SET_HOST_DOORBELL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PNV_SBE_REG_SET_HOST_DOORBELL) || \
    false)

static inline void _nocheck__trace_pnv_sbe_reg_set_host_doorbell(uint64_t val)
{
    if (trace_event_get_state(TRACE_PNV_SBE_REG_SET_HOST_DOORBELL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 111 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:pnv_sbe_reg_set_host_doorbell " "val 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 3000 "trace/trace-hw_ppc.h"
        } else {
#line 111 "../hw/ppc/trace-events"
            qemu_log("pnv_sbe_reg_set_host_doorbell " "val 0x%" PRIx64 "\n", val);
#line 3004 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_pnv_sbe_reg_set_host_doorbell(uint64_t val)
{
    if (true) {
        _nocheck__trace_pnv_sbe_reg_set_host_doorbell(val);
    }
}

#define TRACE_PNV_SBE_CMD_TIMER_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PNV_SBE_CMD_TIMER_START) || \
    false)

static inline void _nocheck__trace_pnv_sbe_cmd_timer_start(uint64_t ns)
{
    if (trace_event_get_state(TRACE_PNV_SBE_CMD_TIMER_START) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 112 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:pnv_sbe_cmd_timer_start " "ns 0x%" PRIu64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ns);
#line 3031 "trace/trace-hw_ppc.h"
        } else {
#line 112 "../hw/ppc/trace-events"
            qemu_log("pnv_sbe_cmd_timer_start " "ns 0x%" PRIu64 "\n", ns);
#line 3035 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_pnv_sbe_cmd_timer_start(uint64_t ns)
{
    if (true) {
        _nocheck__trace_pnv_sbe_cmd_timer_start(ns);
    }
}

#define TRACE_PNV_SBE_CMD_TIMER_STOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PNV_SBE_CMD_TIMER_STOP) || \
    false)

static inline void _nocheck__trace_pnv_sbe_cmd_timer_stop(void)
{
    if (trace_event_get_state(TRACE_PNV_SBE_CMD_TIMER_STOP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 113 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:pnv_sbe_cmd_timer_stop " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 3062 "trace/trace-hw_ppc.h"
        } else {
#line 113 "../hw/ppc/trace-events"
            qemu_log("pnv_sbe_cmd_timer_stop " "" "\n");
#line 3066 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_pnv_sbe_cmd_timer_stop(void)
{
    if (true) {
        _nocheck__trace_pnv_sbe_cmd_timer_stop();
    }
}

#define TRACE_PNV_SBE_CMD_TIMER_EXPIRED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PNV_SBE_CMD_TIMER_EXPIRED) || \
    false)

static inline void _nocheck__trace_pnv_sbe_cmd_timer_expired(void)
{
    if (trace_event_get_state(TRACE_PNV_SBE_CMD_TIMER_EXPIRED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 114 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:pnv_sbe_cmd_timer_expired " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 3093 "trace/trace-hw_ppc.h"
        } else {
#line 114 "../hw/ppc/trace-events"
            qemu_log("pnv_sbe_cmd_timer_expired " "" "\n");
#line 3097 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_pnv_sbe_cmd_timer_expired(void)
{
    if (true) {
        _nocheck__trace_pnv_sbe_cmd_timer_expired();
    }
}

#define TRACE_PNV_SBE_MSG_RECV_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PNV_SBE_MSG_RECV) || \
    false)

static inline void _nocheck__trace_pnv_sbe_msg_recv(uint16_t cmd, uint16_t seq, uint16_t ctrl_flags)
{
    if (trace_event_get_state(TRACE_PNV_SBE_MSG_RECV) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 115 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:pnv_sbe_msg_recv " "cmd 0x%" PRIx16 " seq %"PRIu16 " ctrl_flags 0x%" PRIx16 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, seq, ctrl_flags);
#line 3124 "trace/trace-hw_ppc.h"
        } else {
#line 115 "../hw/ppc/trace-events"
            qemu_log("pnv_sbe_msg_recv " "cmd 0x%" PRIx16 " seq %"PRIu16 " ctrl_flags 0x%" PRIx16 "\n", cmd, seq, ctrl_flags);
#line 3128 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_pnv_sbe_msg_recv(uint16_t cmd, uint16_t seq, uint16_t ctrl_flags)
{
    if (true) {
        _nocheck__trace_pnv_sbe_msg_recv(cmd, seq, ctrl_flags);
    }
}

#define TRACE_PPC_TB_ADJUST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC_TB_ADJUST) || \
    false)

static inline void _nocheck__trace_ppc_tb_adjust(uint64_t offs1, uint64_t offs2, int64_t diff, int64_t seconds)
{
    if (trace_event_get_state(TRACE_PPC_TB_ADJUST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 118 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc_tb_adjust " "adjusted from 0x%"PRIx64" to 0x%"PRIx64", diff %"PRId64" (%"PRId64"s)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offs1, offs2, diff, seconds);
#line 3155 "trace/trace-hw_ppc.h"
        } else {
#line 118 "../hw/ppc/trace-events"
            qemu_log("ppc_tb_adjust " "adjusted from 0x%"PRIx64" to 0x%"PRIx64", diff %"PRId64" (%"PRId64"s)" "\n", offs1, offs2, diff, seconds);
#line 3159 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc_tb_adjust(uint64_t offs1, uint64_t offs2, int64_t diff, int64_t seconds)
{
    if (true) {
        _nocheck__trace_ppc_tb_adjust(offs1, offs2, diff, seconds);
    }
}

#define TRACE_PPC_TB_LOAD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC_TB_LOAD) || \
    false)

static inline void _nocheck__trace_ppc_tb_load(uint64_t tb)
{
    if (trace_event_get_state(TRACE_PPC_TB_LOAD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 119 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc_tb_load " "tb 0x%016" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tb);
#line 3186 "trace/trace-hw_ppc.h"
        } else {
#line 119 "../hw/ppc/trace-events"
            qemu_log("ppc_tb_load " "tb 0x%016" PRIx64 "\n", tb);
#line 3190 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc_tb_load(uint64_t tb)
{
    if (true) {
        _nocheck__trace_ppc_tb_load(tb);
    }
}

#define TRACE_PPC_TB_STORE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC_TB_STORE) || \
    false)

static inline void _nocheck__trace_ppc_tb_store(uint64_t tb, uint64_t offset)
{
    if (trace_event_get_state(TRACE_PPC_TB_STORE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 120 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc_tb_store " "tb 0x%016" PRIx64 " offset 0x%08" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tb, offset);
#line 3217 "trace/trace-hw_ppc.h"
        } else {
#line 120 "../hw/ppc/trace-events"
            qemu_log("ppc_tb_store " "tb 0x%016" PRIx64 " offset 0x%08" PRIx64 "\n", tb, offset);
#line 3221 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc_tb_store(uint64_t tb, uint64_t offset)
{
    if (true) {
        _nocheck__trace_ppc_tb_store(tb, offset);
    }
}

#define TRACE_PPC_DECR_LOAD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC_DECR_LOAD) || \
    false)

static inline void _nocheck__trace_ppc_decr_load(uint64_t tb)
{
    if (trace_event_get_state(TRACE_PPC_DECR_LOAD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 122 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc_decr_load " "decr 0x%016" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tb);
#line 3248 "trace/trace-hw_ppc.h"
        } else {
#line 122 "../hw/ppc/trace-events"
            qemu_log("ppc_decr_load " "decr 0x%016" PRIx64 "\n", tb);
#line 3252 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc_decr_load(uint64_t tb)
{
    if (true) {
        _nocheck__trace_ppc_decr_load(tb);
    }
}

#define TRACE_PPC_DECR_EXCP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC_DECR_EXCP) || \
    false)

static inline void _nocheck__trace_ppc_decr_excp(const char * action)
{
    if (trace_event_get_state(TRACE_PPC_DECR_EXCP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 123 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc_decr_excp " "%s decrementer" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , action);
#line 3279 "trace/trace-hw_ppc.h"
        } else {
#line 123 "../hw/ppc/trace-events"
            qemu_log("ppc_decr_excp " "%s decrementer" "\n", action);
#line 3283 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc_decr_excp(const char * action)
{
    if (true) {
        _nocheck__trace_ppc_decr_excp(action);
    }
}

#define TRACE_PPC_DECR_STORE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC_DECR_STORE) || \
    false)

static inline void _nocheck__trace_ppc_decr_store(uint32_t nr_bits, uint64_t decr, uint64_t value)
{
    if (trace_event_get_state(TRACE_PPC_DECR_STORE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 124 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc_decr_store " "%d-bit 0x%016" PRIx64 " => 0x%016" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , nr_bits, decr, value);
#line 3310 "trace/trace-hw_ppc.h"
        } else {
#line 124 "../hw/ppc/trace-events"
            qemu_log("ppc_decr_store " "%d-bit 0x%016" PRIx64 " => 0x%016" PRIx64 "\n", nr_bits, decr, value);
#line 3314 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc_decr_store(uint32_t nr_bits, uint64_t decr, uint64_t value)
{
    if (true) {
        _nocheck__trace_ppc_decr_store(nr_bits, decr, value);
    }
}

#define TRACE_PPC4XX_FIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC4XX_FIT) || \
    false)

static inline void _nocheck__trace_ppc4xx_fit(uint32_t ir, uint64_t tcr, uint64_t tsr)
{
    if (trace_event_get_state(TRACE_PPC4XX_FIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 126 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc4xx_fit " "ir %d TCR 0x%" PRIx64 " TSR 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ir, tcr, tsr);
#line 3341 "trace/trace-hw_ppc.h"
        } else {
#line 126 "../hw/ppc/trace-events"
            qemu_log("ppc4xx_fit " "ir %d TCR 0x%" PRIx64 " TSR 0x%" PRIx64 "\n", ir, tcr, tsr);
#line 3345 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc4xx_fit(uint32_t ir, uint64_t tcr, uint64_t tsr)
{
    if (true) {
        _nocheck__trace_ppc4xx_fit(ir, tcr, tsr);
    }
}

#define TRACE_PPC4XX_PIT_STOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC4XX_PIT_STOP) || \
    false)

static inline void _nocheck__trace_ppc4xx_pit_stop(void)
{
    if (trace_event_get_state(TRACE_PPC4XX_PIT_STOP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 127 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc4xx_pit_stop " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 3372 "trace/trace-hw_ppc.h"
        } else {
#line 127 "../hw/ppc/trace-events"
            qemu_log("ppc4xx_pit_stop " "" "\n");
#line 3376 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc4xx_pit_stop(void)
{
    if (true) {
        _nocheck__trace_ppc4xx_pit_stop();
    }
}

#define TRACE_PPC4XX_PIT_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC4XX_PIT_START) || \
    false)

static inline void _nocheck__trace_ppc4xx_pit_start(uint64_t reload)
{
    if (trace_event_get_state(TRACE_PPC4XX_PIT_START) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 128 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc4xx_pit_start " "PIT 0x%016" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reload);
#line 3403 "trace/trace-hw_ppc.h"
        } else {
#line 128 "../hw/ppc/trace-events"
            qemu_log("ppc4xx_pit_start " "PIT 0x%016" PRIx64 "\n", reload);
#line 3407 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc4xx_pit_start(uint64_t reload)
{
    if (true) {
        _nocheck__trace_ppc4xx_pit_start(reload);
    }
}

#define TRACE_PPC4XX_PIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC4XX_PIT) || \
    false)

static inline void _nocheck__trace_ppc4xx_pit(uint32_t ar, uint32_t ir, uint64_t tcr, uint64_t tsr, uint64_t reload)
{
    if (trace_event_get_state(TRACE_PPC4XX_PIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 129 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc4xx_pit " "ar %d ir %d TCR 0x%" PRIx64 " TSR 0x%" PRIx64 " PIT 0x%016" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ar, ir, tcr, tsr, reload);
#line 3434 "trace/trace-hw_ppc.h"
        } else {
#line 129 "../hw/ppc/trace-events"
            qemu_log("ppc4xx_pit " "ar %d ir %d TCR 0x%" PRIx64 " TSR 0x%" PRIx64 " PIT 0x%016" PRIx64 "\n", ar, ir, tcr, tsr, reload);
#line 3438 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc4xx_pit(uint32_t ar, uint32_t ir, uint64_t tcr, uint64_t tsr, uint64_t reload)
{
    if (true) {
        _nocheck__trace_ppc4xx_pit(ar, ir, tcr, tsr, reload);
    }
}

#define TRACE_PPC4XX_WDT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC4XX_WDT) || \
    false)

static inline void _nocheck__trace_ppc4xx_wdt(uint64_t tcr, uint64_t tsr)
{
    if (trace_event_get_state(TRACE_PPC4XX_WDT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 130 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc4xx_wdt " "TCR 0x%" PRIx64 " TSR 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tcr, tsr);
#line 3465 "trace/trace-hw_ppc.h"
        } else {
#line 130 "../hw/ppc/trace-events"
            qemu_log("ppc4xx_wdt " "TCR 0x%" PRIx64 " TSR 0x%" PRIx64 "\n", tcr, tsr);
#line 3469 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc4xx_wdt(uint64_t tcr, uint64_t tsr)
{
    if (true) {
        _nocheck__trace_ppc4xx_wdt(tcr, tsr);
    }
}

#define TRACE_PPC40X_STORE_PIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC40X_STORE_PIT) || \
    false)

static inline void _nocheck__trace_ppc40x_store_pit(uint64_t value)
{
    if (trace_event_get_state(TRACE_PPC40X_STORE_PIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 131 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc40x_store_pit " "val 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , value);
#line 3496 "trace/trace-hw_ppc.h"
        } else {
#line 131 "../hw/ppc/trace-events"
            qemu_log("ppc40x_store_pit " "val 0x%" PRIx64 "\n", value);
#line 3500 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc40x_store_pit(uint64_t value)
{
    if (true) {
        _nocheck__trace_ppc40x_store_pit(value);
    }
}

#define TRACE_PPC40X_STORE_TCR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC40X_STORE_TCR) || \
    false)

static inline void _nocheck__trace_ppc40x_store_tcr(uint64_t value)
{
    if (trace_event_get_state(TRACE_PPC40X_STORE_TCR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 132 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc40x_store_tcr " "val 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , value);
#line 3527 "trace/trace-hw_ppc.h"
        } else {
#line 132 "../hw/ppc/trace-events"
            qemu_log("ppc40x_store_tcr " "val 0x%" PRIx64 "\n", value);
#line 3531 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc40x_store_tcr(uint64_t value)
{
    if (true) {
        _nocheck__trace_ppc40x_store_tcr(value);
    }
}

#define TRACE_PPC40X_STORE_TSR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC40X_STORE_TSR) || \
    false)

static inline void _nocheck__trace_ppc40x_store_tsr(uint64_t value)
{
    if (trace_event_get_state(TRACE_PPC40X_STORE_TSR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 133 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc40x_store_tsr " "val 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , value);
#line 3558 "trace/trace-hw_ppc.h"
        } else {
#line 133 "../hw/ppc/trace-events"
            qemu_log("ppc40x_store_tsr " "val 0x%" PRIx64 "\n", value);
#line 3562 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc40x_store_tsr(uint64_t value)
{
    if (true) {
        _nocheck__trace_ppc40x_store_tsr(value);
    }
}

#define TRACE_PPC40X_SET_TB_CLK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC40X_SET_TB_CLK) || \
    false)

static inline void _nocheck__trace_ppc40x_set_tb_clk(uint32_t value)
{
    if (trace_event_get_state(TRACE_PPC40X_SET_TB_CLK) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 134 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc40x_set_tb_clk " "new frequency %" PRIu32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , value);
#line 3589 "trace/trace-hw_ppc.h"
        } else {
#line 134 "../hw/ppc/trace-events"
            qemu_log("ppc40x_set_tb_clk " "new frequency %" PRIu32 "\n", value);
#line 3593 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc40x_set_tb_clk(uint32_t value)
{
    if (true) {
        _nocheck__trace_ppc40x_set_tb_clk(value);
    }
}

#define TRACE_PPC40X_TIMERS_INIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC40X_TIMERS_INIT) || \
    false)

static inline void _nocheck__trace_ppc40x_timers_init(uint32_t value)
{
    if (trace_event_get_state(TRACE_PPC40X_TIMERS_INIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 135 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc40x_timers_init " "frequency %" PRIu32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , value);
#line 3620 "trace/trace-hw_ppc.h"
        } else {
#line 135 "../hw/ppc/trace-events"
            qemu_log("ppc40x_timers_init " "frequency %" PRIu32 "\n", value);
#line 3624 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc40x_timers_init(uint32_t value)
{
    if (true) {
        _nocheck__trace_ppc40x_timers_init(value);
    }
}

#define TRACE_PPC_IRQ_SET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC_IRQ_SET) || \
    false)

static inline void _nocheck__trace_ppc_irq_set(void * env, uint32_t pin, uint32_t level)
{
    if (trace_event_get_state(TRACE_PPC_IRQ_SET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 137 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc_irq_set " "env [%p] pin %d level %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , env, pin, level);
#line 3651 "trace/trace-hw_ppc.h"
        } else {
#line 137 "../hw/ppc/trace-events"
            qemu_log("ppc_irq_set " "env [%p] pin %d level %d" "\n", env, pin, level);
#line 3655 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc_irq_set(void * env, uint32_t pin, uint32_t level)
{
    if (true) {
        _nocheck__trace_ppc_irq_set(env, pin, level);
    }
}

#define TRACE_PPC_IRQ_SET_EXIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC_IRQ_SET_EXIT) || \
    false)

static inline void _nocheck__trace_ppc_irq_set_exit(void * env, uint32_t irq, uint32_t level, uint32_t pending, uint32_t request)
{
    if (trace_event_get_state(TRACE_PPC_IRQ_SET_EXIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 138 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc_irq_set_exit " "env [%p] irq 0x%05" PRIx32 " level %d => pending 0x%08" PRIx32 " req 0x%08" PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , env, irq, level, pending, request);
#line 3682 "trace/trace-hw_ppc.h"
        } else {
#line 138 "../hw/ppc/trace-events"
            qemu_log("ppc_irq_set_exit " "env [%p] irq 0x%05" PRIx32 " level %d => pending 0x%08" PRIx32 " req 0x%08" PRIx32 "\n", env, irq, level, pending, request);
#line 3686 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc_irq_set_exit(void * env, uint32_t irq, uint32_t level, uint32_t pending, uint32_t request)
{
    if (true) {
        _nocheck__trace_ppc_irq_set_exit(env, irq, level, pending, request);
    }
}

#define TRACE_PPC_IRQ_SET_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC_IRQ_SET_STATE) || \
    false)

static inline void _nocheck__trace_ppc_irq_set_state(const char * name, uint32_t level)
{
    if (trace_event_get_state(TRACE_PPC_IRQ_SET_STATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 139 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc_irq_set_state " "\"%s\" level %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, level);
#line 3713 "trace/trace-hw_ppc.h"
        } else {
#line 139 "../hw/ppc/trace-events"
            qemu_log("ppc_irq_set_state " "\"%s\" level %d" "\n", name, level);
#line 3717 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc_irq_set_state(const char * name, uint32_t level)
{
    if (true) {
        _nocheck__trace_ppc_irq_set_state(name, level);
    }
}

#define TRACE_PPC_IRQ_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC_IRQ_RESET) || \
    false)

static inline void _nocheck__trace_ppc_irq_reset(const char * name)
{
    if (trace_event_get_state(TRACE_PPC_IRQ_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 140 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc_irq_reset " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 3744 "trace/trace-hw_ppc.h"
        } else {
#line 140 "../hw/ppc/trace-events"
            qemu_log("ppc_irq_reset " "%s" "\n", name);
#line 3748 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc_irq_reset(const char * name)
{
    if (true) {
        _nocheck__trace_ppc_irq_reset(name);
    }
}

#define TRACE_PPC_IRQ_CPU_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC_IRQ_CPU) || \
    false)

static inline void _nocheck__trace_ppc_irq_cpu(const char * action)
{
    if (trace_event_get_state(TRACE_PPC_IRQ_CPU) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 141 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc_irq_cpu " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , action);
#line 3775 "trace/trace-hw_ppc.h"
        } else {
#line 141 "../hw/ppc/trace-events"
            qemu_log("ppc_irq_cpu " "%s" "\n", action);
#line 3779 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc_irq_cpu(const char * action)
{
    if (true) {
        _nocheck__trace_ppc_irq_cpu(action);
    }
}

#define TRACE_PPC_DCR_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC_DCR_READ) || \
    false)

static inline void _nocheck__trace_ppc_dcr_read(uint32_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_PPC_DCR_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 143 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc_dcr_read " "DRCN[0x%x] -> 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 3806 "trace/trace-hw_ppc.h"
        } else {
#line 143 "../hw/ppc/trace-events"
            qemu_log("ppc_dcr_read " "DRCN[0x%x] -> 0x%x" "\n", addr, val);
#line 3810 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc_dcr_read(uint32_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_ppc_dcr_read(addr, val);
    }
}

#define TRACE_PPC_DCR_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC_DCR_WRITE) || \
    false)

static inline void _nocheck__trace_ppc_dcr_write(uint32_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_PPC_DCR_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 144 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc_dcr_write " "DRCN[0x%x] <- 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 3837 "trace/trace-hw_ppc.h"
        } else {
#line 144 "../hw/ppc/trace-events"
            qemu_log("ppc_dcr_write " "DRCN[0x%x] <- 0x%x" "\n", addr, val);
#line 3841 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc_dcr_write(uint32_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_ppc_dcr_write(addr, val);
    }
}

#define TRACE_PREP_SYSTEMIO_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PREP_SYSTEMIO_READ) || \
    false)

static inline void _nocheck__trace_prep_systemio_read(uint32_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_PREP_SYSTEMIO_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 147 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:prep_systemio_read " "read addr=0x%x val=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 3868 "trace/trace-hw_ppc.h"
        } else {
#line 147 "../hw/ppc/trace-events"
            qemu_log("prep_systemio_read " "read addr=0x%x val=0x%x" "\n", addr, val);
#line 3872 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_prep_systemio_read(uint32_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_prep_systemio_read(addr, val);
    }
}

#define TRACE_PREP_SYSTEMIO_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PREP_SYSTEMIO_WRITE) || \
    false)

static inline void _nocheck__trace_prep_systemio_write(uint32_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_PREP_SYSTEMIO_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 148 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:prep_systemio_write " "write addr=0x%x val=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 3899 "trace/trace-hw_ppc.h"
        } else {
#line 148 "../hw/ppc/trace-events"
            qemu_log("prep_systemio_write " "write addr=0x%x val=0x%x" "\n", addr, val);
#line 3903 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_prep_systemio_write(uint32_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_prep_systemio_write(addr, val);
    }
}

#define TRACE_RS6000MC_ID_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RS6000MC_ID_READ) || \
    false)

static inline void _nocheck__trace_rs6000mc_id_read(uint32_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_RS6000MC_ID_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 151 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:rs6000mc_id_read " "read addr=0x%x val=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 3930 "trace/trace-hw_ppc.h"
        } else {
#line 151 "../hw/ppc/trace-events"
            qemu_log("rs6000mc_id_read " "read addr=0x%x val=0x%x" "\n", addr, val);
#line 3934 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_rs6000mc_id_read(uint32_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_rs6000mc_id_read(addr, val);
    }
}

#define TRACE_RS6000MC_PRESENCE_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RS6000MC_PRESENCE_READ) || \
    false)

static inline void _nocheck__trace_rs6000mc_presence_read(uint32_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_RS6000MC_PRESENCE_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 152 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:rs6000mc_presence_read " "read addr=0x%x val=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 3961 "trace/trace-hw_ppc.h"
        } else {
#line 152 "../hw/ppc/trace-events"
            qemu_log("rs6000mc_presence_read " "read addr=0x%x val=0x%x" "\n", addr, val);
#line 3965 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_rs6000mc_presence_read(uint32_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_rs6000mc_presence_read(addr, val);
    }
}

#define TRACE_RS6000MC_SIZE_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RS6000MC_SIZE_READ) || \
    false)

static inline void _nocheck__trace_rs6000mc_size_read(uint32_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_RS6000MC_SIZE_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 153 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:rs6000mc_size_read " "read addr=0x%x val=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 3992 "trace/trace-hw_ppc.h"
        } else {
#line 153 "../hw/ppc/trace-events"
            qemu_log("rs6000mc_size_read " "read addr=0x%x val=0x%x" "\n", addr, val);
#line 3996 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_rs6000mc_size_read(uint32_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_rs6000mc_size_read(addr, val);
    }
}

#define TRACE_RS6000MC_SIZE_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RS6000MC_SIZE_WRITE) || \
    false)

static inline void _nocheck__trace_rs6000mc_size_write(uint32_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_RS6000MC_SIZE_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 154 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:rs6000mc_size_write " "write addr=0x%x val=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 4023 "trace/trace-hw_ppc.h"
        } else {
#line 154 "../hw/ppc/trace-events"
            qemu_log("rs6000mc_size_write " "write addr=0x%x val=0x%x" "\n", addr, val);
#line 4027 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_rs6000mc_size_write(uint32_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_rs6000mc_size_write(addr, val);
    }
}

#define TRACE_RS6000MC_PARITY_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RS6000MC_PARITY_READ) || \
    false)

static inline void _nocheck__trace_rs6000mc_parity_read(uint32_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_RS6000MC_PARITY_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 155 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:rs6000mc_parity_read " "read addr=0x%x val=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 4054 "trace/trace-hw_ppc.h"
        } else {
#line 155 "../hw/ppc/trace-events"
            qemu_log("rs6000mc_parity_read " "read addr=0x%x val=0x%x" "\n", addr, val);
#line 4058 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_rs6000mc_parity_read(uint32_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_rs6000mc_parity_read(addr, val);
    }
}

#define TRACE_OPBA_READB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_OPBA_READB) || \
    false)

static inline void _nocheck__trace_opba_readb(uint64_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_OPBA_READB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 158 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:opba_readb " "addr 0x%" PRIx64 " = 0x%" PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 4085 "trace/trace-hw_ppc.h"
        } else {
#line 158 "../hw/ppc/trace-events"
            qemu_log("opba_readb " "addr 0x%" PRIx64 " = 0x%" PRIx32 "\n", addr, val);
#line 4089 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_opba_readb(uint64_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_opba_readb(addr, val);
    }
}

#define TRACE_OPBA_WRITEB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_OPBA_WRITEB) || \
    false)

static inline void _nocheck__trace_opba_writeb(uint64_t addr, uint64_t val)
{
    if (trace_event_get_state(TRACE_OPBA_WRITEB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 159 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:opba_writeb " "addr 0x%" PRIx64 " = 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 4116 "trace/trace-hw_ppc.h"
        } else {
#line 159 "../hw/ppc/trace-events"
            qemu_log("opba_writeb " "addr 0x%" PRIx64 " = 0x%" PRIx64 "\n", addr, val);
#line 4120 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_opba_writeb(uint64_t addr, uint64_t val)
{
    if (true) {
        _nocheck__trace_opba_writeb(addr, val);
    }
}

#define TRACE_PPC405_GPIO_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC405_GPIO_READ) || \
    false)

static inline void _nocheck__trace_ppc405_gpio_read(uint64_t addr, uint32_t size)
{
    if (trace_event_get_state(TRACE_PPC405_GPIO_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 161 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc405_gpio_read " "addr 0x%" PRIx64 " size %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, size);
#line 4147 "trace/trace-hw_ppc.h"
        } else {
#line 161 "../hw/ppc/trace-events"
            qemu_log("ppc405_gpio_read " "addr 0x%" PRIx64 " size %d" "\n", addr, size);
#line 4151 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc405_gpio_read(uint64_t addr, uint32_t size)
{
    if (true) {
        _nocheck__trace_ppc405_gpio_read(addr, size);
    }
}

#define TRACE_PPC405_GPIO_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC405_GPIO_WRITE) || \
    false)

static inline void _nocheck__trace_ppc405_gpio_write(uint64_t addr, uint32_t size, uint64_t val)
{
    if (trace_event_get_state(TRACE_PPC405_GPIO_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 162 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc405_gpio_write " "addr 0x%" PRIx64 " size %d = 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, size, val);
#line 4178 "trace/trace-hw_ppc.h"
        } else {
#line 162 "../hw/ppc/trace-events"
            qemu_log("ppc405_gpio_write " "addr 0x%" PRIx64 " size %d = 0x%" PRIx64 "\n", addr, size, val);
#line 4182 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc405_gpio_write(uint64_t addr, uint32_t size, uint64_t val)
{
    if (true) {
        _nocheck__trace_ppc405_gpio_write(addr, size, val);
    }
}

#define TRACE_OCM_UPDATE_MAPPINGS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_OCM_UPDATE_MAPPINGS) || \
    false)

static inline void _nocheck__trace_ocm_update_mappings(uint32_t isarc, uint32_t isacntl, uint32_t dsarc, uint32_t dsacntl, uint32_t ocm_isarc, uint32_t ocm_isacntl, uint32_t ocm_dsarc, uint32_t ocm_dsacntl)
{
    if (trace_event_get_state(TRACE_OCM_UPDATE_MAPPINGS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 164 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ocm_update_mappings " "OCM update ISA 0x%08" PRIx32 " 0x%08" PRIx32 " (0x%08" PRIx32" 0x%08" PRIx32 ") DSA 0x%08" PRIx32 " 0x%08" PRIx32" (0x%08" PRIx32 " 0x%08" PRIx32 ")" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , isarc, isacntl, dsarc, dsacntl, ocm_isarc, ocm_isacntl, ocm_dsarc, ocm_dsacntl);
#line 4209 "trace/trace-hw_ppc.h"
        } else {
#line 164 "../hw/ppc/trace-events"
            qemu_log("ocm_update_mappings " "OCM update ISA 0x%08" PRIx32 " 0x%08" PRIx32 " (0x%08" PRIx32" 0x%08" PRIx32 ") DSA 0x%08" PRIx32 " 0x%08" PRIx32" (0x%08" PRIx32 " 0x%08" PRIx32 ")" "\n", isarc, isacntl, dsarc, dsacntl, ocm_isarc, ocm_isacntl, ocm_dsarc, ocm_dsacntl);
#line 4213 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ocm_update_mappings(uint32_t isarc, uint32_t isacntl, uint32_t dsarc, uint32_t dsacntl, uint32_t ocm_isarc, uint32_t ocm_isacntl, uint32_t ocm_dsarc, uint32_t ocm_dsacntl)
{
    if (true) {
        _nocheck__trace_ocm_update_mappings(isarc, isacntl, dsarc, dsacntl, ocm_isarc, ocm_isacntl, ocm_dsarc, ocm_dsacntl);
    }
}

#define TRACE_OCM_MAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_OCM_MAP) || \
    false)

static inline void _nocheck__trace_ocm_map(const char* prefix, uint32_t isarc)
{
    if (trace_event_get_state(TRACE_OCM_MAP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 165 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ocm_map " "OCM map %s 0x%08" PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , prefix, isarc);
#line 4240 "trace/trace-hw_ppc.h"
        } else {
#line 165 "../hw/ppc/trace-events"
            qemu_log("ocm_map " "OCM map %s 0x%08" PRIx32 "\n", prefix, isarc);
#line 4244 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ocm_map(const char* prefix, uint32_t isarc)
{
    if (true) {
        _nocheck__trace_ocm_map(prefix, isarc);
    }
}

#define TRACE_OCM_UNMAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_OCM_UNMAP) || \
    false)

static inline void _nocheck__trace_ocm_unmap(const char* prefix, uint32_t isarc)
{
    if (trace_event_get_state(TRACE_OCM_UNMAP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 166 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ocm_unmap " "OCM unmap %s 0x%08" PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , prefix, isarc);
#line 4271 "trace/trace-hw_ppc.h"
        } else {
#line 166 "../hw/ppc/trace-events"
            qemu_log("ocm_unmap " "OCM unmap %s 0x%08" PRIx32 "\n", prefix, isarc);
#line 4275 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ocm_unmap(const char* prefix, uint32_t isarc)
{
    if (true) {
        _nocheck__trace_ocm_unmap(prefix, isarc);
    }
}

#define TRACE_PPC4XX_GPT_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC4XX_GPT_READ) || \
    false)

static inline void _nocheck__trace_ppc4xx_gpt_read(uint64_t addr, uint32_t size)
{
    if (trace_event_get_state(TRACE_PPC4XX_GPT_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 168 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc4xx_gpt_read " "addr 0x%" PRIx64 " size %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, size);
#line 4302 "trace/trace-hw_ppc.h"
        } else {
#line 168 "../hw/ppc/trace-events"
            qemu_log("ppc4xx_gpt_read " "addr 0x%" PRIx64 " size %d" "\n", addr, size);
#line 4306 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc4xx_gpt_read(uint64_t addr, uint32_t size)
{
    if (true) {
        _nocheck__trace_ppc4xx_gpt_read(addr, size);
    }
}

#define TRACE_PPC4XX_GPT_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC4XX_GPT_WRITE) || \
    false)

static inline void _nocheck__trace_ppc4xx_gpt_write(uint64_t addr, uint32_t size, uint64_t val)
{
    if (trace_event_get_state(TRACE_PPC4XX_GPT_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 169 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc4xx_gpt_write " "addr 0x%" PRIx64 " size %d = 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, size, val);
#line 4333 "trace/trace-hw_ppc.h"
        } else {
#line 169 "../hw/ppc/trace-events"
            qemu_log("ppc4xx_gpt_write " "addr 0x%" PRIx64 " size %d = 0x%" PRIx64 "\n", addr, size, val);
#line 4337 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc4xx_gpt_write(uint64_t addr, uint32_t size, uint64_t val)
{
    if (true) {
        _nocheck__trace_ppc4xx_gpt_write(addr, size, val);
    }
}

#define TRACE_PPC405EP_CLOCKS_COMPUTE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC405EP_CLOCKS_COMPUTE) || \
    false)

static inline void _nocheck__trace_ppc405ep_clocks_compute(const char * param, uint32_t param2, uint32_t val)
{
    if (trace_event_get_state(TRACE_PPC405EP_CLOCKS_COMPUTE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 171 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc405ep_clocks_compute " "%s 0x%1" PRIx32 " %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , param, param2, val);
#line 4364 "trace/trace-hw_ppc.h"
        } else {
#line 171 "../hw/ppc/trace-events"
            qemu_log("ppc405ep_clocks_compute " "%s 0x%1" PRIx32 " %d" "\n", param, param2, val);
#line 4368 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc405ep_clocks_compute(const char * param, uint32_t param2, uint32_t val)
{
    if (true) {
        _nocheck__trace_ppc405ep_clocks_compute(param, param2, val);
    }
}

#define TRACE_PPC405EP_CLOCKS_SETUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC405EP_CLOCKS_SETUP) || \
    false)

static inline void _nocheck__trace_ppc405ep_clocks_setup(const char * trace)
{
    if (trace_event_get_state(TRACE_PPC405EP_CLOCKS_SETUP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 172 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc405ep_clocks_setup " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , trace);
#line 4395 "trace/trace-hw_ppc.h"
        } else {
#line 172 "../hw/ppc/trace-events"
            qemu_log("ppc405ep_clocks_setup " "%s" "\n", trace);
#line 4399 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc405ep_clocks_setup(const char * trace)
{
    if (true) {
        _nocheck__trace_ppc405ep_clocks_setup(trace);
    }
}

#define TRACE_PPC4XX_SDRAM_ENABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC4XX_SDRAM_ENABLE) || \
    false)

static inline void _nocheck__trace_ppc4xx_sdram_enable(const char * trace)
{
    if (trace_event_get_state(TRACE_PPC4XX_SDRAM_ENABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 175 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc4xx_sdram_enable " "%s SDRAM controller" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , trace);
#line 4426 "trace/trace-hw_ppc.h"
        } else {
#line 175 "../hw/ppc/trace-events"
            qemu_log("ppc4xx_sdram_enable " "%s SDRAM controller" "\n", trace);
#line 4430 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc4xx_sdram_enable(const char * trace)
{
    if (true) {
        _nocheck__trace_ppc4xx_sdram_enable(trace);
    }
}

#define TRACE_PPC4XX_SDRAM_UNMAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC4XX_SDRAM_UNMAP) || \
    false)

static inline void _nocheck__trace_ppc4xx_sdram_unmap(uint64_t addr, uint64_t size)
{
    if (trace_event_get_state(TRACE_PPC4XX_SDRAM_UNMAP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 176 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc4xx_sdram_unmap " "Unmap RAM area 0x%" PRIx64 " size 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, size);
#line 4457 "trace/trace-hw_ppc.h"
        } else {
#line 176 "../hw/ppc/trace-events"
            qemu_log("ppc4xx_sdram_unmap " "Unmap RAM area 0x%" PRIx64 " size 0x%" PRIx64 "\n", addr, size);
#line 4461 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc4xx_sdram_unmap(uint64_t addr, uint64_t size)
{
    if (true) {
        _nocheck__trace_ppc4xx_sdram_unmap(addr, size);
    }
}

#define TRACE_PPC4XX_SDRAM_MAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC4XX_SDRAM_MAP) || \
    false)

static inline void _nocheck__trace_ppc4xx_sdram_map(uint64_t addr, uint64_t size)
{
    if (trace_event_get_state(TRACE_PPC4XX_SDRAM_MAP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 177 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc4xx_sdram_map " "Map RAM area 0x%" PRIx64 " size 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, size);
#line 4488 "trace/trace-hw_ppc.h"
        } else {
#line 177 "../hw/ppc/trace-events"
            qemu_log("ppc4xx_sdram_map " "Map RAM area 0x%" PRIx64 " size 0x%" PRIx64 "\n", addr, size);
#line 4492 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc4xx_sdram_map(uint64_t addr, uint64_t size)
{
    if (true) {
        _nocheck__trace_ppc4xx_sdram_map(addr, size);
    }
}

#define TRACE_PPC4XX_SDRAM_INIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC4XX_SDRAM_INIT) || \
    false)

static inline void _nocheck__trace_ppc4xx_sdram_init(uint64_t base, uint64_t size, uint32_t bcr)
{
    if (trace_event_get_state(TRACE_PPC4XX_SDRAM_INIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 178 "../hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc4xx_sdram_init " "Init RAM area 0x%" PRIx64 " size 0x%" PRIx64 " bcr 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , base, size, bcr);
#line 4519 "trace/trace-hw_ppc.h"
        } else {
#line 178 "../hw/ppc/trace-events"
            qemu_log("ppc4xx_sdram_init " "Init RAM area 0x%" PRIx64 " size 0x%" PRIx64 " bcr 0x%x" "\n", base, size, bcr);
#line 4523 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc4xx_sdram_init(uint64_t base, uint64_t size, uint32_t bcr)
{
    if (true) {
        _nocheck__trace_ppc4xx_sdram_init(base, size, bcr);
    }
}
#endif /* TRACE_HW_PPC_GENERATED_TRACERS_H */
