/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_GDBSTUB_GENERATED_TRACERS_H
#define TRACE_GDBSTUB_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_GDBSTUB_OP_START_EVENT;
extern TraceEvent _TRACE_GDBSTUB_OP_EXITING_EVENT;
extern TraceEvent _TRACE_GDBSTUB_OP_CONTINUE_EVENT;
extern TraceEvent _TRACE_GDBSTUB_OP_CONTINUE_CPU_EVENT;
extern TraceEvent _TRACE_GDBSTUB_OP_STEPPING_EVENT;
extern TraceEvent _TRACE_GDBSTUB_OP_EXTRA_INFO_EVENT;
extern TraceEvent _TRACE_GDBSTUB_HIT_INTERNAL_ERROR_EVENT;
extern TraceEvent _TRACE_GDBSTUB_HIT_BREAK_EVENT;
extern TraceEvent _TRACE_GDBSTUB_HIT_PAUSED_EVENT;
extern TraceEvent _TRACE_GDBSTUB_HIT_SHUTDOWN_EVENT;
extern TraceEvent _TRACE_GDBSTUB_HIT_IO_ERROR_EVENT;
extern TraceEvent _TRACE_GDBSTUB_HIT_WATCHDOG_EVENT;
extern TraceEvent _TRACE_GDBSTUB_HIT_UNKNOWN_EVENT;
extern TraceEvent _TRACE_GDBSTUB_IO_REPLY_EVENT;
extern TraceEvent _TRACE_GDBSTUB_IO_BINARYREPLY_EVENT;
extern TraceEvent _TRACE_GDBSTUB_IO_COMMAND_EVENT;
extern TraceEvent _TRACE_GDBSTUB_IO_GOT_ACK_EVENT;
extern TraceEvent _TRACE_GDBSTUB_IO_GOT_UNEXPECTED_EVENT;
extern TraceEvent _TRACE_GDBSTUB_ERR_GOT_NACK_EVENT;
extern TraceEvent _TRACE_GDBSTUB_ERR_GARBAGE_EVENT;
extern TraceEvent _TRACE_GDBSTUB_ERR_OVERRUN_EVENT;
extern TraceEvent _TRACE_GDBSTUB_ERR_INVALID_REPEAT_EVENT;
extern TraceEvent _TRACE_GDBSTUB_ERR_INVALID_RLE_EVENT;
extern TraceEvent _TRACE_GDBSTUB_ERR_CHECKSUM_INVALID_EVENT;
extern TraceEvent _TRACE_GDBSTUB_ERR_CHECKSUM_INCORRECT_EVENT;
extern TraceEvent _TRACE_GDBSTUB_ERR_UNEXPECTED_RUNPKT_EVENT;
extern TraceEvent _TRACE_GDBSTUB_HIT_WATCHPOINT_EVENT;
extern uint16_t _TRACE_GDBSTUB_OP_START_DSTATE;
extern uint16_t _TRACE_GDBSTUB_OP_EXITING_DSTATE;
extern uint16_t _TRACE_GDBSTUB_OP_CONTINUE_DSTATE;
extern uint16_t _TRACE_GDBSTUB_OP_CONTINUE_CPU_DSTATE;
extern uint16_t _TRACE_GDBSTUB_OP_STEPPING_DSTATE;
extern uint16_t _TRACE_GDBSTUB_OP_EXTRA_INFO_DSTATE;
extern uint16_t _TRACE_GDBSTUB_HIT_INTERNAL_ERROR_DSTATE;
extern uint16_t _TRACE_GDBSTUB_HIT_BREAK_DSTATE;
extern uint16_t _TRACE_GDBSTUB_HIT_PAUSED_DSTATE;
extern uint16_t _TRACE_GDBSTUB_HIT_SHUTDOWN_DSTATE;
extern uint16_t _TRACE_GDBSTUB_HIT_IO_ERROR_DSTATE;
extern uint16_t _TRACE_GDBSTUB_HIT_WATCHDOG_DSTATE;
extern uint16_t _TRACE_GDBSTUB_HIT_UNKNOWN_DSTATE;
extern uint16_t _TRACE_GDBSTUB_IO_REPLY_DSTATE;
extern uint16_t _TRACE_GDBSTUB_IO_BINARYREPLY_DSTATE;
extern uint16_t _TRACE_GDBSTUB_IO_COMMAND_DSTATE;
extern uint16_t _TRACE_GDBSTUB_IO_GOT_ACK_DSTATE;
extern uint16_t _TRACE_GDBSTUB_IO_GOT_UNEXPECTED_DSTATE;
extern uint16_t _TRACE_GDBSTUB_ERR_GOT_NACK_DSTATE;
extern uint16_t _TRACE_GDBSTUB_ERR_GARBAGE_DSTATE;
extern uint16_t _TRACE_GDBSTUB_ERR_OVERRUN_DSTATE;
extern uint16_t _TRACE_GDBSTUB_ERR_INVALID_REPEAT_DSTATE;
extern uint16_t _TRACE_GDBSTUB_ERR_INVALID_RLE_DSTATE;
extern uint16_t _TRACE_GDBSTUB_ERR_CHECKSUM_INVALID_DSTATE;
extern uint16_t _TRACE_GDBSTUB_ERR_CHECKSUM_INCORRECT_DSTATE;
extern uint16_t _TRACE_GDBSTUB_ERR_UNEXPECTED_RUNPKT_DSTATE;
extern uint16_t _TRACE_GDBSTUB_HIT_WATCHPOINT_DSTATE;
#define TRACE_GDBSTUB_OP_START_ENABLED 1
#define TRACE_GDBSTUB_OP_EXITING_ENABLED 1
#define TRACE_GDBSTUB_OP_CONTINUE_ENABLED 1
#define TRACE_GDBSTUB_OP_CONTINUE_CPU_ENABLED 1
#define TRACE_GDBSTUB_OP_STEPPING_ENABLED 1
#define TRACE_GDBSTUB_OP_EXTRA_INFO_ENABLED 1
#define TRACE_GDBSTUB_HIT_INTERNAL_ERROR_ENABLED 1
#define TRACE_GDBSTUB_HIT_BREAK_ENABLED 1
#define TRACE_GDBSTUB_HIT_PAUSED_ENABLED 1
#define TRACE_GDBSTUB_HIT_SHUTDOWN_ENABLED 1
#define TRACE_GDBSTUB_HIT_IO_ERROR_ENABLED 1
#define TRACE_GDBSTUB_HIT_WATCHDOG_ENABLED 1
#define TRACE_GDBSTUB_HIT_UNKNOWN_ENABLED 1
#define TRACE_GDBSTUB_IO_REPLY_ENABLED 1
#define TRACE_GDBSTUB_IO_BINARYREPLY_ENABLED 1
#define TRACE_GDBSTUB_IO_COMMAND_ENABLED 1
#define TRACE_GDBSTUB_IO_GOT_ACK_ENABLED 1
#define TRACE_GDBSTUB_IO_GOT_UNEXPECTED_ENABLED 1
#define TRACE_GDBSTUB_ERR_GOT_NACK_ENABLED 1
#define TRACE_GDBSTUB_ERR_GARBAGE_ENABLED 1
#define TRACE_GDBSTUB_ERR_OVERRUN_ENABLED 1
#define TRACE_GDBSTUB_ERR_INVALID_REPEAT_ENABLED 1
#define TRACE_GDBSTUB_ERR_INVALID_RLE_ENABLED 1
#define TRACE_GDBSTUB_ERR_CHECKSUM_INVALID_ENABLED 1
#define TRACE_GDBSTUB_ERR_CHECKSUM_INCORRECT_ENABLED 1
#define TRACE_GDBSTUB_ERR_UNEXPECTED_RUNPKT_ENABLED 1
#define TRACE_GDBSTUB_HIT_WATCHPOINT_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_GDBSTUB_OP_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_OP_START) || \
    false)

static inline void _nocheck__trace_gdbstub_op_start(const char * device)
{
    if (trace_event_get_state(TRACE_GDBSTUB_OP_START) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 4 "../gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_op_start " "Starting gdbstub using device %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , device);
#line 109 "trace/trace-gdbstub.h"
        } else {
#line 4 "../gdbstub/trace-events"
            qemu_log("gdbstub_op_start " "Starting gdbstub using device %s" "\n", device);
#line 113 "trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_op_start(const char * device)
{
    if (true) {
        _nocheck__trace_gdbstub_op_start(device);
    }
}

#define TRACE_GDBSTUB_OP_EXITING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_OP_EXITING) || \
    false)

static inline void _nocheck__trace_gdbstub_op_exiting(uint8_t code)
{
    if (trace_event_get_state(TRACE_GDBSTUB_OP_EXITING) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 5 "../gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_op_exiting " "notifying exit with code=0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , code);
#line 140 "trace/trace-gdbstub.h"
        } else {
#line 5 "../gdbstub/trace-events"
            qemu_log("gdbstub_op_exiting " "notifying exit with code=0x%02x" "\n", code);
#line 144 "trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_op_exiting(uint8_t code)
{
    if (true) {
        _nocheck__trace_gdbstub_op_exiting(code);
    }
}

#define TRACE_GDBSTUB_OP_CONTINUE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_OP_CONTINUE) || \
    false)

static inline void _nocheck__trace_gdbstub_op_continue(void)
{
    if (trace_event_get_state(TRACE_GDBSTUB_OP_CONTINUE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 6 "../gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_op_continue " "Continuing all CPUs" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 171 "trace/trace-gdbstub.h"
        } else {
#line 6 "../gdbstub/trace-events"
            qemu_log("gdbstub_op_continue " "Continuing all CPUs" "\n");
#line 175 "trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_op_continue(void)
{
    if (true) {
        _nocheck__trace_gdbstub_op_continue();
    }
}

#define TRACE_GDBSTUB_OP_CONTINUE_CPU_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_OP_CONTINUE_CPU) || \
    false)

static inline void _nocheck__trace_gdbstub_op_continue_cpu(int cpu_index)
{
    if (trace_event_get_state(TRACE_GDBSTUB_OP_CONTINUE_CPU) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 7 "../gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_op_continue_cpu " "Continuing CPU %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cpu_index);
#line 202 "trace/trace-gdbstub.h"
        } else {
#line 7 "../gdbstub/trace-events"
            qemu_log("gdbstub_op_continue_cpu " "Continuing CPU %d" "\n", cpu_index);
#line 206 "trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_op_continue_cpu(int cpu_index)
{
    if (true) {
        _nocheck__trace_gdbstub_op_continue_cpu(cpu_index);
    }
}

#define TRACE_GDBSTUB_OP_STEPPING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_OP_STEPPING) || \
    false)

static inline void _nocheck__trace_gdbstub_op_stepping(int cpu_index)
{
    if (trace_event_get_state(TRACE_GDBSTUB_OP_STEPPING) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 8 "../gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_op_stepping " "Stepping CPU %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cpu_index);
#line 233 "trace/trace-gdbstub.h"
        } else {
#line 8 "../gdbstub/trace-events"
            qemu_log("gdbstub_op_stepping " "Stepping CPU %d" "\n", cpu_index);
#line 237 "trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_op_stepping(int cpu_index)
{
    if (true) {
        _nocheck__trace_gdbstub_op_stepping(cpu_index);
    }
}

#define TRACE_GDBSTUB_OP_EXTRA_INFO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_OP_EXTRA_INFO) || \
    false)

static inline void _nocheck__trace_gdbstub_op_extra_info(const char * info)
{
    if (trace_event_get_state(TRACE_GDBSTUB_OP_EXTRA_INFO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 9 "../gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_op_extra_info " "Thread extra info: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , info);
#line 264 "trace/trace-gdbstub.h"
        } else {
#line 9 "../gdbstub/trace-events"
            qemu_log("gdbstub_op_extra_info " "Thread extra info: %s" "\n", info);
#line 268 "trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_op_extra_info(const char * info)
{
    if (true) {
        _nocheck__trace_gdbstub_op_extra_info(info);
    }
}

#define TRACE_GDBSTUB_HIT_INTERNAL_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_HIT_INTERNAL_ERROR) || \
    false)

static inline void _nocheck__trace_gdbstub_hit_internal_error(void)
{
    if (trace_event_get_state(TRACE_GDBSTUB_HIT_INTERNAL_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 10 "../gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_hit_internal_error " "RUN_STATE_INTERNAL_ERROR" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 295 "trace/trace-gdbstub.h"
        } else {
#line 10 "../gdbstub/trace-events"
            qemu_log("gdbstub_hit_internal_error " "RUN_STATE_INTERNAL_ERROR" "\n");
#line 299 "trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_hit_internal_error(void)
{
    if (true) {
        _nocheck__trace_gdbstub_hit_internal_error();
    }
}

#define TRACE_GDBSTUB_HIT_BREAK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_HIT_BREAK) || \
    false)

static inline void _nocheck__trace_gdbstub_hit_break(void)
{
    if (trace_event_get_state(TRACE_GDBSTUB_HIT_BREAK) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 11 "../gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_hit_break " "RUN_STATE_DEBUG" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 326 "trace/trace-gdbstub.h"
        } else {
#line 11 "../gdbstub/trace-events"
            qemu_log("gdbstub_hit_break " "RUN_STATE_DEBUG" "\n");
#line 330 "trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_hit_break(void)
{
    if (true) {
        _nocheck__trace_gdbstub_hit_break();
    }
}

#define TRACE_GDBSTUB_HIT_PAUSED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_HIT_PAUSED) || \
    false)

static inline void _nocheck__trace_gdbstub_hit_paused(void)
{
    if (trace_event_get_state(TRACE_GDBSTUB_HIT_PAUSED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 12 "../gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_hit_paused " "RUN_STATE_PAUSED" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 357 "trace/trace-gdbstub.h"
        } else {
#line 12 "../gdbstub/trace-events"
            qemu_log("gdbstub_hit_paused " "RUN_STATE_PAUSED" "\n");
#line 361 "trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_hit_paused(void)
{
    if (true) {
        _nocheck__trace_gdbstub_hit_paused();
    }
}

#define TRACE_GDBSTUB_HIT_SHUTDOWN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_HIT_SHUTDOWN) || \
    false)

static inline void _nocheck__trace_gdbstub_hit_shutdown(void)
{
    if (trace_event_get_state(TRACE_GDBSTUB_HIT_SHUTDOWN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 13 "../gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_hit_shutdown " "RUN_STATE_SHUTDOWN" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 388 "trace/trace-gdbstub.h"
        } else {
#line 13 "../gdbstub/trace-events"
            qemu_log("gdbstub_hit_shutdown " "RUN_STATE_SHUTDOWN" "\n");
#line 392 "trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_hit_shutdown(void)
{
    if (true) {
        _nocheck__trace_gdbstub_hit_shutdown();
    }
}

#define TRACE_GDBSTUB_HIT_IO_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_HIT_IO_ERROR) || \
    false)

static inline void _nocheck__trace_gdbstub_hit_io_error(void)
{
    if (trace_event_get_state(TRACE_GDBSTUB_HIT_IO_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 14 "../gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_hit_io_error " "RUN_STATE_IO_ERROR" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 419 "trace/trace-gdbstub.h"
        } else {
#line 14 "../gdbstub/trace-events"
            qemu_log("gdbstub_hit_io_error " "RUN_STATE_IO_ERROR" "\n");
#line 423 "trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_hit_io_error(void)
{
    if (true) {
        _nocheck__trace_gdbstub_hit_io_error();
    }
}

#define TRACE_GDBSTUB_HIT_WATCHDOG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_HIT_WATCHDOG) || \
    false)

static inline void _nocheck__trace_gdbstub_hit_watchdog(void)
{
    if (trace_event_get_state(TRACE_GDBSTUB_HIT_WATCHDOG) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 15 "../gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_hit_watchdog " "RUN_STATE_WATCHDOG" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 450 "trace/trace-gdbstub.h"
        } else {
#line 15 "../gdbstub/trace-events"
            qemu_log("gdbstub_hit_watchdog " "RUN_STATE_WATCHDOG" "\n");
#line 454 "trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_hit_watchdog(void)
{
    if (true) {
        _nocheck__trace_gdbstub_hit_watchdog();
    }
}

#define TRACE_GDBSTUB_HIT_UNKNOWN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_HIT_UNKNOWN) || \
    false)

static inline void _nocheck__trace_gdbstub_hit_unknown(int state)
{
    if (trace_event_get_state(TRACE_GDBSTUB_HIT_UNKNOWN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 16 "../gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_hit_unknown " "Unknown run state=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state);
#line 481 "trace/trace-gdbstub.h"
        } else {
#line 16 "../gdbstub/trace-events"
            qemu_log("gdbstub_hit_unknown " "Unknown run state=0x%x" "\n", state);
#line 485 "trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_hit_unknown(int state)
{
    if (true) {
        _nocheck__trace_gdbstub_hit_unknown(state);
    }
}

#define TRACE_GDBSTUB_IO_REPLY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_IO_REPLY) || \
    false)

static inline void _nocheck__trace_gdbstub_io_reply(const char * message)
{
    if (trace_event_get_state(TRACE_GDBSTUB_IO_REPLY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 17 "../gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_io_reply " "Sent: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , message);
#line 512 "trace/trace-gdbstub.h"
        } else {
#line 17 "../gdbstub/trace-events"
            qemu_log("gdbstub_io_reply " "Sent: %s" "\n", message);
#line 516 "trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_io_reply(const char * message)
{
    if (true) {
        _nocheck__trace_gdbstub_io_reply(message);
    }
}

#define TRACE_GDBSTUB_IO_BINARYREPLY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_IO_BINARYREPLY) || \
    false)

static inline void _nocheck__trace_gdbstub_io_binaryreply(size_t ofs, const char * line)
{
    if (trace_event_get_state(TRACE_GDBSTUB_IO_BINARYREPLY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 18 "../gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_io_binaryreply " "0x%04zx: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ofs, line);
#line 543 "trace/trace-gdbstub.h"
        } else {
#line 18 "../gdbstub/trace-events"
            qemu_log("gdbstub_io_binaryreply " "0x%04zx: %s" "\n", ofs, line);
#line 547 "trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_io_binaryreply(size_t ofs, const char * line)
{
    if (true) {
        _nocheck__trace_gdbstub_io_binaryreply(ofs, line);
    }
}

#define TRACE_GDBSTUB_IO_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_IO_COMMAND) || \
    false)

static inline void _nocheck__trace_gdbstub_io_command(const char * command)
{
    if (trace_event_get_state(TRACE_GDBSTUB_IO_COMMAND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 19 "../gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_io_command " "Received: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , command);
#line 574 "trace/trace-gdbstub.h"
        } else {
#line 19 "../gdbstub/trace-events"
            qemu_log("gdbstub_io_command " "Received: %s" "\n", command);
#line 578 "trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_io_command(const char * command)
{
    if (true) {
        _nocheck__trace_gdbstub_io_command(command);
    }
}

#define TRACE_GDBSTUB_IO_GOT_ACK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_IO_GOT_ACK) || \
    false)

static inline void _nocheck__trace_gdbstub_io_got_ack(void)
{
    if (trace_event_get_state(TRACE_GDBSTUB_IO_GOT_ACK) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 20 "../gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_io_got_ack " "Got ACK" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 605 "trace/trace-gdbstub.h"
        } else {
#line 20 "../gdbstub/trace-events"
            qemu_log("gdbstub_io_got_ack " "Got ACK" "\n");
#line 609 "trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_io_got_ack(void)
{
    if (true) {
        _nocheck__trace_gdbstub_io_got_ack();
    }
}

#define TRACE_GDBSTUB_IO_GOT_UNEXPECTED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_IO_GOT_UNEXPECTED) || \
    false)

static inline void _nocheck__trace_gdbstub_io_got_unexpected(uint8_t ch)
{
    if (trace_event_get_state(TRACE_GDBSTUB_IO_GOT_UNEXPECTED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 21 "../gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_io_got_unexpected " "Got 0x%02x when expecting ACK/NACK" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ch);
#line 636 "trace/trace-gdbstub.h"
        } else {
#line 21 "../gdbstub/trace-events"
            qemu_log("gdbstub_io_got_unexpected " "Got 0x%02x when expecting ACK/NACK" "\n", ch);
#line 640 "trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_io_got_unexpected(uint8_t ch)
{
    if (true) {
        _nocheck__trace_gdbstub_io_got_unexpected(ch);
    }
}

#define TRACE_GDBSTUB_ERR_GOT_NACK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_ERR_GOT_NACK) || \
    false)

static inline void _nocheck__trace_gdbstub_err_got_nack(void)
{
    if (trace_event_get_state(TRACE_GDBSTUB_ERR_GOT_NACK) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 22 "../gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_err_got_nack " "Got NACK, retransmitting" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 667 "trace/trace-gdbstub.h"
        } else {
#line 22 "../gdbstub/trace-events"
            qemu_log("gdbstub_err_got_nack " "Got NACK, retransmitting" "\n");
#line 671 "trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_err_got_nack(void)
{
    if (true) {
        _nocheck__trace_gdbstub_err_got_nack();
    }
}

#define TRACE_GDBSTUB_ERR_GARBAGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_ERR_GARBAGE) || \
    false)

static inline void _nocheck__trace_gdbstub_err_garbage(uint8_t ch)
{
    if (trace_event_get_state(TRACE_GDBSTUB_ERR_GARBAGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 23 "../gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_err_garbage " "received garbage between packets: 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ch);
#line 698 "trace/trace-gdbstub.h"
        } else {
#line 23 "../gdbstub/trace-events"
            qemu_log("gdbstub_err_garbage " "received garbage between packets: 0x%02x" "\n", ch);
#line 702 "trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_err_garbage(uint8_t ch)
{
    if (true) {
        _nocheck__trace_gdbstub_err_garbage(ch);
    }
}

#define TRACE_GDBSTUB_ERR_OVERRUN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_ERR_OVERRUN) || \
    false)

static inline void _nocheck__trace_gdbstub_err_overrun(void)
{
    if (trace_event_get_state(TRACE_GDBSTUB_ERR_OVERRUN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 24 "../gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_err_overrun " "command buffer overrun, dropping command" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 729 "trace/trace-gdbstub.h"
        } else {
#line 24 "../gdbstub/trace-events"
            qemu_log("gdbstub_err_overrun " "command buffer overrun, dropping command" "\n");
#line 733 "trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_err_overrun(void)
{
    if (true) {
        _nocheck__trace_gdbstub_err_overrun();
    }
}

#define TRACE_GDBSTUB_ERR_INVALID_REPEAT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_ERR_INVALID_REPEAT) || \
    false)

static inline void _nocheck__trace_gdbstub_err_invalid_repeat(uint8_t ch)
{
    if (trace_event_get_state(TRACE_GDBSTUB_ERR_INVALID_REPEAT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 25 "../gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_err_invalid_repeat " "got invalid RLE count: 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ch);
#line 760 "trace/trace-gdbstub.h"
        } else {
#line 25 "../gdbstub/trace-events"
            qemu_log("gdbstub_err_invalid_repeat " "got invalid RLE count: 0x%02x" "\n", ch);
#line 764 "trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_err_invalid_repeat(uint8_t ch)
{
    if (true) {
        _nocheck__trace_gdbstub_err_invalid_repeat(ch);
    }
}

#define TRACE_GDBSTUB_ERR_INVALID_RLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_ERR_INVALID_RLE) || \
    false)

static inline void _nocheck__trace_gdbstub_err_invalid_rle(void)
{
    if (trace_event_get_state(TRACE_GDBSTUB_ERR_INVALID_RLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 26 "../gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_err_invalid_rle " "got invalid RLE sequence" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 791 "trace/trace-gdbstub.h"
        } else {
#line 26 "../gdbstub/trace-events"
            qemu_log("gdbstub_err_invalid_rle " "got invalid RLE sequence" "\n");
#line 795 "trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_err_invalid_rle(void)
{
    if (true) {
        _nocheck__trace_gdbstub_err_invalid_rle();
    }
}

#define TRACE_GDBSTUB_ERR_CHECKSUM_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_ERR_CHECKSUM_INVALID) || \
    false)

static inline void _nocheck__trace_gdbstub_err_checksum_invalid(uint8_t ch)
{
    if (trace_event_get_state(TRACE_GDBSTUB_ERR_CHECKSUM_INVALID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 27 "../gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_err_checksum_invalid " "got invalid command checksum digit: 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ch);
#line 822 "trace/trace-gdbstub.h"
        } else {
#line 27 "../gdbstub/trace-events"
            qemu_log("gdbstub_err_checksum_invalid " "got invalid command checksum digit: 0x%02x" "\n", ch);
#line 826 "trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_err_checksum_invalid(uint8_t ch)
{
    if (true) {
        _nocheck__trace_gdbstub_err_checksum_invalid(ch);
    }
}

#define TRACE_GDBSTUB_ERR_CHECKSUM_INCORRECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_ERR_CHECKSUM_INCORRECT) || \
    false)

static inline void _nocheck__trace_gdbstub_err_checksum_incorrect(uint8_t expected, uint8_t got)
{
    if (trace_event_get_state(TRACE_GDBSTUB_ERR_CHECKSUM_INCORRECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 28 "../gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_err_checksum_incorrect " "got command packet with incorrect checksum, expected=0x%02x, received=0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , expected, got);
#line 853 "trace/trace-gdbstub.h"
        } else {
#line 28 "../gdbstub/trace-events"
            qemu_log("gdbstub_err_checksum_incorrect " "got command packet with incorrect checksum, expected=0x%02x, received=0x%02x" "\n", expected, got);
#line 857 "trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_err_checksum_incorrect(uint8_t expected, uint8_t got)
{
    if (true) {
        _nocheck__trace_gdbstub_err_checksum_incorrect(expected, got);
    }
}

#define TRACE_GDBSTUB_ERR_UNEXPECTED_RUNPKT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_ERR_UNEXPECTED_RUNPKT) || \
    false)

static inline void _nocheck__trace_gdbstub_err_unexpected_runpkt(uint8_t ch)
{
    if (trace_event_get_state(TRACE_GDBSTUB_ERR_UNEXPECTED_RUNPKT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 29 "../gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_err_unexpected_runpkt " "unexpected packet (0x%02x) while target running" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ch);
#line 884 "trace/trace-gdbstub.h"
        } else {
#line 29 "../gdbstub/trace-events"
            qemu_log("gdbstub_err_unexpected_runpkt " "unexpected packet (0x%02x) while target running" "\n", ch);
#line 888 "trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_err_unexpected_runpkt(uint8_t ch)
{
    if (true) {
        _nocheck__trace_gdbstub_err_unexpected_runpkt(ch);
    }
}

#define TRACE_GDBSTUB_HIT_WATCHPOINT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_HIT_WATCHPOINT) || \
    false)

static inline void _nocheck__trace_gdbstub_hit_watchpoint(const char * type, int cpu_gdb_index, uint64_t vaddr)
{
    if (trace_event_get_state(TRACE_GDBSTUB_HIT_WATCHPOINT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 32 "../gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_hit_watchpoint " "Watchpoint hit, type=\"%s\" cpu=%d, vaddr=0x%" PRIx64 "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, cpu_gdb_index, vaddr);
#line 915 "trace/trace-gdbstub.h"
        } else {
#line 32 "../gdbstub/trace-events"
            qemu_log("gdbstub_hit_watchpoint " "Watchpoint hit, type=\"%s\" cpu=%d, vaddr=0x%" PRIx64 "" "\n", type, cpu_gdb_index, vaddr);
#line 919 "trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_hit_watchpoint(const char * type, int cpu_gdb_index, uint64_t vaddr)
{
    if (true) {
        _nocheck__trace_gdbstub_hit_watchpoint(type, cpu_gdb_index, vaddr);
    }
}
#endif /* TRACE_GDBSTUB_GENERATED_TRACERS_H */
