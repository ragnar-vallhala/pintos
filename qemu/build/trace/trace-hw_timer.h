/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_TIMER_GENERATED_TRACERS_H
#define TRACE_HW_TIMER_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_SLAVIO_TIMER_GET_OUT_EVENT;
extern TraceEvent _TRACE_SLAVIO_TIMER_IRQ_EVENT;
extern TraceEvent _TRACE_SLAVIO_TIMER_MEM_READL_INVALID_EVENT;
extern TraceEvent _TRACE_SLAVIO_TIMER_MEM_READL_EVENT;
extern TraceEvent _TRACE_SLAVIO_TIMER_MEM_WRITEL_EVENT;
extern TraceEvent _TRACE_SLAVIO_TIMER_MEM_WRITEL_LIMIT_EVENT;
extern TraceEvent _TRACE_SLAVIO_TIMER_MEM_WRITEL_COUNTER_INVALID_EVENT;
extern TraceEvent _TRACE_SLAVIO_TIMER_MEM_WRITEL_STATUS_START_EVENT;
extern TraceEvent _TRACE_SLAVIO_TIMER_MEM_WRITEL_STATUS_STOP_EVENT;
extern TraceEvent _TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_USER_EVENT;
extern TraceEvent _TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_COUNTER_EVENT;
extern TraceEvent _TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_INVALID_EVENT;
extern TraceEvent _TRACE_SLAVIO_TIMER_MEM_WRITEL_INVALID_EVENT;
extern TraceEvent _TRACE_GRLIB_GPTIMER_ENABLE_EVENT;
extern TraceEvent _TRACE_GRLIB_GPTIMER_DISABLED_EVENT;
extern TraceEvent _TRACE_GRLIB_GPTIMER_RESTART_EVENT;
extern TraceEvent _TRACE_GRLIB_GPTIMER_SET_SCALER_EVENT;
extern TraceEvent _TRACE_GRLIB_GPTIMER_HIT_EVENT;
extern TraceEvent _TRACE_GRLIB_GPTIMER_READL_EVENT;
extern TraceEvent _TRACE_GRLIB_GPTIMER_WRITEL_EVENT;
extern TraceEvent _TRACE_ASPEED_TIMER_CTRL_ENABLE_EVENT;
extern TraceEvent _TRACE_ASPEED_TIMER_CTRL_EXTERNAL_CLOCK_EVENT;
extern TraceEvent _TRACE_ASPEED_TIMER_CTRL_OVERFLOW_INTERRUPT_EVENT;
extern TraceEvent _TRACE_ASPEED_TIMER_CTRL_PULSE_ENABLE_EVENT;
extern TraceEvent _TRACE_ASPEED_TIMER_SET_CTRL2_EVENT;
extern TraceEvent _TRACE_ASPEED_TIMER_SET_VALUE_EVENT;
extern TraceEvent _TRACE_ASPEED_TIMER_READ_EVENT;
extern TraceEvent _TRACE_SYSTICK_RELOAD_EVENT;
extern TraceEvent _TRACE_SYSTICK_TIMER_TICK_EVENT;
extern TraceEvent _TRACE_SYSTICK_READ_EVENT;
extern TraceEvent _TRACE_SYSTICK_WRITE_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_TIMER_READ_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_TIMER_WRITE_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_TIMER_RESET_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_DUALTIMER_READ_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_DUALTIMER_WRITE_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_DUALTIMER_RESET_EVENT;
extern TraceEvent _TRACE_NPCM7XX_TIMER_READ_EVENT;
extern TraceEvent _TRACE_NPCM7XX_TIMER_WRITE_EVENT;
extern TraceEvent _TRACE_NPCM7XX_TIMER_IRQ_EVENT;
extern TraceEvent _TRACE_NRF51_TIMER_READ_EVENT;
extern TraceEvent _TRACE_NRF51_TIMER_WRITE_EVENT;
extern TraceEvent _TRACE_NRF51_TIMER_SET_COUNT_EVENT;
extern TraceEvent _TRACE_BCM2835_SYSTMR_TIMER_EXPIRED_EVENT;
extern TraceEvent _TRACE_BCM2835_SYSTMR_IRQ_ACK_EVENT;
extern TraceEvent _TRACE_BCM2835_SYSTMR_READ_EVENT;
extern TraceEvent _TRACE_BCM2835_SYSTMR_WRITE_EVENT;
extern TraceEvent _TRACE_BCM2835_SYSTMR_RUN_EVENT;
extern TraceEvent _TRACE_AVR_TIMER16_READ_EVENT;
extern TraceEvent _TRACE_AVR_TIMER16_READ_IFR_EVENT;
extern TraceEvent _TRACE_AVR_TIMER16_READ_IMSK_EVENT;
extern TraceEvent _TRACE_AVR_TIMER16_WRITE_EVENT;
extern TraceEvent _TRACE_AVR_TIMER16_WRITE_IMSK_EVENT;
extern TraceEvent _TRACE_AVR_TIMER16_INTERRUPT_COUNT_EVENT;
extern TraceEvent _TRACE_AVR_TIMER16_INTERRUPT_OVERFLOW_EVENT;
extern TraceEvent _TRACE_AVR_TIMER16_NEXT_ALARM_EVENT;
extern TraceEvent _TRACE_AVR_TIMER16_CLKSRC_UPDATE_EVENT;
extern TraceEvent _TRACE_SSE_COUNTER_CONTROL_READ_EVENT;
extern TraceEvent _TRACE_SSE_COUNTER_CONTROL_WRITE_EVENT;
extern TraceEvent _TRACE_SSE_COUNTER_STATUS_READ_EVENT;
extern TraceEvent _TRACE_SSE_COUNTER_STATUS_WRITE_EVENT;
extern TraceEvent _TRACE_SSE_COUNTER_RESET_EVENT;
extern TraceEvent _TRACE_SSE_TIMER_READ_EVENT;
extern TraceEvent _TRACE_SSE_TIMER_WRITE_EVENT;
extern TraceEvent _TRACE_SSE_TIMER_RESET_EVENT;
extern TraceEvent _TRACE_SIFIVE_PWM_SET_ALARM_EVENT;
extern TraceEvent _TRACE_SIFIVE_PWM_INTERRUPT_EVENT;
extern TraceEvent _TRACE_SIFIVE_PWM_READ_EVENT;
extern TraceEvent _TRACE_SIFIVE_PWM_WRITE_EVENT;
extern TraceEvent _TRACE_SH_TIMER_START_STOP_EVENT;
extern TraceEvent _TRACE_SH_TIMER_READ_EVENT;
extern TraceEvent _TRACE_SH_TIMER_WRITE_EVENT;
extern TraceEvent _TRACE_HPET_TIMER_ID_OUT_OF_RANGE_EVENT;
extern TraceEvent _TRACE_HPET_INVALID_HPET_CFG_EVENT;
extern TraceEvent _TRACE_HPET_RAM_READ_EVENT;
extern TraceEvent _TRACE_HPET_RAM_READ_READING_COUNTER_EVENT;
extern TraceEvent _TRACE_HPET_RAM_READ_INVALID_EVENT;
extern TraceEvent _TRACE_HPET_RAM_WRITE_EVENT;
extern TraceEvent _TRACE_HPET_RAM_WRITE_TIMER_ID_EVENT;
extern TraceEvent _TRACE_HPET_RAM_WRITE_TN_CFG_EVENT;
extern TraceEvent _TRACE_HPET_RAM_WRITE_TN_CMP_EVENT;
extern TraceEvent _TRACE_HPET_RAM_WRITE_INVALID_TN_CMP_EVENT;
extern TraceEvent _TRACE_HPET_RAM_WRITE_INVALID_EVENT;
extern TraceEvent _TRACE_HPET_RAM_WRITE_COUNTER_WRITE_WHILE_ENABLED_EVENT;
extern TraceEvent _TRACE_HPET_RAM_WRITE_COUNTER_WRITTEN_EVENT;
extern uint16_t _TRACE_SLAVIO_TIMER_GET_OUT_DSTATE;
extern uint16_t _TRACE_SLAVIO_TIMER_IRQ_DSTATE;
extern uint16_t _TRACE_SLAVIO_TIMER_MEM_READL_INVALID_DSTATE;
extern uint16_t _TRACE_SLAVIO_TIMER_MEM_READL_DSTATE;
extern uint16_t _TRACE_SLAVIO_TIMER_MEM_WRITEL_DSTATE;
extern uint16_t _TRACE_SLAVIO_TIMER_MEM_WRITEL_LIMIT_DSTATE;
extern uint16_t _TRACE_SLAVIO_TIMER_MEM_WRITEL_COUNTER_INVALID_DSTATE;
extern uint16_t _TRACE_SLAVIO_TIMER_MEM_WRITEL_STATUS_START_DSTATE;
extern uint16_t _TRACE_SLAVIO_TIMER_MEM_WRITEL_STATUS_STOP_DSTATE;
extern uint16_t _TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_USER_DSTATE;
extern uint16_t _TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_COUNTER_DSTATE;
extern uint16_t _TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_INVALID_DSTATE;
extern uint16_t _TRACE_SLAVIO_TIMER_MEM_WRITEL_INVALID_DSTATE;
extern uint16_t _TRACE_GRLIB_GPTIMER_ENABLE_DSTATE;
extern uint16_t _TRACE_GRLIB_GPTIMER_DISABLED_DSTATE;
extern uint16_t _TRACE_GRLIB_GPTIMER_RESTART_DSTATE;
extern uint16_t _TRACE_GRLIB_GPTIMER_SET_SCALER_DSTATE;
extern uint16_t _TRACE_GRLIB_GPTIMER_HIT_DSTATE;
extern uint16_t _TRACE_GRLIB_GPTIMER_READL_DSTATE;
extern uint16_t _TRACE_GRLIB_GPTIMER_WRITEL_DSTATE;
extern uint16_t _TRACE_ASPEED_TIMER_CTRL_ENABLE_DSTATE;
extern uint16_t _TRACE_ASPEED_TIMER_CTRL_EXTERNAL_CLOCK_DSTATE;
extern uint16_t _TRACE_ASPEED_TIMER_CTRL_OVERFLOW_INTERRUPT_DSTATE;
extern uint16_t _TRACE_ASPEED_TIMER_CTRL_PULSE_ENABLE_DSTATE;
extern uint16_t _TRACE_ASPEED_TIMER_SET_CTRL2_DSTATE;
extern uint16_t _TRACE_ASPEED_TIMER_SET_VALUE_DSTATE;
extern uint16_t _TRACE_ASPEED_TIMER_READ_DSTATE;
extern uint16_t _TRACE_SYSTICK_RELOAD_DSTATE;
extern uint16_t _TRACE_SYSTICK_TIMER_TICK_DSTATE;
extern uint16_t _TRACE_SYSTICK_READ_DSTATE;
extern uint16_t _TRACE_SYSTICK_WRITE_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_TIMER_READ_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_TIMER_WRITE_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_TIMER_RESET_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_DUALTIMER_READ_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_DUALTIMER_WRITE_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_DUALTIMER_RESET_DSTATE;
extern uint16_t _TRACE_NPCM7XX_TIMER_READ_DSTATE;
extern uint16_t _TRACE_NPCM7XX_TIMER_WRITE_DSTATE;
extern uint16_t _TRACE_NPCM7XX_TIMER_IRQ_DSTATE;
extern uint16_t _TRACE_NRF51_TIMER_READ_DSTATE;
extern uint16_t _TRACE_NRF51_TIMER_WRITE_DSTATE;
extern uint16_t _TRACE_NRF51_TIMER_SET_COUNT_DSTATE;
extern uint16_t _TRACE_BCM2835_SYSTMR_TIMER_EXPIRED_DSTATE;
extern uint16_t _TRACE_BCM2835_SYSTMR_IRQ_ACK_DSTATE;
extern uint16_t _TRACE_BCM2835_SYSTMR_READ_DSTATE;
extern uint16_t _TRACE_BCM2835_SYSTMR_WRITE_DSTATE;
extern uint16_t _TRACE_BCM2835_SYSTMR_RUN_DSTATE;
extern uint16_t _TRACE_AVR_TIMER16_READ_DSTATE;
extern uint16_t _TRACE_AVR_TIMER16_READ_IFR_DSTATE;
extern uint16_t _TRACE_AVR_TIMER16_READ_IMSK_DSTATE;
extern uint16_t _TRACE_AVR_TIMER16_WRITE_DSTATE;
extern uint16_t _TRACE_AVR_TIMER16_WRITE_IMSK_DSTATE;
extern uint16_t _TRACE_AVR_TIMER16_INTERRUPT_COUNT_DSTATE;
extern uint16_t _TRACE_AVR_TIMER16_INTERRUPT_OVERFLOW_DSTATE;
extern uint16_t _TRACE_AVR_TIMER16_NEXT_ALARM_DSTATE;
extern uint16_t _TRACE_AVR_TIMER16_CLKSRC_UPDATE_DSTATE;
extern uint16_t _TRACE_SSE_COUNTER_CONTROL_READ_DSTATE;
extern uint16_t _TRACE_SSE_COUNTER_CONTROL_WRITE_DSTATE;
extern uint16_t _TRACE_SSE_COUNTER_STATUS_READ_DSTATE;
extern uint16_t _TRACE_SSE_COUNTER_STATUS_WRITE_DSTATE;
extern uint16_t _TRACE_SSE_COUNTER_RESET_DSTATE;
extern uint16_t _TRACE_SSE_TIMER_READ_DSTATE;
extern uint16_t _TRACE_SSE_TIMER_WRITE_DSTATE;
extern uint16_t _TRACE_SSE_TIMER_RESET_DSTATE;
extern uint16_t _TRACE_SIFIVE_PWM_SET_ALARM_DSTATE;
extern uint16_t _TRACE_SIFIVE_PWM_INTERRUPT_DSTATE;
extern uint16_t _TRACE_SIFIVE_PWM_READ_DSTATE;
extern uint16_t _TRACE_SIFIVE_PWM_WRITE_DSTATE;
extern uint16_t _TRACE_SH_TIMER_START_STOP_DSTATE;
extern uint16_t _TRACE_SH_TIMER_READ_DSTATE;
extern uint16_t _TRACE_SH_TIMER_WRITE_DSTATE;
extern uint16_t _TRACE_HPET_TIMER_ID_OUT_OF_RANGE_DSTATE;
extern uint16_t _TRACE_HPET_INVALID_HPET_CFG_DSTATE;
extern uint16_t _TRACE_HPET_RAM_READ_DSTATE;
extern uint16_t _TRACE_HPET_RAM_READ_READING_COUNTER_DSTATE;
extern uint16_t _TRACE_HPET_RAM_READ_INVALID_DSTATE;
extern uint16_t _TRACE_HPET_RAM_WRITE_DSTATE;
extern uint16_t _TRACE_HPET_RAM_WRITE_TIMER_ID_DSTATE;
extern uint16_t _TRACE_HPET_RAM_WRITE_TN_CFG_DSTATE;
extern uint16_t _TRACE_HPET_RAM_WRITE_TN_CMP_DSTATE;
extern uint16_t _TRACE_HPET_RAM_WRITE_INVALID_TN_CMP_DSTATE;
extern uint16_t _TRACE_HPET_RAM_WRITE_INVALID_DSTATE;
extern uint16_t _TRACE_HPET_RAM_WRITE_COUNTER_WRITE_WHILE_ENABLED_DSTATE;
extern uint16_t _TRACE_HPET_RAM_WRITE_COUNTER_WRITTEN_DSTATE;
#define TRACE_SLAVIO_TIMER_GET_OUT_ENABLED 1
#define TRACE_SLAVIO_TIMER_IRQ_ENABLED 1
#define TRACE_SLAVIO_TIMER_MEM_READL_INVALID_ENABLED 1
#define TRACE_SLAVIO_TIMER_MEM_READL_ENABLED 1
#define TRACE_SLAVIO_TIMER_MEM_WRITEL_ENABLED 1
#define TRACE_SLAVIO_TIMER_MEM_WRITEL_LIMIT_ENABLED 1
#define TRACE_SLAVIO_TIMER_MEM_WRITEL_COUNTER_INVALID_ENABLED 1
#define TRACE_SLAVIO_TIMER_MEM_WRITEL_STATUS_START_ENABLED 1
#define TRACE_SLAVIO_TIMER_MEM_WRITEL_STATUS_STOP_ENABLED 1
#define TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_USER_ENABLED 1
#define TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_COUNTER_ENABLED 1
#define TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_INVALID_ENABLED 1
#define TRACE_SLAVIO_TIMER_MEM_WRITEL_INVALID_ENABLED 1
#define TRACE_GRLIB_GPTIMER_ENABLE_ENABLED 1
#define TRACE_GRLIB_GPTIMER_DISABLED_ENABLED 1
#define TRACE_GRLIB_GPTIMER_RESTART_ENABLED 1
#define TRACE_GRLIB_GPTIMER_SET_SCALER_ENABLED 1
#define TRACE_GRLIB_GPTIMER_HIT_ENABLED 1
#define TRACE_GRLIB_GPTIMER_READL_ENABLED 1
#define TRACE_GRLIB_GPTIMER_WRITEL_ENABLED 1
#define TRACE_ASPEED_TIMER_CTRL_ENABLE_ENABLED 1
#define TRACE_ASPEED_TIMER_CTRL_EXTERNAL_CLOCK_ENABLED 1
#define TRACE_ASPEED_TIMER_CTRL_OVERFLOW_INTERRUPT_ENABLED 1
#define TRACE_ASPEED_TIMER_CTRL_PULSE_ENABLE_ENABLED 1
#define TRACE_ASPEED_TIMER_SET_CTRL2_ENABLED 1
#define TRACE_ASPEED_TIMER_SET_VALUE_ENABLED 1
#define TRACE_ASPEED_TIMER_READ_ENABLED 1
#define TRACE_SYSTICK_RELOAD_ENABLED 1
#define TRACE_SYSTICK_TIMER_TICK_ENABLED 1
#define TRACE_SYSTICK_READ_ENABLED 1
#define TRACE_SYSTICK_WRITE_ENABLED 1
#define TRACE_CMSDK_APB_TIMER_READ_ENABLED 1
#define TRACE_CMSDK_APB_TIMER_WRITE_ENABLED 1
#define TRACE_CMSDK_APB_TIMER_RESET_ENABLED 1
#define TRACE_CMSDK_APB_DUALTIMER_READ_ENABLED 1
#define TRACE_CMSDK_APB_DUALTIMER_WRITE_ENABLED 1
#define TRACE_CMSDK_APB_DUALTIMER_RESET_ENABLED 1
#define TRACE_NPCM7XX_TIMER_READ_ENABLED 1
#define TRACE_NPCM7XX_TIMER_WRITE_ENABLED 1
#define TRACE_NPCM7XX_TIMER_IRQ_ENABLED 1
#define TRACE_NRF51_TIMER_READ_ENABLED 1
#define TRACE_NRF51_TIMER_WRITE_ENABLED 1
#define TRACE_NRF51_TIMER_SET_COUNT_ENABLED 1
#define TRACE_BCM2835_SYSTMR_TIMER_EXPIRED_ENABLED 1
#define TRACE_BCM2835_SYSTMR_IRQ_ACK_ENABLED 1
#define TRACE_BCM2835_SYSTMR_READ_ENABLED 1
#define TRACE_BCM2835_SYSTMR_WRITE_ENABLED 1
#define TRACE_BCM2835_SYSTMR_RUN_ENABLED 1
#define TRACE_AVR_TIMER16_READ_ENABLED 1
#define TRACE_AVR_TIMER16_READ_IFR_ENABLED 1
#define TRACE_AVR_TIMER16_READ_IMSK_ENABLED 1
#define TRACE_AVR_TIMER16_WRITE_ENABLED 1
#define TRACE_AVR_TIMER16_WRITE_IMSK_ENABLED 1
#define TRACE_AVR_TIMER16_INTERRUPT_COUNT_ENABLED 1
#define TRACE_AVR_TIMER16_INTERRUPT_OVERFLOW_ENABLED 1
#define TRACE_AVR_TIMER16_NEXT_ALARM_ENABLED 1
#define TRACE_AVR_TIMER16_CLKSRC_UPDATE_ENABLED 1
#define TRACE_SSE_COUNTER_CONTROL_READ_ENABLED 1
#define TRACE_SSE_COUNTER_CONTROL_WRITE_ENABLED 1
#define TRACE_SSE_COUNTER_STATUS_READ_ENABLED 1
#define TRACE_SSE_COUNTER_STATUS_WRITE_ENABLED 1
#define TRACE_SSE_COUNTER_RESET_ENABLED 1
#define TRACE_SSE_TIMER_READ_ENABLED 1
#define TRACE_SSE_TIMER_WRITE_ENABLED 1
#define TRACE_SSE_TIMER_RESET_ENABLED 1
#define TRACE_SIFIVE_PWM_SET_ALARM_ENABLED 1
#define TRACE_SIFIVE_PWM_INTERRUPT_ENABLED 1
#define TRACE_SIFIVE_PWM_READ_ENABLED 1
#define TRACE_SIFIVE_PWM_WRITE_ENABLED 1
#define TRACE_SH_TIMER_START_STOP_ENABLED 1
#define TRACE_SH_TIMER_READ_ENABLED 1
#define TRACE_SH_TIMER_WRITE_ENABLED 1
#define TRACE_HPET_TIMER_ID_OUT_OF_RANGE_ENABLED 1
#define TRACE_HPET_INVALID_HPET_CFG_ENABLED 1
#define TRACE_HPET_RAM_READ_ENABLED 1
#define TRACE_HPET_RAM_READ_READING_COUNTER_ENABLED 1
#define TRACE_HPET_RAM_READ_INVALID_ENABLED 1
#define TRACE_HPET_RAM_WRITE_ENABLED 1
#define TRACE_HPET_RAM_WRITE_TIMER_ID_ENABLED 1
#define TRACE_HPET_RAM_WRITE_TN_CFG_ENABLED 1
#define TRACE_HPET_RAM_WRITE_TN_CMP_ENABLED 1
#define TRACE_HPET_RAM_WRITE_INVALID_TN_CMP_ENABLED 1
#define TRACE_HPET_RAM_WRITE_INVALID_ENABLED 1
#define TRACE_HPET_RAM_WRITE_COUNTER_WRITE_WHILE_ENABLED_ENABLED 1
#define TRACE_HPET_RAM_WRITE_COUNTER_WRITTEN_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_SLAVIO_TIMER_GET_OUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SLAVIO_TIMER_GET_OUT) || \
    false)

static inline void _nocheck__trace_slavio_timer_get_out(uint64_t limit, uint32_t counthigh, uint32_t count)
{
    if (trace_event_get_state(TRACE_SLAVIO_TIMER_GET_OUT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 4 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:slavio_timer_get_out " "limit 0x%"PRIx64" count 0x%x0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , limit, counthigh, count);
#line 283 "trace/trace-hw_timer.h"
        } else {
#line 4 "../hw/timer/trace-events"
            qemu_log("slavio_timer_get_out " "limit 0x%"PRIx64" count 0x%x0x%08x" "\n", limit, counthigh, count);
#line 287 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_slavio_timer_get_out(uint64_t limit, uint32_t counthigh, uint32_t count)
{
    if (true) {
        _nocheck__trace_slavio_timer_get_out(limit, counthigh, count);
    }
}

#define TRACE_SLAVIO_TIMER_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SLAVIO_TIMER_IRQ) || \
    false)

static inline void _nocheck__trace_slavio_timer_irq(uint32_t counthigh, uint32_t count)
{
    if (trace_event_get_state(TRACE_SLAVIO_TIMER_IRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 5 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:slavio_timer_irq " "callback: count 0x%x0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , counthigh, count);
#line 314 "trace/trace-hw_timer.h"
        } else {
#line 5 "../hw/timer/trace-events"
            qemu_log("slavio_timer_irq " "callback: count 0x%x0x%08x" "\n", counthigh, count);
#line 318 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_slavio_timer_irq(uint32_t counthigh, uint32_t count)
{
    if (true) {
        _nocheck__trace_slavio_timer_irq(counthigh, count);
    }
}

#define TRACE_SLAVIO_TIMER_MEM_READL_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SLAVIO_TIMER_MEM_READL_INVALID) || \
    false)

static inline void _nocheck__trace_slavio_timer_mem_readl_invalid(uint64_t addr)
{
    if (trace_event_get_state(TRACE_SLAVIO_TIMER_MEM_READL_INVALID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 6 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:slavio_timer_mem_readl_invalid " "invalid read address 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 345 "trace/trace-hw_timer.h"
        } else {
#line 6 "../hw/timer/trace-events"
            qemu_log("slavio_timer_mem_readl_invalid " "invalid read address 0x%"PRIx64 "\n", addr);
#line 349 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_slavio_timer_mem_readl_invalid(uint64_t addr)
{
    if (true) {
        _nocheck__trace_slavio_timer_mem_readl_invalid(addr);
    }
}

#define TRACE_SLAVIO_TIMER_MEM_READL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SLAVIO_TIMER_MEM_READL) || \
    false)

static inline void _nocheck__trace_slavio_timer_mem_readl(uint64_t addr, uint32_t ret)
{
    if (trace_event_get_state(TRACE_SLAVIO_TIMER_MEM_READL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 7 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:slavio_timer_mem_readl " "read 0x%"PRIx64" = 0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, ret);
#line 376 "trace/trace-hw_timer.h"
        } else {
#line 7 "../hw/timer/trace-events"
            qemu_log("slavio_timer_mem_readl " "read 0x%"PRIx64" = 0x%08x" "\n", addr, ret);
#line 380 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_slavio_timer_mem_readl(uint64_t addr, uint32_t ret)
{
    if (true) {
        _nocheck__trace_slavio_timer_mem_readl(addr, ret);
    }
}

#define TRACE_SLAVIO_TIMER_MEM_WRITEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SLAVIO_TIMER_MEM_WRITEL) || \
    false)

static inline void _nocheck__trace_slavio_timer_mem_writel(uint64_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_SLAVIO_TIMER_MEM_WRITEL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 8 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:slavio_timer_mem_writel " "write 0x%"PRIx64" = 0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 407 "trace/trace-hw_timer.h"
        } else {
#line 8 "../hw/timer/trace-events"
            qemu_log("slavio_timer_mem_writel " "write 0x%"PRIx64" = 0x%08x" "\n", addr, val);
#line 411 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_slavio_timer_mem_writel(uint64_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_slavio_timer_mem_writel(addr, val);
    }
}

#define TRACE_SLAVIO_TIMER_MEM_WRITEL_LIMIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SLAVIO_TIMER_MEM_WRITEL_LIMIT) || \
    false)

static inline void _nocheck__trace_slavio_timer_mem_writel_limit(unsigned int timer_index, uint64_t count)
{
    if (trace_event_get_state(TRACE_SLAVIO_TIMER_MEM_WRITEL_LIMIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 9 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:slavio_timer_mem_writel_limit " "processor %d user timer set to 0x%016"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , timer_index, count);
#line 438 "trace/trace-hw_timer.h"
        } else {
#line 9 "../hw/timer/trace-events"
            qemu_log("slavio_timer_mem_writel_limit " "processor %d user timer set to 0x%016"PRIx64 "\n", timer_index, count);
#line 442 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_slavio_timer_mem_writel_limit(unsigned int timer_index, uint64_t count)
{
    if (true) {
        _nocheck__trace_slavio_timer_mem_writel_limit(timer_index, count);
    }
}

#define TRACE_SLAVIO_TIMER_MEM_WRITEL_COUNTER_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SLAVIO_TIMER_MEM_WRITEL_COUNTER_INVALID) || \
    false)

static inline void _nocheck__trace_slavio_timer_mem_writel_counter_invalid(void)
{
    if (trace_event_get_state(TRACE_SLAVIO_TIMER_MEM_WRITEL_COUNTER_INVALID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 10 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:slavio_timer_mem_writel_counter_invalid " "not user timer" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 469 "trace/trace-hw_timer.h"
        } else {
#line 10 "../hw/timer/trace-events"
            qemu_log("slavio_timer_mem_writel_counter_invalid " "not user timer" "\n");
#line 473 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_slavio_timer_mem_writel_counter_invalid(void)
{
    if (true) {
        _nocheck__trace_slavio_timer_mem_writel_counter_invalid();
    }
}

#define TRACE_SLAVIO_TIMER_MEM_WRITEL_STATUS_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SLAVIO_TIMER_MEM_WRITEL_STATUS_START) || \
    false)

static inline void _nocheck__trace_slavio_timer_mem_writel_status_start(unsigned int timer_index)
{
    if (trace_event_get_state(TRACE_SLAVIO_TIMER_MEM_WRITEL_STATUS_START) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 11 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:slavio_timer_mem_writel_status_start " "processor %d user timer started" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , timer_index);
#line 500 "trace/trace-hw_timer.h"
        } else {
#line 11 "../hw/timer/trace-events"
            qemu_log("slavio_timer_mem_writel_status_start " "processor %d user timer started" "\n", timer_index);
#line 504 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_slavio_timer_mem_writel_status_start(unsigned int timer_index)
{
    if (true) {
        _nocheck__trace_slavio_timer_mem_writel_status_start(timer_index);
    }
}

#define TRACE_SLAVIO_TIMER_MEM_WRITEL_STATUS_STOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SLAVIO_TIMER_MEM_WRITEL_STATUS_STOP) || \
    false)

static inline void _nocheck__trace_slavio_timer_mem_writel_status_stop(unsigned int timer_index)
{
    if (trace_event_get_state(TRACE_SLAVIO_TIMER_MEM_WRITEL_STATUS_STOP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 12 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:slavio_timer_mem_writel_status_stop " "processor %d user timer stopped" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , timer_index);
#line 531 "trace/trace-hw_timer.h"
        } else {
#line 12 "../hw/timer/trace-events"
            qemu_log("slavio_timer_mem_writel_status_stop " "processor %d user timer stopped" "\n", timer_index);
#line 535 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_slavio_timer_mem_writel_status_stop(unsigned int timer_index)
{
    if (true) {
        _nocheck__trace_slavio_timer_mem_writel_status_stop(timer_index);
    }
}

#define TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_USER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_USER) || \
    false)

static inline void _nocheck__trace_slavio_timer_mem_writel_mode_user(unsigned int timer_index)
{
    if (trace_event_get_state(TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_USER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 13 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:slavio_timer_mem_writel_mode_user " "processor %d changed from counter to user timer" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , timer_index);
#line 562 "trace/trace-hw_timer.h"
        } else {
#line 13 "../hw/timer/trace-events"
            qemu_log("slavio_timer_mem_writel_mode_user " "processor %d changed from counter to user timer" "\n", timer_index);
#line 566 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_slavio_timer_mem_writel_mode_user(unsigned int timer_index)
{
    if (true) {
        _nocheck__trace_slavio_timer_mem_writel_mode_user(timer_index);
    }
}

#define TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_COUNTER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_COUNTER) || \
    false)

static inline void _nocheck__trace_slavio_timer_mem_writel_mode_counter(unsigned int timer_index)
{
    if (trace_event_get_state(TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_COUNTER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 14 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:slavio_timer_mem_writel_mode_counter " "processor %d changed from user timer to counter" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , timer_index);
#line 593 "trace/trace-hw_timer.h"
        } else {
#line 14 "../hw/timer/trace-events"
            qemu_log("slavio_timer_mem_writel_mode_counter " "processor %d changed from user timer to counter" "\n", timer_index);
#line 597 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_slavio_timer_mem_writel_mode_counter(unsigned int timer_index)
{
    if (true) {
        _nocheck__trace_slavio_timer_mem_writel_mode_counter(timer_index);
    }
}

#define TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_INVALID) || \
    false)

static inline void _nocheck__trace_slavio_timer_mem_writel_mode_invalid(void)
{
    if (trace_event_get_state(TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_INVALID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 15 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:slavio_timer_mem_writel_mode_invalid " "not system timer" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 624 "trace/trace-hw_timer.h"
        } else {
#line 15 "../hw/timer/trace-events"
            qemu_log("slavio_timer_mem_writel_mode_invalid " "not system timer" "\n");
#line 628 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_slavio_timer_mem_writel_mode_invalid(void)
{
    if (true) {
        _nocheck__trace_slavio_timer_mem_writel_mode_invalid();
    }
}

#define TRACE_SLAVIO_TIMER_MEM_WRITEL_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SLAVIO_TIMER_MEM_WRITEL_INVALID) || \
    false)

static inline void _nocheck__trace_slavio_timer_mem_writel_invalid(uint64_t addr)
{
    if (trace_event_get_state(TRACE_SLAVIO_TIMER_MEM_WRITEL_INVALID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 16 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:slavio_timer_mem_writel_invalid " "invalid write address 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 655 "trace/trace-hw_timer.h"
        } else {
#line 16 "../hw/timer/trace-events"
            qemu_log("slavio_timer_mem_writel_invalid " "invalid write address 0x%"PRIx64 "\n", addr);
#line 659 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_slavio_timer_mem_writel_invalid(uint64_t addr)
{
    if (true) {
        _nocheck__trace_slavio_timer_mem_writel_invalid(addr);
    }
}

#define TRACE_GRLIB_GPTIMER_ENABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GRLIB_GPTIMER_ENABLE) || \
    false)

static inline void _nocheck__trace_grlib_gptimer_enable(int id, uint32_t count)
{
    if (trace_event_get_state(TRACE_GRLIB_GPTIMER_ENABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 19 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:grlib_gptimer_enable " "timer:%d set count 0x%x and run" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, count);
#line 686 "trace/trace-hw_timer.h"
        } else {
#line 19 "../hw/timer/trace-events"
            qemu_log("grlib_gptimer_enable " "timer:%d set count 0x%x and run" "\n", id, count);
#line 690 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_grlib_gptimer_enable(int id, uint32_t count)
{
    if (true) {
        _nocheck__trace_grlib_gptimer_enable(id, count);
    }
}

#define TRACE_GRLIB_GPTIMER_DISABLED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GRLIB_GPTIMER_DISABLED) || \
    false)

static inline void _nocheck__trace_grlib_gptimer_disabled(int id, uint32_t config)
{
    if (trace_event_get_state(TRACE_GRLIB_GPTIMER_DISABLED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 20 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:grlib_gptimer_disabled " "timer:%d Timer disable config 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, config);
#line 717 "trace/trace-hw_timer.h"
        } else {
#line 20 "../hw/timer/trace-events"
            qemu_log("grlib_gptimer_disabled " "timer:%d Timer disable config 0x%x" "\n", id, config);
#line 721 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_grlib_gptimer_disabled(int id, uint32_t config)
{
    if (true) {
        _nocheck__trace_grlib_gptimer_disabled(id, config);
    }
}

#define TRACE_GRLIB_GPTIMER_RESTART_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GRLIB_GPTIMER_RESTART) || \
    false)

static inline void _nocheck__trace_grlib_gptimer_restart(int id, uint32_t reload)
{
    if (trace_event_get_state(TRACE_GRLIB_GPTIMER_RESTART) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 21 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:grlib_gptimer_restart " "timer:%d reload val: 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, reload);
#line 748 "trace/trace-hw_timer.h"
        } else {
#line 21 "../hw/timer/trace-events"
            qemu_log("grlib_gptimer_restart " "timer:%d reload val: 0x%x" "\n", id, reload);
#line 752 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_grlib_gptimer_restart(int id, uint32_t reload)
{
    if (true) {
        _nocheck__trace_grlib_gptimer_restart(id, reload);
    }
}

#define TRACE_GRLIB_GPTIMER_SET_SCALER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GRLIB_GPTIMER_SET_SCALER) || \
    false)

static inline void _nocheck__trace_grlib_gptimer_set_scaler(uint32_t scaler, uint32_t freq)
{
    if (trace_event_get_state(TRACE_GRLIB_GPTIMER_SET_SCALER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 22 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:grlib_gptimer_set_scaler " "scaler:0x%x freq:%uHz" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , scaler, freq);
#line 779 "trace/trace-hw_timer.h"
        } else {
#line 22 "../hw/timer/trace-events"
            qemu_log("grlib_gptimer_set_scaler " "scaler:0x%x freq:%uHz" "\n", scaler, freq);
#line 783 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_grlib_gptimer_set_scaler(uint32_t scaler, uint32_t freq)
{
    if (true) {
        _nocheck__trace_grlib_gptimer_set_scaler(scaler, freq);
    }
}

#define TRACE_GRLIB_GPTIMER_HIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GRLIB_GPTIMER_HIT) || \
    false)

static inline void _nocheck__trace_grlib_gptimer_hit(int id)
{
    if (trace_event_get_state(TRACE_GRLIB_GPTIMER_HIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 23 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:grlib_gptimer_hit " "timer:%d HIT" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id);
#line 810 "trace/trace-hw_timer.h"
        } else {
#line 23 "../hw/timer/trace-events"
            qemu_log("grlib_gptimer_hit " "timer:%d HIT" "\n", id);
#line 814 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_grlib_gptimer_hit(int id)
{
    if (true) {
        _nocheck__trace_grlib_gptimer_hit(id);
    }
}

#define TRACE_GRLIB_GPTIMER_READL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GRLIB_GPTIMER_READL) || \
    false)

static inline void _nocheck__trace_grlib_gptimer_readl(int id, uint64_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_GRLIB_GPTIMER_READL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 24 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:grlib_gptimer_readl " "timer:%d addr 0x%"PRIx64" 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, addr, val);
#line 841 "trace/trace-hw_timer.h"
        } else {
#line 24 "../hw/timer/trace-events"
            qemu_log("grlib_gptimer_readl " "timer:%d addr 0x%"PRIx64" 0x%x" "\n", id, addr, val);
#line 845 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_grlib_gptimer_readl(int id, uint64_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_grlib_gptimer_readl(id, addr, val);
    }
}

#define TRACE_GRLIB_GPTIMER_WRITEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GRLIB_GPTIMER_WRITEL) || \
    false)

static inline void _nocheck__trace_grlib_gptimer_writel(int id, uint64_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_GRLIB_GPTIMER_WRITEL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 25 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:grlib_gptimer_writel " "timer:%d addr 0x%"PRIx64" 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, addr, val);
#line 872 "trace/trace-hw_timer.h"
        } else {
#line 25 "../hw/timer/trace-events"
            qemu_log("grlib_gptimer_writel " "timer:%d addr 0x%"PRIx64" 0x%x" "\n", id, addr, val);
#line 876 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_grlib_gptimer_writel(int id, uint64_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_grlib_gptimer_writel(id, addr, val);
    }
}

#define TRACE_ASPEED_TIMER_CTRL_ENABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ASPEED_TIMER_CTRL_ENABLE) || \
    false)

static inline void _nocheck__trace_aspeed_timer_ctrl_enable(uint8_t i, bool enable)
{
    if (trace_event_get_state(TRACE_ASPEED_TIMER_CTRL_ENABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 28 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:aspeed_timer_ctrl_enable " "Timer %" PRIu8 ": %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , i, enable);
#line 903 "trace/trace-hw_timer.h"
        } else {
#line 28 "../hw/timer/trace-events"
            qemu_log("aspeed_timer_ctrl_enable " "Timer %" PRIu8 ": %d" "\n", i, enable);
#line 907 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_aspeed_timer_ctrl_enable(uint8_t i, bool enable)
{
    if (true) {
        _nocheck__trace_aspeed_timer_ctrl_enable(i, enable);
    }
}

#define TRACE_ASPEED_TIMER_CTRL_EXTERNAL_CLOCK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ASPEED_TIMER_CTRL_EXTERNAL_CLOCK) || \
    false)

static inline void _nocheck__trace_aspeed_timer_ctrl_external_clock(uint8_t i, bool enable)
{
    if (trace_event_get_state(TRACE_ASPEED_TIMER_CTRL_EXTERNAL_CLOCK) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 29 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:aspeed_timer_ctrl_external_clock " "Timer %" PRIu8 ": %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , i, enable);
#line 934 "trace/trace-hw_timer.h"
        } else {
#line 29 "../hw/timer/trace-events"
            qemu_log("aspeed_timer_ctrl_external_clock " "Timer %" PRIu8 ": %d" "\n", i, enable);
#line 938 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_aspeed_timer_ctrl_external_clock(uint8_t i, bool enable)
{
    if (true) {
        _nocheck__trace_aspeed_timer_ctrl_external_clock(i, enable);
    }
}

#define TRACE_ASPEED_TIMER_CTRL_OVERFLOW_INTERRUPT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ASPEED_TIMER_CTRL_OVERFLOW_INTERRUPT) || \
    false)

static inline void _nocheck__trace_aspeed_timer_ctrl_overflow_interrupt(uint8_t i, bool enable)
{
    if (trace_event_get_state(TRACE_ASPEED_TIMER_CTRL_OVERFLOW_INTERRUPT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 30 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:aspeed_timer_ctrl_overflow_interrupt " "Timer %" PRIu8 ": %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , i, enable);
#line 965 "trace/trace-hw_timer.h"
        } else {
#line 30 "../hw/timer/trace-events"
            qemu_log("aspeed_timer_ctrl_overflow_interrupt " "Timer %" PRIu8 ": %d" "\n", i, enable);
#line 969 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_aspeed_timer_ctrl_overflow_interrupt(uint8_t i, bool enable)
{
    if (true) {
        _nocheck__trace_aspeed_timer_ctrl_overflow_interrupt(i, enable);
    }
}

#define TRACE_ASPEED_TIMER_CTRL_PULSE_ENABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ASPEED_TIMER_CTRL_PULSE_ENABLE) || \
    false)

static inline void _nocheck__trace_aspeed_timer_ctrl_pulse_enable(uint8_t i, bool enable)
{
    if (trace_event_get_state(TRACE_ASPEED_TIMER_CTRL_PULSE_ENABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 31 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:aspeed_timer_ctrl_pulse_enable " "Timer %" PRIu8 ": %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , i, enable);
#line 996 "trace/trace-hw_timer.h"
        } else {
#line 31 "../hw/timer/trace-events"
            qemu_log("aspeed_timer_ctrl_pulse_enable " "Timer %" PRIu8 ": %d" "\n", i, enable);
#line 1000 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_aspeed_timer_ctrl_pulse_enable(uint8_t i, bool enable)
{
    if (true) {
        _nocheck__trace_aspeed_timer_ctrl_pulse_enable(i, enable);
    }
}

#define TRACE_ASPEED_TIMER_SET_CTRL2_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ASPEED_TIMER_SET_CTRL2) || \
    false)

static inline void _nocheck__trace_aspeed_timer_set_ctrl2(uint32_t value)
{
    if (trace_event_get_state(TRACE_ASPEED_TIMER_SET_CTRL2) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 32 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:aspeed_timer_set_ctrl2 " "Value: 0x%" PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , value);
#line 1027 "trace/trace-hw_timer.h"
        } else {
#line 32 "../hw/timer/trace-events"
            qemu_log("aspeed_timer_set_ctrl2 " "Value: 0x%" PRIx32 "\n", value);
#line 1031 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_aspeed_timer_set_ctrl2(uint32_t value)
{
    if (true) {
        _nocheck__trace_aspeed_timer_set_ctrl2(value);
    }
}

#define TRACE_ASPEED_TIMER_SET_VALUE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ASPEED_TIMER_SET_VALUE) || \
    false)

static inline void _nocheck__trace_aspeed_timer_set_value(int timer, int reg, uint32_t value)
{
    if (trace_event_get_state(TRACE_ASPEED_TIMER_SET_VALUE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 33 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:aspeed_timer_set_value " "Timer %d register %d: 0x%" PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , timer, reg, value);
#line 1058 "trace/trace-hw_timer.h"
        } else {
#line 33 "../hw/timer/trace-events"
            qemu_log("aspeed_timer_set_value " "Timer %d register %d: 0x%" PRIx32 "\n", timer, reg, value);
#line 1062 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_aspeed_timer_set_value(int timer, int reg, uint32_t value)
{
    if (true) {
        _nocheck__trace_aspeed_timer_set_value(timer, reg, value);
    }
}

#define TRACE_ASPEED_TIMER_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ASPEED_TIMER_READ) || \
    false)

static inline void _nocheck__trace_aspeed_timer_read(uint64_t offset, unsigned size, uint64_t value)
{
    if (trace_event_get_state(TRACE_ASPEED_TIMER_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 34 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:aspeed_timer_read " "From 0x%" PRIx64 ": of size %u: 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, size, value);
#line 1089 "trace/trace-hw_timer.h"
        } else {
#line 34 "../hw/timer/trace-events"
            qemu_log("aspeed_timer_read " "From 0x%" PRIx64 ": of size %u: 0x%" PRIx64 "\n", offset, size, value);
#line 1093 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_aspeed_timer_read(uint64_t offset, unsigned size, uint64_t value)
{
    if (true) {
        _nocheck__trace_aspeed_timer_read(offset, size, value);
    }
}

#define TRACE_SYSTICK_RELOAD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SYSTICK_RELOAD) || \
    false)

static inline void _nocheck__trace_systick_reload(void)
{
    if (trace_event_get_state(TRACE_SYSTICK_RELOAD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 37 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:systick_reload " "systick reload" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1120 "trace/trace-hw_timer.h"
        } else {
#line 37 "../hw/timer/trace-events"
            qemu_log("systick_reload " "systick reload" "\n");
#line 1124 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_systick_reload(void)
{
    if (true) {
        _nocheck__trace_systick_reload();
    }
}

#define TRACE_SYSTICK_TIMER_TICK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SYSTICK_TIMER_TICK) || \
    false)

static inline void _nocheck__trace_systick_timer_tick(void)
{
    if (trace_event_get_state(TRACE_SYSTICK_TIMER_TICK) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 38 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:systick_timer_tick " "systick tick" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1151 "trace/trace-hw_timer.h"
        } else {
#line 38 "../hw/timer/trace-events"
            qemu_log("systick_timer_tick " "systick tick" "\n");
#line 1155 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_systick_timer_tick(void)
{
    if (true) {
        _nocheck__trace_systick_timer_tick();
    }
}

#define TRACE_SYSTICK_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SYSTICK_READ) || \
    false)

static inline void _nocheck__trace_systick_read(uint64_t addr, uint32_t value, unsigned size)
{
    if (trace_event_get_state(TRACE_SYSTICK_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 39 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:systick_read " "systick read addr 0x%" PRIx64 " data 0x%" PRIx32 " size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value, size);
#line 1182 "trace/trace-hw_timer.h"
        } else {
#line 39 "../hw/timer/trace-events"
            qemu_log("systick_read " "systick read addr 0x%" PRIx64 " data 0x%" PRIx32 " size %u" "\n", addr, value, size);
#line 1186 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_systick_read(uint64_t addr, uint32_t value, unsigned size)
{
    if (true) {
        _nocheck__trace_systick_read(addr, value, size);
    }
}

#define TRACE_SYSTICK_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SYSTICK_WRITE) || \
    false)

static inline void _nocheck__trace_systick_write(uint64_t addr, uint32_t value, unsigned size)
{
    if (trace_event_get_state(TRACE_SYSTICK_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 40 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:systick_write " "systick write addr 0x%" PRIx64 " data 0x%" PRIx32 " size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value, size);
#line 1213 "trace/trace-hw_timer.h"
        } else {
#line 40 "../hw/timer/trace-events"
            qemu_log("systick_write " "systick write addr 0x%" PRIx64 " data 0x%" PRIx32 " size %u" "\n", addr, value, size);
#line 1217 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_systick_write(uint64_t addr, uint32_t value, unsigned size)
{
    if (true) {
        _nocheck__trace_systick_write(addr, value, size);
    }
}

#define TRACE_CMSDK_APB_TIMER_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_TIMER_READ) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_timer_read(uint64_t offset, uint64_t data, unsigned size)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_TIMER_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 43 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:cmsdk_apb_timer_read " "CMSDK APB timer read: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, data, size);
#line 1244 "trace/trace-hw_timer.h"
        } else {
#line 43 "../hw/timer/trace-events"
            qemu_log("cmsdk_apb_timer_read " "CMSDK APB timer read: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n", offset, data, size);
#line 1248 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_cmsdk_apb_timer_read(uint64_t offset, uint64_t data, unsigned size)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_timer_read(offset, data, size);
    }
}

#define TRACE_CMSDK_APB_TIMER_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_TIMER_WRITE) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_timer_write(uint64_t offset, uint64_t data, unsigned size)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_TIMER_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 44 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:cmsdk_apb_timer_write " "CMSDK APB timer write: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, data, size);
#line 1275 "trace/trace-hw_timer.h"
        } else {
#line 44 "../hw/timer/trace-events"
            qemu_log("cmsdk_apb_timer_write " "CMSDK APB timer write: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n", offset, data, size);
#line 1279 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_cmsdk_apb_timer_write(uint64_t offset, uint64_t data, unsigned size)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_timer_write(offset, data, size);
    }
}

#define TRACE_CMSDK_APB_TIMER_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_TIMER_RESET) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_timer_reset(void)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_TIMER_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 45 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:cmsdk_apb_timer_reset " "CMSDK APB timer: reset" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1306 "trace/trace-hw_timer.h"
        } else {
#line 45 "../hw/timer/trace-events"
            qemu_log("cmsdk_apb_timer_reset " "CMSDK APB timer: reset" "\n");
#line 1310 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_cmsdk_apb_timer_reset(void)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_timer_reset();
    }
}

#define TRACE_CMSDK_APB_DUALTIMER_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_DUALTIMER_READ) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_dualtimer_read(uint64_t offset, uint64_t data, unsigned size)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_DUALTIMER_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 48 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:cmsdk_apb_dualtimer_read " "CMSDK APB dualtimer read: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, data, size);
#line 1337 "trace/trace-hw_timer.h"
        } else {
#line 48 "../hw/timer/trace-events"
            qemu_log("cmsdk_apb_dualtimer_read " "CMSDK APB dualtimer read: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n", offset, data, size);
#line 1341 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_cmsdk_apb_dualtimer_read(uint64_t offset, uint64_t data, unsigned size)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_dualtimer_read(offset, data, size);
    }
}

#define TRACE_CMSDK_APB_DUALTIMER_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_DUALTIMER_WRITE) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_dualtimer_write(uint64_t offset, uint64_t data, unsigned size)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_DUALTIMER_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 49 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:cmsdk_apb_dualtimer_write " "CMSDK APB dualtimer write: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, data, size);
#line 1368 "trace/trace-hw_timer.h"
        } else {
#line 49 "../hw/timer/trace-events"
            qemu_log("cmsdk_apb_dualtimer_write " "CMSDK APB dualtimer write: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n", offset, data, size);
#line 1372 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_cmsdk_apb_dualtimer_write(uint64_t offset, uint64_t data, unsigned size)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_dualtimer_write(offset, data, size);
    }
}

#define TRACE_CMSDK_APB_DUALTIMER_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_DUALTIMER_RESET) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_dualtimer_reset(void)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_DUALTIMER_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 50 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:cmsdk_apb_dualtimer_reset " "CMSDK APB dualtimer: reset" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1399 "trace/trace-hw_timer.h"
        } else {
#line 50 "../hw/timer/trace-events"
            qemu_log("cmsdk_apb_dualtimer_reset " "CMSDK APB dualtimer: reset" "\n");
#line 1403 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_cmsdk_apb_dualtimer_reset(void)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_dualtimer_reset();
    }
}

#define TRACE_NPCM7XX_TIMER_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NPCM7XX_TIMER_READ) || \
    false)

static inline void _nocheck__trace_npcm7xx_timer_read(const char * id, uint64_t offset, uint64_t value)
{
    if (trace_event_get_state(TRACE_NPCM7XX_TIMER_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 53 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:npcm7xx_timer_read " " %s offset: 0x%04" PRIx64 " value 0x%08" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, offset, value);
#line 1430 "trace/trace-hw_timer.h"
        } else {
#line 53 "../hw/timer/trace-events"
            qemu_log("npcm7xx_timer_read " " %s offset: 0x%04" PRIx64 " value 0x%08" PRIx64 "\n", id, offset, value);
#line 1434 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_npcm7xx_timer_read(const char * id, uint64_t offset, uint64_t value)
{
    if (true) {
        _nocheck__trace_npcm7xx_timer_read(id, offset, value);
    }
}

#define TRACE_NPCM7XX_TIMER_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NPCM7XX_TIMER_WRITE) || \
    false)

static inline void _nocheck__trace_npcm7xx_timer_write(const char * id, uint64_t offset, uint64_t value)
{
    if (trace_event_get_state(TRACE_NPCM7XX_TIMER_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 54 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:npcm7xx_timer_write " "%s offset: 0x%04" PRIx64 " value 0x%08" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, offset, value);
#line 1461 "trace/trace-hw_timer.h"
        } else {
#line 54 "../hw/timer/trace-events"
            qemu_log("npcm7xx_timer_write " "%s offset: 0x%04" PRIx64 " value 0x%08" PRIx64 "\n", id, offset, value);
#line 1465 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_npcm7xx_timer_write(const char * id, uint64_t offset, uint64_t value)
{
    if (true) {
        _nocheck__trace_npcm7xx_timer_write(id, offset, value);
    }
}

#define TRACE_NPCM7XX_TIMER_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NPCM7XX_TIMER_IRQ) || \
    false)

static inline void _nocheck__trace_npcm7xx_timer_irq(const char * id, int timer, int state)
{
    if (trace_event_get_state(TRACE_NPCM7XX_TIMER_IRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 55 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:npcm7xx_timer_irq " "%s timer %d state %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, timer, state);
#line 1492 "trace/trace-hw_timer.h"
        } else {
#line 55 "../hw/timer/trace-events"
            qemu_log("npcm7xx_timer_irq " "%s timer %d state %d" "\n", id, timer, state);
#line 1496 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_npcm7xx_timer_irq(const char * id, int timer, int state)
{
    if (true) {
        _nocheck__trace_npcm7xx_timer_irq(id, timer, state);
    }
}

#define TRACE_NRF51_TIMER_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NRF51_TIMER_READ) || \
    false)

static inline void _nocheck__trace_nrf51_timer_read(uint8_t timer_id, uint64_t addr, uint32_t value, unsigned size)
{
    if (trace_event_get_state(TRACE_NRF51_TIMER_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 58 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:nrf51_timer_read " "timer %u read addr 0x%" PRIx64 " data 0x%" PRIx32 " size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , timer_id, addr, value, size);
#line 1523 "trace/trace-hw_timer.h"
        } else {
#line 58 "../hw/timer/trace-events"
            qemu_log("nrf51_timer_read " "timer %u read addr 0x%" PRIx64 " data 0x%" PRIx32 " size %u" "\n", timer_id, addr, value, size);
#line 1527 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_nrf51_timer_read(uint8_t timer_id, uint64_t addr, uint32_t value, unsigned size)
{
    if (true) {
        _nocheck__trace_nrf51_timer_read(timer_id, addr, value, size);
    }
}

#define TRACE_NRF51_TIMER_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NRF51_TIMER_WRITE) || \
    false)

static inline void _nocheck__trace_nrf51_timer_write(uint8_t timer_id, uint64_t addr, uint32_t value, unsigned size)
{
    if (trace_event_get_state(TRACE_NRF51_TIMER_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 59 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:nrf51_timer_write " "timer %u write addr 0x%" PRIx64 " data 0x%" PRIx32 " size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , timer_id, addr, value, size);
#line 1554 "trace/trace-hw_timer.h"
        } else {
#line 59 "../hw/timer/trace-events"
            qemu_log("nrf51_timer_write " "timer %u write addr 0x%" PRIx64 " data 0x%" PRIx32 " size %u" "\n", timer_id, addr, value, size);
#line 1558 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_nrf51_timer_write(uint8_t timer_id, uint64_t addr, uint32_t value, unsigned size)
{
    if (true) {
        _nocheck__trace_nrf51_timer_write(timer_id, addr, value, size);
    }
}

#define TRACE_NRF51_TIMER_SET_COUNT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NRF51_TIMER_SET_COUNT) || \
    false)

static inline void _nocheck__trace_nrf51_timer_set_count(uint8_t timer_id, uint8_t counter_id, uint32_t value)
{
    if (trace_event_get_state(TRACE_NRF51_TIMER_SET_COUNT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 60 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:nrf51_timer_set_count " "timer %u counter %u count 0x%" PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , timer_id, counter_id, value);
#line 1585 "trace/trace-hw_timer.h"
        } else {
#line 60 "../hw/timer/trace-events"
            qemu_log("nrf51_timer_set_count " "timer %u counter %u count 0x%" PRIx32 "\n", timer_id, counter_id, value);
#line 1589 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_nrf51_timer_set_count(uint8_t timer_id, uint8_t counter_id, uint32_t value)
{
    if (true) {
        _nocheck__trace_nrf51_timer_set_count(timer_id, counter_id, value);
    }
}

#define TRACE_BCM2835_SYSTMR_TIMER_EXPIRED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BCM2835_SYSTMR_TIMER_EXPIRED) || \
    false)

static inline void _nocheck__trace_bcm2835_systmr_timer_expired(unsigned id)
{
    if (trace_event_get_state(TRACE_BCM2835_SYSTMR_TIMER_EXPIRED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 63 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:bcm2835_systmr_timer_expired " "timer #%u expired" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id);
#line 1616 "trace/trace-hw_timer.h"
        } else {
#line 63 "../hw/timer/trace-events"
            qemu_log("bcm2835_systmr_timer_expired " "timer #%u expired" "\n", id);
#line 1620 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_bcm2835_systmr_timer_expired(unsigned id)
{
    if (true) {
        _nocheck__trace_bcm2835_systmr_timer_expired(id);
    }
}

#define TRACE_BCM2835_SYSTMR_IRQ_ACK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BCM2835_SYSTMR_IRQ_ACK) || \
    false)

static inline void _nocheck__trace_bcm2835_systmr_irq_ack(unsigned id)
{
    if (trace_event_get_state(TRACE_BCM2835_SYSTMR_IRQ_ACK) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 64 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:bcm2835_systmr_irq_ack " "timer #%u acked" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id);
#line 1647 "trace/trace-hw_timer.h"
        } else {
#line 64 "../hw/timer/trace-events"
            qemu_log("bcm2835_systmr_irq_ack " "timer #%u acked" "\n", id);
#line 1651 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_bcm2835_systmr_irq_ack(unsigned id)
{
    if (true) {
        _nocheck__trace_bcm2835_systmr_irq_ack(id);
    }
}

#define TRACE_BCM2835_SYSTMR_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BCM2835_SYSTMR_READ) || \
    false)

static inline void _nocheck__trace_bcm2835_systmr_read(uint64_t offset, uint64_t data)
{
    if (trace_event_get_state(TRACE_BCM2835_SYSTMR_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 65 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:bcm2835_systmr_read " "timer read: offset 0x%" PRIx64 " data 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, data);
#line 1678 "trace/trace-hw_timer.h"
        } else {
#line 65 "../hw/timer/trace-events"
            qemu_log("bcm2835_systmr_read " "timer read: offset 0x%" PRIx64 " data 0x%" PRIx64 "\n", offset, data);
#line 1682 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_bcm2835_systmr_read(uint64_t offset, uint64_t data)
{
    if (true) {
        _nocheck__trace_bcm2835_systmr_read(offset, data);
    }
}

#define TRACE_BCM2835_SYSTMR_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BCM2835_SYSTMR_WRITE) || \
    false)

static inline void _nocheck__trace_bcm2835_systmr_write(uint64_t offset, uint32_t data)
{
    if (trace_event_get_state(TRACE_BCM2835_SYSTMR_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 66 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:bcm2835_systmr_write " "timer write: offset 0x%" PRIx64 " data 0x%" PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, data);
#line 1709 "trace/trace-hw_timer.h"
        } else {
#line 66 "../hw/timer/trace-events"
            qemu_log("bcm2835_systmr_write " "timer write: offset 0x%" PRIx64 " data 0x%" PRIx32 "\n", offset, data);
#line 1713 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_bcm2835_systmr_write(uint64_t offset, uint32_t data)
{
    if (true) {
        _nocheck__trace_bcm2835_systmr_write(offset, data);
    }
}

#define TRACE_BCM2835_SYSTMR_RUN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BCM2835_SYSTMR_RUN) || \
    false)

static inline void _nocheck__trace_bcm2835_systmr_run(unsigned id, uint64_t delay_us)
{
    if (trace_event_get_state(TRACE_BCM2835_SYSTMR_RUN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 67 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:bcm2835_systmr_run " "timer #%u expiring in %"PRIu64" us" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, delay_us);
#line 1740 "trace/trace-hw_timer.h"
        } else {
#line 67 "../hw/timer/trace-events"
            qemu_log("bcm2835_systmr_run " "timer #%u expiring in %"PRIu64" us" "\n", id, delay_us);
#line 1744 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_bcm2835_systmr_run(unsigned id, uint64_t delay_us)
{
    if (true) {
        _nocheck__trace_bcm2835_systmr_run(id, delay_us);
    }
}

#define TRACE_AVR_TIMER16_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AVR_TIMER16_READ) || \
    false)

static inline void _nocheck__trace_avr_timer16_read(uint8_t addr, uint8_t value)
{
    if (trace_event_get_state(TRACE_AVR_TIMER16_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 70 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:avr_timer16_read " "timer16 read addr:%u value:%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value);
#line 1771 "trace/trace-hw_timer.h"
        } else {
#line 70 "../hw/timer/trace-events"
            qemu_log("avr_timer16_read " "timer16 read addr:%u value:%u" "\n", addr, value);
#line 1775 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_avr_timer16_read(uint8_t addr, uint8_t value)
{
    if (true) {
        _nocheck__trace_avr_timer16_read(addr, value);
    }
}

#define TRACE_AVR_TIMER16_READ_IFR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AVR_TIMER16_READ_IFR) || \
    false)

static inline void _nocheck__trace_avr_timer16_read_ifr(uint8_t value)
{
    if (trace_event_get_state(TRACE_AVR_TIMER16_READ_IFR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 71 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:avr_timer16_read_ifr " "timer16 read addr:ifr value:%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , value);
#line 1802 "trace/trace-hw_timer.h"
        } else {
#line 71 "../hw/timer/trace-events"
            qemu_log("avr_timer16_read_ifr " "timer16 read addr:ifr value:%u" "\n", value);
#line 1806 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_avr_timer16_read_ifr(uint8_t value)
{
    if (true) {
        _nocheck__trace_avr_timer16_read_ifr(value);
    }
}

#define TRACE_AVR_TIMER16_READ_IMSK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AVR_TIMER16_READ_IMSK) || \
    false)

static inline void _nocheck__trace_avr_timer16_read_imsk(uint8_t value)
{
    if (trace_event_get_state(TRACE_AVR_TIMER16_READ_IMSK) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 72 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:avr_timer16_read_imsk " "timer16 read addr:imsk value:%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , value);
#line 1833 "trace/trace-hw_timer.h"
        } else {
#line 72 "../hw/timer/trace-events"
            qemu_log("avr_timer16_read_imsk " "timer16 read addr:imsk value:%u" "\n", value);
#line 1837 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_avr_timer16_read_imsk(uint8_t value)
{
    if (true) {
        _nocheck__trace_avr_timer16_read_imsk(value);
    }
}

#define TRACE_AVR_TIMER16_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AVR_TIMER16_WRITE) || \
    false)

static inline void _nocheck__trace_avr_timer16_write(uint8_t addr, uint8_t value)
{
    if (trace_event_get_state(TRACE_AVR_TIMER16_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 73 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:avr_timer16_write " "timer16 write addr:%u value:%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value);
#line 1864 "trace/trace-hw_timer.h"
        } else {
#line 73 "../hw/timer/trace-events"
            qemu_log("avr_timer16_write " "timer16 write addr:%u value:%u" "\n", addr, value);
#line 1868 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_avr_timer16_write(uint8_t addr, uint8_t value)
{
    if (true) {
        _nocheck__trace_avr_timer16_write(addr, value);
    }
}

#define TRACE_AVR_TIMER16_WRITE_IMSK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AVR_TIMER16_WRITE_IMSK) || \
    false)

static inline void _nocheck__trace_avr_timer16_write_imsk(uint8_t value)
{
    if (trace_event_get_state(TRACE_AVR_TIMER16_WRITE_IMSK) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 74 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:avr_timer16_write_imsk " "timer16 write addr:imsk value:%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , value);
#line 1895 "trace/trace-hw_timer.h"
        } else {
#line 74 "../hw/timer/trace-events"
            qemu_log("avr_timer16_write_imsk " "timer16 write addr:imsk value:%u" "\n", value);
#line 1899 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_avr_timer16_write_imsk(uint8_t value)
{
    if (true) {
        _nocheck__trace_avr_timer16_write_imsk(value);
    }
}

#define TRACE_AVR_TIMER16_INTERRUPT_COUNT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AVR_TIMER16_INTERRUPT_COUNT) || \
    false)

static inline void _nocheck__trace_avr_timer16_interrupt_count(uint8_t cnt)
{
    if (trace_event_get_state(TRACE_AVR_TIMER16_INTERRUPT_COUNT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 75 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:avr_timer16_interrupt_count " "count: %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cnt);
#line 1926 "trace/trace-hw_timer.h"
        } else {
#line 75 "../hw/timer/trace-events"
            qemu_log("avr_timer16_interrupt_count " "count: %u" "\n", cnt);
#line 1930 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_avr_timer16_interrupt_count(uint8_t cnt)
{
    if (true) {
        _nocheck__trace_avr_timer16_interrupt_count(cnt);
    }
}

#define TRACE_AVR_TIMER16_INTERRUPT_OVERFLOW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AVR_TIMER16_INTERRUPT_OVERFLOW) || \
    false)

static inline void _nocheck__trace_avr_timer16_interrupt_overflow(const char * reason)
{
    if (trace_event_get_state(TRACE_AVR_TIMER16_INTERRUPT_OVERFLOW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 76 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:avr_timer16_interrupt_overflow " "overflow: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reason);
#line 1957 "trace/trace-hw_timer.h"
        } else {
#line 76 "../hw/timer/trace-events"
            qemu_log("avr_timer16_interrupt_overflow " "overflow: %s" "\n", reason);
#line 1961 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_avr_timer16_interrupt_overflow(const char * reason)
{
    if (true) {
        _nocheck__trace_avr_timer16_interrupt_overflow(reason);
    }
}

#define TRACE_AVR_TIMER16_NEXT_ALARM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AVR_TIMER16_NEXT_ALARM) || \
    false)

static inline void _nocheck__trace_avr_timer16_next_alarm(uint64_t delay_ns)
{
    if (trace_event_get_state(TRACE_AVR_TIMER16_NEXT_ALARM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 77 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:avr_timer16_next_alarm " "next alarm: %" PRIu64 " ns from now" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , delay_ns);
#line 1988 "trace/trace-hw_timer.h"
        } else {
#line 77 "../hw/timer/trace-events"
            qemu_log("avr_timer16_next_alarm " "next alarm: %" PRIu64 " ns from now" "\n", delay_ns);
#line 1992 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_avr_timer16_next_alarm(uint64_t delay_ns)
{
    if (true) {
        _nocheck__trace_avr_timer16_next_alarm(delay_ns);
    }
}

#define TRACE_AVR_TIMER16_CLKSRC_UPDATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AVR_TIMER16_CLKSRC_UPDATE) || \
    false)

static inline void _nocheck__trace_avr_timer16_clksrc_update(uint64_t freq_hz, uint64_t period_ns, uint64_t delay_s)
{
    if (trace_event_get_state(TRACE_AVR_TIMER16_CLKSRC_UPDATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 78 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:avr_timer16_clksrc_update " "timer frequency: %" PRIu64 " Hz, period: %" PRIu64 " ns (%" PRId64 " us)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , freq_hz, period_ns, delay_s);
#line 2019 "trace/trace-hw_timer.h"
        } else {
#line 78 "../hw/timer/trace-events"
            qemu_log("avr_timer16_clksrc_update " "timer frequency: %" PRIu64 " Hz, period: %" PRIu64 " ns (%" PRId64 " us)" "\n", freq_hz, period_ns, delay_s);
#line 2023 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_avr_timer16_clksrc_update(uint64_t freq_hz, uint64_t period_ns, uint64_t delay_s)
{
    if (true) {
        _nocheck__trace_avr_timer16_clksrc_update(freq_hz, period_ns, delay_s);
    }
}

#define TRACE_SSE_COUNTER_CONTROL_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SSE_COUNTER_CONTROL_READ) || \
    false)

static inline void _nocheck__trace_sse_counter_control_read(uint64_t offset, uint64_t data, unsigned size)
{
    if (trace_event_get_state(TRACE_SSE_COUNTER_CONTROL_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 81 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:sse_counter_control_read " "SSE system counter control frame read: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, data, size);
#line 2050 "trace/trace-hw_timer.h"
        } else {
#line 81 "../hw/timer/trace-events"
            qemu_log("sse_counter_control_read " "SSE system counter control frame read: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n", offset, data, size);
#line 2054 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_sse_counter_control_read(uint64_t offset, uint64_t data, unsigned size)
{
    if (true) {
        _nocheck__trace_sse_counter_control_read(offset, data, size);
    }
}

#define TRACE_SSE_COUNTER_CONTROL_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SSE_COUNTER_CONTROL_WRITE) || \
    false)

static inline void _nocheck__trace_sse_counter_control_write(uint64_t offset, uint64_t data, unsigned size)
{
    if (trace_event_get_state(TRACE_SSE_COUNTER_CONTROL_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 82 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:sse_counter_control_write " "SSE system counter control framen write: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, data, size);
#line 2081 "trace/trace-hw_timer.h"
        } else {
#line 82 "../hw/timer/trace-events"
            qemu_log("sse_counter_control_write " "SSE system counter control framen write: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n", offset, data, size);
#line 2085 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_sse_counter_control_write(uint64_t offset, uint64_t data, unsigned size)
{
    if (true) {
        _nocheck__trace_sse_counter_control_write(offset, data, size);
    }
}

#define TRACE_SSE_COUNTER_STATUS_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SSE_COUNTER_STATUS_READ) || \
    false)

static inline void _nocheck__trace_sse_counter_status_read(uint64_t offset, uint64_t data, unsigned size)
{
    if (trace_event_get_state(TRACE_SSE_COUNTER_STATUS_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 83 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:sse_counter_status_read " "SSE system counter status frame read: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, data, size);
#line 2112 "trace/trace-hw_timer.h"
        } else {
#line 83 "../hw/timer/trace-events"
            qemu_log("sse_counter_status_read " "SSE system counter status frame read: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n", offset, data, size);
#line 2116 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_sse_counter_status_read(uint64_t offset, uint64_t data, unsigned size)
{
    if (true) {
        _nocheck__trace_sse_counter_status_read(offset, data, size);
    }
}

#define TRACE_SSE_COUNTER_STATUS_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SSE_COUNTER_STATUS_WRITE) || \
    false)

static inline void _nocheck__trace_sse_counter_status_write(uint64_t offset, uint64_t data, unsigned size)
{
    if (trace_event_get_state(TRACE_SSE_COUNTER_STATUS_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 84 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:sse_counter_status_write " "SSE system counter status frame write: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, data, size);
#line 2143 "trace/trace-hw_timer.h"
        } else {
#line 84 "../hw/timer/trace-events"
            qemu_log("sse_counter_status_write " "SSE system counter status frame write: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n", offset, data, size);
#line 2147 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_sse_counter_status_write(uint64_t offset, uint64_t data, unsigned size)
{
    if (true) {
        _nocheck__trace_sse_counter_status_write(offset, data, size);
    }
}

#define TRACE_SSE_COUNTER_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SSE_COUNTER_RESET) || \
    false)

static inline void _nocheck__trace_sse_counter_reset(void)
{
    if (trace_event_get_state(TRACE_SSE_COUNTER_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 85 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:sse_counter_reset " "SSE system counter: reset" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2174 "trace/trace-hw_timer.h"
        } else {
#line 85 "../hw/timer/trace-events"
            qemu_log("sse_counter_reset " "SSE system counter: reset" "\n");
#line 2178 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_sse_counter_reset(void)
{
    if (true) {
        _nocheck__trace_sse_counter_reset();
    }
}

#define TRACE_SSE_TIMER_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SSE_TIMER_READ) || \
    false)

static inline void _nocheck__trace_sse_timer_read(uint64_t offset, uint64_t data, unsigned size)
{
    if (trace_event_get_state(TRACE_SSE_TIMER_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 88 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:sse_timer_read " "SSE system timer read: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, data, size);
#line 2205 "trace/trace-hw_timer.h"
        } else {
#line 88 "../hw/timer/trace-events"
            qemu_log("sse_timer_read " "SSE system timer read: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n", offset, data, size);
#line 2209 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_sse_timer_read(uint64_t offset, uint64_t data, unsigned size)
{
    if (true) {
        _nocheck__trace_sse_timer_read(offset, data, size);
    }
}

#define TRACE_SSE_TIMER_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SSE_TIMER_WRITE) || \
    false)

static inline void _nocheck__trace_sse_timer_write(uint64_t offset, uint64_t data, unsigned size)
{
    if (trace_event_get_state(TRACE_SSE_TIMER_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 89 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:sse_timer_write " "SSE system timer write: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, data, size);
#line 2236 "trace/trace-hw_timer.h"
        } else {
#line 89 "../hw/timer/trace-events"
            qemu_log("sse_timer_write " "SSE system timer write: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n", offset, data, size);
#line 2240 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_sse_timer_write(uint64_t offset, uint64_t data, unsigned size)
{
    if (true) {
        _nocheck__trace_sse_timer_write(offset, data, size);
    }
}

#define TRACE_SSE_TIMER_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SSE_TIMER_RESET) || \
    false)

static inline void _nocheck__trace_sse_timer_reset(void)
{
    if (trace_event_get_state(TRACE_SSE_TIMER_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 90 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:sse_timer_reset " "SSE system timer: reset" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2267 "trace/trace-hw_timer.h"
        } else {
#line 90 "../hw/timer/trace-events"
            qemu_log("sse_timer_reset " "SSE system timer: reset" "\n");
#line 2271 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_sse_timer_reset(void)
{
    if (true) {
        _nocheck__trace_sse_timer_reset();
    }
}

#define TRACE_SIFIVE_PWM_SET_ALARM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SIFIVE_PWM_SET_ALARM) || \
    false)

static inline void _nocheck__trace_sifive_pwm_set_alarm(uint64_t alarm, uint64_t now)
{
    if (trace_event_get_state(TRACE_SIFIVE_PWM_SET_ALARM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 93 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:sifive_pwm_set_alarm " "Setting alarm to: 0x%" PRIx64 ", now: 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , alarm, now);
#line 2298 "trace/trace-hw_timer.h"
        } else {
#line 93 "../hw/timer/trace-events"
            qemu_log("sifive_pwm_set_alarm " "Setting alarm to: 0x%" PRIx64 ", now: 0x%" PRIx64 "\n", alarm, now);
#line 2302 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_sifive_pwm_set_alarm(uint64_t alarm, uint64_t now)
{
    if (true) {
        _nocheck__trace_sifive_pwm_set_alarm(alarm, now);
    }
}

#define TRACE_SIFIVE_PWM_INTERRUPT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SIFIVE_PWM_INTERRUPT) || \
    false)

static inline void _nocheck__trace_sifive_pwm_interrupt(int num)
{
    if (trace_event_get_state(TRACE_SIFIVE_PWM_INTERRUPT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 94 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:sifive_pwm_interrupt " "Interrupt %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , num);
#line 2329 "trace/trace-hw_timer.h"
        } else {
#line 94 "../hw/timer/trace-events"
            qemu_log("sifive_pwm_interrupt " "Interrupt %d" "\n", num);
#line 2333 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_sifive_pwm_interrupt(int num)
{
    if (true) {
        _nocheck__trace_sifive_pwm_interrupt(num);
    }
}

#define TRACE_SIFIVE_PWM_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SIFIVE_PWM_READ) || \
    false)

static inline void _nocheck__trace_sifive_pwm_read(uint64_t offset)
{
    if (trace_event_get_state(TRACE_SIFIVE_PWM_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 95 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:sifive_pwm_read " "Read at address: 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset);
#line 2360 "trace/trace-hw_timer.h"
        } else {
#line 95 "../hw/timer/trace-events"
            qemu_log("sifive_pwm_read " "Read at address: 0x%" PRIx64 "\n", offset);
#line 2364 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_sifive_pwm_read(uint64_t offset)
{
    if (true) {
        _nocheck__trace_sifive_pwm_read(offset);
    }
}

#define TRACE_SIFIVE_PWM_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SIFIVE_PWM_WRITE) || \
    false)

static inline void _nocheck__trace_sifive_pwm_write(uint64_t data, uint64_t offset)
{
    if (trace_event_get_state(TRACE_SIFIVE_PWM_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 96 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:sifive_pwm_write " "Write 0x%" PRIx64 " at address: 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , data, offset);
#line 2391 "trace/trace-hw_timer.h"
        } else {
#line 96 "../hw/timer/trace-events"
            qemu_log("sifive_pwm_write " "Write 0x%" PRIx64 " at address: 0x%" PRIx64 "\n", data, offset);
#line 2395 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_sifive_pwm_write(uint64_t data, uint64_t offset)
{
    if (true) {
        _nocheck__trace_sifive_pwm_write(data, offset);
    }
}

#define TRACE_SH_TIMER_START_STOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SH_TIMER_START_STOP) || \
    false)

static inline void _nocheck__trace_sh_timer_start_stop(int enable, int current)
{
    if (trace_event_get_state(TRACE_SH_TIMER_START_STOP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 99 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:sh_timer_start_stop " "%d (%d)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , enable, current);
#line 2422 "trace/trace-hw_timer.h"
        } else {
#line 99 "../hw/timer/trace-events"
            qemu_log("sh_timer_start_stop " "%d (%d)" "\n", enable, current);
#line 2426 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_sh_timer_start_stop(int enable, int current)
{
    if (true) {
        _nocheck__trace_sh_timer_start_stop(enable, current);
    }
}

#define TRACE_SH_TIMER_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SH_TIMER_READ) || \
    false)

static inline void _nocheck__trace_sh_timer_read(uint64_t offset)
{
    if (trace_event_get_state(TRACE_SH_TIMER_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 100 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:sh_timer_read " "tmu012_read 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset);
#line 2453 "trace/trace-hw_timer.h"
        } else {
#line 100 "../hw/timer/trace-events"
            qemu_log("sh_timer_read " "tmu012_read 0x%" PRIx64 "\n", offset);
#line 2457 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_sh_timer_read(uint64_t offset)
{
    if (true) {
        _nocheck__trace_sh_timer_read(offset);
    }
}

#define TRACE_SH_TIMER_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SH_TIMER_WRITE) || \
    false)

static inline void _nocheck__trace_sh_timer_write(uint64_t offset, uint64_t value)
{
    if (trace_event_get_state(TRACE_SH_TIMER_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 101 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:sh_timer_write " "tmu012_write 0x%" PRIx64 " 0x%08" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, value);
#line 2484 "trace/trace-hw_timer.h"
        } else {
#line 101 "../hw/timer/trace-events"
            qemu_log("sh_timer_write " "tmu012_write 0x%" PRIx64 " 0x%08" PRIx64 "\n", offset, value);
#line 2488 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_sh_timer_write(uint64_t offset, uint64_t value)
{
    if (true) {
        _nocheck__trace_sh_timer_write(offset, value);
    }
}

#define TRACE_HPET_TIMER_ID_OUT_OF_RANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HPET_TIMER_ID_OUT_OF_RANGE) || \
    false)

static inline void _nocheck__trace_hpet_timer_id_out_of_range(uint8_t timer_id)
{
    if (trace_event_get_state(TRACE_HPET_TIMER_ID_OUT_OF_RANGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 104 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:hpet_timer_id_out_of_range " "timer id out of range: 0x%" PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , timer_id);
#line 2515 "trace/trace-hw_timer.h"
        } else {
#line 104 "../hw/timer/trace-events"
            qemu_log("hpet_timer_id_out_of_range " "timer id out of range: 0x%" PRIx8 "\n", timer_id);
#line 2519 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_hpet_timer_id_out_of_range(uint8_t timer_id)
{
    if (true) {
        _nocheck__trace_hpet_timer_id_out_of_range(timer_id);
    }
}

#define TRACE_HPET_INVALID_HPET_CFG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HPET_INVALID_HPET_CFG) || \
    false)

static inline void _nocheck__trace_hpet_invalid_hpet_cfg(uint8_t reg_off)
{
    if (trace_event_get_state(TRACE_HPET_INVALID_HPET_CFG) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 105 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:hpet_invalid_hpet_cfg " "invalid HPET_CFG + %u" PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reg_off);
#line 2546 "trace/trace-hw_timer.h"
        } else {
#line 105 "../hw/timer/trace-events"
            qemu_log("hpet_invalid_hpet_cfg " "invalid HPET_CFG + %u" PRIx8 "\n", reg_off);
#line 2550 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_hpet_invalid_hpet_cfg(uint8_t reg_off)
{
    if (true) {
        _nocheck__trace_hpet_invalid_hpet_cfg(reg_off);
    }
}

#define TRACE_HPET_RAM_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HPET_RAM_READ) || \
    false)

static inline void _nocheck__trace_hpet_ram_read(uint64_t addr)
{
    if (trace_event_get_state(TRACE_HPET_RAM_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 106 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:hpet_ram_read " "enter hpet_ram_readl at 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 2577 "trace/trace-hw_timer.h"
        } else {
#line 106 "../hw/timer/trace-events"
            qemu_log("hpet_ram_read " "enter hpet_ram_readl at 0x%" PRIx64 "\n", addr);
#line 2581 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_hpet_ram_read(uint64_t addr)
{
    if (true) {
        _nocheck__trace_hpet_ram_read(addr);
    }
}

#define TRACE_HPET_RAM_READ_READING_COUNTER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HPET_RAM_READ_READING_COUNTER) || \
    false)

static inline void _nocheck__trace_hpet_ram_read_reading_counter(uint8_t reg_off, uint64_t cur_tick)
{
    if (trace_event_get_state(TRACE_HPET_RAM_READ_READING_COUNTER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 107 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:hpet_ram_read_reading_counter " "reading counter + %" PRIu8 " = 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reg_off, cur_tick);
#line 2608 "trace/trace-hw_timer.h"
        } else {
#line 107 "../hw/timer/trace-events"
            qemu_log("hpet_ram_read_reading_counter " "reading counter + %" PRIu8 " = 0x%" PRIx64 "\n", reg_off, cur_tick);
#line 2612 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_hpet_ram_read_reading_counter(uint8_t reg_off, uint64_t cur_tick)
{
    if (true) {
        _nocheck__trace_hpet_ram_read_reading_counter(reg_off, cur_tick);
    }
}

#define TRACE_HPET_RAM_READ_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HPET_RAM_READ_INVALID) || \
    false)

static inline void _nocheck__trace_hpet_ram_read_invalid(void)
{
    if (trace_event_get_state(TRACE_HPET_RAM_READ_INVALID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 108 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:hpet_ram_read_invalid " "invalid hpet_ram_readl" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2639 "trace/trace-hw_timer.h"
        } else {
#line 108 "../hw/timer/trace-events"
            qemu_log("hpet_ram_read_invalid " "invalid hpet_ram_readl" "\n");
#line 2643 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_hpet_ram_read_invalid(void)
{
    if (true) {
        _nocheck__trace_hpet_ram_read_invalid();
    }
}

#define TRACE_HPET_RAM_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HPET_RAM_WRITE) || \
    false)

static inline void _nocheck__trace_hpet_ram_write(uint64_t addr, uint64_t value)
{
    if (trace_event_get_state(TRACE_HPET_RAM_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 109 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:hpet_ram_write " "enter hpet_ram_writel at 0x%" PRIx64 " = 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value);
#line 2670 "trace/trace-hw_timer.h"
        } else {
#line 109 "../hw/timer/trace-events"
            qemu_log("hpet_ram_write " "enter hpet_ram_writel at 0x%" PRIx64 " = 0x%" PRIx64 "\n", addr, value);
#line 2674 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_hpet_ram_write(uint64_t addr, uint64_t value)
{
    if (true) {
        _nocheck__trace_hpet_ram_write(addr, value);
    }
}

#define TRACE_HPET_RAM_WRITE_TIMER_ID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HPET_RAM_WRITE_TIMER_ID) || \
    false)

static inline void _nocheck__trace_hpet_ram_write_timer_id(uint64_t timer_id)
{
    if (trace_event_get_state(TRACE_HPET_RAM_WRITE_TIMER_ID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 110 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:hpet_ram_write_timer_id " "hpet_ram_writel timer_id = 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , timer_id);
#line 2701 "trace/trace-hw_timer.h"
        } else {
#line 110 "../hw/timer/trace-events"
            qemu_log("hpet_ram_write_timer_id " "hpet_ram_writel timer_id = 0x%" PRIx64 "\n", timer_id);
#line 2705 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_hpet_ram_write_timer_id(uint64_t timer_id)
{
    if (true) {
        _nocheck__trace_hpet_ram_write_timer_id(timer_id);
    }
}

#define TRACE_HPET_RAM_WRITE_TN_CFG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HPET_RAM_WRITE_TN_CFG) || \
    false)

static inline void _nocheck__trace_hpet_ram_write_tn_cfg(uint8_t reg_off)
{
    if (trace_event_get_state(TRACE_HPET_RAM_WRITE_TN_CFG) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 111 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:hpet_ram_write_tn_cfg " "hpet_ram_writel HPET_TN_CFG + %" PRIu8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reg_off);
#line 2732 "trace/trace-hw_timer.h"
        } else {
#line 111 "../hw/timer/trace-events"
            qemu_log("hpet_ram_write_tn_cfg " "hpet_ram_writel HPET_TN_CFG + %" PRIu8 "\n", reg_off);
#line 2736 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_hpet_ram_write_tn_cfg(uint8_t reg_off)
{
    if (true) {
        _nocheck__trace_hpet_ram_write_tn_cfg(reg_off);
    }
}

#define TRACE_HPET_RAM_WRITE_TN_CMP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HPET_RAM_WRITE_TN_CMP) || \
    false)

static inline void _nocheck__trace_hpet_ram_write_tn_cmp(uint8_t reg_off)
{
    if (trace_event_get_state(TRACE_HPET_RAM_WRITE_TN_CMP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 112 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:hpet_ram_write_tn_cmp " "hpet_ram_writel HPET_TN_CMP + %" PRIu8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reg_off);
#line 2763 "trace/trace-hw_timer.h"
        } else {
#line 112 "../hw/timer/trace-events"
            qemu_log("hpet_ram_write_tn_cmp " "hpet_ram_writel HPET_TN_CMP + %" PRIu8 "\n", reg_off);
#line 2767 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_hpet_ram_write_tn_cmp(uint8_t reg_off)
{
    if (true) {
        _nocheck__trace_hpet_ram_write_tn_cmp(reg_off);
    }
}

#define TRACE_HPET_RAM_WRITE_INVALID_TN_CMP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HPET_RAM_WRITE_INVALID_TN_CMP) || \
    false)

static inline void _nocheck__trace_hpet_ram_write_invalid_tn_cmp(void)
{
    if (trace_event_get_state(TRACE_HPET_RAM_WRITE_INVALID_TN_CMP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 113 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:hpet_ram_write_invalid_tn_cmp " "invalid HPET_TN_CMP + 4 write" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2794 "trace/trace-hw_timer.h"
        } else {
#line 113 "../hw/timer/trace-events"
            qemu_log("hpet_ram_write_invalid_tn_cmp " "invalid HPET_TN_CMP + 4 write" "\n");
#line 2798 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_hpet_ram_write_invalid_tn_cmp(void)
{
    if (true) {
        _nocheck__trace_hpet_ram_write_invalid_tn_cmp();
    }
}

#define TRACE_HPET_RAM_WRITE_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HPET_RAM_WRITE_INVALID) || \
    false)

static inline void _nocheck__trace_hpet_ram_write_invalid(void)
{
    if (trace_event_get_state(TRACE_HPET_RAM_WRITE_INVALID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 114 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:hpet_ram_write_invalid " "invalid hpet_ram_writel" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2825 "trace/trace-hw_timer.h"
        } else {
#line 114 "../hw/timer/trace-events"
            qemu_log("hpet_ram_write_invalid " "invalid hpet_ram_writel" "\n");
#line 2829 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_hpet_ram_write_invalid(void)
{
    if (true) {
        _nocheck__trace_hpet_ram_write_invalid();
    }
}

#define TRACE_HPET_RAM_WRITE_COUNTER_WRITE_WHILE_ENABLED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HPET_RAM_WRITE_COUNTER_WRITE_WHILE_ENABLED) || \
    false)

static inline void _nocheck__trace_hpet_ram_write_counter_write_while_enabled(void)
{
    if (trace_event_get_state(TRACE_HPET_RAM_WRITE_COUNTER_WRITE_WHILE_ENABLED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 115 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:hpet_ram_write_counter_write_while_enabled " "Writing counter while HPET enabled!" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2856 "trace/trace-hw_timer.h"
        } else {
#line 115 "../hw/timer/trace-events"
            qemu_log("hpet_ram_write_counter_write_while_enabled " "Writing counter while HPET enabled!" "\n");
#line 2860 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_hpet_ram_write_counter_write_while_enabled(void)
{
    if (true) {
        _nocheck__trace_hpet_ram_write_counter_write_while_enabled();
    }
}

#define TRACE_HPET_RAM_WRITE_COUNTER_WRITTEN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HPET_RAM_WRITE_COUNTER_WRITTEN) || \
    false)

static inline void _nocheck__trace_hpet_ram_write_counter_written(uint8_t reg_off, uint64_t value, uint64_t counter)
{
    if (trace_event_get_state(TRACE_HPET_RAM_WRITE_COUNTER_WRITTEN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 116 "../hw/timer/trace-events"
            qemu_log("%d@%zu.%06zu:hpet_ram_write_counter_written " "HPET counter + %" PRIu8 "written. crt = 0x%" PRIx64 " -> 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reg_off, value, counter);
#line 2887 "trace/trace-hw_timer.h"
        } else {
#line 116 "../hw/timer/trace-events"
            qemu_log("hpet_ram_write_counter_written " "HPET counter + %" PRIu8 "written. crt = 0x%" PRIx64 " -> 0x%" PRIx64 "\n", reg_off, value, counter);
#line 2891 "trace/trace-hw_timer.h"
        }
    }
}

static inline void trace_hpet_ram_write_counter_written(uint8_t reg_off, uint64_t value, uint64_t counter)
{
    if (true) {
        _nocheck__trace_hpet_ram_write_counter_written(reg_off, value, counter);
    }
}
#endif /* TRACE_HW_TIMER_GENERATED_TRACERS_H */
