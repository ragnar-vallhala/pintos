/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_I386_GENERATED_TRACERS_H
#define TRACE_HW_I386_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_X86_IOMMU_IEC_NOTIFY_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_CC_DOMAIN_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_CC_GLOBAL_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_CC_DEVICE_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_CC_DEVICES_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_IOTLB_GLOBAL_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_IOTLB_DOMAIN_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_IOTLB_PAGES_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_IOTLB_PASID_PAGES_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_IOTLB_PASID_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_WAIT_SW_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_WAIT_IRQ_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_WAIT_WRITE_FAIL_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_IEC_EVENT;
extern TraceEvent _TRACE_VTD_INV_QI_ENABLE_EVENT;
extern TraceEvent _TRACE_VTD_INV_QI_SETUP_EVENT;
extern TraceEvent _TRACE_VTD_INV_QI_HEAD_EVENT;
extern TraceEvent _TRACE_VTD_INV_QI_TAIL_EVENT;
extern TraceEvent _TRACE_VTD_INV_QI_FETCH_EVENT;
extern TraceEvent _TRACE_VTD_CONTEXT_CACHE_RESET_EVENT;
extern TraceEvent _TRACE_VTD_RE_NOT_PRESENT_EVENT;
extern TraceEvent _TRACE_VTD_CE_NOT_PRESENT_EVENT;
extern TraceEvent _TRACE_VTD_IOTLB_PAGE_HIT_EVENT;
extern TraceEvent _TRACE_VTD_IOTLB_PAGE_UPDATE_EVENT;
extern TraceEvent _TRACE_VTD_IOTLB_CC_HIT_EVENT;
extern TraceEvent _TRACE_VTD_IOTLB_CC_UPDATE_EVENT;
extern TraceEvent _TRACE_VTD_IOTLB_RESET_EVENT;
extern TraceEvent _TRACE_VTD_FAULT_DISABLED_EVENT;
extern TraceEvent _TRACE_VTD_REPLAY_CE_VALID_EVENT;
extern TraceEvent _TRACE_VTD_REPLAY_CE_INVALID_EVENT;
extern TraceEvent _TRACE_VTD_PAGE_WALK_LEVEL_EVENT;
extern TraceEvent _TRACE_VTD_PAGE_WALK_ONE_EVENT;
extern TraceEvent _TRACE_VTD_PAGE_WALK_ONE_SKIP_MAP_EVENT;
extern TraceEvent _TRACE_VTD_PAGE_WALK_ONE_SKIP_UNMAP_EVENT;
extern TraceEvent _TRACE_VTD_PAGE_WALK_SKIP_READ_EVENT;
extern TraceEvent _TRACE_VTD_PAGE_WALK_SKIP_RESERVE_EVENT;
extern TraceEvent _TRACE_VTD_SWITCH_ADDRESS_SPACE_EVENT;
extern TraceEvent _TRACE_VTD_AS_UNMAP_WHOLE_EVENT;
extern TraceEvent _TRACE_VTD_TRANSLATE_PT_EVENT;
extern TraceEvent _TRACE_VTD_PT_ENABLE_FAST_PATH_EVENT;
extern TraceEvent _TRACE_VTD_IRQ_GENERATE_EVENT;
extern TraceEvent _TRACE_VTD_REG_READ_EVENT;
extern TraceEvent _TRACE_VTD_REG_WRITE_EVENT;
extern TraceEvent _TRACE_VTD_REG_DMAR_ROOT_EVENT;
extern TraceEvent _TRACE_VTD_REG_IR_ROOT_EVENT;
extern TraceEvent _TRACE_VTD_REG_WRITE_GCMD_EVENT;
extern TraceEvent _TRACE_VTD_REG_WRITE_FECTL_EVENT;
extern TraceEvent _TRACE_VTD_REG_WRITE_IECTL_EVENT;
extern TraceEvent _TRACE_VTD_REG_ICS_CLEAR_IP_EVENT;
extern TraceEvent _TRACE_VTD_DMAR_TRANSLATE_EVENT;
extern TraceEvent _TRACE_VTD_DMAR_ENABLE_EVENT;
extern TraceEvent _TRACE_VTD_DMAR_FAULT_EVENT;
extern TraceEvent _TRACE_VTD_IR_ENABLE_EVENT;
extern TraceEvent _TRACE_VTD_IR_IRTE_GET_EVENT;
extern TraceEvent _TRACE_VTD_IR_REMAP_EVENT;
extern TraceEvent _TRACE_VTD_IR_REMAP_TYPE_EVENT;
extern TraceEvent _TRACE_VTD_IR_REMAP_MSI_EVENT;
extern TraceEvent _TRACE_VTD_IR_REMAP_MSI_REQ_EVENT;
extern TraceEvent _TRACE_VTD_FSTS_PPF_EVENT;
extern TraceEvent _TRACE_VTD_FSTS_CLEAR_IP_EVENT;
extern TraceEvent _TRACE_VTD_FRR_NEW_EVENT;
extern TraceEvent _TRACE_VTD_WARN_INVALID_QI_TAIL_EVENT;
extern TraceEvent _TRACE_VTD_WARN_IR_VECTOR_EVENT;
extern TraceEvent _TRACE_VTD_WARN_IR_TRIGGER_EVENT;
extern TraceEvent _TRACE_AMDVI_EVNTLOG_FAIL_EVENT;
extern TraceEvent _TRACE_AMDVI_CACHE_UPDATE_EVENT;
extern TraceEvent _TRACE_AMDVI_COMPLETION_WAIT_FAIL_EVENT;
extern TraceEvent _TRACE_AMDVI_MMIO_WRITE_EVENT;
extern TraceEvent _TRACE_AMDVI_MMIO_READ_EVENT;
extern TraceEvent _TRACE_AMDVI_MMIO_READ_INVALID_EVENT;
extern TraceEvent _TRACE_AMDVI_COMMAND_ERROR_EVENT;
extern TraceEvent _TRACE_AMDVI_COMMAND_READ_FAIL_EVENT;
extern TraceEvent _TRACE_AMDVI_COMMAND_EXEC_EVENT;
extern TraceEvent _TRACE_AMDVI_UNHANDLED_COMMAND_EVENT;
extern TraceEvent _TRACE_AMDVI_INTR_INVAL_EVENT;
extern TraceEvent _TRACE_AMDVI_IOTLB_INVAL_EVENT;
extern TraceEvent _TRACE_AMDVI_PREFETCH_PAGES_EVENT;
extern TraceEvent _TRACE_AMDVI_PAGES_INVAL_EVENT;
extern TraceEvent _TRACE_AMDVI_ALL_INVAL_EVENT;
extern TraceEvent _TRACE_AMDVI_PPR_EXEC_EVENT;
extern TraceEvent _TRACE_AMDVI_DEVTAB_INVAL_EVENT;
extern TraceEvent _TRACE_AMDVI_COMPLETION_WAIT_EVENT;
extern TraceEvent _TRACE_AMDVI_CONTROL_STATUS_EVENT;
extern TraceEvent _TRACE_AMDVI_IOTLB_RESET_EVENT;
extern TraceEvent _TRACE_AMDVI_DTE_GET_FAIL_EVENT;
extern TraceEvent _TRACE_AMDVI_INVALID_DTE_EVENT;
extern TraceEvent _TRACE_AMDVI_GET_PTE_HWERROR_EVENT;
extern TraceEvent _TRACE_AMDVI_MODE_INVALID_EVENT;
extern TraceEvent _TRACE_AMDVI_PAGE_FAULT_EVENT;
extern TraceEvent _TRACE_AMDVI_IOTLB_HIT_EVENT;
extern TraceEvent _TRACE_AMDVI_TRANSLATION_RESULT_EVENT;
extern TraceEvent _TRACE_AMDVI_MEM_IR_WRITE_REQ_EVENT;
extern TraceEvent _TRACE_AMDVI_MEM_IR_WRITE_EVENT;
extern TraceEvent _TRACE_AMDVI_IR_REMAP_MSI_REQ_EVENT;
extern TraceEvent _TRACE_AMDVI_IR_REMAP_MSI_EVENT;
extern TraceEvent _TRACE_AMDVI_ERR_EVENT;
extern TraceEvent _TRACE_AMDVI_IR_IRTE_EVENT;
extern TraceEvent _TRACE_AMDVI_IR_IRTE_VAL_EVENT;
extern TraceEvent _TRACE_AMDVI_IR_ERR_EVENT;
extern TraceEvent _TRACE_AMDVI_IR_INTCTL_EVENT;
extern TraceEvent _TRACE_AMDVI_IR_TARGET_ABORT_EVENT;
extern TraceEvent _TRACE_AMDVI_IR_DELIVERY_MODE_EVENT;
extern TraceEvent _TRACE_AMDVI_IR_IRTE_GA_VAL_EVENT;
extern TraceEvent _TRACE_VMPORT_REGISTER_EVENT;
extern TraceEvent _TRACE_VMPORT_COMMAND_EVENT;
extern TraceEvent _TRACE_X86_GSI_INTERRUPT_EVENT;
extern TraceEvent _TRACE_X86_PIC_INTERRUPT_EVENT;
extern TraceEvent _TRACE_PORT92_READ_EVENT;
extern TraceEvent _TRACE_PORT92_WRITE_EVENT;
extern TraceEvent _TRACE_VMMOUSE_GET_STATUS_EVENT;
extern TraceEvent _TRACE_VMMOUSE_MOUSE_EVENT_EVENT;
extern TraceEvent _TRACE_VMMOUSE_INIT_EVENT;
extern TraceEvent _TRACE_VMMOUSE_READ_ID_EVENT;
extern TraceEvent _TRACE_VMMOUSE_REQUEST_RELATIVE_EVENT;
extern TraceEvent _TRACE_VMMOUSE_REQUEST_ABSOLUTE_EVENT;
extern TraceEvent _TRACE_VMMOUSE_DISABLE_EVENT;
extern TraceEvent _TRACE_VMMOUSE_DATA_EVENT;
extern uint16_t _TRACE_X86_IOMMU_IEC_NOTIFY_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_CC_DOMAIN_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_CC_GLOBAL_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_CC_DEVICE_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_CC_DEVICES_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_IOTLB_GLOBAL_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_IOTLB_DOMAIN_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_IOTLB_PAGES_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_IOTLB_PASID_PAGES_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_IOTLB_PASID_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_WAIT_SW_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_WAIT_IRQ_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_WAIT_WRITE_FAIL_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_IEC_DSTATE;
extern uint16_t _TRACE_VTD_INV_QI_ENABLE_DSTATE;
extern uint16_t _TRACE_VTD_INV_QI_SETUP_DSTATE;
extern uint16_t _TRACE_VTD_INV_QI_HEAD_DSTATE;
extern uint16_t _TRACE_VTD_INV_QI_TAIL_DSTATE;
extern uint16_t _TRACE_VTD_INV_QI_FETCH_DSTATE;
extern uint16_t _TRACE_VTD_CONTEXT_CACHE_RESET_DSTATE;
extern uint16_t _TRACE_VTD_RE_NOT_PRESENT_DSTATE;
extern uint16_t _TRACE_VTD_CE_NOT_PRESENT_DSTATE;
extern uint16_t _TRACE_VTD_IOTLB_PAGE_HIT_DSTATE;
extern uint16_t _TRACE_VTD_IOTLB_PAGE_UPDATE_DSTATE;
extern uint16_t _TRACE_VTD_IOTLB_CC_HIT_DSTATE;
extern uint16_t _TRACE_VTD_IOTLB_CC_UPDATE_DSTATE;
extern uint16_t _TRACE_VTD_IOTLB_RESET_DSTATE;
extern uint16_t _TRACE_VTD_FAULT_DISABLED_DSTATE;
extern uint16_t _TRACE_VTD_REPLAY_CE_VALID_DSTATE;
extern uint16_t _TRACE_VTD_REPLAY_CE_INVALID_DSTATE;
extern uint16_t _TRACE_VTD_PAGE_WALK_LEVEL_DSTATE;
extern uint16_t _TRACE_VTD_PAGE_WALK_ONE_DSTATE;
extern uint16_t _TRACE_VTD_PAGE_WALK_ONE_SKIP_MAP_DSTATE;
extern uint16_t _TRACE_VTD_PAGE_WALK_ONE_SKIP_UNMAP_DSTATE;
extern uint16_t _TRACE_VTD_PAGE_WALK_SKIP_READ_DSTATE;
extern uint16_t _TRACE_VTD_PAGE_WALK_SKIP_RESERVE_DSTATE;
extern uint16_t _TRACE_VTD_SWITCH_ADDRESS_SPACE_DSTATE;
extern uint16_t _TRACE_VTD_AS_UNMAP_WHOLE_DSTATE;
extern uint16_t _TRACE_VTD_TRANSLATE_PT_DSTATE;
extern uint16_t _TRACE_VTD_PT_ENABLE_FAST_PATH_DSTATE;
extern uint16_t _TRACE_VTD_IRQ_GENERATE_DSTATE;
extern uint16_t _TRACE_VTD_REG_READ_DSTATE;
extern uint16_t _TRACE_VTD_REG_WRITE_DSTATE;
extern uint16_t _TRACE_VTD_REG_DMAR_ROOT_DSTATE;
extern uint16_t _TRACE_VTD_REG_IR_ROOT_DSTATE;
extern uint16_t _TRACE_VTD_REG_WRITE_GCMD_DSTATE;
extern uint16_t _TRACE_VTD_REG_WRITE_FECTL_DSTATE;
extern uint16_t _TRACE_VTD_REG_WRITE_IECTL_DSTATE;
extern uint16_t _TRACE_VTD_REG_ICS_CLEAR_IP_DSTATE;
extern uint16_t _TRACE_VTD_DMAR_TRANSLATE_DSTATE;
extern uint16_t _TRACE_VTD_DMAR_ENABLE_DSTATE;
extern uint16_t _TRACE_VTD_DMAR_FAULT_DSTATE;
extern uint16_t _TRACE_VTD_IR_ENABLE_DSTATE;
extern uint16_t _TRACE_VTD_IR_IRTE_GET_DSTATE;
extern uint16_t _TRACE_VTD_IR_REMAP_DSTATE;
extern uint16_t _TRACE_VTD_IR_REMAP_TYPE_DSTATE;
extern uint16_t _TRACE_VTD_IR_REMAP_MSI_DSTATE;
extern uint16_t _TRACE_VTD_IR_REMAP_MSI_REQ_DSTATE;
extern uint16_t _TRACE_VTD_FSTS_PPF_DSTATE;
extern uint16_t _TRACE_VTD_FSTS_CLEAR_IP_DSTATE;
extern uint16_t _TRACE_VTD_FRR_NEW_DSTATE;
extern uint16_t _TRACE_VTD_WARN_INVALID_QI_TAIL_DSTATE;
extern uint16_t _TRACE_VTD_WARN_IR_VECTOR_DSTATE;
extern uint16_t _TRACE_VTD_WARN_IR_TRIGGER_DSTATE;
extern uint16_t _TRACE_AMDVI_EVNTLOG_FAIL_DSTATE;
extern uint16_t _TRACE_AMDVI_CACHE_UPDATE_DSTATE;
extern uint16_t _TRACE_AMDVI_COMPLETION_WAIT_FAIL_DSTATE;
extern uint16_t _TRACE_AMDVI_MMIO_WRITE_DSTATE;
extern uint16_t _TRACE_AMDVI_MMIO_READ_DSTATE;
extern uint16_t _TRACE_AMDVI_MMIO_READ_INVALID_DSTATE;
extern uint16_t _TRACE_AMDVI_COMMAND_ERROR_DSTATE;
extern uint16_t _TRACE_AMDVI_COMMAND_READ_FAIL_DSTATE;
extern uint16_t _TRACE_AMDVI_COMMAND_EXEC_DSTATE;
extern uint16_t _TRACE_AMDVI_UNHANDLED_COMMAND_DSTATE;
extern uint16_t _TRACE_AMDVI_INTR_INVAL_DSTATE;
extern uint16_t _TRACE_AMDVI_IOTLB_INVAL_DSTATE;
extern uint16_t _TRACE_AMDVI_PREFETCH_PAGES_DSTATE;
extern uint16_t _TRACE_AMDVI_PAGES_INVAL_DSTATE;
extern uint16_t _TRACE_AMDVI_ALL_INVAL_DSTATE;
extern uint16_t _TRACE_AMDVI_PPR_EXEC_DSTATE;
extern uint16_t _TRACE_AMDVI_DEVTAB_INVAL_DSTATE;
extern uint16_t _TRACE_AMDVI_COMPLETION_WAIT_DSTATE;
extern uint16_t _TRACE_AMDVI_CONTROL_STATUS_DSTATE;
extern uint16_t _TRACE_AMDVI_IOTLB_RESET_DSTATE;
extern uint16_t _TRACE_AMDVI_DTE_GET_FAIL_DSTATE;
extern uint16_t _TRACE_AMDVI_INVALID_DTE_DSTATE;
extern uint16_t _TRACE_AMDVI_GET_PTE_HWERROR_DSTATE;
extern uint16_t _TRACE_AMDVI_MODE_INVALID_DSTATE;
extern uint16_t _TRACE_AMDVI_PAGE_FAULT_DSTATE;
extern uint16_t _TRACE_AMDVI_IOTLB_HIT_DSTATE;
extern uint16_t _TRACE_AMDVI_TRANSLATION_RESULT_DSTATE;
extern uint16_t _TRACE_AMDVI_MEM_IR_WRITE_REQ_DSTATE;
extern uint16_t _TRACE_AMDVI_MEM_IR_WRITE_DSTATE;
extern uint16_t _TRACE_AMDVI_IR_REMAP_MSI_REQ_DSTATE;
extern uint16_t _TRACE_AMDVI_IR_REMAP_MSI_DSTATE;
extern uint16_t _TRACE_AMDVI_ERR_DSTATE;
extern uint16_t _TRACE_AMDVI_IR_IRTE_DSTATE;
extern uint16_t _TRACE_AMDVI_IR_IRTE_VAL_DSTATE;
extern uint16_t _TRACE_AMDVI_IR_ERR_DSTATE;
extern uint16_t _TRACE_AMDVI_IR_INTCTL_DSTATE;
extern uint16_t _TRACE_AMDVI_IR_TARGET_ABORT_DSTATE;
extern uint16_t _TRACE_AMDVI_IR_DELIVERY_MODE_DSTATE;
extern uint16_t _TRACE_AMDVI_IR_IRTE_GA_VAL_DSTATE;
extern uint16_t _TRACE_VMPORT_REGISTER_DSTATE;
extern uint16_t _TRACE_VMPORT_COMMAND_DSTATE;
extern uint16_t _TRACE_X86_GSI_INTERRUPT_DSTATE;
extern uint16_t _TRACE_X86_PIC_INTERRUPT_DSTATE;
extern uint16_t _TRACE_PORT92_READ_DSTATE;
extern uint16_t _TRACE_PORT92_WRITE_DSTATE;
extern uint16_t _TRACE_VMMOUSE_GET_STATUS_DSTATE;
extern uint16_t _TRACE_VMMOUSE_MOUSE_EVENT_DSTATE;
extern uint16_t _TRACE_VMMOUSE_INIT_DSTATE;
extern uint16_t _TRACE_VMMOUSE_READ_ID_DSTATE;
extern uint16_t _TRACE_VMMOUSE_REQUEST_RELATIVE_DSTATE;
extern uint16_t _TRACE_VMMOUSE_REQUEST_ABSOLUTE_DSTATE;
extern uint16_t _TRACE_VMMOUSE_DISABLE_DSTATE;
extern uint16_t _TRACE_VMMOUSE_DATA_DSTATE;
#define TRACE_X86_IOMMU_IEC_NOTIFY_ENABLED 1
#define TRACE_VTD_INV_DESC_ENABLED 1
#define TRACE_VTD_INV_DESC_CC_DOMAIN_ENABLED 1
#define TRACE_VTD_INV_DESC_CC_GLOBAL_ENABLED 1
#define TRACE_VTD_INV_DESC_CC_DEVICE_ENABLED 1
#define TRACE_VTD_INV_DESC_CC_DEVICES_ENABLED 1
#define TRACE_VTD_INV_DESC_IOTLB_GLOBAL_ENABLED 1
#define TRACE_VTD_INV_DESC_IOTLB_DOMAIN_ENABLED 1
#define TRACE_VTD_INV_DESC_IOTLB_PAGES_ENABLED 1
#define TRACE_VTD_INV_DESC_IOTLB_PASID_PAGES_ENABLED 1
#define TRACE_VTD_INV_DESC_IOTLB_PASID_ENABLED 1
#define TRACE_VTD_INV_DESC_WAIT_SW_ENABLED 1
#define TRACE_VTD_INV_DESC_WAIT_IRQ_ENABLED 1
#define TRACE_VTD_INV_DESC_WAIT_WRITE_FAIL_ENABLED 1
#define TRACE_VTD_INV_DESC_IEC_ENABLED 1
#define TRACE_VTD_INV_QI_ENABLE_ENABLED 1
#define TRACE_VTD_INV_QI_SETUP_ENABLED 1
#define TRACE_VTD_INV_QI_HEAD_ENABLED 1
#define TRACE_VTD_INV_QI_TAIL_ENABLED 1
#define TRACE_VTD_INV_QI_FETCH_ENABLED 1
#define TRACE_VTD_CONTEXT_CACHE_RESET_ENABLED 1
#define TRACE_VTD_RE_NOT_PRESENT_ENABLED 1
#define TRACE_VTD_CE_NOT_PRESENT_ENABLED 1
#define TRACE_VTD_IOTLB_PAGE_HIT_ENABLED 1
#define TRACE_VTD_IOTLB_PAGE_UPDATE_ENABLED 1
#define TRACE_VTD_IOTLB_CC_HIT_ENABLED 1
#define TRACE_VTD_IOTLB_CC_UPDATE_ENABLED 1
#define TRACE_VTD_IOTLB_RESET_ENABLED 1
#define TRACE_VTD_FAULT_DISABLED_ENABLED 1
#define TRACE_VTD_REPLAY_CE_VALID_ENABLED 1
#define TRACE_VTD_REPLAY_CE_INVALID_ENABLED 1
#define TRACE_VTD_PAGE_WALK_LEVEL_ENABLED 1
#define TRACE_VTD_PAGE_WALK_ONE_ENABLED 1
#define TRACE_VTD_PAGE_WALK_ONE_SKIP_MAP_ENABLED 1
#define TRACE_VTD_PAGE_WALK_ONE_SKIP_UNMAP_ENABLED 1
#define TRACE_VTD_PAGE_WALK_SKIP_READ_ENABLED 1
#define TRACE_VTD_PAGE_WALK_SKIP_RESERVE_ENABLED 1
#define TRACE_VTD_SWITCH_ADDRESS_SPACE_ENABLED 1
#define TRACE_VTD_AS_UNMAP_WHOLE_ENABLED 1
#define TRACE_VTD_TRANSLATE_PT_ENABLED 1
#define TRACE_VTD_PT_ENABLE_FAST_PATH_ENABLED 1
#define TRACE_VTD_IRQ_GENERATE_ENABLED 1
#define TRACE_VTD_REG_READ_ENABLED 1
#define TRACE_VTD_REG_WRITE_ENABLED 1
#define TRACE_VTD_REG_DMAR_ROOT_ENABLED 1
#define TRACE_VTD_REG_IR_ROOT_ENABLED 1
#define TRACE_VTD_REG_WRITE_GCMD_ENABLED 1
#define TRACE_VTD_REG_WRITE_FECTL_ENABLED 1
#define TRACE_VTD_REG_WRITE_IECTL_ENABLED 1
#define TRACE_VTD_REG_ICS_CLEAR_IP_ENABLED 1
#define TRACE_VTD_DMAR_TRANSLATE_ENABLED 1
#define TRACE_VTD_DMAR_ENABLE_ENABLED 1
#define TRACE_VTD_DMAR_FAULT_ENABLED 1
#define TRACE_VTD_IR_ENABLE_ENABLED 1
#define TRACE_VTD_IR_IRTE_GET_ENABLED 1
#define TRACE_VTD_IR_REMAP_ENABLED 1
#define TRACE_VTD_IR_REMAP_TYPE_ENABLED 1
#define TRACE_VTD_IR_REMAP_MSI_ENABLED 1
#define TRACE_VTD_IR_REMAP_MSI_REQ_ENABLED 1
#define TRACE_VTD_FSTS_PPF_ENABLED 1
#define TRACE_VTD_FSTS_CLEAR_IP_ENABLED 1
#define TRACE_VTD_FRR_NEW_ENABLED 1
#define TRACE_VTD_WARN_INVALID_QI_TAIL_ENABLED 1
#define TRACE_VTD_WARN_IR_VECTOR_ENABLED 1
#define TRACE_VTD_WARN_IR_TRIGGER_ENABLED 1
#define TRACE_AMDVI_EVNTLOG_FAIL_ENABLED 1
#define TRACE_AMDVI_CACHE_UPDATE_ENABLED 1
#define TRACE_AMDVI_COMPLETION_WAIT_FAIL_ENABLED 1
#define TRACE_AMDVI_MMIO_WRITE_ENABLED 1
#define TRACE_AMDVI_MMIO_READ_ENABLED 1
#define TRACE_AMDVI_MMIO_READ_INVALID_ENABLED 1
#define TRACE_AMDVI_COMMAND_ERROR_ENABLED 1
#define TRACE_AMDVI_COMMAND_READ_FAIL_ENABLED 1
#define TRACE_AMDVI_COMMAND_EXEC_ENABLED 1
#define TRACE_AMDVI_UNHANDLED_COMMAND_ENABLED 1
#define TRACE_AMDVI_INTR_INVAL_ENABLED 1
#define TRACE_AMDVI_IOTLB_INVAL_ENABLED 1
#define TRACE_AMDVI_PREFETCH_PAGES_ENABLED 1
#define TRACE_AMDVI_PAGES_INVAL_ENABLED 1
#define TRACE_AMDVI_ALL_INVAL_ENABLED 1
#define TRACE_AMDVI_PPR_EXEC_ENABLED 1
#define TRACE_AMDVI_DEVTAB_INVAL_ENABLED 1
#define TRACE_AMDVI_COMPLETION_WAIT_ENABLED 1
#define TRACE_AMDVI_CONTROL_STATUS_ENABLED 1
#define TRACE_AMDVI_IOTLB_RESET_ENABLED 1
#define TRACE_AMDVI_DTE_GET_FAIL_ENABLED 1
#define TRACE_AMDVI_INVALID_DTE_ENABLED 1
#define TRACE_AMDVI_GET_PTE_HWERROR_ENABLED 1
#define TRACE_AMDVI_MODE_INVALID_ENABLED 1
#define TRACE_AMDVI_PAGE_FAULT_ENABLED 1
#define TRACE_AMDVI_IOTLB_HIT_ENABLED 1
#define TRACE_AMDVI_TRANSLATION_RESULT_ENABLED 1
#define TRACE_AMDVI_MEM_IR_WRITE_REQ_ENABLED 1
#define TRACE_AMDVI_MEM_IR_WRITE_ENABLED 1
#define TRACE_AMDVI_IR_REMAP_MSI_REQ_ENABLED 1
#define TRACE_AMDVI_IR_REMAP_MSI_ENABLED 1
#define TRACE_AMDVI_ERR_ENABLED 1
#define TRACE_AMDVI_IR_IRTE_ENABLED 1
#define TRACE_AMDVI_IR_IRTE_VAL_ENABLED 1
#define TRACE_AMDVI_IR_ERR_ENABLED 1
#define TRACE_AMDVI_IR_INTCTL_ENABLED 1
#define TRACE_AMDVI_IR_TARGET_ABORT_ENABLED 1
#define TRACE_AMDVI_IR_DELIVERY_MODE_ENABLED 1
#define TRACE_AMDVI_IR_IRTE_GA_VAL_ENABLED 1
#define TRACE_VMPORT_REGISTER_ENABLED 1
#define TRACE_VMPORT_COMMAND_ENABLED 1
#define TRACE_X86_GSI_INTERRUPT_ENABLED 1
#define TRACE_X86_PIC_INTERRUPT_ENABLED 1
#define TRACE_PORT92_READ_ENABLED 1
#define TRACE_PORT92_WRITE_ENABLED 1
#define TRACE_VMMOUSE_GET_STATUS_ENABLED 1
#define TRACE_VMMOUSE_MOUSE_EVENT_ENABLED 1
#define TRACE_VMMOUSE_INIT_ENABLED 1
#define TRACE_VMMOUSE_READ_ID_ENABLED 1
#define TRACE_VMMOUSE_REQUEST_RELATIVE_ENABLED 1
#define TRACE_VMMOUSE_REQUEST_ABSOLUTE_ENABLED 1
#define TRACE_VMMOUSE_DISABLE_ENABLED 1
#define TRACE_VMMOUSE_DATA_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_X86_IOMMU_IEC_NOTIFY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_X86_IOMMU_IEC_NOTIFY) || \
    false)

static inline void _nocheck__trace_x86_iommu_iec_notify(bool global, uint32_t index, uint32_t mask)
{
    if (trace_event_get_state(TRACE_X86_IOMMU_IEC_NOTIFY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 4 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:x86_iommu_iec_notify " "Notify IEC invalidation: global=%d index=%" PRIu32 " mask=%" PRIu32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , global, index, mask);
#line 382 "trace/trace-hw_i386.h"
        } else {
#line 4 "../hw/i386/trace-events"
            qemu_log("x86_iommu_iec_notify " "Notify IEC invalidation: global=%d index=%" PRIu32 " mask=%" PRIu32 "\n", global, index, mask);
#line 386 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_x86_iommu_iec_notify(bool global, uint32_t index, uint32_t mask)
{
    if (true) {
        _nocheck__trace_x86_iommu_iec_notify(global, index, mask);
    }
}

#define TRACE_VTD_INV_DESC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc(const char * type, uint64_t hi, uint64_t lo)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 7 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_inv_desc " "invalidate desc type %s high 0x%"PRIx64" low 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, hi, lo);
#line 413 "trace/trace-hw_i386.h"
        } else {
#line 7 "../hw/i386/trace-events"
            qemu_log("vtd_inv_desc " "invalidate desc type %s high 0x%"PRIx64" low 0x%"PRIx64 "\n", type, hi, lo);
#line 417 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_inv_desc(const char * type, uint64_t hi, uint64_t lo)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc(type, hi, lo);
    }
}

#define TRACE_VTD_INV_DESC_CC_DOMAIN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_CC_DOMAIN) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_cc_domain(uint16_t domain)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_CC_DOMAIN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 8 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_inv_desc_cc_domain " "context invalidate domain 0x%"PRIx16 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , domain);
#line 444 "trace/trace-hw_i386.h"
        } else {
#line 8 "../hw/i386/trace-events"
            qemu_log("vtd_inv_desc_cc_domain " "context invalidate domain 0x%"PRIx16 "\n", domain);
#line 448 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_inv_desc_cc_domain(uint16_t domain)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_cc_domain(domain);
    }
}

#define TRACE_VTD_INV_DESC_CC_GLOBAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_CC_GLOBAL) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_cc_global(void)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_CC_GLOBAL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 9 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_inv_desc_cc_global " "context invalidate globally" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 475 "trace/trace-hw_i386.h"
        } else {
#line 9 "../hw/i386/trace-events"
            qemu_log("vtd_inv_desc_cc_global " "context invalidate globally" "\n");
#line 479 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_inv_desc_cc_global(void)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_cc_global();
    }
}

#define TRACE_VTD_INV_DESC_CC_DEVICE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_CC_DEVICE) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_cc_device(uint8_t bus, uint8_t dev, uint8_t fn)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_CC_DEVICE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 10 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_inv_desc_cc_device " "context invalidate device %02"PRIx8":%02"PRIx8".%02"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bus, dev, fn);
#line 506 "trace/trace-hw_i386.h"
        } else {
#line 10 "../hw/i386/trace-events"
            qemu_log("vtd_inv_desc_cc_device " "context invalidate device %02"PRIx8":%02"PRIx8".%02"PRIx8 "\n", bus, dev, fn);
#line 510 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_inv_desc_cc_device(uint8_t bus, uint8_t dev, uint8_t fn)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_cc_device(bus, dev, fn);
    }
}

#define TRACE_VTD_INV_DESC_CC_DEVICES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_CC_DEVICES) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_cc_devices(uint16_t sid, uint16_t fmask)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_CC_DEVICES) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 11 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_inv_desc_cc_devices " "context invalidate devices sid 0x%"PRIx16" fmask 0x%"PRIx16 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , sid, fmask);
#line 537 "trace/trace-hw_i386.h"
        } else {
#line 11 "../hw/i386/trace-events"
            qemu_log("vtd_inv_desc_cc_devices " "context invalidate devices sid 0x%"PRIx16" fmask 0x%"PRIx16 "\n", sid, fmask);
#line 541 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_inv_desc_cc_devices(uint16_t sid, uint16_t fmask)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_cc_devices(sid, fmask);
    }
}

#define TRACE_VTD_INV_DESC_IOTLB_GLOBAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_IOTLB_GLOBAL) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_iotlb_global(void)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_IOTLB_GLOBAL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 12 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_inv_desc_iotlb_global " "iotlb invalidate global" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 568 "trace/trace-hw_i386.h"
        } else {
#line 12 "../hw/i386/trace-events"
            qemu_log("vtd_inv_desc_iotlb_global " "iotlb invalidate global" "\n");
#line 572 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_inv_desc_iotlb_global(void)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_iotlb_global();
    }
}

#define TRACE_VTD_INV_DESC_IOTLB_DOMAIN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_IOTLB_DOMAIN) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_iotlb_domain(uint16_t domain)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_IOTLB_DOMAIN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 13 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_inv_desc_iotlb_domain " "iotlb invalidate whole domain 0x%"PRIx16 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , domain);
#line 599 "trace/trace-hw_i386.h"
        } else {
#line 13 "../hw/i386/trace-events"
            qemu_log("vtd_inv_desc_iotlb_domain " "iotlb invalidate whole domain 0x%"PRIx16 "\n", domain);
#line 603 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_inv_desc_iotlb_domain(uint16_t domain)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_iotlb_domain(domain);
    }
}

#define TRACE_VTD_INV_DESC_IOTLB_PAGES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_IOTLB_PAGES) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_iotlb_pages(uint16_t domain, uint64_t addr, uint8_t mask)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_IOTLB_PAGES) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 14 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_inv_desc_iotlb_pages " "iotlb invalidate domain 0x%"PRIx16" addr 0x%"PRIx64" mask 0x%"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , domain, addr, mask);
#line 630 "trace/trace-hw_i386.h"
        } else {
#line 14 "../hw/i386/trace-events"
            qemu_log("vtd_inv_desc_iotlb_pages " "iotlb invalidate domain 0x%"PRIx16" addr 0x%"PRIx64" mask 0x%"PRIx8 "\n", domain, addr, mask);
#line 634 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_inv_desc_iotlb_pages(uint16_t domain, uint64_t addr, uint8_t mask)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_iotlb_pages(domain, addr, mask);
    }
}

#define TRACE_VTD_INV_DESC_IOTLB_PASID_PAGES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_IOTLB_PASID_PAGES) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_iotlb_pasid_pages(uint16_t domain, uint64_t addr, uint8_t mask, uint32_t pasid)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_IOTLB_PASID_PAGES) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 15 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_inv_desc_iotlb_pasid_pages " "iotlb invalidate domain 0x%"PRIx16" addr 0x%"PRIx64" mask 0x%"PRIx8" pasid 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , domain, addr, mask, pasid);
#line 661 "trace/trace-hw_i386.h"
        } else {
#line 15 "../hw/i386/trace-events"
            qemu_log("vtd_inv_desc_iotlb_pasid_pages " "iotlb invalidate domain 0x%"PRIx16" addr 0x%"PRIx64" mask 0x%"PRIx8" pasid 0x%"PRIx32 "\n", domain, addr, mask, pasid);
#line 665 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_inv_desc_iotlb_pasid_pages(uint16_t domain, uint64_t addr, uint8_t mask, uint32_t pasid)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_iotlb_pasid_pages(domain, addr, mask, pasid);
    }
}

#define TRACE_VTD_INV_DESC_IOTLB_PASID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_IOTLB_PASID) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_iotlb_pasid(uint16_t domain, uint32_t pasid)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_IOTLB_PASID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 16 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_inv_desc_iotlb_pasid " "iotlb invalidate domain 0x%"PRIx16" pasid 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , domain, pasid);
#line 692 "trace/trace-hw_i386.h"
        } else {
#line 16 "../hw/i386/trace-events"
            qemu_log("vtd_inv_desc_iotlb_pasid " "iotlb invalidate domain 0x%"PRIx16" pasid 0x%"PRIx32 "\n", domain, pasid);
#line 696 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_inv_desc_iotlb_pasid(uint16_t domain, uint32_t pasid)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_iotlb_pasid(domain, pasid);
    }
}

#define TRACE_VTD_INV_DESC_WAIT_SW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_WAIT_SW) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_wait_sw(uint64_t addr, uint32_t data)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_WAIT_SW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 17 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_inv_desc_wait_sw " "wait invalidate status write addr 0x%"PRIx64" data 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, data);
#line 723 "trace/trace-hw_i386.h"
        } else {
#line 17 "../hw/i386/trace-events"
            qemu_log("vtd_inv_desc_wait_sw " "wait invalidate status write addr 0x%"PRIx64" data 0x%"PRIx32 "\n", addr, data);
#line 727 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_inv_desc_wait_sw(uint64_t addr, uint32_t data)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_wait_sw(addr, data);
    }
}

#define TRACE_VTD_INV_DESC_WAIT_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_WAIT_IRQ) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_wait_irq(const char * msg)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_WAIT_IRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 18 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_inv_desc_wait_irq " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , msg);
#line 754 "trace/trace-hw_i386.h"
        } else {
#line 18 "../hw/i386/trace-events"
            qemu_log("vtd_inv_desc_wait_irq " "%s" "\n", msg);
#line 758 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_inv_desc_wait_irq(const char * msg)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_wait_irq(msg);
    }
}

#define TRACE_VTD_INV_DESC_WAIT_WRITE_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_WAIT_WRITE_FAIL) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_wait_write_fail(uint64_t hi, uint64_t lo)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_WAIT_WRITE_FAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 19 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_inv_desc_wait_write_fail " "write fail for wait desc hi 0x%"PRIx64" lo 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , hi, lo);
#line 785 "trace/trace-hw_i386.h"
        } else {
#line 19 "../hw/i386/trace-events"
            qemu_log("vtd_inv_desc_wait_write_fail " "write fail for wait desc hi 0x%"PRIx64" lo 0x%"PRIx64 "\n", hi, lo);
#line 789 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_inv_desc_wait_write_fail(uint64_t hi, uint64_t lo)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_wait_write_fail(hi, lo);
    }
}

#define TRACE_VTD_INV_DESC_IEC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_IEC) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_iec(uint32_t granularity, uint32_t index, uint32_t mask)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_IEC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 20 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_inv_desc_iec " "granularity 0x%"PRIx32" index 0x%"PRIx32" mask 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , granularity, index, mask);
#line 816 "trace/trace-hw_i386.h"
        } else {
#line 20 "../hw/i386/trace-events"
            qemu_log("vtd_inv_desc_iec " "granularity 0x%"PRIx32" index 0x%"PRIx32" mask 0x%"PRIx32 "\n", granularity, index, mask);
#line 820 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_inv_desc_iec(uint32_t granularity, uint32_t index, uint32_t mask)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_iec(granularity, index, mask);
    }
}

#define TRACE_VTD_INV_QI_ENABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_QI_ENABLE) || \
    false)

static inline void _nocheck__trace_vtd_inv_qi_enable(bool enable)
{
    if (trace_event_get_state(TRACE_VTD_INV_QI_ENABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 21 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_inv_qi_enable " "enabled %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , enable);
#line 847 "trace/trace-hw_i386.h"
        } else {
#line 21 "../hw/i386/trace-events"
            qemu_log("vtd_inv_qi_enable " "enabled %d" "\n", enable);
#line 851 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_inv_qi_enable(bool enable)
{
    if (true) {
        _nocheck__trace_vtd_inv_qi_enable(enable);
    }
}

#define TRACE_VTD_INV_QI_SETUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_QI_SETUP) || \
    false)

static inline void _nocheck__trace_vtd_inv_qi_setup(uint64_t addr, int size)
{
    if (trace_event_get_state(TRACE_VTD_INV_QI_SETUP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 22 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_inv_qi_setup " "addr 0x%"PRIx64" size %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, size);
#line 878 "trace/trace-hw_i386.h"
        } else {
#line 22 "../hw/i386/trace-events"
            qemu_log("vtd_inv_qi_setup " "addr 0x%"PRIx64" size %d" "\n", addr, size);
#line 882 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_inv_qi_setup(uint64_t addr, int size)
{
    if (true) {
        _nocheck__trace_vtd_inv_qi_setup(addr, size);
    }
}

#define TRACE_VTD_INV_QI_HEAD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_QI_HEAD) || \
    false)

static inline void _nocheck__trace_vtd_inv_qi_head(uint16_t head)
{
    if (trace_event_get_state(TRACE_VTD_INV_QI_HEAD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 23 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_inv_qi_head " "read head %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , head);
#line 909 "trace/trace-hw_i386.h"
        } else {
#line 23 "../hw/i386/trace-events"
            qemu_log("vtd_inv_qi_head " "read head %d" "\n", head);
#line 913 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_inv_qi_head(uint16_t head)
{
    if (true) {
        _nocheck__trace_vtd_inv_qi_head(head);
    }
}

#define TRACE_VTD_INV_QI_TAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_QI_TAIL) || \
    false)

static inline void _nocheck__trace_vtd_inv_qi_tail(uint16_t head)
{
    if (trace_event_get_state(TRACE_VTD_INV_QI_TAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 24 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_inv_qi_tail " "write tail %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , head);
#line 940 "trace/trace-hw_i386.h"
        } else {
#line 24 "../hw/i386/trace-events"
            qemu_log("vtd_inv_qi_tail " "write tail %d" "\n", head);
#line 944 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_inv_qi_tail(uint16_t head)
{
    if (true) {
        _nocheck__trace_vtd_inv_qi_tail(head);
    }
}

#define TRACE_VTD_INV_QI_FETCH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_QI_FETCH) || \
    false)

static inline void _nocheck__trace_vtd_inv_qi_fetch(void)
{
    if (trace_event_get_state(TRACE_VTD_INV_QI_FETCH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 25 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_inv_qi_fetch " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 971 "trace/trace-hw_i386.h"
        } else {
#line 25 "../hw/i386/trace-events"
            qemu_log("vtd_inv_qi_fetch " "" "\n");
#line 975 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_inv_qi_fetch(void)
{
    if (true) {
        _nocheck__trace_vtd_inv_qi_fetch();
    }
}

#define TRACE_VTD_CONTEXT_CACHE_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_CONTEXT_CACHE_RESET) || \
    false)

static inline void _nocheck__trace_vtd_context_cache_reset(void)
{
    if (trace_event_get_state(TRACE_VTD_CONTEXT_CACHE_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 26 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_context_cache_reset " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1002 "trace/trace-hw_i386.h"
        } else {
#line 26 "../hw/i386/trace-events"
            qemu_log("vtd_context_cache_reset " "" "\n");
#line 1006 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_context_cache_reset(void)
{
    if (true) {
        _nocheck__trace_vtd_context_cache_reset();
    }
}

#define TRACE_VTD_RE_NOT_PRESENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_RE_NOT_PRESENT) || \
    false)

static inline void _nocheck__trace_vtd_re_not_present(uint8_t bus)
{
    if (trace_event_get_state(TRACE_VTD_RE_NOT_PRESENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 27 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_re_not_present " "Root entry bus %"PRIu8" not present" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bus);
#line 1033 "trace/trace-hw_i386.h"
        } else {
#line 27 "../hw/i386/trace-events"
            qemu_log("vtd_re_not_present " "Root entry bus %"PRIu8" not present" "\n", bus);
#line 1037 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_re_not_present(uint8_t bus)
{
    if (true) {
        _nocheck__trace_vtd_re_not_present(bus);
    }
}

#define TRACE_VTD_CE_NOT_PRESENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_CE_NOT_PRESENT) || \
    false)

static inline void _nocheck__trace_vtd_ce_not_present(uint8_t bus, uint8_t devfn)
{
    if (trace_event_get_state(TRACE_VTD_CE_NOT_PRESENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 28 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_ce_not_present " "Context entry bus %"PRIu8" devfn %"PRIu8" not present" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bus, devfn);
#line 1064 "trace/trace-hw_i386.h"
        } else {
#line 28 "../hw/i386/trace-events"
            qemu_log("vtd_ce_not_present " "Context entry bus %"PRIu8" devfn %"PRIu8" not present" "\n", bus, devfn);
#line 1068 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_ce_not_present(uint8_t bus, uint8_t devfn)
{
    if (true) {
        _nocheck__trace_vtd_ce_not_present(bus, devfn);
    }
}

#define TRACE_VTD_IOTLB_PAGE_HIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IOTLB_PAGE_HIT) || \
    false)

static inline void _nocheck__trace_vtd_iotlb_page_hit(uint16_t sid, uint64_t addr, uint64_t slpte, uint16_t domain)
{
    if (trace_event_get_state(TRACE_VTD_IOTLB_PAGE_HIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 29 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_iotlb_page_hit " "IOTLB page hit sid 0x%"PRIx16" iova 0x%"PRIx64" slpte 0x%"PRIx64" domain 0x%"PRIx16 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , sid, addr, slpte, domain);
#line 1095 "trace/trace-hw_i386.h"
        } else {
#line 29 "../hw/i386/trace-events"
            qemu_log("vtd_iotlb_page_hit " "IOTLB page hit sid 0x%"PRIx16" iova 0x%"PRIx64" slpte 0x%"PRIx64" domain 0x%"PRIx16 "\n", sid, addr, slpte, domain);
#line 1099 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_iotlb_page_hit(uint16_t sid, uint64_t addr, uint64_t slpte, uint16_t domain)
{
    if (true) {
        _nocheck__trace_vtd_iotlb_page_hit(sid, addr, slpte, domain);
    }
}

#define TRACE_VTD_IOTLB_PAGE_UPDATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IOTLB_PAGE_UPDATE) || \
    false)

static inline void _nocheck__trace_vtd_iotlb_page_update(uint16_t sid, uint64_t addr, uint64_t slpte, uint16_t domain)
{
    if (trace_event_get_state(TRACE_VTD_IOTLB_PAGE_UPDATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 30 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_iotlb_page_update " "IOTLB page update sid 0x%"PRIx16" iova 0x%"PRIx64" slpte 0x%"PRIx64" domain 0x%"PRIx16 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , sid, addr, slpte, domain);
#line 1126 "trace/trace-hw_i386.h"
        } else {
#line 30 "../hw/i386/trace-events"
            qemu_log("vtd_iotlb_page_update " "IOTLB page update sid 0x%"PRIx16" iova 0x%"PRIx64" slpte 0x%"PRIx64" domain 0x%"PRIx16 "\n", sid, addr, slpte, domain);
#line 1130 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_iotlb_page_update(uint16_t sid, uint64_t addr, uint64_t slpte, uint16_t domain)
{
    if (true) {
        _nocheck__trace_vtd_iotlb_page_update(sid, addr, slpte, domain);
    }
}

#define TRACE_VTD_IOTLB_CC_HIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IOTLB_CC_HIT) || \
    false)

static inline void _nocheck__trace_vtd_iotlb_cc_hit(uint8_t bus, uint8_t devfn, uint64_t high, uint64_t low, uint32_t gen)
{
    if (trace_event_get_state(TRACE_VTD_IOTLB_CC_HIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 31 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_iotlb_cc_hit " "IOTLB context hit bus 0x%"PRIx8" devfn 0x%"PRIx8" high 0x%"PRIx64" low 0x%"PRIx64" gen %"PRIu32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bus, devfn, high, low, gen);
#line 1157 "trace/trace-hw_i386.h"
        } else {
#line 31 "../hw/i386/trace-events"
            qemu_log("vtd_iotlb_cc_hit " "IOTLB context hit bus 0x%"PRIx8" devfn 0x%"PRIx8" high 0x%"PRIx64" low 0x%"PRIx64" gen %"PRIu32 "\n", bus, devfn, high, low, gen);
#line 1161 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_iotlb_cc_hit(uint8_t bus, uint8_t devfn, uint64_t high, uint64_t low, uint32_t gen)
{
    if (true) {
        _nocheck__trace_vtd_iotlb_cc_hit(bus, devfn, high, low, gen);
    }
}

#define TRACE_VTD_IOTLB_CC_UPDATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IOTLB_CC_UPDATE) || \
    false)

static inline void _nocheck__trace_vtd_iotlb_cc_update(uint8_t bus, uint8_t devfn, uint64_t high, uint64_t low, uint32_t gen1, uint32_t gen2)
{
    if (trace_event_get_state(TRACE_VTD_IOTLB_CC_UPDATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 32 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_iotlb_cc_update " "IOTLB context update bus 0x%"PRIx8" devfn 0x%"PRIx8" high 0x%"PRIx64" low 0x%"PRIx64" gen %"PRIu32" -> gen %"PRIu32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bus, devfn, high, low, gen1, gen2);
#line 1188 "trace/trace-hw_i386.h"
        } else {
#line 32 "../hw/i386/trace-events"
            qemu_log("vtd_iotlb_cc_update " "IOTLB context update bus 0x%"PRIx8" devfn 0x%"PRIx8" high 0x%"PRIx64" low 0x%"PRIx64" gen %"PRIu32" -> gen %"PRIu32 "\n", bus, devfn, high, low, gen1, gen2);
#line 1192 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_iotlb_cc_update(uint8_t bus, uint8_t devfn, uint64_t high, uint64_t low, uint32_t gen1, uint32_t gen2)
{
    if (true) {
        _nocheck__trace_vtd_iotlb_cc_update(bus, devfn, high, low, gen1, gen2);
    }
}

#define TRACE_VTD_IOTLB_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IOTLB_RESET) || \
    false)

static inline void _nocheck__trace_vtd_iotlb_reset(const char * reason)
{
    if (trace_event_get_state(TRACE_VTD_IOTLB_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 33 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_iotlb_reset " "IOTLB reset (reason: %s)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reason);
#line 1219 "trace/trace-hw_i386.h"
        } else {
#line 33 "../hw/i386/trace-events"
            qemu_log("vtd_iotlb_reset " "IOTLB reset (reason: %s)" "\n", reason);
#line 1223 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_iotlb_reset(const char * reason)
{
    if (true) {
        _nocheck__trace_vtd_iotlb_reset(reason);
    }
}

#define TRACE_VTD_FAULT_DISABLED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_FAULT_DISABLED) || \
    false)

static inline void _nocheck__trace_vtd_fault_disabled(void)
{
    if (trace_event_get_state(TRACE_VTD_FAULT_DISABLED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 34 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_fault_disabled " "Fault processing disabled for context entry" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1250 "trace/trace-hw_i386.h"
        } else {
#line 34 "../hw/i386/trace-events"
            qemu_log("vtd_fault_disabled " "Fault processing disabled for context entry" "\n");
#line 1254 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_fault_disabled(void)
{
    if (true) {
        _nocheck__trace_vtd_fault_disabled();
    }
}

#define TRACE_VTD_REPLAY_CE_VALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REPLAY_CE_VALID) || \
    false)

static inline void _nocheck__trace_vtd_replay_ce_valid(const char * mode, uint8_t bus, uint8_t dev, uint8_t fn, uint16_t domain, uint64_t hi, uint64_t lo)
{
    if (trace_event_get_state(TRACE_VTD_REPLAY_CE_VALID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 35 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_replay_ce_valid " "%s: replay valid context device %02"PRIx8":%02"PRIx8".%02"PRIx8" domain 0x%"PRIx16" hi 0x%"PRIx64" lo 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , mode, bus, dev, fn, domain, hi, lo);
#line 1281 "trace/trace-hw_i386.h"
        } else {
#line 35 "../hw/i386/trace-events"
            qemu_log("vtd_replay_ce_valid " "%s: replay valid context device %02"PRIx8":%02"PRIx8".%02"PRIx8" domain 0x%"PRIx16" hi 0x%"PRIx64" lo 0x%"PRIx64 "\n", mode, bus, dev, fn, domain, hi, lo);
#line 1285 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_replay_ce_valid(const char * mode, uint8_t bus, uint8_t dev, uint8_t fn, uint16_t domain, uint64_t hi, uint64_t lo)
{
    if (true) {
        _nocheck__trace_vtd_replay_ce_valid(mode, bus, dev, fn, domain, hi, lo);
    }
}

#define TRACE_VTD_REPLAY_CE_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REPLAY_CE_INVALID) || \
    false)

static inline void _nocheck__trace_vtd_replay_ce_invalid(uint8_t bus, uint8_t dev, uint8_t fn)
{
    if (trace_event_get_state(TRACE_VTD_REPLAY_CE_INVALID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 36 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_replay_ce_invalid " "replay invalid context device %02"PRIx8":%02"PRIx8".%02"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bus, dev, fn);
#line 1312 "trace/trace-hw_i386.h"
        } else {
#line 36 "../hw/i386/trace-events"
            qemu_log("vtd_replay_ce_invalid " "replay invalid context device %02"PRIx8":%02"PRIx8".%02"PRIx8 "\n", bus, dev, fn);
#line 1316 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_replay_ce_invalid(uint8_t bus, uint8_t dev, uint8_t fn)
{
    if (true) {
        _nocheck__trace_vtd_replay_ce_invalid(bus, dev, fn);
    }
}

#define TRACE_VTD_PAGE_WALK_LEVEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_PAGE_WALK_LEVEL) || \
    false)

static inline void _nocheck__trace_vtd_page_walk_level(uint64_t addr, uint32_t level, uint64_t start, uint64_t end)
{
    if (trace_event_get_state(TRACE_VTD_PAGE_WALK_LEVEL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 37 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_page_walk_level " "walk (base=0x%"PRIx64", level=%"PRIu32") iova range 0x%"PRIx64" - 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, level, start, end);
#line 1343 "trace/trace-hw_i386.h"
        } else {
#line 37 "../hw/i386/trace-events"
            qemu_log("vtd_page_walk_level " "walk (base=0x%"PRIx64", level=%"PRIu32") iova range 0x%"PRIx64" - 0x%"PRIx64 "\n", addr, level, start, end);
#line 1347 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_page_walk_level(uint64_t addr, uint32_t level, uint64_t start, uint64_t end)
{
    if (true) {
        _nocheck__trace_vtd_page_walk_level(addr, level, start, end);
    }
}

#define TRACE_VTD_PAGE_WALK_ONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_PAGE_WALK_ONE) || \
    false)

static inline void _nocheck__trace_vtd_page_walk_one(uint16_t domain, uint64_t iova, uint64_t gpa, uint64_t mask, int perm)
{
    if (trace_event_get_state(TRACE_VTD_PAGE_WALK_ONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 38 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_page_walk_one " "domain 0x%"PRIx16" iova 0x%"PRIx64" -> gpa 0x%"PRIx64" mask 0x%"PRIx64" perm %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , domain, iova, gpa, mask, perm);
#line 1374 "trace/trace-hw_i386.h"
        } else {
#line 38 "../hw/i386/trace-events"
            qemu_log("vtd_page_walk_one " "domain 0x%"PRIx16" iova 0x%"PRIx64" -> gpa 0x%"PRIx64" mask 0x%"PRIx64" perm %d" "\n", domain, iova, gpa, mask, perm);
#line 1378 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_page_walk_one(uint16_t domain, uint64_t iova, uint64_t gpa, uint64_t mask, int perm)
{
    if (true) {
        _nocheck__trace_vtd_page_walk_one(domain, iova, gpa, mask, perm);
    }
}

#define TRACE_VTD_PAGE_WALK_ONE_SKIP_MAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_PAGE_WALK_ONE_SKIP_MAP) || \
    false)

static inline void _nocheck__trace_vtd_page_walk_one_skip_map(uint64_t iova, uint64_t mask, uint64_t translated)
{
    if (trace_event_get_state(TRACE_VTD_PAGE_WALK_ONE_SKIP_MAP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 39 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_page_walk_one_skip_map " "iova 0x%"PRIx64" mask 0x%"PRIx64" translated 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , iova, mask, translated);
#line 1405 "trace/trace-hw_i386.h"
        } else {
#line 39 "../hw/i386/trace-events"
            qemu_log("vtd_page_walk_one_skip_map " "iova 0x%"PRIx64" mask 0x%"PRIx64" translated 0x%"PRIx64 "\n", iova, mask, translated);
#line 1409 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_page_walk_one_skip_map(uint64_t iova, uint64_t mask, uint64_t translated)
{
    if (true) {
        _nocheck__trace_vtd_page_walk_one_skip_map(iova, mask, translated);
    }
}

#define TRACE_VTD_PAGE_WALK_ONE_SKIP_UNMAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_PAGE_WALK_ONE_SKIP_UNMAP) || \
    false)

static inline void _nocheck__trace_vtd_page_walk_one_skip_unmap(uint64_t iova, uint64_t mask)
{
    if (trace_event_get_state(TRACE_VTD_PAGE_WALK_ONE_SKIP_UNMAP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 40 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_page_walk_one_skip_unmap " "iova 0x%"PRIx64" mask 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , iova, mask);
#line 1436 "trace/trace-hw_i386.h"
        } else {
#line 40 "../hw/i386/trace-events"
            qemu_log("vtd_page_walk_one_skip_unmap " "iova 0x%"PRIx64" mask 0x%"PRIx64 "\n", iova, mask);
#line 1440 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_page_walk_one_skip_unmap(uint64_t iova, uint64_t mask)
{
    if (true) {
        _nocheck__trace_vtd_page_walk_one_skip_unmap(iova, mask);
    }
}

#define TRACE_VTD_PAGE_WALK_SKIP_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_PAGE_WALK_SKIP_READ) || \
    false)

static inline void _nocheck__trace_vtd_page_walk_skip_read(uint64_t iova, uint64_t next)
{
    if (trace_event_get_state(TRACE_VTD_PAGE_WALK_SKIP_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 41 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_page_walk_skip_read " "Page walk skip iova 0x%"PRIx64" - 0x%"PRIx64" due to unable to read" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , iova, next);
#line 1467 "trace/trace-hw_i386.h"
        } else {
#line 41 "../hw/i386/trace-events"
            qemu_log("vtd_page_walk_skip_read " "Page walk skip iova 0x%"PRIx64" - 0x%"PRIx64" due to unable to read" "\n", iova, next);
#line 1471 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_page_walk_skip_read(uint64_t iova, uint64_t next)
{
    if (true) {
        _nocheck__trace_vtd_page_walk_skip_read(iova, next);
    }
}

#define TRACE_VTD_PAGE_WALK_SKIP_RESERVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_PAGE_WALK_SKIP_RESERVE) || \
    false)

static inline void _nocheck__trace_vtd_page_walk_skip_reserve(uint64_t iova, uint64_t next)
{
    if (trace_event_get_state(TRACE_VTD_PAGE_WALK_SKIP_RESERVE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 42 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_page_walk_skip_reserve " "Page walk skip iova 0x%"PRIx64" - 0x%"PRIx64" due to rsrv set" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , iova, next);
#line 1498 "trace/trace-hw_i386.h"
        } else {
#line 42 "../hw/i386/trace-events"
            qemu_log("vtd_page_walk_skip_reserve " "Page walk skip iova 0x%"PRIx64" - 0x%"PRIx64" due to rsrv set" "\n", iova, next);
#line 1502 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_page_walk_skip_reserve(uint64_t iova, uint64_t next)
{
    if (true) {
        _nocheck__trace_vtd_page_walk_skip_reserve(iova, next);
    }
}

#define TRACE_VTD_SWITCH_ADDRESS_SPACE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_SWITCH_ADDRESS_SPACE) || \
    false)

static inline void _nocheck__trace_vtd_switch_address_space(uint8_t bus, uint8_t slot, uint8_t fn, bool on)
{
    if (trace_event_get_state(TRACE_VTD_SWITCH_ADDRESS_SPACE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 43 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_switch_address_space " "Device %02x:%02x.%x switching address space (iommu enabled=%d)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bus, slot, fn, on);
#line 1529 "trace/trace-hw_i386.h"
        } else {
#line 43 "../hw/i386/trace-events"
            qemu_log("vtd_switch_address_space " "Device %02x:%02x.%x switching address space (iommu enabled=%d)" "\n", bus, slot, fn, on);
#line 1533 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_switch_address_space(uint8_t bus, uint8_t slot, uint8_t fn, bool on)
{
    if (true) {
        _nocheck__trace_vtd_switch_address_space(bus, slot, fn, on);
    }
}

#define TRACE_VTD_AS_UNMAP_WHOLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_AS_UNMAP_WHOLE) || \
    false)

static inline void _nocheck__trace_vtd_as_unmap_whole(uint8_t bus, uint8_t slot, uint8_t fn, uint64_t iova, uint64_t size)
{
    if (trace_event_get_state(TRACE_VTD_AS_UNMAP_WHOLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 44 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_as_unmap_whole " "Device %02x:%02x.%x start 0x%"PRIx64" size 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bus, slot, fn, iova, size);
#line 1560 "trace/trace-hw_i386.h"
        } else {
#line 44 "../hw/i386/trace-events"
            qemu_log("vtd_as_unmap_whole " "Device %02x:%02x.%x start 0x%"PRIx64" size 0x%"PRIx64 "\n", bus, slot, fn, iova, size);
#line 1564 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_as_unmap_whole(uint8_t bus, uint8_t slot, uint8_t fn, uint64_t iova, uint64_t size)
{
    if (true) {
        _nocheck__trace_vtd_as_unmap_whole(bus, slot, fn, iova, size);
    }
}

#define TRACE_VTD_TRANSLATE_PT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_TRANSLATE_PT) || \
    false)

static inline void _nocheck__trace_vtd_translate_pt(uint16_t sid, uint64_t addr)
{
    if (trace_event_get_state(TRACE_VTD_TRANSLATE_PT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 45 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_translate_pt " "source id 0x%"PRIx16", iova 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , sid, addr);
#line 1591 "trace/trace-hw_i386.h"
        } else {
#line 45 "../hw/i386/trace-events"
            qemu_log("vtd_translate_pt " "source id 0x%"PRIx16", iova 0x%"PRIx64 "\n", sid, addr);
#line 1595 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_translate_pt(uint16_t sid, uint64_t addr)
{
    if (true) {
        _nocheck__trace_vtd_translate_pt(sid, addr);
    }
}

#define TRACE_VTD_PT_ENABLE_FAST_PATH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_PT_ENABLE_FAST_PATH) || \
    false)

static inline void _nocheck__trace_vtd_pt_enable_fast_path(uint16_t sid, bool success)
{
    if (trace_event_get_state(TRACE_VTD_PT_ENABLE_FAST_PATH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 46 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_pt_enable_fast_path " "sid 0x%"PRIx16" %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , sid, success);
#line 1622 "trace/trace-hw_i386.h"
        } else {
#line 46 "../hw/i386/trace-events"
            qemu_log("vtd_pt_enable_fast_path " "sid 0x%"PRIx16" %d" "\n", sid, success);
#line 1626 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_pt_enable_fast_path(uint16_t sid, bool success)
{
    if (true) {
        _nocheck__trace_vtd_pt_enable_fast_path(sid, success);
    }
}

#define TRACE_VTD_IRQ_GENERATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IRQ_GENERATE) || \
    false)

static inline void _nocheck__trace_vtd_irq_generate(uint64_t addr, uint64_t data)
{
    if (trace_event_get_state(TRACE_VTD_IRQ_GENERATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 47 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_irq_generate " "addr 0x%"PRIx64" data 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, data);
#line 1653 "trace/trace-hw_i386.h"
        } else {
#line 47 "../hw/i386/trace-events"
            qemu_log("vtd_irq_generate " "addr 0x%"PRIx64" data 0x%"PRIx64 "\n", addr, data);
#line 1657 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_irq_generate(uint64_t addr, uint64_t data)
{
    if (true) {
        _nocheck__trace_vtd_irq_generate(addr, data);
    }
}

#define TRACE_VTD_REG_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REG_READ) || \
    false)

static inline void _nocheck__trace_vtd_reg_read(uint64_t addr, uint64_t size)
{
    if (trace_event_get_state(TRACE_VTD_REG_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 48 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_reg_read " "addr 0x%"PRIx64" size 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, size);
#line 1684 "trace/trace-hw_i386.h"
        } else {
#line 48 "../hw/i386/trace-events"
            qemu_log("vtd_reg_read " "addr 0x%"PRIx64" size 0x%"PRIx64 "\n", addr, size);
#line 1688 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_reg_read(uint64_t addr, uint64_t size)
{
    if (true) {
        _nocheck__trace_vtd_reg_read(addr, size);
    }
}

#define TRACE_VTD_REG_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REG_WRITE) || \
    false)

static inline void _nocheck__trace_vtd_reg_write(uint64_t addr, uint64_t size, uint64_t val)
{
    if (trace_event_get_state(TRACE_VTD_REG_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 49 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_reg_write " "addr 0x%"PRIx64" size 0x%"PRIx64" value 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, size, val);
#line 1715 "trace/trace-hw_i386.h"
        } else {
#line 49 "../hw/i386/trace-events"
            qemu_log("vtd_reg_write " "addr 0x%"PRIx64" size 0x%"PRIx64" value 0x%"PRIx64 "\n", addr, size, val);
#line 1719 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_reg_write(uint64_t addr, uint64_t size, uint64_t val)
{
    if (true) {
        _nocheck__trace_vtd_reg_write(addr, size, val);
    }
}

#define TRACE_VTD_REG_DMAR_ROOT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REG_DMAR_ROOT) || \
    false)

static inline void _nocheck__trace_vtd_reg_dmar_root(uint64_t addr, bool scalable)
{
    if (trace_event_get_state(TRACE_VTD_REG_DMAR_ROOT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 50 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_reg_dmar_root " "addr 0x%"PRIx64" scalable %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, scalable);
#line 1746 "trace/trace-hw_i386.h"
        } else {
#line 50 "../hw/i386/trace-events"
            qemu_log("vtd_reg_dmar_root " "addr 0x%"PRIx64" scalable %d" "\n", addr, scalable);
#line 1750 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_reg_dmar_root(uint64_t addr, bool scalable)
{
    if (true) {
        _nocheck__trace_vtd_reg_dmar_root(addr, scalable);
    }
}

#define TRACE_VTD_REG_IR_ROOT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REG_IR_ROOT) || \
    false)

static inline void _nocheck__trace_vtd_reg_ir_root(uint64_t addr, uint32_t size)
{
    if (trace_event_get_state(TRACE_VTD_REG_IR_ROOT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 51 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_reg_ir_root " "addr 0x%"PRIx64" size 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, size);
#line 1777 "trace/trace-hw_i386.h"
        } else {
#line 51 "../hw/i386/trace-events"
            qemu_log("vtd_reg_ir_root " "addr 0x%"PRIx64" size 0x%"PRIx32 "\n", addr, size);
#line 1781 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_reg_ir_root(uint64_t addr, uint32_t size)
{
    if (true) {
        _nocheck__trace_vtd_reg_ir_root(addr, size);
    }
}

#define TRACE_VTD_REG_WRITE_GCMD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REG_WRITE_GCMD) || \
    false)

static inline void _nocheck__trace_vtd_reg_write_gcmd(uint32_t status, uint32_t val)
{
    if (trace_event_get_state(TRACE_VTD_REG_WRITE_GCMD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 52 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_reg_write_gcmd " "status 0x%"PRIx32" value 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , status, val);
#line 1808 "trace/trace-hw_i386.h"
        } else {
#line 52 "../hw/i386/trace-events"
            qemu_log("vtd_reg_write_gcmd " "status 0x%"PRIx32" value 0x%"PRIx32 "\n", status, val);
#line 1812 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_reg_write_gcmd(uint32_t status, uint32_t val)
{
    if (true) {
        _nocheck__trace_vtd_reg_write_gcmd(status, val);
    }
}

#define TRACE_VTD_REG_WRITE_FECTL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REG_WRITE_FECTL) || \
    false)

static inline void _nocheck__trace_vtd_reg_write_fectl(uint32_t value)
{
    if (trace_event_get_state(TRACE_VTD_REG_WRITE_FECTL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 53 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_reg_write_fectl " "value 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , value);
#line 1839 "trace/trace-hw_i386.h"
        } else {
#line 53 "../hw/i386/trace-events"
            qemu_log("vtd_reg_write_fectl " "value 0x%"PRIx32 "\n", value);
#line 1843 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_reg_write_fectl(uint32_t value)
{
    if (true) {
        _nocheck__trace_vtd_reg_write_fectl(value);
    }
}

#define TRACE_VTD_REG_WRITE_IECTL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REG_WRITE_IECTL) || \
    false)

static inline void _nocheck__trace_vtd_reg_write_iectl(uint32_t value)
{
    if (trace_event_get_state(TRACE_VTD_REG_WRITE_IECTL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 54 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_reg_write_iectl " "value 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , value);
#line 1870 "trace/trace-hw_i386.h"
        } else {
#line 54 "../hw/i386/trace-events"
            qemu_log("vtd_reg_write_iectl " "value 0x%"PRIx32 "\n", value);
#line 1874 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_reg_write_iectl(uint32_t value)
{
    if (true) {
        _nocheck__trace_vtd_reg_write_iectl(value);
    }
}

#define TRACE_VTD_REG_ICS_CLEAR_IP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REG_ICS_CLEAR_IP) || \
    false)

static inline void _nocheck__trace_vtd_reg_ics_clear_ip(void)
{
    if (trace_event_get_state(TRACE_VTD_REG_ICS_CLEAR_IP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 55 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_reg_ics_clear_ip " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1901 "trace/trace-hw_i386.h"
        } else {
#line 55 "../hw/i386/trace-events"
            qemu_log("vtd_reg_ics_clear_ip " "" "\n");
#line 1905 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_reg_ics_clear_ip(void)
{
    if (true) {
        _nocheck__trace_vtd_reg_ics_clear_ip();
    }
}

#define TRACE_VTD_DMAR_TRANSLATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_DMAR_TRANSLATE) || \
    false)

static inline void _nocheck__trace_vtd_dmar_translate(uint8_t bus, uint8_t slot, uint8_t func, uint64_t iova, uint64_t gpa, uint64_t mask)
{
    if (trace_event_get_state(TRACE_VTD_DMAR_TRANSLATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 56 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_dmar_translate " "dev %02x:%02x.%02x iova 0x%"PRIx64" -> gpa 0x%"PRIx64" mask 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bus, slot, func, iova, gpa, mask);
#line 1932 "trace/trace-hw_i386.h"
        } else {
#line 56 "../hw/i386/trace-events"
            qemu_log("vtd_dmar_translate " "dev %02x:%02x.%02x iova 0x%"PRIx64" -> gpa 0x%"PRIx64" mask 0x%"PRIx64 "\n", bus, slot, func, iova, gpa, mask);
#line 1936 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_dmar_translate(uint8_t bus, uint8_t slot, uint8_t func, uint64_t iova, uint64_t gpa, uint64_t mask)
{
    if (true) {
        _nocheck__trace_vtd_dmar_translate(bus, slot, func, iova, gpa, mask);
    }
}

#define TRACE_VTD_DMAR_ENABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_DMAR_ENABLE) || \
    false)

static inline void _nocheck__trace_vtd_dmar_enable(bool en)
{
    if (trace_event_get_state(TRACE_VTD_DMAR_ENABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 57 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_dmar_enable " "enable %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , en);
#line 1963 "trace/trace-hw_i386.h"
        } else {
#line 57 "../hw/i386/trace-events"
            qemu_log("vtd_dmar_enable " "enable %d" "\n", en);
#line 1967 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_dmar_enable(bool en)
{
    if (true) {
        _nocheck__trace_vtd_dmar_enable(en);
    }
}

#define TRACE_VTD_DMAR_FAULT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_DMAR_FAULT) || \
    false)

static inline void _nocheck__trace_vtd_dmar_fault(uint16_t sid, int fault, uint64_t addr, bool is_write)
{
    if (trace_event_get_state(TRACE_VTD_DMAR_FAULT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 58 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_dmar_fault " "sid 0x%"PRIx16" fault %d addr 0x%"PRIx64" write %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , sid, fault, addr, is_write);
#line 1994 "trace/trace-hw_i386.h"
        } else {
#line 58 "../hw/i386/trace-events"
            qemu_log("vtd_dmar_fault " "sid 0x%"PRIx16" fault %d addr 0x%"PRIx64" write %d" "\n", sid, fault, addr, is_write);
#line 1998 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_dmar_fault(uint16_t sid, int fault, uint64_t addr, bool is_write)
{
    if (true) {
        _nocheck__trace_vtd_dmar_fault(sid, fault, addr, is_write);
    }
}

#define TRACE_VTD_IR_ENABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IR_ENABLE) || \
    false)

static inline void _nocheck__trace_vtd_ir_enable(bool en)
{
    if (trace_event_get_state(TRACE_VTD_IR_ENABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 59 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_ir_enable " "enable %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , en);
#line 2025 "trace/trace-hw_i386.h"
        } else {
#line 59 "../hw/i386/trace-events"
            qemu_log("vtd_ir_enable " "enable %d" "\n", en);
#line 2029 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_ir_enable(bool en)
{
    if (true) {
        _nocheck__trace_vtd_ir_enable(en);
    }
}

#define TRACE_VTD_IR_IRTE_GET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IR_IRTE_GET) || \
    false)

static inline void _nocheck__trace_vtd_ir_irte_get(int index, uint64_t lo, uint64_t hi)
{
    if (trace_event_get_state(TRACE_VTD_IR_IRTE_GET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 60 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_ir_irte_get " "index %d low 0x%"PRIx64" high 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index, lo, hi);
#line 2056 "trace/trace-hw_i386.h"
        } else {
#line 60 "../hw/i386/trace-events"
            qemu_log("vtd_ir_irte_get " "index %d low 0x%"PRIx64" high 0x%"PRIx64 "\n", index, lo, hi);
#line 2060 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_ir_irte_get(int index, uint64_t lo, uint64_t hi)
{
    if (true) {
        _nocheck__trace_vtd_ir_irte_get(index, lo, hi);
    }
}

#define TRACE_VTD_IR_REMAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IR_REMAP) || \
    false)

static inline void _nocheck__trace_vtd_ir_remap(int index, int tri, int vec, int deliver, uint32_t dest, int dest_mode)
{
    if (trace_event_get_state(TRACE_VTD_IR_REMAP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 61 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_ir_remap " "index %d trigger %d vector %d deliver %d dest 0x%"PRIx32" mode %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index, tri, vec, deliver, dest, dest_mode);
#line 2087 "trace/trace-hw_i386.h"
        } else {
#line 61 "../hw/i386/trace-events"
            qemu_log("vtd_ir_remap " "index %d trigger %d vector %d deliver %d dest 0x%"PRIx32" mode %d" "\n", index, tri, vec, deliver, dest, dest_mode);
#line 2091 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_ir_remap(int index, int tri, int vec, int deliver, uint32_t dest, int dest_mode)
{
    if (true) {
        _nocheck__trace_vtd_ir_remap(index, tri, vec, deliver, dest, dest_mode);
    }
}

#define TRACE_VTD_IR_REMAP_TYPE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IR_REMAP_TYPE) || \
    false)

static inline void _nocheck__trace_vtd_ir_remap_type(const char * type)
{
    if (trace_event_get_state(TRACE_VTD_IR_REMAP_TYPE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 62 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_ir_remap_type " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type);
#line 2118 "trace/trace-hw_i386.h"
        } else {
#line 62 "../hw/i386/trace-events"
            qemu_log("vtd_ir_remap_type " "%s" "\n", type);
#line 2122 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_ir_remap_type(const char * type)
{
    if (true) {
        _nocheck__trace_vtd_ir_remap_type(type);
    }
}

#define TRACE_VTD_IR_REMAP_MSI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IR_REMAP_MSI) || \
    false)

static inline void _nocheck__trace_vtd_ir_remap_msi(uint64_t addr, uint64_t data, uint64_t addr2, uint64_t data2)
{
    if (trace_event_get_state(TRACE_VTD_IR_REMAP_MSI) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 63 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_ir_remap_msi " "(addr 0x%"PRIx64", data 0x%"PRIx64") -> (addr 0x%"PRIx64", data 0x%"PRIx64")" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, data, addr2, data2);
#line 2149 "trace/trace-hw_i386.h"
        } else {
#line 63 "../hw/i386/trace-events"
            qemu_log("vtd_ir_remap_msi " "(addr 0x%"PRIx64", data 0x%"PRIx64") -> (addr 0x%"PRIx64", data 0x%"PRIx64")" "\n", addr, data, addr2, data2);
#line 2153 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_ir_remap_msi(uint64_t addr, uint64_t data, uint64_t addr2, uint64_t data2)
{
    if (true) {
        _nocheck__trace_vtd_ir_remap_msi(addr, data, addr2, data2);
    }
}

#define TRACE_VTD_IR_REMAP_MSI_REQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IR_REMAP_MSI_REQ) || \
    false)

static inline void _nocheck__trace_vtd_ir_remap_msi_req(uint64_t addr, uint64_t data)
{
    if (trace_event_get_state(TRACE_VTD_IR_REMAP_MSI_REQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 64 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_ir_remap_msi_req " "addr 0x%"PRIx64" data 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, data);
#line 2180 "trace/trace-hw_i386.h"
        } else {
#line 64 "../hw/i386/trace-events"
            qemu_log("vtd_ir_remap_msi_req " "addr 0x%"PRIx64" data 0x%"PRIx64 "\n", addr, data);
#line 2184 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_ir_remap_msi_req(uint64_t addr, uint64_t data)
{
    if (true) {
        _nocheck__trace_vtd_ir_remap_msi_req(addr, data);
    }
}

#define TRACE_VTD_FSTS_PPF_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_FSTS_PPF) || \
    false)

static inline void _nocheck__trace_vtd_fsts_ppf(bool set)
{
    if (trace_event_get_state(TRACE_VTD_FSTS_PPF) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 65 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_fsts_ppf " "FSTS PPF bit set to %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , set);
#line 2211 "trace/trace-hw_i386.h"
        } else {
#line 65 "../hw/i386/trace-events"
            qemu_log("vtd_fsts_ppf " "FSTS PPF bit set to %d" "\n", set);
#line 2215 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_fsts_ppf(bool set)
{
    if (true) {
        _nocheck__trace_vtd_fsts_ppf(set);
    }
}

#define TRACE_VTD_FSTS_CLEAR_IP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_FSTS_CLEAR_IP) || \
    false)

static inline void _nocheck__trace_vtd_fsts_clear_ip(void)
{
    if (trace_event_get_state(TRACE_VTD_FSTS_CLEAR_IP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 66 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_fsts_clear_ip " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2242 "trace/trace-hw_i386.h"
        } else {
#line 66 "../hw/i386/trace-events"
            qemu_log("vtd_fsts_clear_ip " "" "\n");
#line 2246 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_fsts_clear_ip(void)
{
    if (true) {
        _nocheck__trace_vtd_fsts_clear_ip();
    }
}

#define TRACE_VTD_FRR_NEW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_FRR_NEW) || \
    false)

static inline void _nocheck__trace_vtd_frr_new(int index, uint64_t hi, uint64_t lo)
{
    if (trace_event_get_state(TRACE_VTD_FRR_NEW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 67 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_frr_new " "index %d high 0x%"PRIx64" low 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index, hi, lo);
#line 2273 "trace/trace-hw_i386.h"
        } else {
#line 67 "../hw/i386/trace-events"
            qemu_log("vtd_frr_new " "index %d high 0x%"PRIx64" low 0x%"PRIx64 "\n", index, hi, lo);
#line 2277 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_frr_new(int index, uint64_t hi, uint64_t lo)
{
    if (true) {
        _nocheck__trace_vtd_frr_new(index, hi, lo);
    }
}

#define TRACE_VTD_WARN_INVALID_QI_TAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_WARN_INVALID_QI_TAIL) || \
    false)

static inline void _nocheck__trace_vtd_warn_invalid_qi_tail(uint16_t tail)
{
    if (trace_event_get_state(TRACE_VTD_WARN_INVALID_QI_TAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 68 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_warn_invalid_qi_tail " "tail 0x%"PRIx16 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tail);
#line 2304 "trace/trace-hw_i386.h"
        } else {
#line 68 "../hw/i386/trace-events"
            qemu_log("vtd_warn_invalid_qi_tail " "tail 0x%"PRIx16 "\n", tail);
#line 2308 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_warn_invalid_qi_tail(uint16_t tail)
{
    if (true) {
        _nocheck__trace_vtd_warn_invalid_qi_tail(tail);
    }
}

#define TRACE_VTD_WARN_IR_VECTOR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_WARN_IR_VECTOR) || \
    false)

static inline void _nocheck__trace_vtd_warn_ir_vector(uint16_t sid, int index, int vec, int target)
{
    if (trace_event_get_state(TRACE_VTD_WARN_IR_VECTOR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 69 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_warn_ir_vector " "sid 0x%"PRIx16" index %d vec %d (should be: %d)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , sid, index, vec, target);
#line 2335 "trace/trace-hw_i386.h"
        } else {
#line 69 "../hw/i386/trace-events"
            qemu_log("vtd_warn_ir_vector " "sid 0x%"PRIx16" index %d vec %d (should be: %d)" "\n", sid, index, vec, target);
#line 2339 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_warn_ir_vector(uint16_t sid, int index, int vec, int target)
{
    if (true) {
        _nocheck__trace_vtd_warn_ir_vector(sid, index, vec, target);
    }
}

#define TRACE_VTD_WARN_IR_TRIGGER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_WARN_IR_TRIGGER) || \
    false)

static inline void _nocheck__trace_vtd_warn_ir_trigger(uint16_t sid, int index, int trig, int target)
{
    if (trace_event_get_state(TRACE_VTD_WARN_IR_TRIGGER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 70 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_warn_ir_trigger " "sid 0x%"PRIx16" index %d trigger %d (should be: %d)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , sid, index, trig, target);
#line 2366 "trace/trace-hw_i386.h"
        } else {
#line 70 "../hw/i386/trace-events"
            qemu_log("vtd_warn_ir_trigger " "sid 0x%"PRIx16" index %d trigger %d (should be: %d)" "\n", sid, index, trig, target);
#line 2370 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_warn_ir_trigger(uint16_t sid, int index, int trig, int target)
{
    if (true) {
        _nocheck__trace_vtd_warn_ir_trigger(sid, index, trig, target);
    }
}

#define TRACE_AMDVI_EVNTLOG_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_EVNTLOG_FAIL) || \
    false)

static inline void _nocheck__trace_amdvi_evntlog_fail(uint64_t addr, uint32_t head)
{
    if (trace_event_get_state(TRACE_AMDVI_EVNTLOG_FAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 73 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_evntlog_fail " "error: fail to write at addr 0x%"PRIx64" +  offset 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, head);
#line 2397 "trace/trace-hw_i386.h"
        } else {
#line 73 "../hw/i386/trace-events"
            qemu_log("amdvi_evntlog_fail " "error: fail to write at addr 0x%"PRIx64" +  offset 0x%"PRIx32 "\n", addr, head);
#line 2401 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_evntlog_fail(uint64_t addr, uint32_t head)
{
    if (true) {
        _nocheck__trace_amdvi_evntlog_fail(addr, head);
    }
}

#define TRACE_AMDVI_CACHE_UPDATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_CACHE_UPDATE) || \
    false)

static inline void _nocheck__trace_amdvi_cache_update(uint16_t domid, uint8_t bus, uint8_t slot, uint8_t func, uint64_t gpa, uint64_t txaddr)
{
    if (trace_event_get_state(TRACE_AMDVI_CACHE_UPDATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 74 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_cache_update " " update iotlb domid 0x%"PRIx16" devid: %02x:%02x.%x gpa 0x%"PRIx64" hpa 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , domid, bus, slot, func, gpa, txaddr);
#line 2428 "trace/trace-hw_i386.h"
        } else {
#line 74 "../hw/i386/trace-events"
            qemu_log("amdvi_cache_update " " update iotlb domid 0x%"PRIx16" devid: %02x:%02x.%x gpa 0x%"PRIx64" hpa 0x%"PRIx64 "\n", domid, bus, slot, func, gpa, txaddr);
#line 2432 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_cache_update(uint16_t domid, uint8_t bus, uint8_t slot, uint8_t func, uint64_t gpa, uint64_t txaddr)
{
    if (true) {
        _nocheck__trace_amdvi_cache_update(domid, bus, slot, func, gpa, txaddr);
    }
}

#define TRACE_AMDVI_COMPLETION_WAIT_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_COMPLETION_WAIT_FAIL) || \
    false)

static inline void _nocheck__trace_amdvi_completion_wait_fail(uint64_t addr)
{
    if (trace_event_get_state(TRACE_AMDVI_COMPLETION_WAIT_FAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 75 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_completion_wait_fail " "error: fail to write at address 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 2459 "trace/trace-hw_i386.h"
        } else {
#line 75 "../hw/i386/trace-events"
            qemu_log("amdvi_completion_wait_fail " "error: fail to write at address 0x%"PRIx64 "\n", addr);
#line 2463 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_completion_wait_fail(uint64_t addr)
{
    if (true) {
        _nocheck__trace_amdvi_completion_wait_fail(addr);
    }
}

#define TRACE_AMDVI_MMIO_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_MMIO_WRITE) || \
    false)

static inline void _nocheck__trace_amdvi_mmio_write(const char * reg, uint64_t addr, unsigned size, uint64_t val, uint64_t offset)
{
    if (trace_event_get_state(TRACE_AMDVI_MMIO_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 76 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_mmio_write " "%s write addr 0x%"PRIx64", size %u, val 0x%"PRIx64", offset 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reg, addr, size, val, offset);
#line 2490 "trace/trace-hw_i386.h"
        } else {
#line 76 "../hw/i386/trace-events"
            qemu_log("amdvi_mmio_write " "%s write addr 0x%"PRIx64", size %u, val 0x%"PRIx64", offset 0x%"PRIx64 "\n", reg, addr, size, val, offset);
#line 2494 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_mmio_write(const char * reg, uint64_t addr, unsigned size, uint64_t val, uint64_t offset)
{
    if (true) {
        _nocheck__trace_amdvi_mmio_write(reg, addr, size, val, offset);
    }
}

#define TRACE_AMDVI_MMIO_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_MMIO_READ) || \
    false)

static inline void _nocheck__trace_amdvi_mmio_read(const char * reg, uint64_t addr, unsigned size, uint64_t offset)
{
    if (trace_event_get_state(TRACE_AMDVI_MMIO_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 77 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_mmio_read " "%s read addr 0x%"PRIx64", size %u offset 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reg, addr, size, offset);
#line 2521 "trace/trace-hw_i386.h"
        } else {
#line 77 "../hw/i386/trace-events"
            qemu_log("amdvi_mmio_read " "%s read addr 0x%"PRIx64", size %u offset 0x%"PRIx64 "\n", reg, addr, size, offset);
#line 2525 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_mmio_read(const char * reg, uint64_t addr, unsigned size, uint64_t offset)
{
    if (true) {
        _nocheck__trace_amdvi_mmio_read(reg, addr, size, offset);
    }
}

#define TRACE_AMDVI_MMIO_READ_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_MMIO_READ_INVALID) || \
    false)

static inline void _nocheck__trace_amdvi_mmio_read_invalid(int max, uint64_t addr, unsigned size)
{
    if (trace_event_get_state(TRACE_AMDVI_MMIO_READ_INVALID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 78 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_mmio_read_invalid " "error: addr outside region (max 0x%x): read addr 0x%" PRIx64 ", size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , max, addr, size);
#line 2552 "trace/trace-hw_i386.h"
        } else {
#line 78 "../hw/i386/trace-events"
            qemu_log("amdvi_mmio_read_invalid " "error: addr outside region (max 0x%x): read addr 0x%" PRIx64 ", size %u" "\n", max, addr, size);
#line 2556 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_mmio_read_invalid(int max, uint64_t addr, unsigned size)
{
    if (true) {
        _nocheck__trace_amdvi_mmio_read_invalid(max, addr, size);
    }
}

#define TRACE_AMDVI_COMMAND_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_COMMAND_ERROR) || \
    false)

static inline void _nocheck__trace_amdvi_command_error(uint64_t status)
{
    if (trace_event_get_state(TRACE_AMDVI_COMMAND_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 79 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_command_error " "error: Executing commands with command buffer disabled 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , status);
#line 2583 "trace/trace-hw_i386.h"
        } else {
#line 79 "../hw/i386/trace-events"
            qemu_log("amdvi_command_error " "error: Executing commands with command buffer disabled 0x%"PRIx64 "\n", status);
#line 2587 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_command_error(uint64_t status)
{
    if (true) {
        _nocheck__trace_amdvi_command_error(status);
    }
}

#define TRACE_AMDVI_COMMAND_READ_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_COMMAND_READ_FAIL) || \
    false)

static inline void _nocheck__trace_amdvi_command_read_fail(uint64_t addr, uint32_t head)
{
    if (trace_event_get_state(TRACE_AMDVI_COMMAND_READ_FAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 80 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_command_read_fail " "error: fail to access memory at 0x%"PRIx64" + 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, head);
#line 2614 "trace/trace-hw_i386.h"
        } else {
#line 80 "../hw/i386/trace-events"
            qemu_log("amdvi_command_read_fail " "error: fail to access memory at 0x%"PRIx64" + 0x%"PRIx32 "\n", addr, head);
#line 2618 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_command_read_fail(uint64_t addr, uint32_t head)
{
    if (true) {
        _nocheck__trace_amdvi_command_read_fail(addr, head);
    }
}

#define TRACE_AMDVI_COMMAND_EXEC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_COMMAND_EXEC) || \
    false)

static inline void _nocheck__trace_amdvi_command_exec(uint32_t head, uint32_t tail, uint64_t buf)
{
    if (trace_event_get_state(TRACE_AMDVI_COMMAND_EXEC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 81 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_command_exec " "command buffer head at 0x%"PRIx32" command buffer tail at 0x%"PRIx32" command buffer base at 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , head, tail, buf);
#line 2645 "trace/trace-hw_i386.h"
        } else {
#line 81 "../hw/i386/trace-events"
            qemu_log("amdvi_command_exec " "command buffer head at 0x%"PRIx32" command buffer tail at 0x%"PRIx32" command buffer base at 0x%"PRIx64 "\n", head, tail, buf);
#line 2649 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_command_exec(uint32_t head, uint32_t tail, uint64_t buf)
{
    if (true) {
        _nocheck__trace_amdvi_command_exec(head, tail, buf);
    }
}

#define TRACE_AMDVI_UNHANDLED_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_UNHANDLED_COMMAND) || \
    false)

static inline void _nocheck__trace_amdvi_unhandled_command(uint8_t type)
{
    if (trace_event_get_state(TRACE_AMDVI_UNHANDLED_COMMAND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 82 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_unhandled_command " "unhandled command 0x%"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type);
#line 2676 "trace/trace-hw_i386.h"
        } else {
#line 82 "../hw/i386/trace-events"
            qemu_log("amdvi_unhandled_command " "unhandled command 0x%"PRIx8 "\n", type);
#line 2680 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_unhandled_command(uint8_t type)
{
    if (true) {
        _nocheck__trace_amdvi_unhandled_command(type);
    }
}

#define TRACE_AMDVI_INTR_INVAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_INTR_INVAL) || \
    false)

static inline void _nocheck__trace_amdvi_intr_inval(void)
{
    if (trace_event_get_state(TRACE_AMDVI_INTR_INVAL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 83 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_intr_inval " "Interrupt table invalidated" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2707 "trace/trace-hw_i386.h"
        } else {
#line 83 "../hw/i386/trace-events"
            qemu_log("amdvi_intr_inval " "Interrupt table invalidated" "\n");
#line 2711 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_intr_inval(void)
{
    if (true) {
        _nocheck__trace_amdvi_intr_inval();
    }
}

#define TRACE_AMDVI_IOTLB_INVAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IOTLB_INVAL) || \
    false)

static inline void _nocheck__trace_amdvi_iotlb_inval(void)
{
    if (trace_event_get_state(TRACE_AMDVI_IOTLB_INVAL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 84 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_iotlb_inval " "IOTLB pages invalidated" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2738 "trace/trace-hw_i386.h"
        } else {
#line 84 "../hw/i386/trace-events"
            qemu_log("amdvi_iotlb_inval " "IOTLB pages invalidated" "\n");
#line 2742 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_iotlb_inval(void)
{
    if (true) {
        _nocheck__trace_amdvi_iotlb_inval();
    }
}

#define TRACE_AMDVI_PREFETCH_PAGES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_PREFETCH_PAGES) || \
    false)

static inline void _nocheck__trace_amdvi_prefetch_pages(void)
{
    if (trace_event_get_state(TRACE_AMDVI_PREFETCH_PAGES) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 85 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_prefetch_pages " "Pre-fetch of AMD-Vi pages requested" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2769 "trace/trace-hw_i386.h"
        } else {
#line 85 "../hw/i386/trace-events"
            qemu_log("amdvi_prefetch_pages " "Pre-fetch of AMD-Vi pages requested" "\n");
#line 2773 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_prefetch_pages(void)
{
    if (true) {
        _nocheck__trace_amdvi_prefetch_pages();
    }
}

#define TRACE_AMDVI_PAGES_INVAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_PAGES_INVAL) || \
    false)

static inline void _nocheck__trace_amdvi_pages_inval(uint16_t domid)
{
    if (trace_event_get_state(TRACE_AMDVI_PAGES_INVAL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 86 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_pages_inval " "AMD-Vi pages for domain 0x%"PRIx16 " invalidated" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , domid);
#line 2800 "trace/trace-hw_i386.h"
        } else {
#line 86 "../hw/i386/trace-events"
            qemu_log("amdvi_pages_inval " "AMD-Vi pages for domain 0x%"PRIx16 " invalidated" "\n", domid);
#line 2804 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_pages_inval(uint16_t domid)
{
    if (true) {
        _nocheck__trace_amdvi_pages_inval(domid);
    }
}

#define TRACE_AMDVI_ALL_INVAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_ALL_INVAL) || \
    false)

static inline void _nocheck__trace_amdvi_all_inval(void)
{
    if (trace_event_get_state(TRACE_AMDVI_ALL_INVAL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 87 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_all_inval " "Invalidation of all AMD-Vi cache requested " "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2831 "trace/trace-hw_i386.h"
        } else {
#line 87 "../hw/i386/trace-events"
            qemu_log("amdvi_all_inval " "Invalidation of all AMD-Vi cache requested " "\n");
#line 2835 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_all_inval(void)
{
    if (true) {
        _nocheck__trace_amdvi_all_inval();
    }
}

#define TRACE_AMDVI_PPR_EXEC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_PPR_EXEC) || \
    false)

static inline void _nocheck__trace_amdvi_ppr_exec(void)
{
    if (trace_event_get_state(TRACE_AMDVI_PPR_EXEC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 88 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_ppr_exec " "Execution of PPR queue requested " "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2862 "trace/trace-hw_i386.h"
        } else {
#line 88 "../hw/i386/trace-events"
            qemu_log("amdvi_ppr_exec " "Execution of PPR queue requested " "\n");
#line 2866 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_ppr_exec(void)
{
    if (true) {
        _nocheck__trace_amdvi_ppr_exec();
    }
}

#define TRACE_AMDVI_DEVTAB_INVAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_DEVTAB_INVAL) || \
    false)

static inline void _nocheck__trace_amdvi_devtab_inval(uint8_t bus, uint8_t slot, uint8_t func)
{
    if (trace_event_get_state(TRACE_AMDVI_DEVTAB_INVAL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 89 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_devtab_inval " "device table entry for devid: %02x:%02x.%x invalidated" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bus, slot, func);
#line 2893 "trace/trace-hw_i386.h"
        } else {
#line 89 "../hw/i386/trace-events"
            qemu_log("amdvi_devtab_inval " "device table entry for devid: %02x:%02x.%x invalidated" "\n", bus, slot, func);
#line 2897 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_devtab_inval(uint8_t bus, uint8_t slot, uint8_t func)
{
    if (true) {
        _nocheck__trace_amdvi_devtab_inval(bus, slot, func);
    }
}

#define TRACE_AMDVI_COMPLETION_WAIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_COMPLETION_WAIT) || \
    false)

static inline void _nocheck__trace_amdvi_completion_wait(uint64_t addr, uint64_t data)
{
    if (trace_event_get_state(TRACE_AMDVI_COMPLETION_WAIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 90 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_completion_wait " "completion wait requested with store address 0x%"PRIx64" and store data 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, data);
#line 2924 "trace/trace-hw_i386.h"
        } else {
#line 90 "../hw/i386/trace-events"
            qemu_log("amdvi_completion_wait " "completion wait requested with store address 0x%"PRIx64" and store data 0x%"PRIx64 "\n", addr, data);
#line 2928 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_completion_wait(uint64_t addr, uint64_t data)
{
    if (true) {
        _nocheck__trace_amdvi_completion_wait(addr, data);
    }
}

#define TRACE_AMDVI_CONTROL_STATUS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_CONTROL_STATUS) || \
    false)

static inline void _nocheck__trace_amdvi_control_status(uint64_t val)
{
    if (trace_event_get_state(TRACE_AMDVI_CONTROL_STATUS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 91 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_control_status " "MMIO_STATUS state 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 2955 "trace/trace-hw_i386.h"
        } else {
#line 91 "../hw/i386/trace-events"
            qemu_log("amdvi_control_status " "MMIO_STATUS state 0x%"PRIx64 "\n", val);
#line 2959 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_control_status(uint64_t val)
{
    if (true) {
        _nocheck__trace_amdvi_control_status(val);
    }
}

#define TRACE_AMDVI_IOTLB_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IOTLB_RESET) || \
    false)

static inline void _nocheck__trace_amdvi_iotlb_reset(void)
{
    if (trace_event_get_state(TRACE_AMDVI_IOTLB_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 92 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_iotlb_reset " "IOTLB exceed size limit - reset " "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2986 "trace/trace-hw_i386.h"
        } else {
#line 92 "../hw/i386/trace-events"
            qemu_log("amdvi_iotlb_reset " "IOTLB exceed size limit - reset " "\n");
#line 2990 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_iotlb_reset(void)
{
    if (true) {
        _nocheck__trace_amdvi_iotlb_reset();
    }
}

#define TRACE_AMDVI_DTE_GET_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_DTE_GET_FAIL) || \
    false)

static inline void _nocheck__trace_amdvi_dte_get_fail(uint64_t addr, uint32_t offset)
{
    if (trace_event_get_state(TRACE_AMDVI_DTE_GET_FAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 93 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_dte_get_fail " "error: failed to access Device Entry devtab 0x%"PRIx64" offset 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, offset);
#line 3017 "trace/trace-hw_i386.h"
        } else {
#line 93 "../hw/i386/trace-events"
            qemu_log("amdvi_dte_get_fail " "error: failed to access Device Entry devtab 0x%"PRIx64" offset 0x%"PRIx32 "\n", addr, offset);
#line 3021 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_dte_get_fail(uint64_t addr, uint32_t offset)
{
    if (true) {
        _nocheck__trace_amdvi_dte_get_fail(addr, offset);
    }
}

#define TRACE_AMDVI_INVALID_DTE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_INVALID_DTE) || \
    false)

static inline void _nocheck__trace_amdvi_invalid_dte(uint64_t addr)
{
    if (trace_event_get_state(TRACE_AMDVI_INVALID_DTE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 94 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_invalid_dte " "PTE entry at 0x%"PRIx64" is invalid " "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 3048 "trace/trace-hw_i386.h"
        } else {
#line 94 "../hw/i386/trace-events"
            qemu_log("amdvi_invalid_dte " "PTE entry at 0x%"PRIx64" is invalid " "\n", addr);
#line 3052 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_invalid_dte(uint64_t addr)
{
    if (true) {
        _nocheck__trace_amdvi_invalid_dte(addr);
    }
}

#define TRACE_AMDVI_GET_PTE_HWERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_GET_PTE_HWERROR) || \
    false)

static inline void _nocheck__trace_amdvi_get_pte_hwerror(uint64_t addr)
{
    if (trace_event_get_state(TRACE_AMDVI_GET_PTE_HWERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 95 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_get_pte_hwerror " "hardware error eccessing PTE at addr 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 3079 "trace/trace-hw_i386.h"
        } else {
#line 95 "../hw/i386/trace-events"
            qemu_log("amdvi_get_pte_hwerror " "hardware error eccessing PTE at addr 0x%"PRIx64 "\n", addr);
#line 3083 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_get_pte_hwerror(uint64_t addr)
{
    if (true) {
        _nocheck__trace_amdvi_get_pte_hwerror(addr);
    }
}

#define TRACE_AMDVI_MODE_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_MODE_INVALID) || \
    false)

static inline void _nocheck__trace_amdvi_mode_invalid(uint8_t level, uint64_t addr)
{
    if (trace_event_get_state(TRACE_AMDVI_MODE_INVALID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 96 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_mode_invalid " "error: translation level 0x%"PRIx8" translating addr 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , level, addr);
#line 3110 "trace/trace-hw_i386.h"
        } else {
#line 96 "../hw/i386/trace-events"
            qemu_log("amdvi_mode_invalid " "error: translation level 0x%"PRIx8" translating addr 0x%"PRIx64 "\n", level, addr);
#line 3114 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_mode_invalid(uint8_t level, uint64_t addr)
{
    if (true) {
        _nocheck__trace_amdvi_mode_invalid(level, addr);
    }
}

#define TRACE_AMDVI_PAGE_FAULT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_PAGE_FAULT) || \
    false)

static inline void _nocheck__trace_amdvi_page_fault(uint64_t addr)
{
    if (trace_event_get_state(TRACE_AMDVI_PAGE_FAULT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 97 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_page_fault " "error: page fault accessing guest physical address 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 3141 "trace/trace-hw_i386.h"
        } else {
#line 97 "../hw/i386/trace-events"
            qemu_log("amdvi_page_fault " "error: page fault accessing guest physical address 0x%"PRIx64 "\n", addr);
#line 3145 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_page_fault(uint64_t addr)
{
    if (true) {
        _nocheck__trace_amdvi_page_fault(addr);
    }
}

#define TRACE_AMDVI_IOTLB_HIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IOTLB_HIT) || \
    false)

static inline void _nocheck__trace_amdvi_iotlb_hit(uint8_t bus, uint8_t slot, uint8_t func, uint64_t addr, uint64_t txaddr)
{
    if (trace_event_get_state(TRACE_AMDVI_IOTLB_HIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 98 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_iotlb_hit " "hit iotlb devid %02x:%02x.%x gpa 0x%"PRIx64" hpa 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bus, slot, func, addr, txaddr);
#line 3172 "trace/trace-hw_i386.h"
        } else {
#line 98 "../hw/i386/trace-events"
            qemu_log("amdvi_iotlb_hit " "hit iotlb devid %02x:%02x.%x gpa 0x%"PRIx64" hpa 0x%"PRIx64 "\n", bus, slot, func, addr, txaddr);
#line 3176 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_iotlb_hit(uint8_t bus, uint8_t slot, uint8_t func, uint64_t addr, uint64_t txaddr)
{
    if (true) {
        _nocheck__trace_amdvi_iotlb_hit(bus, slot, func, addr, txaddr);
    }
}

#define TRACE_AMDVI_TRANSLATION_RESULT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_TRANSLATION_RESULT) || \
    false)

static inline void _nocheck__trace_amdvi_translation_result(uint8_t bus, uint8_t slot, uint8_t func, uint64_t addr, uint64_t txaddr)
{
    if (trace_event_get_state(TRACE_AMDVI_TRANSLATION_RESULT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 99 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_translation_result " "devid: %02x:%02x.%x gpa 0x%"PRIx64" hpa 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bus, slot, func, addr, txaddr);
#line 3203 "trace/trace-hw_i386.h"
        } else {
#line 99 "../hw/i386/trace-events"
            qemu_log("amdvi_translation_result " "devid: %02x:%02x.%x gpa 0x%"PRIx64" hpa 0x%"PRIx64 "\n", bus, slot, func, addr, txaddr);
#line 3207 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_translation_result(uint8_t bus, uint8_t slot, uint8_t func, uint64_t addr, uint64_t txaddr)
{
    if (true) {
        _nocheck__trace_amdvi_translation_result(bus, slot, func, addr, txaddr);
    }
}

#define TRACE_AMDVI_MEM_IR_WRITE_REQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_MEM_IR_WRITE_REQ) || \
    false)

static inline void _nocheck__trace_amdvi_mem_ir_write_req(uint64_t addr, uint64_t val, uint32_t size)
{
    if (trace_event_get_state(TRACE_AMDVI_MEM_IR_WRITE_REQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 100 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_mem_ir_write_req " "addr 0x%"PRIx64" data 0x%"PRIx64" size 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val, size);
#line 3234 "trace/trace-hw_i386.h"
        } else {
#line 100 "../hw/i386/trace-events"
            qemu_log("amdvi_mem_ir_write_req " "addr 0x%"PRIx64" data 0x%"PRIx64" size 0x%"PRIx32 "\n", addr, val, size);
#line 3238 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_mem_ir_write_req(uint64_t addr, uint64_t val, uint32_t size)
{
    if (true) {
        _nocheck__trace_amdvi_mem_ir_write_req(addr, val, size);
    }
}

#define TRACE_AMDVI_MEM_IR_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_MEM_IR_WRITE) || \
    false)

static inline void _nocheck__trace_amdvi_mem_ir_write(uint64_t addr, uint64_t val)
{
    if (trace_event_get_state(TRACE_AMDVI_MEM_IR_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 101 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_mem_ir_write " "addr 0x%"PRIx64" data 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 3265 "trace/trace-hw_i386.h"
        } else {
#line 101 "../hw/i386/trace-events"
            qemu_log("amdvi_mem_ir_write " "addr 0x%"PRIx64" data 0x%"PRIx64 "\n", addr, val);
#line 3269 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_mem_ir_write(uint64_t addr, uint64_t val)
{
    if (true) {
        _nocheck__trace_amdvi_mem_ir_write(addr, val);
    }
}

#define TRACE_AMDVI_IR_REMAP_MSI_REQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IR_REMAP_MSI_REQ) || \
    false)

static inline void _nocheck__trace_amdvi_ir_remap_msi_req(uint64_t addr, uint64_t data, uint8_t devid)
{
    if (trace_event_get_state(TRACE_AMDVI_IR_REMAP_MSI_REQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 102 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_ir_remap_msi_req " "addr 0x%"PRIx64" data 0x%"PRIx64" devid 0x%"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, data, devid);
#line 3296 "trace/trace-hw_i386.h"
        } else {
#line 102 "../hw/i386/trace-events"
            qemu_log("amdvi_ir_remap_msi_req " "addr 0x%"PRIx64" data 0x%"PRIx64" devid 0x%"PRIx8 "\n", addr, data, devid);
#line 3300 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_ir_remap_msi_req(uint64_t addr, uint64_t data, uint8_t devid)
{
    if (true) {
        _nocheck__trace_amdvi_ir_remap_msi_req(addr, data, devid);
    }
}

#define TRACE_AMDVI_IR_REMAP_MSI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IR_REMAP_MSI) || \
    false)

static inline void _nocheck__trace_amdvi_ir_remap_msi(uint64_t addr, uint64_t data, uint64_t addr2, uint64_t data2)
{
    if (trace_event_get_state(TRACE_AMDVI_IR_REMAP_MSI) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 103 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_ir_remap_msi " "(addr 0x%"PRIx64", data 0x%"PRIx64") -> (addr 0x%"PRIx64", data 0x%"PRIx64")" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, data, addr2, data2);
#line 3327 "trace/trace-hw_i386.h"
        } else {
#line 103 "../hw/i386/trace-events"
            qemu_log("amdvi_ir_remap_msi " "(addr 0x%"PRIx64", data 0x%"PRIx64") -> (addr 0x%"PRIx64", data 0x%"PRIx64")" "\n", addr, data, addr2, data2);
#line 3331 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_ir_remap_msi(uint64_t addr, uint64_t data, uint64_t addr2, uint64_t data2)
{
    if (true) {
        _nocheck__trace_amdvi_ir_remap_msi(addr, data, addr2, data2);
    }
}

#define TRACE_AMDVI_ERR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_ERR) || \
    false)

static inline void _nocheck__trace_amdvi_err(const char * str)
{
    if (trace_event_get_state(TRACE_AMDVI_ERR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 104 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_err " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , str);
#line 3358 "trace/trace-hw_i386.h"
        } else {
#line 104 "../hw/i386/trace-events"
            qemu_log("amdvi_err " "%s" "\n", str);
#line 3362 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_err(const char * str)
{
    if (true) {
        _nocheck__trace_amdvi_err(str);
    }
}

#define TRACE_AMDVI_IR_IRTE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IR_IRTE) || \
    false)

static inline void _nocheck__trace_amdvi_ir_irte(uint64_t addr, uint64_t data)
{
    if (trace_event_get_state(TRACE_AMDVI_IR_IRTE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 105 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_ir_irte " "addr 0x%"PRIx64" offset 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, data);
#line 3389 "trace/trace-hw_i386.h"
        } else {
#line 105 "../hw/i386/trace-events"
            qemu_log("amdvi_ir_irte " "addr 0x%"PRIx64" offset 0x%"PRIx64 "\n", addr, data);
#line 3393 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_ir_irte(uint64_t addr, uint64_t data)
{
    if (true) {
        _nocheck__trace_amdvi_ir_irte(addr, data);
    }
}

#define TRACE_AMDVI_IR_IRTE_VAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IR_IRTE_VAL) || \
    false)

static inline void _nocheck__trace_amdvi_ir_irte_val(uint32_t data)
{
    if (trace_event_get_state(TRACE_AMDVI_IR_IRTE_VAL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 106 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_ir_irte_val " "data 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , data);
#line 3420 "trace/trace-hw_i386.h"
        } else {
#line 106 "../hw/i386/trace-events"
            qemu_log("amdvi_ir_irte_val " "data 0x%"PRIx32 "\n", data);
#line 3424 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_ir_irte_val(uint32_t data)
{
    if (true) {
        _nocheck__trace_amdvi_ir_irte_val(data);
    }
}

#define TRACE_AMDVI_IR_ERR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IR_ERR) || \
    false)

static inline void _nocheck__trace_amdvi_ir_err(const char * str)
{
    if (trace_event_get_state(TRACE_AMDVI_IR_ERR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 107 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_ir_err " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , str);
#line 3451 "trace/trace-hw_i386.h"
        } else {
#line 107 "../hw/i386/trace-events"
            qemu_log("amdvi_ir_err " "%s" "\n", str);
#line 3455 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_ir_err(const char * str)
{
    if (true) {
        _nocheck__trace_amdvi_ir_err(str);
    }
}

#define TRACE_AMDVI_IR_INTCTL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IR_INTCTL) || \
    false)

static inline void _nocheck__trace_amdvi_ir_intctl(uint8_t val)
{
    if (trace_event_get_state(TRACE_AMDVI_IR_INTCTL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 108 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_ir_intctl " "int_ctl 0x%"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 3482 "trace/trace-hw_i386.h"
        } else {
#line 108 "../hw/i386/trace-events"
            qemu_log("amdvi_ir_intctl " "int_ctl 0x%"PRIx8 "\n", val);
#line 3486 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_ir_intctl(uint8_t val)
{
    if (true) {
        _nocheck__trace_amdvi_ir_intctl(val);
    }
}

#define TRACE_AMDVI_IR_TARGET_ABORT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IR_TARGET_ABORT) || \
    false)

static inline void _nocheck__trace_amdvi_ir_target_abort(const char * str)
{
    if (trace_event_get_state(TRACE_AMDVI_IR_TARGET_ABORT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 109 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_ir_target_abort " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , str);
#line 3513 "trace/trace-hw_i386.h"
        } else {
#line 109 "../hw/i386/trace-events"
            qemu_log("amdvi_ir_target_abort " "%s" "\n", str);
#line 3517 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_ir_target_abort(const char * str)
{
    if (true) {
        _nocheck__trace_amdvi_ir_target_abort(str);
    }
}

#define TRACE_AMDVI_IR_DELIVERY_MODE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IR_DELIVERY_MODE) || \
    false)

static inline void _nocheck__trace_amdvi_ir_delivery_mode(const char * str)
{
    if (trace_event_get_state(TRACE_AMDVI_IR_DELIVERY_MODE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 110 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_ir_delivery_mode " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , str);
#line 3544 "trace/trace-hw_i386.h"
        } else {
#line 110 "../hw/i386/trace-events"
            qemu_log("amdvi_ir_delivery_mode " "%s" "\n", str);
#line 3548 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_ir_delivery_mode(const char * str)
{
    if (true) {
        _nocheck__trace_amdvi_ir_delivery_mode(str);
    }
}

#define TRACE_AMDVI_IR_IRTE_GA_VAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IR_IRTE_GA_VAL) || \
    false)

static inline void _nocheck__trace_amdvi_ir_irte_ga_val(uint64_t hi, uint64_t lo)
{
    if (trace_event_get_state(TRACE_AMDVI_IR_IRTE_GA_VAL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 111 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_ir_irte_ga_val " "hi 0x%"PRIx64" lo 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , hi, lo);
#line 3575 "trace/trace-hw_i386.h"
        } else {
#line 111 "../hw/i386/trace-events"
            qemu_log("amdvi_ir_irte_ga_val " "hi 0x%"PRIx64" lo 0x%"PRIx64 "\n", hi, lo);
#line 3579 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_ir_irte_ga_val(uint64_t hi, uint64_t lo)
{
    if (true) {
        _nocheck__trace_amdvi_ir_irte_ga_val(hi, lo);
    }
}

#define TRACE_VMPORT_REGISTER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMPORT_REGISTER) || \
    false)

static inline void _nocheck__trace_vmport_register(unsigned char command, void * func, void * opaque)
{
    if (trace_event_get_state(TRACE_VMPORT_REGISTER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 114 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vmport_register " "command: 0x%02x func: %p opaque: %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , command, func, opaque);
#line 3606 "trace/trace-hw_i386.h"
        } else {
#line 114 "../hw/i386/trace-events"
            qemu_log("vmport_register " "command: 0x%02x func: %p opaque: %p" "\n", command, func, opaque);
#line 3610 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vmport_register(unsigned char command, void * func, void * opaque)
{
    if (true) {
        _nocheck__trace_vmport_register(command, func, opaque);
    }
}

#define TRACE_VMPORT_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMPORT_COMMAND) || \
    false)

static inline void _nocheck__trace_vmport_command(unsigned char command)
{
    if (trace_event_get_state(TRACE_VMPORT_COMMAND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 115 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vmport_command " "command: 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , command);
#line 3637 "trace/trace-hw_i386.h"
        } else {
#line 115 "../hw/i386/trace-events"
            qemu_log("vmport_command " "command: 0x%02x" "\n", command);
#line 3641 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vmport_command(unsigned char command)
{
    if (true) {
        _nocheck__trace_vmport_command(command);
    }
}

#define TRACE_X86_GSI_INTERRUPT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_X86_GSI_INTERRUPT) || \
    false)

static inline void _nocheck__trace_x86_gsi_interrupt(int irqn, int level)
{
    if (trace_event_get_state(TRACE_X86_GSI_INTERRUPT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 118 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:x86_gsi_interrupt " "GSI interrupt #%d level:%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , irqn, level);
#line 3668 "trace/trace-hw_i386.h"
        } else {
#line 118 "../hw/i386/trace-events"
            qemu_log("x86_gsi_interrupt " "GSI interrupt #%d level:%d" "\n", irqn, level);
#line 3672 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_x86_gsi_interrupt(int irqn, int level)
{
    if (true) {
        _nocheck__trace_x86_gsi_interrupt(irqn, level);
    }
}

#define TRACE_X86_PIC_INTERRUPT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_X86_PIC_INTERRUPT) || \
    false)

static inline void _nocheck__trace_x86_pic_interrupt(int irqn, int level)
{
    if (trace_event_get_state(TRACE_X86_PIC_INTERRUPT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 119 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:x86_pic_interrupt " "PIC interrupt #%d level:%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , irqn, level);
#line 3699 "trace/trace-hw_i386.h"
        } else {
#line 119 "../hw/i386/trace-events"
            qemu_log("x86_pic_interrupt " "PIC interrupt #%d level:%d" "\n", irqn, level);
#line 3703 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_x86_pic_interrupt(int irqn, int level)
{
    if (true) {
        _nocheck__trace_x86_pic_interrupt(irqn, level);
    }
}

#define TRACE_PORT92_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PORT92_READ) || \
    false)

static inline void _nocheck__trace_port92_read(uint8_t val)
{
    if (trace_event_get_state(TRACE_PORT92_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 122 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:port92_read " "port92: read 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 3730 "trace/trace-hw_i386.h"
        } else {
#line 122 "../hw/i386/trace-events"
            qemu_log("port92_read " "port92: read 0x%02x" "\n", val);
#line 3734 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_port92_read(uint8_t val)
{
    if (true) {
        _nocheck__trace_port92_read(val);
    }
}

#define TRACE_PORT92_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PORT92_WRITE) || \
    false)

static inline void _nocheck__trace_port92_write(uint8_t val)
{
    if (trace_event_get_state(TRACE_PORT92_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 123 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:port92_write " "port92: write 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 3761 "trace/trace-hw_i386.h"
        } else {
#line 123 "../hw/i386/trace-events"
            qemu_log("port92_write " "port92: write 0x%02x" "\n", val);
#line 3765 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_port92_write(uint8_t val)
{
    if (true) {
        _nocheck__trace_port92_write(val);
    }
}

#define TRACE_VMMOUSE_GET_STATUS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMMOUSE_GET_STATUS) || \
    false)

static inline void _nocheck__trace_vmmouse_get_status(void)
{
    if (trace_event_get_state(TRACE_VMMOUSE_GET_STATUS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 126 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vmmouse_get_status " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 3792 "trace/trace-hw_i386.h"
        } else {
#line 126 "../hw/i386/trace-events"
            qemu_log("vmmouse_get_status " "" "\n");
#line 3796 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vmmouse_get_status(void)
{
    if (true) {
        _nocheck__trace_vmmouse_get_status();
    }
}

#define TRACE_VMMOUSE_MOUSE_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMMOUSE_MOUSE_EVENT) || \
    false)

static inline void _nocheck__trace_vmmouse_mouse_event(int x, int y, int dz, int buttons_state)
{
    if (trace_event_get_state(TRACE_VMMOUSE_MOUSE_EVENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 127 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vmmouse_mouse_event " "event: x=%d y=%d dz=%d state=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , x, y, dz, buttons_state);
#line 3823 "trace/trace-hw_i386.h"
        } else {
#line 127 "../hw/i386/trace-events"
            qemu_log("vmmouse_mouse_event " "event: x=%d y=%d dz=%d state=%d" "\n", x, y, dz, buttons_state);
#line 3827 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vmmouse_mouse_event(int x, int y, int dz, int buttons_state)
{
    if (true) {
        _nocheck__trace_vmmouse_mouse_event(x, y, dz, buttons_state);
    }
}

#define TRACE_VMMOUSE_INIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMMOUSE_INIT) || \
    false)

static inline void _nocheck__trace_vmmouse_init(void)
{
    if (trace_event_get_state(TRACE_VMMOUSE_INIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 128 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vmmouse_init " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 3854 "trace/trace-hw_i386.h"
        } else {
#line 128 "../hw/i386/trace-events"
            qemu_log("vmmouse_init " "" "\n");
#line 3858 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vmmouse_init(void)
{
    if (true) {
        _nocheck__trace_vmmouse_init();
    }
}

#define TRACE_VMMOUSE_READ_ID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMMOUSE_READ_ID) || \
    false)

static inline void _nocheck__trace_vmmouse_read_id(void)
{
    if (trace_event_get_state(TRACE_VMMOUSE_READ_ID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 129 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vmmouse_read_id " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 3885 "trace/trace-hw_i386.h"
        } else {
#line 129 "../hw/i386/trace-events"
            qemu_log("vmmouse_read_id " "" "\n");
#line 3889 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vmmouse_read_id(void)
{
    if (true) {
        _nocheck__trace_vmmouse_read_id();
    }
}

#define TRACE_VMMOUSE_REQUEST_RELATIVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMMOUSE_REQUEST_RELATIVE) || \
    false)

static inline void _nocheck__trace_vmmouse_request_relative(void)
{
    if (trace_event_get_state(TRACE_VMMOUSE_REQUEST_RELATIVE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 130 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vmmouse_request_relative " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 3916 "trace/trace-hw_i386.h"
        } else {
#line 130 "../hw/i386/trace-events"
            qemu_log("vmmouse_request_relative " "" "\n");
#line 3920 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vmmouse_request_relative(void)
{
    if (true) {
        _nocheck__trace_vmmouse_request_relative();
    }
}

#define TRACE_VMMOUSE_REQUEST_ABSOLUTE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMMOUSE_REQUEST_ABSOLUTE) || \
    false)

static inline void _nocheck__trace_vmmouse_request_absolute(void)
{
    if (trace_event_get_state(TRACE_VMMOUSE_REQUEST_ABSOLUTE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 131 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vmmouse_request_absolute " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 3947 "trace/trace-hw_i386.h"
        } else {
#line 131 "../hw/i386/trace-events"
            qemu_log("vmmouse_request_absolute " "" "\n");
#line 3951 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vmmouse_request_absolute(void)
{
    if (true) {
        _nocheck__trace_vmmouse_request_absolute();
    }
}

#define TRACE_VMMOUSE_DISABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMMOUSE_DISABLE) || \
    false)

static inline void _nocheck__trace_vmmouse_disable(void)
{
    if (trace_event_get_state(TRACE_VMMOUSE_DISABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 132 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vmmouse_disable " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 3978 "trace/trace-hw_i386.h"
        } else {
#line 132 "../hw/i386/trace-events"
            qemu_log("vmmouse_disable " "" "\n");
#line 3982 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vmmouse_disable(void)
{
    if (true) {
        _nocheck__trace_vmmouse_disable();
    }
}

#define TRACE_VMMOUSE_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMMOUSE_DATA) || \
    false)

static inline void _nocheck__trace_vmmouse_data(uint32_t size)
{
    if (trace_event_get_state(TRACE_VMMOUSE_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 133 "../hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vmmouse_data " "data: size=%" PRIu32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , size);
#line 4009 "trace/trace-hw_i386.h"
        } else {
#line 133 "../hw/i386/trace-events"
            qemu_log("vmmouse_data " "data: size=%" PRIu32 "\n", size);
#line 4013 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vmmouse_data(uint32_t size)
{
    if (true) {
        _nocheck__trace_vmmouse_data(size);
    }
}
#endif /* TRACE_HW_I386_GENERATED_TRACERS_H */
