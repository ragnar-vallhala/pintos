/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_SSI_GENERATED_TRACERS_H
#define TRACE_HW_SSI_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_ASPEED_SMC_FLASH_SET_SEGMENT_EVENT;
extern TraceEvent _TRACE_ASPEED_SMC_FLASH_READ_EVENT;
extern TraceEvent _TRACE_ASPEED_SMC_DO_SNOOP_EVENT;
extern TraceEvent _TRACE_ASPEED_SMC_FLASH_WRITE_EVENT;
extern TraceEvent _TRACE_ASPEED_SMC_READ_EVENT;
extern TraceEvent _TRACE_ASPEED_SMC_DMA_CHECKSUM_EVENT;
extern TraceEvent _TRACE_ASPEED_SMC_DMA_RW_EVENT;
extern TraceEvent _TRACE_ASPEED_SMC_WRITE_EVENT;
extern TraceEvent _TRACE_ASPEED_SMC_FLASH_SELECT_EVENT;
extern TraceEvent _TRACE_NPCM7XX_FIU_ENTER_RESET_EVENT;
extern TraceEvent _TRACE_NPCM7XX_FIU_HOLD_RESET_EVENT;
extern TraceEvent _TRACE_NPCM7XX_FIU_SELECT_EVENT;
extern TraceEvent _TRACE_NPCM7XX_FIU_DESELECT_EVENT;
extern TraceEvent _TRACE_NPCM7XX_FIU_CTRL_READ_EVENT;
extern TraceEvent _TRACE_NPCM7XX_FIU_CTRL_WRITE_EVENT;
extern TraceEvent _TRACE_NPCM7XX_FIU_FLASH_READ_EVENT;
extern TraceEvent _TRACE_NPCM7XX_FIU_FLASH_WRITE_EVENT;
extern TraceEvent _TRACE_NPCM_PSPI_ENTER_RESET_EVENT;
extern TraceEvent _TRACE_NPCM_PSPI_CTRL_READ_EVENT;
extern TraceEvent _TRACE_NPCM_PSPI_CTRL_WRITE_EVENT;
extern TraceEvent _TRACE_IBEX_SPI_HOST_RESET_EVENT;
extern TraceEvent _TRACE_IBEX_SPI_HOST_TRANSFER_EVENT;
extern TraceEvent _TRACE_IBEX_SPI_HOST_WRITE_EVENT;
extern TraceEvent _TRACE_IBEX_SPI_HOST_READ_EVENT;
extern TraceEvent _TRACE_PNV_SPI_READ_EVENT;
extern TraceEvent _TRACE_PNV_SPI_WRITE_EVENT;
extern TraceEvent _TRACE_PNV_SPI_READ_RDR_EVENT;
extern TraceEvent _TRACE_PNV_SPI_WRITE_TDR_EVENT;
extern TraceEvent _TRACE_PNV_SPI_START_SEQUENCER_EVENT;
extern TraceEvent _TRACE_PNV_SPI_RESET_EVENT;
extern TraceEvent _TRACE_PNV_SPI_SEQUENCER_OP_EVENT;
extern TraceEvent _TRACE_PNV_SPI_SHIFTER_STATING_EVENT;
extern TraceEvent _TRACE_PNV_SPI_SHIFTER_DONE_EVENT;
extern TraceEvent _TRACE_PNV_SPI_LOG_NCOUNTS_EVENT;
extern TraceEvent _TRACE_PNV_SPI_TX_APPEND_EVENT;
extern TraceEvent _TRACE_PNV_SPI_TX_APPEND_FF_EVENT;
extern TraceEvent _TRACE_PNV_SPI_TX_REQUEST_EVENT;
extern TraceEvent _TRACE_PNV_SPI_RX_RECEIVED_EVENT;
extern TraceEvent _TRACE_PNV_SPI_RX_READ_N1FRAME_EVENT;
extern TraceEvent _TRACE_PNV_SPI_RX_READ_N2FRAME_EVENT;
extern TraceEvent _TRACE_PNV_SPI_SHIFT_RX_EVENT;
extern TraceEvent _TRACE_PNV_SPI_SEQUENCER_STOP_REQUESTED_EVENT;
extern TraceEvent _TRACE_PNV_SPI_RDR_MATCH_EVENT;
extern uint16_t _TRACE_ASPEED_SMC_FLASH_SET_SEGMENT_DSTATE;
extern uint16_t _TRACE_ASPEED_SMC_FLASH_READ_DSTATE;
extern uint16_t _TRACE_ASPEED_SMC_DO_SNOOP_DSTATE;
extern uint16_t _TRACE_ASPEED_SMC_FLASH_WRITE_DSTATE;
extern uint16_t _TRACE_ASPEED_SMC_READ_DSTATE;
extern uint16_t _TRACE_ASPEED_SMC_DMA_CHECKSUM_DSTATE;
extern uint16_t _TRACE_ASPEED_SMC_DMA_RW_DSTATE;
extern uint16_t _TRACE_ASPEED_SMC_WRITE_DSTATE;
extern uint16_t _TRACE_ASPEED_SMC_FLASH_SELECT_DSTATE;
extern uint16_t _TRACE_NPCM7XX_FIU_ENTER_RESET_DSTATE;
extern uint16_t _TRACE_NPCM7XX_FIU_HOLD_RESET_DSTATE;
extern uint16_t _TRACE_NPCM7XX_FIU_SELECT_DSTATE;
extern uint16_t _TRACE_NPCM7XX_FIU_DESELECT_DSTATE;
extern uint16_t _TRACE_NPCM7XX_FIU_CTRL_READ_DSTATE;
extern uint16_t _TRACE_NPCM7XX_FIU_CTRL_WRITE_DSTATE;
extern uint16_t _TRACE_NPCM7XX_FIU_FLASH_READ_DSTATE;
extern uint16_t _TRACE_NPCM7XX_FIU_FLASH_WRITE_DSTATE;
extern uint16_t _TRACE_NPCM_PSPI_ENTER_RESET_DSTATE;
extern uint16_t _TRACE_NPCM_PSPI_CTRL_READ_DSTATE;
extern uint16_t _TRACE_NPCM_PSPI_CTRL_WRITE_DSTATE;
extern uint16_t _TRACE_IBEX_SPI_HOST_RESET_DSTATE;
extern uint16_t _TRACE_IBEX_SPI_HOST_TRANSFER_DSTATE;
extern uint16_t _TRACE_IBEX_SPI_HOST_WRITE_DSTATE;
extern uint16_t _TRACE_IBEX_SPI_HOST_READ_DSTATE;
extern uint16_t _TRACE_PNV_SPI_READ_DSTATE;
extern uint16_t _TRACE_PNV_SPI_WRITE_DSTATE;
extern uint16_t _TRACE_PNV_SPI_READ_RDR_DSTATE;
extern uint16_t _TRACE_PNV_SPI_WRITE_TDR_DSTATE;
extern uint16_t _TRACE_PNV_SPI_START_SEQUENCER_DSTATE;
extern uint16_t _TRACE_PNV_SPI_RESET_DSTATE;
extern uint16_t _TRACE_PNV_SPI_SEQUENCER_OP_DSTATE;
extern uint16_t _TRACE_PNV_SPI_SHIFTER_STATING_DSTATE;
extern uint16_t _TRACE_PNV_SPI_SHIFTER_DONE_DSTATE;
extern uint16_t _TRACE_PNV_SPI_LOG_NCOUNTS_DSTATE;
extern uint16_t _TRACE_PNV_SPI_TX_APPEND_DSTATE;
extern uint16_t _TRACE_PNV_SPI_TX_APPEND_FF_DSTATE;
extern uint16_t _TRACE_PNV_SPI_TX_REQUEST_DSTATE;
extern uint16_t _TRACE_PNV_SPI_RX_RECEIVED_DSTATE;
extern uint16_t _TRACE_PNV_SPI_RX_READ_N1FRAME_DSTATE;
extern uint16_t _TRACE_PNV_SPI_RX_READ_N2FRAME_DSTATE;
extern uint16_t _TRACE_PNV_SPI_SHIFT_RX_DSTATE;
extern uint16_t _TRACE_PNV_SPI_SEQUENCER_STOP_REQUESTED_DSTATE;
extern uint16_t _TRACE_PNV_SPI_RDR_MATCH_DSTATE;
#define TRACE_ASPEED_SMC_FLASH_SET_SEGMENT_ENABLED 1
#define TRACE_ASPEED_SMC_FLASH_READ_ENABLED 1
#define TRACE_ASPEED_SMC_DO_SNOOP_ENABLED 1
#define TRACE_ASPEED_SMC_FLASH_WRITE_ENABLED 1
#define TRACE_ASPEED_SMC_READ_ENABLED 1
#define TRACE_ASPEED_SMC_DMA_CHECKSUM_ENABLED 1
#define TRACE_ASPEED_SMC_DMA_RW_ENABLED 1
#define TRACE_ASPEED_SMC_WRITE_ENABLED 1
#define TRACE_ASPEED_SMC_FLASH_SELECT_ENABLED 1
#define TRACE_NPCM7XX_FIU_ENTER_RESET_ENABLED 1
#define TRACE_NPCM7XX_FIU_HOLD_RESET_ENABLED 1
#define TRACE_NPCM7XX_FIU_SELECT_ENABLED 1
#define TRACE_NPCM7XX_FIU_DESELECT_ENABLED 1
#define TRACE_NPCM7XX_FIU_CTRL_READ_ENABLED 1
#define TRACE_NPCM7XX_FIU_CTRL_WRITE_ENABLED 1
#define TRACE_NPCM7XX_FIU_FLASH_READ_ENABLED 1
#define TRACE_NPCM7XX_FIU_FLASH_WRITE_ENABLED 1
#define TRACE_NPCM_PSPI_ENTER_RESET_ENABLED 1
#define TRACE_NPCM_PSPI_CTRL_READ_ENABLED 1
#define TRACE_NPCM_PSPI_CTRL_WRITE_ENABLED 1
#define TRACE_IBEX_SPI_HOST_RESET_ENABLED 1
#define TRACE_IBEX_SPI_HOST_TRANSFER_ENABLED 1
#define TRACE_IBEX_SPI_HOST_WRITE_ENABLED 1
#define TRACE_IBEX_SPI_HOST_READ_ENABLED 1
#define TRACE_PNV_SPI_READ_ENABLED 1
#define TRACE_PNV_SPI_WRITE_ENABLED 1
#define TRACE_PNV_SPI_READ_RDR_ENABLED 1
#define TRACE_PNV_SPI_WRITE_TDR_ENABLED 1
#define TRACE_PNV_SPI_START_SEQUENCER_ENABLED 1
#define TRACE_PNV_SPI_RESET_ENABLED 1
#define TRACE_PNV_SPI_SEQUENCER_OP_ENABLED 1
#define TRACE_PNV_SPI_SHIFTER_STATING_ENABLED 1
#define TRACE_PNV_SPI_SHIFTER_DONE_ENABLED 1
#define TRACE_PNV_SPI_LOG_NCOUNTS_ENABLED 1
#define TRACE_PNV_SPI_TX_APPEND_ENABLED 1
#define TRACE_PNV_SPI_TX_APPEND_FF_ENABLED 1
#define TRACE_PNV_SPI_TX_REQUEST_ENABLED 1
#define TRACE_PNV_SPI_RX_RECEIVED_ENABLED 1
#define TRACE_PNV_SPI_RX_READ_N1FRAME_ENABLED 1
#define TRACE_PNV_SPI_RX_READ_N2FRAME_ENABLED 1
#define TRACE_PNV_SPI_SHIFT_RX_ENABLED 1
#define TRACE_PNV_SPI_SEQUENCER_STOP_REQUESTED_ENABLED 1
#define TRACE_PNV_SPI_RDR_MATCH_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_ASPEED_SMC_FLASH_SET_SEGMENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ASPEED_SMC_FLASH_SET_SEGMENT) || \
    false)

static inline void _nocheck__trace_aspeed_smc_flash_set_segment(int cs, uint64_t reg, uint64_t start, uint64_t end)
{
    if (trace_event_get_state(TRACE_ASPEED_SMC_FLASH_SET_SEGMENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 3 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:aspeed_smc_flash_set_segment " "CS%d segreg=0x%"PRIx64" [ 0x%"PRIx64" - 0x%"PRIx64" ]" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cs, reg, start, end);
#line 157 "trace/trace-hw_ssi.h"
        } else {
#line 3 "../hw/ssi/trace-events"
            qemu_log("aspeed_smc_flash_set_segment " "CS%d segreg=0x%"PRIx64" [ 0x%"PRIx64" - 0x%"PRIx64" ]" "\n", cs, reg, start, end);
#line 161 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_aspeed_smc_flash_set_segment(int cs, uint64_t reg, uint64_t start, uint64_t end)
{
    if (true) {
        _nocheck__trace_aspeed_smc_flash_set_segment(cs, reg, start, end);
    }
}

#define TRACE_ASPEED_SMC_FLASH_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ASPEED_SMC_FLASH_READ) || \
    false)

static inline void _nocheck__trace_aspeed_smc_flash_read(int cs, uint64_t addr, uint32_t size, uint64_t data, int mode)
{
    if (trace_event_get_state(TRACE_ASPEED_SMC_FLASH_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 4 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:aspeed_smc_flash_read " "CS%d @0x%" PRIx64 " size %u: 0x%" PRIx64" mode:%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cs, addr, size, data, mode);
#line 188 "trace/trace-hw_ssi.h"
        } else {
#line 4 "../hw/ssi/trace-events"
            qemu_log("aspeed_smc_flash_read " "CS%d @0x%" PRIx64 " size %u: 0x%" PRIx64" mode:%d" "\n", cs, addr, size, data, mode);
#line 192 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_aspeed_smc_flash_read(int cs, uint64_t addr, uint32_t size, uint64_t data, int mode)
{
    if (true) {
        _nocheck__trace_aspeed_smc_flash_read(cs, addr, size, data, mode);
    }
}

#define TRACE_ASPEED_SMC_DO_SNOOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ASPEED_SMC_DO_SNOOP) || \
    false)

static inline void _nocheck__trace_aspeed_smc_do_snoop(int cs, int index, int dummies, int data)
{
    if (trace_event_get_state(TRACE_ASPEED_SMC_DO_SNOOP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 5 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:aspeed_smc_do_snoop " "CS%d index:0x%x dummies:%d data:0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cs, index, dummies, data);
#line 219 "trace/trace-hw_ssi.h"
        } else {
#line 5 "../hw/ssi/trace-events"
            qemu_log("aspeed_smc_do_snoop " "CS%d index:0x%x dummies:%d data:0x%x" "\n", cs, index, dummies, data);
#line 223 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_aspeed_smc_do_snoop(int cs, int index, int dummies, int data)
{
    if (true) {
        _nocheck__trace_aspeed_smc_do_snoop(cs, index, dummies, data);
    }
}

#define TRACE_ASPEED_SMC_FLASH_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ASPEED_SMC_FLASH_WRITE) || \
    false)

static inline void _nocheck__trace_aspeed_smc_flash_write(int cs, uint64_t addr, uint32_t size, uint64_t data, int mode)
{
    if (trace_event_get_state(TRACE_ASPEED_SMC_FLASH_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 6 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:aspeed_smc_flash_write " "CS%d @0x%" PRIx64 " size %u: 0x%" PRIx64" mode:%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cs, addr, size, data, mode);
#line 250 "trace/trace-hw_ssi.h"
        } else {
#line 6 "../hw/ssi/trace-events"
            qemu_log("aspeed_smc_flash_write " "CS%d @0x%" PRIx64 " size %u: 0x%" PRIx64" mode:%d" "\n", cs, addr, size, data, mode);
#line 254 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_aspeed_smc_flash_write(int cs, uint64_t addr, uint32_t size, uint64_t data, int mode)
{
    if (true) {
        _nocheck__trace_aspeed_smc_flash_write(cs, addr, size, data, mode);
    }
}

#define TRACE_ASPEED_SMC_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ASPEED_SMC_READ) || \
    false)

static inline void _nocheck__trace_aspeed_smc_read(uint64_t addr, uint32_t size, uint64_t data)
{
    if (trace_event_get_state(TRACE_ASPEED_SMC_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 7 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:aspeed_smc_read " "@0x%" PRIx64 " size %u: 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, size, data);
#line 281 "trace/trace-hw_ssi.h"
        } else {
#line 7 "../hw/ssi/trace-events"
            qemu_log("aspeed_smc_read " "@0x%" PRIx64 " size %u: 0x%" PRIx64 "\n", addr, size, data);
#line 285 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_aspeed_smc_read(uint64_t addr, uint32_t size, uint64_t data)
{
    if (true) {
        _nocheck__trace_aspeed_smc_read(addr, size, data);
    }
}

#define TRACE_ASPEED_SMC_DMA_CHECKSUM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ASPEED_SMC_DMA_CHECKSUM) || \
    false)

static inline void _nocheck__trace_aspeed_smc_dma_checksum(uint32_t addr, uint32_t data)
{
    if (trace_event_get_state(TRACE_ASPEED_SMC_DMA_CHECKSUM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 8 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:aspeed_smc_dma_checksum " "0x%08x: 0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, data);
#line 312 "trace/trace-hw_ssi.h"
        } else {
#line 8 "../hw/ssi/trace-events"
            qemu_log("aspeed_smc_dma_checksum " "0x%08x: 0x%08x" "\n", addr, data);
#line 316 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_aspeed_smc_dma_checksum(uint32_t addr, uint32_t data)
{
    if (true) {
        _nocheck__trace_aspeed_smc_dma_checksum(addr, data);
    }
}

#define TRACE_ASPEED_SMC_DMA_RW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ASPEED_SMC_DMA_RW) || \
    false)

static inline void _nocheck__trace_aspeed_smc_dma_rw(const char * dir, uint32_t flash_addr, uint64_t dram_addr, uint32_t size)
{
    if (trace_event_get_state(TRACE_ASPEED_SMC_DMA_RW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 9 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:aspeed_smc_dma_rw " "%s flash:@0x%08x dram:@0x%" PRIx64 " size:0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dir, flash_addr, dram_addr, size);
#line 343 "trace/trace-hw_ssi.h"
        } else {
#line 9 "../hw/ssi/trace-events"
            qemu_log("aspeed_smc_dma_rw " "%s flash:@0x%08x dram:@0x%" PRIx64 " size:0x%08x" "\n", dir, flash_addr, dram_addr, size);
#line 347 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_aspeed_smc_dma_rw(const char * dir, uint32_t flash_addr, uint64_t dram_addr, uint32_t size)
{
    if (true) {
        _nocheck__trace_aspeed_smc_dma_rw(dir, flash_addr, dram_addr, size);
    }
}

#define TRACE_ASPEED_SMC_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ASPEED_SMC_WRITE) || \
    false)

static inline void _nocheck__trace_aspeed_smc_write(uint64_t addr, uint32_t size, uint64_t data)
{
    if (trace_event_get_state(TRACE_ASPEED_SMC_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 10 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:aspeed_smc_write " "@0x%" PRIx64 " size %u: 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, size, data);
#line 374 "trace/trace-hw_ssi.h"
        } else {
#line 10 "../hw/ssi/trace-events"
            qemu_log("aspeed_smc_write " "@0x%" PRIx64 " size %u: 0x%" PRIx64 "\n", addr, size, data);
#line 378 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_aspeed_smc_write(uint64_t addr, uint32_t size, uint64_t data)
{
    if (true) {
        _nocheck__trace_aspeed_smc_write(addr, size, data);
    }
}

#define TRACE_ASPEED_SMC_FLASH_SELECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ASPEED_SMC_FLASH_SELECT) || \
    false)

static inline void _nocheck__trace_aspeed_smc_flash_select(int cs, const char * prefix)
{
    if (trace_event_get_state(TRACE_ASPEED_SMC_FLASH_SELECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 11 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:aspeed_smc_flash_select " "CS%d %sselect" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cs, prefix);
#line 405 "trace/trace-hw_ssi.h"
        } else {
#line 11 "../hw/ssi/trace-events"
            qemu_log("aspeed_smc_flash_select " "CS%d %sselect" "\n", cs, prefix);
#line 409 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_aspeed_smc_flash_select(int cs, const char * prefix)
{
    if (true) {
        _nocheck__trace_aspeed_smc_flash_select(cs, prefix);
    }
}

#define TRACE_NPCM7XX_FIU_ENTER_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NPCM7XX_FIU_ENTER_RESET) || \
    false)

static inline void _nocheck__trace_npcm7xx_fiu_enter_reset(const char * id, int reset_type)
{
    if (trace_event_get_state(TRACE_NPCM7XX_FIU_ENTER_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 15 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:npcm7xx_fiu_enter_reset " "%s reset type: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, reset_type);
#line 436 "trace/trace-hw_ssi.h"
        } else {
#line 15 "../hw/ssi/trace-events"
            qemu_log("npcm7xx_fiu_enter_reset " "%s reset type: %d" "\n", id, reset_type);
#line 440 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_npcm7xx_fiu_enter_reset(const char * id, int reset_type)
{
    if (true) {
        _nocheck__trace_npcm7xx_fiu_enter_reset(id, reset_type);
    }
}

#define TRACE_NPCM7XX_FIU_HOLD_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NPCM7XX_FIU_HOLD_RESET) || \
    false)

static inline void _nocheck__trace_npcm7xx_fiu_hold_reset(const char * id)
{
    if (trace_event_get_state(TRACE_NPCM7XX_FIU_HOLD_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 16 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:npcm7xx_fiu_hold_reset " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id);
#line 467 "trace/trace-hw_ssi.h"
        } else {
#line 16 "../hw/ssi/trace-events"
            qemu_log("npcm7xx_fiu_hold_reset " "%s" "\n", id);
#line 471 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_npcm7xx_fiu_hold_reset(const char * id)
{
    if (true) {
        _nocheck__trace_npcm7xx_fiu_hold_reset(id);
    }
}

#define TRACE_NPCM7XX_FIU_SELECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NPCM7XX_FIU_SELECT) || \
    false)

static inline void _nocheck__trace_npcm7xx_fiu_select(const char * id, int cs)
{
    if (trace_event_get_state(TRACE_NPCM7XX_FIU_SELECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 17 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:npcm7xx_fiu_select " "%s select CS%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, cs);
#line 498 "trace/trace-hw_ssi.h"
        } else {
#line 17 "../hw/ssi/trace-events"
            qemu_log("npcm7xx_fiu_select " "%s select CS%d" "\n", id, cs);
#line 502 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_npcm7xx_fiu_select(const char * id, int cs)
{
    if (true) {
        _nocheck__trace_npcm7xx_fiu_select(id, cs);
    }
}

#define TRACE_NPCM7XX_FIU_DESELECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NPCM7XX_FIU_DESELECT) || \
    false)

static inline void _nocheck__trace_npcm7xx_fiu_deselect(const char * id, int cs)
{
    if (trace_event_get_state(TRACE_NPCM7XX_FIU_DESELECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 18 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:npcm7xx_fiu_deselect " "%s deselect CS%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, cs);
#line 529 "trace/trace-hw_ssi.h"
        } else {
#line 18 "../hw/ssi/trace-events"
            qemu_log("npcm7xx_fiu_deselect " "%s deselect CS%d" "\n", id, cs);
#line 533 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_npcm7xx_fiu_deselect(const char * id, int cs)
{
    if (true) {
        _nocheck__trace_npcm7xx_fiu_deselect(id, cs);
    }
}

#define TRACE_NPCM7XX_FIU_CTRL_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NPCM7XX_FIU_CTRL_READ) || \
    false)

static inline void _nocheck__trace_npcm7xx_fiu_ctrl_read(const char * id, uint64_t addr, uint32_t data)
{
    if (trace_event_get_state(TRACE_NPCM7XX_FIU_CTRL_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 19 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:npcm7xx_fiu_ctrl_read " "%s offset: 0x%04" PRIx64 " value: 0x%08" PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, addr, data);
#line 560 "trace/trace-hw_ssi.h"
        } else {
#line 19 "../hw/ssi/trace-events"
            qemu_log("npcm7xx_fiu_ctrl_read " "%s offset: 0x%04" PRIx64 " value: 0x%08" PRIx32 "\n", id, addr, data);
#line 564 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_npcm7xx_fiu_ctrl_read(const char * id, uint64_t addr, uint32_t data)
{
    if (true) {
        _nocheck__trace_npcm7xx_fiu_ctrl_read(id, addr, data);
    }
}

#define TRACE_NPCM7XX_FIU_CTRL_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NPCM7XX_FIU_CTRL_WRITE) || \
    false)

static inline void _nocheck__trace_npcm7xx_fiu_ctrl_write(const char * id, uint64_t addr, uint32_t data)
{
    if (trace_event_get_state(TRACE_NPCM7XX_FIU_CTRL_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 20 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:npcm7xx_fiu_ctrl_write " "%s offset: 0x%04" PRIx64 " value: 0x%08" PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, addr, data);
#line 591 "trace/trace-hw_ssi.h"
        } else {
#line 20 "../hw/ssi/trace-events"
            qemu_log("npcm7xx_fiu_ctrl_write " "%s offset: 0x%04" PRIx64 " value: 0x%08" PRIx32 "\n", id, addr, data);
#line 595 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_npcm7xx_fiu_ctrl_write(const char * id, uint64_t addr, uint32_t data)
{
    if (true) {
        _nocheck__trace_npcm7xx_fiu_ctrl_write(id, addr, data);
    }
}

#define TRACE_NPCM7XX_FIU_FLASH_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NPCM7XX_FIU_FLASH_READ) || \
    false)

static inline void _nocheck__trace_npcm7xx_fiu_flash_read(const char * id, int cs, uint64_t addr, unsigned int size, uint64_t value)
{
    if (trace_event_get_state(TRACE_NPCM7XX_FIU_FLASH_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 21 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:npcm7xx_fiu_flash_read " "%s[%d] offset: 0x%08" PRIx64 " size: %u value: 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, cs, addr, size, value);
#line 622 "trace/trace-hw_ssi.h"
        } else {
#line 21 "../hw/ssi/trace-events"
            qemu_log("npcm7xx_fiu_flash_read " "%s[%d] offset: 0x%08" PRIx64 " size: %u value: 0x%" PRIx64 "\n", id, cs, addr, size, value);
#line 626 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_npcm7xx_fiu_flash_read(const char * id, int cs, uint64_t addr, unsigned int size, uint64_t value)
{
    if (true) {
        _nocheck__trace_npcm7xx_fiu_flash_read(id, cs, addr, size, value);
    }
}

#define TRACE_NPCM7XX_FIU_FLASH_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NPCM7XX_FIU_FLASH_WRITE) || \
    false)

static inline void _nocheck__trace_npcm7xx_fiu_flash_write(const char * id, unsigned cs, uint64_t addr, unsigned int size, uint64_t value)
{
    if (trace_event_get_state(TRACE_NPCM7XX_FIU_FLASH_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 22 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:npcm7xx_fiu_flash_write " "%s[%d] offset: 0x%08" PRIx64 " size: %u value: 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, cs, addr, size, value);
#line 653 "trace/trace-hw_ssi.h"
        } else {
#line 22 "../hw/ssi/trace-events"
            qemu_log("npcm7xx_fiu_flash_write " "%s[%d] offset: 0x%08" PRIx64 " size: %u value: 0x%" PRIx64 "\n", id, cs, addr, size, value);
#line 657 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_npcm7xx_fiu_flash_write(const char * id, unsigned cs, uint64_t addr, unsigned int size, uint64_t value)
{
    if (true) {
        _nocheck__trace_npcm7xx_fiu_flash_write(id, cs, addr, size, value);
    }
}

#define TRACE_NPCM_PSPI_ENTER_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NPCM_PSPI_ENTER_RESET) || \
    false)

static inline void _nocheck__trace_npcm_pspi_enter_reset(const char * id, int reset_type)
{
    if (trace_event_get_state(TRACE_NPCM_PSPI_ENTER_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 25 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:npcm_pspi_enter_reset " "%s reset type: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, reset_type);
#line 684 "trace/trace-hw_ssi.h"
        } else {
#line 25 "../hw/ssi/trace-events"
            qemu_log("npcm_pspi_enter_reset " "%s reset type: %d" "\n", id, reset_type);
#line 688 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_npcm_pspi_enter_reset(const char * id, int reset_type)
{
    if (true) {
        _nocheck__trace_npcm_pspi_enter_reset(id, reset_type);
    }
}

#define TRACE_NPCM_PSPI_CTRL_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NPCM_PSPI_CTRL_READ) || \
    false)

static inline void _nocheck__trace_npcm_pspi_ctrl_read(const char * id, uint64_t addr, uint16_t data)
{
    if (trace_event_get_state(TRACE_NPCM_PSPI_CTRL_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 26 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:npcm_pspi_ctrl_read " "%s offset: 0x%03" PRIx64 " value: 0x%04" PRIx16 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, addr, data);
#line 715 "trace/trace-hw_ssi.h"
        } else {
#line 26 "../hw/ssi/trace-events"
            qemu_log("npcm_pspi_ctrl_read " "%s offset: 0x%03" PRIx64 " value: 0x%04" PRIx16 "\n", id, addr, data);
#line 719 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_npcm_pspi_ctrl_read(const char * id, uint64_t addr, uint16_t data)
{
    if (true) {
        _nocheck__trace_npcm_pspi_ctrl_read(id, addr, data);
    }
}

#define TRACE_NPCM_PSPI_CTRL_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NPCM_PSPI_CTRL_WRITE) || \
    false)

static inline void _nocheck__trace_npcm_pspi_ctrl_write(const char * id, uint64_t addr, uint16_t data)
{
    if (trace_event_get_state(TRACE_NPCM_PSPI_CTRL_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 27 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:npcm_pspi_ctrl_write " "%s offset: 0x%03" PRIx64 " value: 0x%04" PRIx16 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, addr, data);
#line 746 "trace/trace-hw_ssi.h"
        } else {
#line 27 "../hw/ssi/trace-events"
            qemu_log("npcm_pspi_ctrl_write " "%s offset: 0x%03" PRIx64 " value: 0x%04" PRIx16 "\n", id, addr, data);
#line 750 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_npcm_pspi_ctrl_write(const char * id, uint64_t addr, uint16_t data)
{
    if (true) {
        _nocheck__trace_npcm_pspi_ctrl_write(id, addr, data);
    }
}

#define TRACE_IBEX_SPI_HOST_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IBEX_SPI_HOST_RESET) || \
    false)

static inline void _nocheck__trace_ibex_spi_host_reset(const char * msg)
{
    if (trace_event_get_state(TRACE_IBEX_SPI_HOST_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 31 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:ibex_spi_host_reset " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , msg);
#line 777 "trace/trace-hw_ssi.h"
        } else {
#line 31 "../hw/ssi/trace-events"
            qemu_log("ibex_spi_host_reset " "%s" "\n", msg);
#line 781 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_ibex_spi_host_reset(const char * msg)
{
    if (true) {
        _nocheck__trace_ibex_spi_host_reset(msg);
    }
}

#define TRACE_IBEX_SPI_HOST_TRANSFER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IBEX_SPI_HOST_TRANSFER) || \
    false)

static inline void _nocheck__trace_ibex_spi_host_transfer(uint32_t tx_data, uint32_t rx_data)
{
    if (trace_event_get_state(TRACE_IBEX_SPI_HOST_TRANSFER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 32 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:ibex_spi_host_transfer " "tx_data: 0x%" PRIx32 " rx_data: @0x%" PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tx_data, rx_data);
#line 808 "trace/trace-hw_ssi.h"
        } else {
#line 32 "../hw/ssi/trace-events"
            qemu_log("ibex_spi_host_transfer " "tx_data: 0x%" PRIx32 " rx_data: @0x%" PRIx32 "\n", tx_data, rx_data);
#line 812 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_ibex_spi_host_transfer(uint32_t tx_data, uint32_t rx_data)
{
    if (true) {
        _nocheck__trace_ibex_spi_host_transfer(tx_data, rx_data);
    }
}

#define TRACE_IBEX_SPI_HOST_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IBEX_SPI_HOST_WRITE) || \
    false)

static inline void _nocheck__trace_ibex_spi_host_write(uint64_t addr, uint32_t size, uint64_t data)
{
    if (trace_event_get_state(TRACE_IBEX_SPI_HOST_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 33 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:ibex_spi_host_write " "@0x%" PRIx64 " size %u: 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, size, data);
#line 839 "trace/trace-hw_ssi.h"
        } else {
#line 33 "../hw/ssi/trace-events"
            qemu_log("ibex_spi_host_write " "@0x%" PRIx64 " size %u: 0x%" PRIx64 "\n", addr, size, data);
#line 843 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_ibex_spi_host_write(uint64_t addr, uint32_t size, uint64_t data)
{
    if (true) {
        _nocheck__trace_ibex_spi_host_write(addr, size, data);
    }
}

#define TRACE_IBEX_SPI_HOST_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IBEX_SPI_HOST_READ) || \
    false)

static inline void _nocheck__trace_ibex_spi_host_read(uint64_t addr, uint32_t size)
{
    if (trace_event_get_state(TRACE_IBEX_SPI_HOST_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 34 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:ibex_spi_host_read " "@0x%" PRIx64 " size %u:" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, size);
#line 870 "trace/trace-hw_ssi.h"
        } else {
#line 34 "../hw/ssi/trace-events"
            qemu_log("ibex_spi_host_read " "@0x%" PRIx64 " size %u:" "\n", addr, size);
#line 874 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_ibex_spi_host_read(uint64_t addr, uint32_t size)
{
    if (true) {
        _nocheck__trace_ibex_spi_host_read(addr, size);
    }
}

#define TRACE_PNV_SPI_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PNV_SPI_READ) || \
    false)

static inline void _nocheck__trace_pnv_spi_read(uint64_t addr, uint64_t val)
{
    if (trace_event_get_state(TRACE_PNV_SPI_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 37 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:pnv_spi_read " "addr 0x%" PRIx64 " val 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 901 "trace/trace-hw_ssi.h"
        } else {
#line 37 "../hw/ssi/trace-events"
            qemu_log("pnv_spi_read " "addr 0x%" PRIx64 " val 0x%" PRIx64 "\n", addr, val);
#line 905 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_pnv_spi_read(uint64_t addr, uint64_t val)
{
    if (true) {
        _nocheck__trace_pnv_spi_read(addr, val);
    }
}

#define TRACE_PNV_SPI_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PNV_SPI_WRITE) || \
    false)

static inline void _nocheck__trace_pnv_spi_write(uint64_t addr, uint64_t val)
{
    if (trace_event_get_state(TRACE_PNV_SPI_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 38 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:pnv_spi_write " "addr 0x%" PRIx64 " val 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 932 "trace/trace-hw_ssi.h"
        } else {
#line 38 "../hw/ssi/trace-events"
            qemu_log("pnv_spi_write " "addr 0x%" PRIx64 " val 0x%" PRIx64 "\n", addr, val);
#line 936 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_pnv_spi_write(uint64_t addr, uint64_t val)
{
    if (true) {
        _nocheck__trace_pnv_spi_write(addr, val);
    }
}

#define TRACE_PNV_SPI_READ_RDR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PNV_SPI_READ_RDR) || \
    false)

static inline void _nocheck__trace_pnv_spi_read_RDR(uint64_t val)
{
    if (trace_event_get_state(TRACE_PNV_SPI_READ_RDR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 39 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:pnv_spi_read_RDR " "data extracted = 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 963 "trace/trace-hw_ssi.h"
        } else {
#line 39 "../hw/ssi/trace-events"
            qemu_log("pnv_spi_read_RDR " "data extracted = 0x%" PRIx64 "\n", val);
#line 967 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_pnv_spi_read_RDR(uint64_t val)
{
    if (true) {
        _nocheck__trace_pnv_spi_read_RDR(val);
    }
}

#define TRACE_PNV_SPI_WRITE_TDR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PNV_SPI_WRITE_TDR) || \
    false)

static inline void _nocheck__trace_pnv_spi_write_TDR(uint64_t val)
{
    if (trace_event_get_state(TRACE_PNV_SPI_WRITE_TDR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 40 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:pnv_spi_write_TDR " "being written, data written = 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 994 "trace/trace-hw_ssi.h"
        } else {
#line 40 "../hw/ssi/trace-events"
            qemu_log("pnv_spi_write_TDR " "being written, data written = 0x%" PRIx64 "\n", val);
#line 998 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_pnv_spi_write_TDR(uint64_t val)
{
    if (true) {
        _nocheck__trace_pnv_spi_write_TDR(val);
    }
}

#define TRACE_PNV_SPI_START_SEQUENCER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PNV_SPI_START_SEQUENCER) || \
    false)

static inline void _nocheck__trace_pnv_spi_start_sequencer(void)
{
    if (trace_event_get_state(TRACE_PNV_SPI_START_SEQUENCER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 41 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:pnv_spi_start_sequencer " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1025 "trace/trace-hw_ssi.h"
        } else {
#line 41 "../hw/ssi/trace-events"
            qemu_log("pnv_spi_start_sequencer " "" "\n");
#line 1029 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_pnv_spi_start_sequencer(void)
{
    if (true) {
        _nocheck__trace_pnv_spi_start_sequencer();
    }
}

#define TRACE_PNV_SPI_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PNV_SPI_RESET) || \
    false)

static inline void _nocheck__trace_pnv_spi_reset(void)
{
    if (trace_event_get_state(TRACE_PNV_SPI_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 42 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:pnv_spi_reset " "spic engine sequencer configuration and spi communication" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1056 "trace/trace-hw_ssi.h"
        } else {
#line 42 "../hw/ssi/trace-events"
            qemu_log("pnv_spi_reset " "spic engine sequencer configuration and spi communication" "\n");
#line 1060 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_pnv_spi_reset(void)
{
    if (true) {
        _nocheck__trace_pnv_spi_reset();
    }
}

#define TRACE_PNV_SPI_SEQUENCER_OP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PNV_SPI_SEQUENCER_OP) || \
    false)

static inline void _nocheck__trace_pnv_spi_sequencer_op(const char* op, uint8_t index)
{
    if (trace_event_get_state(TRACE_PNV_SPI_SEQUENCER_OP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 43 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:pnv_spi_sequencer_op " "%s at index = 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , op, index);
#line 1087 "trace/trace-hw_ssi.h"
        } else {
#line 43 "../hw/ssi/trace-events"
            qemu_log("pnv_spi_sequencer_op " "%s at index = 0x%x" "\n", op, index);
#line 1091 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_pnv_spi_sequencer_op(const char* op, uint8_t index)
{
    if (true) {
        _nocheck__trace_pnv_spi_sequencer_op(op, index);
    }
}

#define TRACE_PNV_SPI_SHIFTER_STATING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PNV_SPI_SHIFTER_STATING) || \
    false)

static inline void _nocheck__trace_pnv_spi_shifter_stating(void)
{
    if (trace_event_get_state(TRACE_PNV_SPI_SHIFTER_STATING) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 44 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:pnv_spi_shifter_stating " "pull CS line low" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1118 "trace/trace-hw_ssi.h"
        } else {
#line 44 "../hw/ssi/trace-events"
            qemu_log("pnv_spi_shifter_stating " "pull CS line low" "\n");
#line 1122 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_pnv_spi_shifter_stating(void)
{
    if (true) {
        _nocheck__trace_pnv_spi_shifter_stating();
    }
}

#define TRACE_PNV_SPI_SHIFTER_DONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PNV_SPI_SHIFTER_DONE) || \
    false)

static inline void _nocheck__trace_pnv_spi_shifter_done(void)
{
    if (trace_event_get_state(TRACE_PNV_SPI_SHIFTER_DONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 45 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:pnv_spi_shifter_done " "pull the CS line high" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1149 "trace/trace-hw_ssi.h"
        } else {
#line 45 "../hw/ssi/trace-events"
            qemu_log("pnv_spi_shifter_done " "pull the CS line high" "\n");
#line 1153 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_pnv_spi_shifter_done(void)
{
    if (true) {
        _nocheck__trace_pnv_spi_shifter_done();
    }
}

#define TRACE_PNV_SPI_LOG_NCOUNTS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PNV_SPI_LOG_NCOUNTS) || \
    false)

static inline void _nocheck__trace_pnv_spi_log_Ncounts(uint8_t N1_bits, uint8_t N1_bytes, uint8_t N1_tx, uint8_t N1_rx, uint8_t N2_bits, uint8_t N2_bytes, uint8_t N2_tx, uint8_t N2_rx)
{
    if (trace_event_get_state(TRACE_PNV_SPI_LOG_NCOUNTS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 46 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:pnv_spi_log_Ncounts " "N1_bits = %d, N1_bytes = %d, N1_tx = %d, N1_rx = %d, N2_bits = %d, N2_bytes = %d, N2_tx = %d, N2_rx = %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , N1_bits, N1_bytes, N1_tx, N1_rx, N2_bits, N2_bytes, N2_tx, N2_rx);
#line 1180 "trace/trace-hw_ssi.h"
        } else {
#line 46 "../hw/ssi/trace-events"
            qemu_log("pnv_spi_log_Ncounts " "N1_bits = %d, N1_bytes = %d, N1_tx = %d, N1_rx = %d, N2_bits = %d, N2_bytes = %d, N2_tx = %d, N2_rx = %d" "\n", N1_bits, N1_bytes, N1_tx, N1_rx, N2_bits, N2_bytes, N2_tx, N2_rx);
#line 1184 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_pnv_spi_log_Ncounts(uint8_t N1_bits, uint8_t N1_bytes, uint8_t N1_tx, uint8_t N1_rx, uint8_t N2_bits, uint8_t N2_bytes, uint8_t N2_tx, uint8_t N2_rx)
{
    if (true) {
        _nocheck__trace_pnv_spi_log_Ncounts(N1_bits, N1_bytes, N1_tx, N1_rx, N2_bits, N2_bytes, N2_tx, N2_rx);
    }
}

#define TRACE_PNV_SPI_TX_APPEND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PNV_SPI_TX_APPEND) || \
    false)

static inline void _nocheck__trace_pnv_spi_tx_append(const char* frame, uint8_t byte, uint8_t tdr_index)
{
    if (trace_event_get_state(TRACE_PNV_SPI_TX_APPEND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 47 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:pnv_spi_tx_append " "%s = 0x%2.2x to payload from TDR at index %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , frame, byte, tdr_index);
#line 1211 "trace/trace-hw_ssi.h"
        } else {
#line 47 "../hw/ssi/trace-events"
            qemu_log("pnv_spi_tx_append " "%s = 0x%2.2x to payload from TDR at index %d" "\n", frame, byte, tdr_index);
#line 1215 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_pnv_spi_tx_append(const char* frame, uint8_t byte, uint8_t tdr_index)
{
    if (true) {
        _nocheck__trace_pnv_spi_tx_append(frame, byte, tdr_index);
    }
}

#define TRACE_PNV_SPI_TX_APPEND_FF_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PNV_SPI_TX_APPEND_FF) || \
    false)

static inline void _nocheck__trace_pnv_spi_tx_append_FF(const char* frame)
{
    if (trace_event_get_state(TRACE_PNV_SPI_TX_APPEND_FF) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 48 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:pnv_spi_tx_append_FF " "%s to Payload" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , frame);
#line 1242 "trace/trace-hw_ssi.h"
        } else {
#line 48 "../hw/ssi/trace-events"
            qemu_log("pnv_spi_tx_append_FF " "%s to Payload" "\n", frame);
#line 1246 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_pnv_spi_tx_append_FF(const char* frame)
{
    if (true) {
        _nocheck__trace_pnv_spi_tx_append_FF(frame);
    }
}

#define TRACE_PNV_SPI_TX_REQUEST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PNV_SPI_TX_REQUEST) || \
    false)

static inline void _nocheck__trace_pnv_spi_tx_request(const char* frame, uint32_t payload_len)
{
    if (trace_event_get_state(TRACE_PNV_SPI_TX_REQUEST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 49 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:pnv_spi_tx_request " "%s, payload len = %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , frame, payload_len);
#line 1273 "trace/trace-hw_ssi.h"
        } else {
#line 49 "../hw/ssi/trace-events"
            qemu_log("pnv_spi_tx_request " "%s, payload len = %d" "\n", frame, payload_len);
#line 1277 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_pnv_spi_tx_request(const char* frame, uint32_t payload_len)
{
    if (true) {
        _nocheck__trace_pnv_spi_tx_request(frame, payload_len);
    }
}

#define TRACE_PNV_SPI_RX_RECEIVED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PNV_SPI_RX_RECEIVED) || \
    false)

static inline void _nocheck__trace_pnv_spi_rx_received(uint32_t payload_len)
{
    if (trace_event_get_state(TRACE_PNV_SPI_RX_RECEIVED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 50 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:pnv_spi_rx_received " "payload len = %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , payload_len);
#line 1304 "trace/trace-hw_ssi.h"
        } else {
#line 50 "../hw/ssi/trace-events"
            qemu_log("pnv_spi_rx_received " "payload len = %d" "\n", payload_len);
#line 1308 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_pnv_spi_rx_received(uint32_t payload_len)
{
    if (true) {
        _nocheck__trace_pnv_spi_rx_received(payload_len);
    }
}

#define TRACE_PNV_SPI_RX_READ_N1FRAME_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PNV_SPI_RX_READ_N1FRAME) || \
    false)

static inline void _nocheck__trace_pnv_spi_rx_read_N1frame(void)
{
    if (trace_event_get_state(TRACE_PNV_SPI_RX_READ_N1FRAME) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 51 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:pnv_spi_rx_read_N1frame " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1335 "trace/trace-hw_ssi.h"
        } else {
#line 51 "../hw/ssi/trace-events"
            qemu_log("pnv_spi_rx_read_N1frame " "" "\n");
#line 1339 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_pnv_spi_rx_read_N1frame(void)
{
    if (true) {
        _nocheck__trace_pnv_spi_rx_read_N1frame();
    }
}

#define TRACE_PNV_SPI_RX_READ_N2FRAME_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PNV_SPI_RX_READ_N2FRAME) || \
    false)

static inline void _nocheck__trace_pnv_spi_rx_read_N2frame(void)
{
    if (trace_event_get_state(TRACE_PNV_SPI_RX_READ_N2FRAME) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 52 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:pnv_spi_rx_read_N2frame " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1366 "trace/trace-hw_ssi.h"
        } else {
#line 52 "../hw/ssi/trace-events"
            qemu_log("pnv_spi_rx_read_N2frame " "" "\n");
#line 1370 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_pnv_spi_rx_read_N2frame(void)
{
    if (true) {
        _nocheck__trace_pnv_spi_rx_read_N2frame();
    }
}

#define TRACE_PNV_SPI_SHIFT_RX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PNV_SPI_SHIFT_RX) || \
    false)

static inline void _nocheck__trace_pnv_spi_shift_rx(uint8_t byte, uint32_t index)
{
    if (trace_event_get_state(TRACE_PNV_SPI_SHIFT_RX) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 53 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:pnv_spi_shift_rx " "byte = 0x%2.2x into RDR from payload index %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , byte, index);
#line 1397 "trace/trace-hw_ssi.h"
        } else {
#line 53 "../hw/ssi/trace-events"
            qemu_log("pnv_spi_shift_rx " "byte = 0x%2.2x into RDR from payload index %d" "\n", byte, index);
#line 1401 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_pnv_spi_shift_rx(uint8_t byte, uint32_t index)
{
    if (true) {
        _nocheck__trace_pnv_spi_shift_rx(byte, index);
    }
}

#define TRACE_PNV_SPI_SEQUENCER_STOP_REQUESTED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PNV_SPI_SEQUENCER_STOP_REQUESTED) || \
    false)

static inline void _nocheck__trace_pnv_spi_sequencer_stop_requested(const char* reason)
{
    if (trace_event_get_state(TRACE_PNV_SPI_SEQUENCER_STOP_REQUESTED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 54 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:pnv_spi_sequencer_stop_requested " "due to %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reason);
#line 1428 "trace/trace-hw_ssi.h"
        } else {
#line 54 "../hw/ssi/trace-events"
            qemu_log("pnv_spi_sequencer_stop_requested " "due to %s" "\n", reason);
#line 1432 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_pnv_spi_sequencer_stop_requested(const char* reason)
{
    if (true) {
        _nocheck__trace_pnv_spi_sequencer_stop_requested(reason);
    }
}

#define TRACE_PNV_SPI_RDR_MATCH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PNV_SPI_RDR_MATCH) || \
    false)

static inline void _nocheck__trace_pnv_spi_RDR_match(const char* result)
{
    if (trace_event_get_state(TRACE_PNV_SPI_RDR_MATCH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 55 "../hw/ssi/trace-events"
            qemu_log("%d@%zu.%06zu:pnv_spi_RDR_match " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , result);
#line 1459 "trace/trace-hw_ssi.h"
        } else {
#line 55 "../hw/ssi/trace-events"
            qemu_log("pnv_spi_RDR_match " "%s" "\n", result);
#line 1463 "trace/trace-hw_ssi.h"
        }
    }
}

static inline void trace_pnv_spi_RDR_match(const char* result)
{
    if (true) {
        _nocheck__trace_pnv_spi_RDR_match(result);
    }
}
#endif /* TRACE_HW_SSI_GENERATED_TRACERS_H */
