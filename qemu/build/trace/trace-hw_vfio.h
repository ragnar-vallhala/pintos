/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_VFIO_GENERATED_TRACERS_H
#define TRACE_HW_VFIO_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_VFIO_INTX_INTERRUPT_EVENT;
extern TraceEvent _TRACE_VFIO_INTX_EOI_EVENT;
extern TraceEvent _TRACE_VFIO_INTX_ENABLE_KVM_EVENT;
extern TraceEvent _TRACE_VFIO_INTX_DISABLE_KVM_EVENT;
extern TraceEvent _TRACE_VFIO_INTX_UPDATE_EVENT;
extern TraceEvent _TRACE_VFIO_INTX_ENABLE_EVENT;
extern TraceEvent _TRACE_VFIO_INTX_DISABLE_EVENT;
extern TraceEvent _TRACE_VFIO_MSI_INTERRUPT_EVENT;
extern TraceEvent _TRACE_VFIO_MSIX_VECTOR_DO_USE_EVENT;
extern TraceEvent _TRACE_VFIO_MSIX_VECTOR_RELEASE_EVENT;
extern TraceEvent _TRACE_VFIO_MSIX_ENABLE_EVENT;
extern TraceEvent _TRACE_VFIO_MSIX_PBA_DISABLE_EVENT;
extern TraceEvent _TRACE_VFIO_MSIX_PBA_ENABLE_EVENT;
extern TraceEvent _TRACE_VFIO_MSIX_DISABLE_EVENT;
extern TraceEvent _TRACE_VFIO_MSIX_FIXUP_EVENT;
extern TraceEvent _TRACE_VFIO_MSIX_RELO_EVENT;
extern TraceEvent _TRACE_VFIO_MSI_ENABLE_EVENT;
extern TraceEvent _TRACE_VFIO_MSI_DISABLE_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_LOAD_ROM_EVENT;
extern TraceEvent _TRACE_VFIO_ROM_READ_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_SIZE_ROM_EVENT;
extern TraceEvent _TRACE_VFIO_VGA_WRITE_EVENT;
extern TraceEvent _TRACE_VFIO_VGA_READ_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_READ_CONFIG_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_WRITE_CONFIG_EVENT;
extern TraceEvent _TRACE_VFIO_MSI_SETUP_EVENT;
extern TraceEvent _TRACE_VFIO_MSIX_EARLY_SETUP_EVENT;
extern TraceEvent _TRACE_VFIO_CHECK_PCIE_FLR_EVENT;
extern TraceEvent _TRACE_VFIO_CHECK_PM_RESET_EVENT;
extern TraceEvent _TRACE_VFIO_CHECK_AF_FLR_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_HOT_RESET_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_HOT_RESET_HAS_DEP_DEVICES_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_HOT_RESET_DEP_DEVICES_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_HOT_RESET_RESULT_EVENT;
extern TraceEvent _TRACE_VFIO_POPULATE_DEVICE_CONFIG_EVENT;
extern TraceEvent _TRACE_VFIO_POPULATE_DEVICE_GET_IRQ_INFO_FAILURE_EVENT;
extern TraceEvent _TRACE_VFIO_ATTACH_DEVICE_EVENT;
extern TraceEvent _TRACE_VFIO_DETACH_DEVICE_EVENT;
extern TraceEvent _TRACE_VFIO_MDEV_EVENT;
extern TraceEvent _TRACE_VFIO_ADD_EXT_CAP_DROPPED_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_RESET_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_RESET_FLR_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_RESET_PM_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_EMULATED_VENDOR_ID_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_EMULATED_DEVICE_ID_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_EMULATED_SUB_VENDOR_ID_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_EMULATED_SUB_DEVICE_ID_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_ROM_IN_DENYLIST_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_GENERIC_WINDOW_ADDRESS_WRITE_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_GENERIC_WINDOW_DATA_READ_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_GENERIC_WINDOW_DATA_WRITE_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_GENERIC_MIRROR_READ_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_GENERIC_MIRROR_WRITE_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_ATI_3C3_READ_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_ATI_3C3_PROBE_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_ATI_BAR4_PROBE_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_ATI_BAR2_PROBE_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_NVIDIA_3D0_STATE_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_NVIDIA_3D0_READ_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_NVIDIA_3D0_WRITE_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_NVIDIA_3D0_PROBE_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_NVIDIA_BAR5_STATE_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_NVIDIA_BAR5_PROBE_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_NVIDIA_BAR0_MSI_ACK_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_NVIDIA_BAR0_PROBE_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_RTL8168_FAKE_LATCH_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_RTL8168_MSIX_WRITE_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_RTL8168_MSIX_READ_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_RTL8168_PROBE_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_SKIPPED_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_NO_SMC_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_TIMEOUT_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_DONE_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_EVENT;
extern TraceEvent _TRACE_VFIO_IOEVENTFD_EXIT_EVENT;
extern TraceEvent _TRACE_VFIO_IOEVENTFD_HANDLER_EVENT;
extern TraceEvent _TRACE_VFIO_IOEVENTFD_INIT_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_IGD_OPREGION_ENABLED_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_IGD_BAR4_WRITE_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_IGD_BDSM_ENABLED_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_IGD_HOST_BRIDGE_ENABLED_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_IGD_LPC_BRIDGE_ENABLED_EVENT;
extern TraceEvent _TRACE_VFIO_REGION_WRITE_EVENT;
extern TraceEvent _TRACE_VFIO_REGION_READ_EVENT;
extern TraceEvent _TRACE_VFIO_IOMMU_MAP_NOTIFY_EVENT;
extern TraceEvent _TRACE_VFIO_LISTENER_REGION_SKIP_EVENT;
extern TraceEvent _TRACE_VFIO_SPAPR_GROUP_ATTACH_EVENT;
extern TraceEvent _TRACE_VFIO_LISTENER_REGION_ADD_IOMMU_EVENT;
extern TraceEvent _TRACE_VFIO_LISTENER_REGION_DEL_IOMMU_EVENT;
extern TraceEvent _TRACE_VFIO_LISTENER_REGION_ADD_RAM_EVENT;
extern TraceEvent _TRACE_VFIO_KNOWN_SAFE_MISALIGNMENT_EVENT;
extern TraceEvent _TRACE_VFIO_LISTENER_REGION_ADD_NO_DMA_MAP_EVENT;
extern TraceEvent _TRACE_VFIO_LISTENER_REGION_DEL_EVENT;
extern TraceEvent _TRACE_VFIO_DEVICE_DIRTY_TRACKING_UPDATE_EVENT;
extern TraceEvent _TRACE_VFIO_DEVICE_DIRTY_TRACKING_START_EVENT;
extern TraceEvent _TRACE_VFIO_DISCONNECT_CONTAINER_EVENT;
extern TraceEvent _TRACE_VFIO_PUT_GROUP_EVENT;
extern TraceEvent _TRACE_VFIO_GET_DEVICE_EVENT;
extern TraceEvent _TRACE_VFIO_PUT_BASE_DEVICE_EVENT;
extern TraceEvent _TRACE_VFIO_REGION_SETUP_EVENT;
extern TraceEvent _TRACE_VFIO_REGION_MMAP_FAULT_EVENT;
extern TraceEvent _TRACE_VFIO_REGION_MMAP_EVENT;
extern TraceEvent _TRACE_VFIO_REGION_EXIT_EVENT;
extern TraceEvent _TRACE_VFIO_REGION_FINALIZE_EVENT;
extern TraceEvent _TRACE_VFIO_REGION_MMAPS_SET_ENABLED_EVENT;
extern TraceEvent _TRACE_VFIO_REGION_UNMAP_EVENT;
extern TraceEvent _TRACE_VFIO_REGION_SPARSE_MMAP_HEADER_EVENT;
extern TraceEvent _TRACE_VFIO_REGION_SPARSE_MMAP_ENTRY_EVENT;
extern TraceEvent _TRACE_VFIO_GET_DEV_REGION_EVENT;
extern TraceEvent _TRACE_VFIO_LEGACY_DMA_UNMAP_OVERFLOW_WORKAROUND_EVENT;
extern TraceEvent _TRACE_VFIO_GET_DIRTY_BITMAP_EVENT;
extern TraceEvent _TRACE_VFIO_IOMMU_MAP_DIRTY_NOTIFY_EVENT;
extern TraceEvent _TRACE_VFIO_PLATFORM_REALIZE_EVENT;
extern TraceEvent _TRACE_VFIO_PLATFORM_EOI_EVENT;
extern TraceEvent _TRACE_VFIO_PLATFORM_INTP_MMAP_ENABLE_EVENT;
extern TraceEvent _TRACE_VFIO_PLATFORM_INTP_INTERRUPT_EVENT;
extern TraceEvent _TRACE_VFIO_PLATFORM_INTP_INJECT_PENDING_LOCKHELD_EVENT;
extern TraceEvent _TRACE_VFIO_PLATFORM_POPULATE_INTERRUPTS_EVENT;
extern TraceEvent _TRACE_VFIO_INTP_INTERRUPT_SET_PENDING_EVENT;
extern TraceEvent _TRACE_VFIO_PLATFORM_START_LEVEL_IRQFD_INJECTION_EVENT;
extern TraceEvent _TRACE_VFIO_PLATFORM_START_EDGE_IRQFD_INJECTION_EVENT;
extern TraceEvent _TRACE_VFIO_PREREG_LISTENER_REGION_ADD_SKIP_EVENT;
extern TraceEvent _TRACE_VFIO_PREREG_LISTENER_REGION_DEL_SKIP_EVENT;
extern TraceEvent _TRACE_VFIO_PREREG_REGISTER_EVENT;
extern TraceEvent _TRACE_VFIO_PREREG_UNREGISTER_EVENT;
extern TraceEvent _TRACE_VFIO_SPAPR_CREATE_WINDOW_EVENT;
extern TraceEvent _TRACE_VFIO_SPAPR_REMOVE_WINDOW_EVENT;
extern TraceEvent _TRACE_VFIO_DISPLAY_EDID_AVAILABLE_EVENT;
extern TraceEvent _TRACE_VFIO_DISPLAY_EDID_LINK_UP_EVENT;
extern TraceEvent _TRACE_VFIO_DISPLAY_EDID_LINK_DOWN_EVENT;
extern TraceEvent _TRACE_VFIO_DISPLAY_EDID_UPDATE_EVENT;
extern TraceEvent _TRACE_VFIO_DISPLAY_EDID_WRITE_ERROR_EVENT;
extern TraceEvent _TRACE_VFIO_LOAD_CLEANUP_EVENT;
extern TraceEvent _TRACE_VFIO_LOAD_DEVICE_CONFIG_STATE_EVENT;
extern TraceEvent _TRACE_VFIO_LOAD_STATE_EVENT;
extern TraceEvent _TRACE_VFIO_LOAD_STATE_DEVICE_DATA_EVENT;
extern TraceEvent _TRACE_VFIO_MIGRATION_REALIZE_EVENT;
extern TraceEvent _TRACE_VFIO_MIGRATION_SET_DEVICE_STATE_EVENT;
extern TraceEvent _TRACE_VFIO_MIGRATION_SET_STATE_EVENT;
extern TraceEvent _TRACE_VFIO_MIGRATION_STATE_NOTIFIER_EVENT;
extern TraceEvent _TRACE_VFIO_SAVE_BLOCK_EVENT;
extern TraceEvent _TRACE_VFIO_SAVE_CLEANUP_EVENT;
extern TraceEvent _TRACE_VFIO_SAVE_COMPLETE_PRECOPY_EVENT;
extern TraceEvent _TRACE_VFIO_SAVE_DEVICE_CONFIG_STATE_EVENT;
extern TraceEvent _TRACE_VFIO_SAVE_ITERATE_EVENT;
extern TraceEvent _TRACE_VFIO_SAVE_SETUP_EVENT;
extern TraceEvent _TRACE_VFIO_STATE_PENDING_ESTIMATE_EVENT;
extern TraceEvent _TRACE_VFIO_STATE_PENDING_EXACT_EVENT;
extern TraceEvent _TRACE_VFIO_VMSTATE_CHANGE_EVENT;
extern TraceEvent _TRACE_VFIO_VMSTATE_CHANGE_PREPARE_EVENT;
extern TraceEvent _TRACE_IOMMUFD_CDEV_CONNECT_AND_BIND_EVENT;
extern TraceEvent _TRACE_IOMMUFD_CDEV_GETFD_EVENT;
extern TraceEvent _TRACE_IOMMUFD_CDEV_ATTACH_IOAS_HWPT_EVENT;
extern TraceEvent _TRACE_IOMMUFD_CDEV_DETACH_IOAS_HWPT_EVENT;
extern TraceEvent _TRACE_IOMMUFD_CDEV_FAIL_ATTACH_EXISTING_CONTAINER_EVENT;
extern TraceEvent _TRACE_IOMMUFD_CDEV_ALLOC_IOAS_EVENT;
extern TraceEvent _TRACE_IOMMUFD_CDEV_DEVICE_INFO_EVENT;
extern TraceEvent _TRACE_IOMMUFD_CDEV_PCI_HOT_RESET_DEP_DEVICES_EVENT;
extern uint16_t _TRACE_VFIO_INTX_INTERRUPT_DSTATE;
extern uint16_t _TRACE_VFIO_INTX_EOI_DSTATE;
extern uint16_t _TRACE_VFIO_INTX_ENABLE_KVM_DSTATE;
extern uint16_t _TRACE_VFIO_INTX_DISABLE_KVM_DSTATE;
extern uint16_t _TRACE_VFIO_INTX_UPDATE_DSTATE;
extern uint16_t _TRACE_VFIO_INTX_ENABLE_DSTATE;
extern uint16_t _TRACE_VFIO_INTX_DISABLE_DSTATE;
extern uint16_t _TRACE_VFIO_MSI_INTERRUPT_DSTATE;
extern uint16_t _TRACE_VFIO_MSIX_VECTOR_DO_USE_DSTATE;
extern uint16_t _TRACE_VFIO_MSIX_VECTOR_RELEASE_DSTATE;
extern uint16_t _TRACE_VFIO_MSIX_ENABLE_DSTATE;
extern uint16_t _TRACE_VFIO_MSIX_PBA_DISABLE_DSTATE;
extern uint16_t _TRACE_VFIO_MSIX_PBA_ENABLE_DSTATE;
extern uint16_t _TRACE_VFIO_MSIX_DISABLE_DSTATE;
extern uint16_t _TRACE_VFIO_MSIX_FIXUP_DSTATE;
extern uint16_t _TRACE_VFIO_MSIX_RELO_DSTATE;
extern uint16_t _TRACE_VFIO_MSI_ENABLE_DSTATE;
extern uint16_t _TRACE_VFIO_MSI_DISABLE_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_LOAD_ROM_DSTATE;
extern uint16_t _TRACE_VFIO_ROM_READ_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_SIZE_ROM_DSTATE;
extern uint16_t _TRACE_VFIO_VGA_WRITE_DSTATE;
extern uint16_t _TRACE_VFIO_VGA_READ_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_READ_CONFIG_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_WRITE_CONFIG_DSTATE;
extern uint16_t _TRACE_VFIO_MSI_SETUP_DSTATE;
extern uint16_t _TRACE_VFIO_MSIX_EARLY_SETUP_DSTATE;
extern uint16_t _TRACE_VFIO_CHECK_PCIE_FLR_DSTATE;
extern uint16_t _TRACE_VFIO_CHECK_PM_RESET_DSTATE;
extern uint16_t _TRACE_VFIO_CHECK_AF_FLR_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_HOT_RESET_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_HOT_RESET_HAS_DEP_DEVICES_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_HOT_RESET_DEP_DEVICES_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_HOT_RESET_RESULT_DSTATE;
extern uint16_t _TRACE_VFIO_POPULATE_DEVICE_CONFIG_DSTATE;
extern uint16_t _TRACE_VFIO_POPULATE_DEVICE_GET_IRQ_INFO_FAILURE_DSTATE;
extern uint16_t _TRACE_VFIO_ATTACH_DEVICE_DSTATE;
extern uint16_t _TRACE_VFIO_DETACH_DEVICE_DSTATE;
extern uint16_t _TRACE_VFIO_MDEV_DSTATE;
extern uint16_t _TRACE_VFIO_ADD_EXT_CAP_DROPPED_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_RESET_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_RESET_FLR_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_RESET_PM_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_EMULATED_VENDOR_ID_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_EMULATED_DEVICE_ID_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_EMULATED_SUB_VENDOR_ID_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_EMULATED_SUB_DEVICE_ID_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_ROM_IN_DENYLIST_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_GENERIC_WINDOW_ADDRESS_WRITE_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_GENERIC_WINDOW_DATA_READ_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_GENERIC_WINDOW_DATA_WRITE_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_GENERIC_MIRROR_READ_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_GENERIC_MIRROR_WRITE_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_ATI_3C3_READ_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_ATI_3C3_PROBE_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_ATI_BAR4_PROBE_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_ATI_BAR2_PROBE_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_NVIDIA_3D0_STATE_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_NVIDIA_3D0_READ_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_NVIDIA_3D0_WRITE_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_NVIDIA_3D0_PROBE_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_NVIDIA_BAR5_STATE_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_NVIDIA_BAR5_PROBE_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_NVIDIA_BAR0_MSI_ACK_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_NVIDIA_BAR0_PROBE_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_RTL8168_FAKE_LATCH_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_RTL8168_MSIX_WRITE_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_RTL8168_MSIX_READ_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_RTL8168_PROBE_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_SKIPPED_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_NO_SMC_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_TIMEOUT_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_DONE_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_DSTATE;
extern uint16_t _TRACE_VFIO_IOEVENTFD_EXIT_DSTATE;
extern uint16_t _TRACE_VFIO_IOEVENTFD_HANDLER_DSTATE;
extern uint16_t _TRACE_VFIO_IOEVENTFD_INIT_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_IGD_OPREGION_ENABLED_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_IGD_BAR4_WRITE_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_IGD_BDSM_ENABLED_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_IGD_HOST_BRIDGE_ENABLED_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_IGD_LPC_BRIDGE_ENABLED_DSTATE;
extern uint16_t _TRACE_VFIO_REGION_WRITE_DSTATE;
extern uint16_t _TRACE_VFIO_REGION_READ_DSTATE;
extern uint16_t _TRACE_VFIO_IOMMU_MAP_NOTIFY_DSTATE;
extern uint16_t _TRACE_VFIO_LISTENER_REGION_SKIP_DSTATE;
extern uint16_t _TRACE_VFIO_SPAPR_GROUP_ATTACH_DSTATE;
extern uint16_t _TRACE_VFIO_LISTENER_REGION_ADD_IOMMU_DSTATE;
extern uint16_t _TRACE_VFIO_LISTENER_REGION_DEL_IOMMU_DSTATE;
extern uint16_t _TRACE_VFIO_LISTENER_REGION_ADD_RAM_DSTATE;
extern uint16_t _TRACE_VFIO_KNOWN_SAFE_MISALIGNMENT_DSTATE;
extern uint16_t _TRACE_VFIO_LISTENER_REGION_ADD_NO_DMA_MAP_DSTATE;
extern uint16_t _TRACE_VFIO_LISTENER_REGION_DEL_DSTATE;
extern uint16_t _TRACE_VFIO_DEVICE_DIRTY_TRACKING_UPDATE_DSTATE;
extern uint16_t _TRACE_VFIO_DEVICE_DIRTY_TRACKING_START_DSTATE;
extern uint16_t _TRACE_VFIO_DISCONNECT_CONTAINER_DSTATE;
extern uint16_t _TRACE_VFIO_PUT_GROUP_DSTATE;
extern uint16_t _TRACE_VFIO_GET_DEVICE_DSTATE;
extern uint16_t _TRACE_VFIO_PUT_BASE_DEVICE_DSTATE;
extern uint16_t _TRACE_VFIO_REGION_SETUP_DSTATE;
extern uint16_t _TRACE_VFIO_REGION_MMAP_FAULT_DSTATE;
extern uint16_t _TRACE_VFIO_REGION_MMAP_DSTATE;
extern uint16_t _TRACE_VFIO_REGION_EXIT_DSTATE;
extern uint16_t _TRACE_VFIO_REGION_FINALIZE_DSTATE;
extern uint16_t _TRACE_VFIO_REGION_MMAPS_SET_ENABLED_DSTATE;
extern uint16_t _TRACE_VFIO_REGION_UNMAP_DSTATE;
extern uint16_t _TRACE_VFIO_REGION_SPARSE_MMAP_HEADER_DSTATE;
extern uint16_t _TRACE_VFIO_REGION_SPARSE_MMAP_ENTRY_DSTATE;
extern uint16_t _TRACE_VFIO_GET_DEV_REGION_DSTATE;
extern uint16_t _TRACE_VFIO_LEGACY_DMA_UNMAP_OVERFLOW_WORKAROUND_DSTATE;
extern uint16_t _TRACE_VFIO_GET_DIRTY_BITMAP_DSTATE;
extern uint16_t _TRACE_VFIO_IOMMU_MAP_DIRTY_NOTIFY_DSTATE;
extern uint16_t _TRACE_VFIO_PLATFORM_REALIZE_DSTATE;
extern uint16_t _TRACE_VFIO_PLATFORM_EOI_DSTATE;
extern uint16_t _TRACE_VFIO_PLATFORM_INTP_MMAP_ENABLE_DSTATE;
extern uint16_t _TRACE_VFIO_PLATFORM_INTP_INTERRUPT_DSTATE;
extern uint16_t _TRACE_VFIO_PLATFORM_INTP_INJECT_PENDING_LOCKHELD_DSTATE;
extern uint16_t _TRACE_VFIO_PLATFORM_POPULATE_INTERRUPTS_DSTATE;
extern uint16_t _TRACE_VFIO_INTP_INTERRUPT_SET_PENDING_DSTATE;
extern uint16_t _TRACE_VFIO_PLATFORM_START_LEVEL_IRQFD_INJECTION_DSTATE;
extern uint16_t _TRACE_VFIO_PLATFORM_START_EDGE_IRQFD_INJECTION_DSTATE;
extern uint16_t _TRACE_VFIO_PREREG_LISTENER_REGION_ADD_SKIP_DSTATE;
extern uint16_t _TRACE_VFIO_PREREG_LISTENER_REGION_DEL_SKIP_DSTATE;
extern uint16_t _TRACE_VFIO_PREREG_REGISTER_DSTATE;
extern uint16_t _TRACE_VFIO_PREREG_UNREGISTER_DSTATE;
extern uint16_t _TRACE_VFIO_SPAPR_CREATE_WINDOW_DSTATE;
extern uint16_t _TRACE_VFIO_SPAPR_REMOVE_WINDOW_DSTATE;
extern uint16_t _TRACE_VFIO_DISPLAY_EDID_AVAILABLE_DSTATE;
extern uint16_t _TRACE_VFIO_DISPLAY_EDID_LINK_UP_DSTATE;
extern uint16_t _TRACE_VFIO_DISPLAY_EDID_LINK_DOWN_DSTATE;
extern uint16_t _TRACE_VFIO_DISPLAY_EDID_UPDATE_DSTATE;
extern uint16_t _TRACE_VFIO_DISPLAY_EDID_WRITE_ERROR_DSTATE;
extern uint16_t _TRACE_VFIO_LOAD_CLEANUP_DSTATE;
extern uint16_t _TRACE_VFIO_LOAD_DEVICE_CONFIG_STATE_DSTATE;
extern uint16_t _TRACE_VFIO_LOAD_STATE_DSTATE;
extern uint16_t _TRACE_VFIO_LOAD_STATE_DEVICE_DATA_DSTATE;
extern uint16_t _TRACE_VFIO_MIGRATION_REALIZE_DSTATE;
extern uint16_t _TRACE_VFIO_MIGRATION_SET_DEVICE_STATE_DSTATE;
extern uint16_t _TRACE_VFIO_MIGRATION_SET_STATE_DSTATE;
extern uint16_t _TRACE_VFIO_MIGRATION_STATE_NOTIFIER_DSTATE;
extern uint16_t _TRACE_VFIO_SAVE_BLOCK_DSTATE;
extern uint16_t _TRACE_VFIO_SAVE_CLEANUP_DSTATE;
extern uint16_t _TRACE_VFIO_SAVE_COMPLETE_PRECOPY_DSTATE;
extern uint16_t _TRACE_VFIO_SAVE_DEVICE_CONFIG_STATE_DSTATE;
extern uint16_t _TRACE_VFIO_SAVE_ITERATE_DSTATE;
extern uint16_t _TRACE_VFIO_SAVE_SETUP_DSTATE;
extern uint16_t _TRACE_VFIO_STATE_PENDING_ESTIMATE_DSTATE;
extern uint16_t _TRACE_VFIO_STATE_PENDING_EXACT_DSTATE;
extern uint16_t _TRACE_VFIO_VMSTATE_CHANGE_DSTATE;
extern uint16_t _TRACE_VFIO_VMSTATE_CHANGE_PREPARE_DSTATE;
extern uint16_t _TRACE_IOMMUFD_CDEV_CONNECT_AND_BIND_DSTATE;
extern uint16_t _TRACE_IOMMUFD_CDEV_GETFD_DSTATE;
extern uint16_t _TRACE_IOMMUFD_CDEV_ATTACH_IOAS_HWPT_DSTATE;
extern uint16_t _TRACE_IOMMUFD_CDEV_DETACH_IOAS_HWPT_DSTATE;
extern uint16_t _TRACE_IOMMUFD_CDEV_FAIL_ATTACH_EXISTING_CONTAINER_DSTATE;
extern uint16_t _TRACE_IOMMUFD_CDEV_ALLOC_IOAS_DSTATE;
extern uint16_t _TRACE_IOMMUFD_CDEV_DEVICE_INFO_DSTATE;
extern uint16_t _TRACE_IOMMUFD_CDEV_PCI_HOT_RESET_DEP_DEVICES_DSTATE;
#define TRACE_VFIO_INTX_INTERRUPT_ENABLED 1
#define TRACE_VFIO_INTX_EOI_ENABLED 1
#define TRACE_VFIO_INTX_ENABLE_KVM_ENABLED 1
#define TRACE_VFIO_INTX_DISABLE_KVM_ENABLED 1
#define TRACE_VFIO_INTX_UPDATE_ENABLED 1
#define TRACE_VFIO_INTX_ENABLE_ENABLED 1
#define TRACE_VFIO_INTX_DISABLE_ENABLED 1
#define TRACE_VFIO_MSI_INTERRUPT_ENABLED 1
#define TRACE_VFIO_MSIX_VECTOR_DO_USE_ENABLED 1
#define TRACE_VFIO_MSIX_VECTOR_RELEASE_ENABLED 1
#define TRACE_VFIO_MSIX_ENABLE_ENABLED 1
#define TRACE_VFIO_MSIX_PBA_DISABLE_ENABLED 1
#define TRACE_VFIO_MSIX_PBA_ENABLE_ENABLED 1
#define TRACE_VFIO_MSIX_DISABLE_ENABLED 1
#define TRACE_VFIO_MSIX_FIXUP_ENABLED 1
#define TRACE_VFIO_MSIX_RELO_ENABLED 1
#define TRACE_VFIO_MSI_ENABLE_ENABLED 1
#define TRACE_VFIO_MSI_DISABLE_ENABLED 1
#define TRACE_VFIO_PCI_LOAD_ROM_ENABLED 1
#define TRACE_VFIO_ROM_READ_ENABLED 1
#define TRACE_VFIO_PCI_SIZE_ROM_ENABLED 1
#define TRACE_VFIO_VGA_WRITE_ENABLED 1
#define TRACE_VFIO_VGA_READ_ENABLED 1
#define TRACE_VFIO_PCI_READ_CONFIG_ENABLED 1
#define TRACE_VFIO_PCI_WRITE_CONFIG_ENABLED 1
#define TRACE_VFIO_MSI_SETUP_ENABLED 1
#define TRACE_VFIO_MSIX_EARLY_SETUP_ENABLED 1
#define TRACE_VFIO_CHECK_PCIE_FLR_ENABLED 1
#define TRACE_VFIO_CHECK_PM_RESET_ENABLED 1
#define TRACE_VFIO_CHECK_AF_FLR_ENABLED 1
#define TRACE_VFIO_PCI_HOT_RESET_ENABLED 1
#define TRACE_VFIO_PCI_HOT_RESET_HAS_DEP_DEVICES_ENABLED 1
#define TRACE_VFIO_PCI_HOT_RESET_DEP_DEVICES_ENABLED 1
#define TRACE_VFIO_PCI_HOT_RESET_RESULT_ENABLED 1
#define TRACE_VFIO_POPULATE_DEVICE_CONFIG_ENABLED 1
#define TRACE_VFIO_POPULATE_DEVICE_GET_IRQ_INFO_FAILURE_ENABLED 1
#define TRACE_VFIO_ATTACH_DEVICE_ENABLED 1
#define TRACE_VFIO_DETACH_DEVICE_ENABLED 1
#define TRACE_VFIO_MDEV_ENABLED 1
#define TRACE_VFIO_ADD_EXT_CAP_DROPPED_ENABLED 1
#define TRACE_VFIO_PCI_RESET_ENABLED 1
#define TRACE_VFIO_PCI_RESET_FLR_ENABLED 1
#define TRACE_VFIO_PCI_RESET_PM_ENABLED 1
#define TRACE_VFIO_PCI_EMULATED_VENDOR_ID_ENABLED 1
#define TRACE_VFIO_PCI_EMULATED_DEVICE_ID_ENABLED 1
#define TRACE_VFIO_PCI_EMULATED_SUB_VENDOR_ID_ENABLED 1
#define TRACE_VFIO_PCI_EMULATED_SUB_DEVICE_ID_ENABLED 1
#define TRACE_VFIO_QUIRK_ROM_IN_DENYLIST_ENABLED 1
#define TRACE_VFIO_QUIRK_GENERIC_WINDOW_ADDRESS_WRITE_ENABLED 1
#define TRACE_VFIO_QUIRK_GENERIC_WINDOW_DATA_READ_ENABLED 1
#define TRACE_VFIO_QUIRK_GENERIC_WINDOW_DATA_WRITE_ENABLED 1
#define TRACE_VFIO_QUIRK_GENERIC_MIRROR_READ_ENABLED 1
#define TRACE_VFIO_QUIRK_GENERIC_MIRROR_WRITE_ENABLED 1
#define TRACE_VFIO_QUIRK_ATI_3C3_READ_ENABLED 1
#define TRACE_VFIO_QUIRK_ATI_3C3_PROBE_ENABLED 1
#define TRACE_VFIO_QUIRK_ATI_BAR4_PROBE_ENABLED 1
#define TRACE_VFIO_QUIRK_ATI_BAR2_PROBE_ENABLED 1
#define TRACE_VFIO_QUIRK_NVIDIA_3D0_STATE_ENABLED 1
#define TRACE_VFIO_QUIRK_NVIDIA_3D0_READ_ENABLED 1
#define TRACE_VFIO_QUIRK_NVIDIA_3D0_WRITE_ENABLED 1
#define TRACE_VFIO_QUIRK_NVIDIA_3D0_PROBE_ENABLED 1
#define TRACE_VFIO_QUIRK_NVIDIA_BAR5_STATE_ENABLED 1
#define TRACE_VFIO_QUIRK_NVIDIA_BAR5_PROBE_ENABLED 1
#define TRACE_VFIO_QUIRK_NVIDIA_BAR0_MSI_ACK_ENABLED 1
#define TRACE_VFIO_QUIRK_NVIDIA_BAR0_PROBE_ENABLED 1
#define TRACE_VFIO_QUIRK_RTL8168_FAKE_LATCH_ENABLED 1
#define TRACE_VFIO_QUIRK_RTL8168_MSIX_WRITE_ENABLED 1
#define TRACE_VFIO_QUIRK_RTL8168_MSIX_READ_ENABLED 1
#define TRACE_VFIO_QUIRK_RTL8168_PROBE_ENABLED 1
#define TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_SKIPPED_ENABLED 1
#define TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_NO_SMC_ENABLED 1
#define TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_TIMEOUT_ENABLED 1
#define TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_DONE_ENABLED 1
#define TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_ENABLED 1
#define TRACE_VFIO_IOEVENTFD_EXIT_ENABLED 1
#define TRACE_VFIO_IOEVENTFD_HANDLER_ENABLED 1
#define TRACE_VFIO_IOEVENTFD_INIT_ENABLED 1
#define TRACE_VFIO_PCI_IGD_OPREGION_ENABLED_ENABLED 1
#define TRACE_VFIO_PCI_IGD_BAR4_WRITE_ENABLED 1
#define TRACE_VFIO_PCI_IGD_BDSM_ENABLED_ENABLED 1
#define TRACE_VFIO_PCI_IGD_HOST_BRIDGE_ENABLED_ENABLED 1
#define TRACE_VFIO_PCI_IGD_LPC_BRIDGE_ENABLED_ENABLED 1
#define TRACE_VFIO_REGION_WRITE_ENABLED 1
#define TRACE_VFIO_REGION_READ_ENABLED 1
#define TRACE_VFIO_IOMMU_MAP_NOTIFY_ENABLED 1
#define TRACE_VFIO_LISTENER_REGION_SKIP_ENABLED 1
#define TRACE_VFIO_SPAPR_GROUP_ATTACH_ENABLED 1
#define TRACE_VFIO_LISTENER_REGION_ADD_IOMMU_ENABLED 1
#define TRACE_VFIO_LISTENER_REGION_DEL_IOMMU_ENABLED 1
#define TRACE_VFIO_LISTENER_REGION_ADD_RAM_ENABLED 1
#define TRACE_VFIO_KNOWN_SAFE_MISALIGNMENT_ENABLED 1
#define TRACE_VFIO_LISTENER_REGION_ADD_NO_DMA_MAP_ENABLED 1
#define TRACE_VFIO_LISTENER_REGION_DEL_ENABLED 1
#define TRACE_VFIO_DEVICE_DIRTY_TRACKING_UPDATE_ENABLED 1
#define TRACE_VFIO_DEVICE_DIRTY_TRACKING_START_ENABLED 1
#define TRACE_VFIO_DISCONNECT_CONTAINER_ENABLED 1
#define TRACE_VFIO_PUT_GROUP_ENABLED 1
#define TRACE_VFIO_GET_DEVICE_ENABLED 1
#define TRACE_VFIO_PUT_BASE_DEVICE_ENABLED 1
#define TRACE_VFIO_REGION_SETUP_ENABLED 1
#define TRACE_VFIO_REGION_MMAP_FAULT_ENABLED 1
#define TRACE_VFIO_REGION_MMAP_ENABLED 1
#define TRACE_VFIO_REGION_EXIT_ENABLED 1
#define TRACE_VFIO_REGION_FINALIZE_ENABLED 1
#define TRACE_VFIO_REGION_MMAPS_SET_ENABLED_ENABLED 1
#define TRACE_VFIO_REGION_UNMAP_ENABLED 1
#define TRACE_VFIO_REGION_SPARSE_MMAP_HEADER_ENABLED 1
#define TRACE_VFIO_REGION_SPARSE_MMAP_ENTRY_ENABLED 1
#define TRACE_VFIO_GET_DEV_REGION_ENABLED 1
#define TRACE_VFIO_LEGACY_DMA_UNMAP_OVERFLOW_WORKAROUND_ENABLED 1
#define TRACE_VFIO_GET_DIRTY_BITMAP_ENABLED 1
#define TRACE_VFIO_IOMMU_MAP_DIRTY_NOTIFY_ENABLED 1
#define TRACE_VFIO_PLATFORM_REALIZE_ENABLED 1
#define TRACE_VFIO_PLATFORM_EOI_ENABLED 1
#define TRACE_VFIO_PLATFORM_INTP_MMAP_ENABLE_ENABLED 1
#define TRACE_VFIO_PLATFORM_INTP_INTERRUPT_ENABLED 1
#define TRACE_VFIO_PLATFORM_INTP_INJECT_PENDING_LOCKHELD_ENABLED 1
#define TRACE_VFIO_PLATFORM_POPULATE_INTERRUPTS_ENABLED 1
#define TRACE_VFIO_INTP_INTERRUPT_SET_PENDING_ENABLED 1
#define TRACE_VFIO_PLATFORM_START_LEVEL_IRQFD_INJECTION_ENABLED 1
#define TRACE_VFIO_PLATFORM_START_EDGE_IRQFD_INJECTION_ENABLED 1
#define TRACE_VFIO_PREREG_LISTENER_REGION_ADD_SKIP_ENABLED 1
#define TRACE_VFIO_PREREG_LISTENER_REGION_DEL_SKIP_ENABLED 1
#define TRACE_VFIO_PREREG_REGISTER_ENABLED 1
#define TRACE_VFIO_PREREG_UNREGISTER_ENABLED 1
#define TRACE_VFIO_SPAPR_CREATE_WINDOW_ENABLED 1
#define TRACE_VFIO_SPAPR_REMOVE_WINDOW_ENABLED 1
#define TRACE_VFIO_DISPLAY_EDID_AVAILABLE_ENABLED 1
#define TRACE_VFIO_DISPLAY_EDID_LINK_UP_ENABLED 1
#define TRACE_VFIO_DISPLAY_EDID_LINK_DOWN_ENABLED 1
#define TRACE_VFIO_DISPLAY_EDID_UPDATE_ENABLED 1
#define TRACE_VFIO_DISPLAY_EDID_WRITE_ERROR_ENABLED 1
#define TRACE_VFIO_LOAD_CLEANUP_ENABLED 1
#define TRACE_VFIO_LOAD_DEVICE_CONFIG_STATE_ENABLED 1
#define TRACE_VFIO_LOAD_STATE_ENABLED 1
#define TRACE_VFIO_LOAD_STATE_DEVICE_DATA_ENABLED 1
#define TRACE_VFIO_MIGRATION_REALIZE_ENABLED 1
#define TRACE_VFIO_MIGRATION_SET_DEVICE_STATE_ENABLED 1
#define TRACE_VFIO_MIGRATION_SET_STATE_ENABLED 1
#define TRACE_VFIO_MIGRATION_STATE_NOTIFIER_ENABLED 1
#define TRACE_VFIO_SAVE_BLOCK_ENABLED 1
#define TRACE_VFIO_SAVE_CLEANUP_ENABLED 1
#define TRACE_VFIO_SAVE_COMPLETE_PRECOPY_ENABLED 1
#define TRACE_VFIO_SAVE_DEVICE_CONFIG_STATE_ENABLED 1
#define TRACE_VFIO_SAVE_ITERATE_ENABLED 1
#define TRACE_VFIO_SAVE_SETUP_ENABLED 1
#define TRACE_VFIO_STATE_PENDING_ESTIMATE_ENABLED 1
#define TRACE_VFIO_STATE_PENDING_EXACT_ENABLED 1
#define TRACE_VFIO_VMSTATE_CHANGE_ENABLED 1
#define TRACE_VFIO_VMSTATE_CHANGE_PREPARE_ENABLED 1
#define TRACE_IOMMUFD_CDEV_CONNECT_AND_BIND_ENABLED 1
#define TRACE_IOMMUFD_CDEV_GETFD_ENABLED 1
#define TRACE_IOMMUFD_CDEV_ATTACH_IOAS_HWPT_ENABLED 1
#define TRACE_IOMMUFD_CDEV_DETACH_IOAS_HWPT_ENABLED 1
#define TRACE_IOMMUFD_CDEV_FAIL_ATTACH_EXISTING_CONTAINER_ENABLED 1
#define TRACE_IOMMUFD_CDEV_ALLOC_IOAS_ENABLED 1
#define TRACE_IOMMUFD_CDEV_DEVICE_INFO_ENABLED 1
#define TRACE_IOMMUFD_CDEV_PCI_HOT_RESET_DEP_DEVICES_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_VFIO_INTX_INTERRUPT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_INTX_INTERRUPT) || \
    false)

static inline void _nocheck__trace_vfio_intx_interrupt(const char * name, char line)
{
    if (trace_event_get_state(TRACE_VFIO_INTX_INTERRUPT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 4 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_intx_interrupt " " (%s) Pin %c" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, line);
#line 502 "trace/trace-hw_vfio.h"
        } else {
#line 4 "../hw/vfio/trace-events"
            qemu_log("vfio_intx_interrupt " " (%s) Pin %c" "\n", name, line);
#line 506 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_intx_interrupt(const char * name, char line)
{
    if (true) {
        _nocheck__trace_vfio_intx_interrupt(name, line);
    }
}

#define TRACE_VFIO_INTX_EOI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_INTX_EOI) || \
    false)

static inline void _nocheck__trace_vfio_intx_eoi(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_INTX_EOI) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 5 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_intx_eoi " " (%s) EOI" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 533 "trace/trace-hw_vfio.h"
        } else {
#line 5 "../hw/vfio/trace-events"
            qemu_log("vfio_intx_eoi " " (%s) EOI" "\n", name);
#line 537 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_intx_eoi(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_intx_eoi(name);
    }
}

#define TRACE_VFIO_INTX_ENABLE_KVM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_INTX_ENABLE_KVM) || \
    false)

static inline void _nocheck__trace_vfio_intx_enable_kvm(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_INTX_ENABLE_KVM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 6 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_intx_enable_kvm " " (%s) KVM INTx accel enabled" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 564 "trace/trace-hw_vfio.h"
        } else {
#line 6 "../hw/vfio/trace-events"
            qemu_log("vfio_intx_enable_kvm " " (%s) KVM INTx accel enabled" "\n", name);
#line 568 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_intx_enable_kvm(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_intx_enable_kvm(name);
    }
}

#define TRACE_VFIO_INTX_DISABLE_KVM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_INTX_DISABLE_KVM) || \
    false)

static inline void _nocheck__trace_vfio_intx_disable_kvm(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_INTX_DISABLE_KVM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 7 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_intx_disable_kvm " " (%s) KVM INTx accel disabled" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 595 "trace/trace-hw_vfio.h"
        } else {
#line 7 "../hw/vfio/trace-events"
            qemu_log("vfio_intx_disable_kvm " " (%s) KVM INTx accel disabled" "\n", name);
#line 599 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_intx_disable_kvm(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_intx_disable_kvm(name);
    }
}

#define TRACE_VFIO_INTX_UPDATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_INTX_UPDATE) || \
    false)

static inline void _nocheck__trace_vfio_intx_update(const char * name, int new_irq, int target_irq)
{
    if (trace_event_get_state(TRACE_VFIO_INTX_UPDATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 8 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_intx_update " " (%s) IRQ moved %d -> %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, new_irq, target_irq);
#line 626 "trace/trace-hw_vfio.h"
        } else {
#line 8 "../hw/vfio/trace-events"
            qemu_log("vfio_intx_update " " (%s) IRQ moved %d -> %d" "\n", name, new_irq, target_irq);
#line 630 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_intx_update(const char * name, int new_irq, int target_irq)
{
    if (true) {
        _nocheck__trace_vfio_intx_update(name, new_irq, target_irq);
    }
}

#define TRACE_VFIO_INTX_ENABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_INTX_ENABLE) || \
    false)

static inline void _nocheck__trace_vfio_intx_enable(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_INTX_ENABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 9 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_intx_enable " " (%s)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 657 "trace/trace-hw_vfio.h"
        } else {
#line 9 "../hw/vfio/trace-events"
            qemu_log("vfio_intx_enable " " (%s)" "\n", name);
#line 661 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_intx_enable(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_intx_enable(name);
    }
}

#define TRACE_VFIO_INTX_DISABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_INTX_DISABLE) || \
    false)

static inline void _nocheck__trace_vfio_intx_disable(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_INTX_DISABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 10 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_intx_disable " " (%s)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 688 "trace/trace-hw_vfio.h"
        } else {
#line 10 "../hw/vfio/trace-events"
            qemu_log("vfio_intx_disable " " (%s)" "\n", name);
#line 692 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_intx_disable(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_intx_disable(name);
    }
}

#define TRACE_VFIO_MSI_INTERRUPT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_MSI_INTERRUPT) || \
    false)

static inline void _nocheck__trace_vfio_msi_interrupt(const char * name, int index, uint64_t addr, int data)
{
    if (trace_event_get_state(TRACE_VFIO_MSI_INTERRUPT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 11 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_msi_interrupt " " (%s) vector %d 0x%"PRIx64"/0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, index, addr, data);
#line 719 "trace/trace-hw_vfio.h"
        } else {
#line 11 "../hw/vfio/trace-events"
            qemu_log("vfio_msi_interrupt " " (%s) vector %d 0x%"PRIx64"/0x%x" "\n", name, index, addr, data);
#line 723 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_msi_interrupt(const char * name, int index, uint64_t addr, int data)
{
    if (true) {
        _nocheck__trace_vfio_msi_interrupt(name, index, addr, data);
    }
}

#define TRACE_VFIO_MSIX_VECTOR_DO_USE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_MSIX_VECTOR_DO_USE) || \
    false)

static inline void _nocheck__trace_vfio_msix_vector_do_use(const char * name, int index)
{
    if (trace_event_get_state(TRACE_VFIO_MSIX_VECTOR_DO_USE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 12 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_msix_vector_do_use " " (%s) vector %d used" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, index);
#line 750 "trace/trace-hw_vfio.h"
        } else {
#line 12 "../hw/vfio/trace-events"
            qemu_log("vfio_msix_vector_do_use " " (%s) vector %d used" "\n", name, index);
#line 754 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_msix_vector_do_use(const char * name, int index)
{
    if (true) {
        _nocheck__trace_vfio_msix_vector_do_use(name, index);
    }
}

#define TRACE_VFIO_MSIX_VECTOR_RELEASE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_MSIX_VECTOR_RELEASE) || \
    false)

static inline void _nocheck__trace_vfio_msix_vector_release(const char * name, int index)
{
    if (trace_event_get_state(TRACE_VFIO_MSIX_VECTOR_RELEASE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 13 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_msix_vector_release " " (%s) vector %d released" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, index);
#line 781 "trace/trace-hw_vfio.h"
        } else {
#line 13 "../hw/vfio/trace-events"
            qemu_log("vfio_msix_vector_release " " (%s) vector %d released" "\n", name, index);
#line 785 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_msix_vector_release(const char * name, int index)
{
    if (true) {
        _nocheck__trace_vfio_msix_vector_release(name, index);
    }
}

#define TRACE_VFIO_MSIX_ENABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_MSIX_ENABLE) || \
    false)

static inline void _nocheck__trace_vfio_msix_enable(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_MSIX_ENABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 14 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_msix_enable " " (%s)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 812 "trace/trace-hw_vfio.h"
        } else {
#line 14 "../hw/vfio/trace-events"
            qemu_log("vfio_msix_enable " " (%s)" "\n", name);
#line 816 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_msix_enable(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_msix_enable(name);
    }
}

#define TRACE_VFIO_MSIX_PBA_DISABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_MSIX_PBA_DISABLE) || \
    false)

static inline void _nocheck__trace_vfio_msix_pba_disable(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_MSIX_PBA_DISABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 15 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_msix_pba_disable " " (%s)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 843 "trace/trace-hw_vfio.h"
        } else {
#line 15 "../hw/vfio/trace-events"
            qemu_log("vfio_msix_pba_disable " " (%s)" "\n", name);
#line 847 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_msix_pba_disable(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_msix_pba_disable(name);
    }
}

#define TRACE_VFIO_MSIX_PBA_ENABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_MSIX_PBA_ENABLE) || \
    false)

static inline void _nocheck__trace_vfio_msix_pba_enable(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_MSIX_PBA_ENABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 16 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_msix_pba_enable " " (%s)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 874 "trace/trace-hw_vfio.h"
        } else {
#line 16 "../hw/vfio/trace-events"
            qemu_log("vfio_msix_pba_enable " " (%s)" "\n", name);
#line 878 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_msix_pba_enable(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_msix_pba_enable(name);
    }
}

#define TRACE_VFIO_MSIX_DISABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_MSIX_DISABLE) || \
    false)

static inline void _nocheck__trace_vfio_msix_disable(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_MSIX_DISABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 17 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_msix_disable " " (%s)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 905 "trace/trace-hw_vfio.h"
        } else {
#line 17 "../hw/vfio/trace-events"
            qemu_log("vfio_msix_disable " " (%s)" "\n", name);
#line 909 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_msix_disable(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_msix_disable(name);
    }
}

#define TRACE_VFIO_MSIX_FIXUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_MSIX_FIXUP) || \
    false)

static inline void _nocheck__trace_vfio_msix_fixup(const char * name, int bar, uint64_t start, uint64_t end)
{
    if (trace_event_get_state(TRACE_VFIO_MSIX_FIXUP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 18 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_msix_fixup " " (%s) MSI-X region %d mmap fixup [0x%"PRIx64" - 0x%"PRIx64"]" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, bar, start, end);
#line 936 "trace/trace-hw_vfio.h"
        } else {
#line 18 "../hw/vfio/trace-events"
            qemu_log("vfio_msix_fixup " " (%s) MSI-X region %d mmap fixup [0x%"PRIx64" - 0x%"PRIx64"]" "\n", name, bar, start, end);
#line 940 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_msix_fixup(const char * name, int bar, uint64_t start, uint64_t end)
{
    if (true) {
        _nocheck__trace_vfio_msix_fixup(name, bar, start, end);
    }
}

#define TRACE_VFIO_MSIX_RELO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_MSIX_RELO) || \
    false)

static inline void _nocheck__trace_vfio_msix_relo(const char * name, int bar, uint64_t offset)
{
    if (trace_event_get_state(TRACE_VFIO_MSIX_RELO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 19 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_msix_relo " " (%s) BAR %d offset 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, bar, offset);
#line 967 "trace/trace-hw_vfio.h"
        } else {
#line 19 "../hw/vfio/trace-events"
            qemu_log("vfio_msix_relo " " (%s) BAR %d offset 0x%"PRIx64"" "\n", name, bar, offset);
#line 971 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_msix_relo(const char * name, int bar, uint64_t offset)
{
    if (true) {
        _nocheck__trace_vfio_msix_relo(name, bar, offset);
    }
}

#define TRACE_VFIO_MSI_ENABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_MSI_ENABLE) || \
    false)

static inline void _nocheck__trace_vfio_msi_enable(const char * name, int nr_vectors)
{
    if (trace_event_get_state(TRACE_VFIO_MSI_ENABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 20 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_msi_enable " " (%s) Enabled %d MSI vectors" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, nr_vectors);
#line 998 "trace/trace-hw_vfio.h"
        } else {
#line 20 "../hw/vfio/trace-events"
            qemu_log("vfio_msi_enable " " (%s) Enabled %d MSI vectors" "\n", name, nr_vectors);
#line 1002 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_msi_enable(const char * name, int nr_vectors)
{
    if (true) {
        _nocheck__trace_vfio_msi_enable(name, nr_vectors);
    }
}

#define TRACE_VFIO_MSI_DISABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_MSI_DISABLE) || \
    false)

static inline void _nocheck__trace_vfio_msi_disable(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_MSI_DISABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 21 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_msi_disable " " (%s)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 1029 "trace/trace-hw_vfio.h"
        } else {
#line 21 "../hw/vfio/trace-events"
            qemu_log("vfio_msi_disable " " (%s)" "\n", name);
#line 1033 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_msi_disable(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_msi_disable(name);
    }
}

#define TRACE_VFIO_PCI_LOAD_ROM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_PCI_LOAD_ROM) || \
    false)

static inline void _nocheck__trace_vfio_pci_load_rom(const char * name, unsigned long size, unsigned long offset, unsigned long flags)
{
    if (trace_event_get_state(TRACE_VFIO_PCI_LOAD_ROM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 22 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_pci_load_rom " "Device '%s' ROM: size: 0x%lx, offset: 0x%lx, flags: 0x%lx" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, size, offset, flags);
#line 1060 "trace/trace-hw_vfio.h"
        } else {
#line 22 "../hw/vfio/trace-events"
            qemu_log("vfio_pci_load_rom " "Device '%s' ROM: size: 0x%lx, offset: 0x%lx, flags: 0x%lx" "\n", name, size, offset, flags);
#line 1064 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_pci_load_rom(const char * name, unsigned long size, unsigned long offset, unsigned long flags)
{
    if (true) {
        _nocheck__trace_vfio_pci_load_rom(name, size, offset, flags);
    }
}

#define TRACE_VFIO_ROM_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_ROM_READ) || \
    false)

static inline void _nocheck__trace_vfio_rom_read(const char * name, uint64_t addr, int size, uint64_t data)
{
    if (trace_event_get_state(TRACE_VFIO_ROM_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 23 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_rom_read " " (%s, 0x%"PRIx64", 0x%x) = 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, addr, size, data);
#line 1091 "trace/trace-hw_vfio.h"
        } else {
#line 23 "../hw/vfio/trace-events"
            qemu_log("vfio_rom_read " " (%s, 0x%"PRIx64", 0x%x) = 0x%"PRIx64 "\n", name, addr, size, data);
#line 1095 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_rom_read(const char * name, uint64_t addr, int size, uint64_t data)
{
    if (true) {
        _nocheck__trace_vfio_rom_read(name, addr, size, data);
    }
}

#define TRACE_VFIO_PCI_SIZE_ROM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_PCI_SIZE_ROM) || \
    false)

static inline void _nocheck__trace_vfio_pci_size_rom(const char * name, int size)
{
    if (trace_event_get_state(TRACE_VFIO_PCI_SIZE_ROM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 24 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_pci_size_rom " "%s ROM size 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, size);
#line 1122 "trace/trace-hw_vfio.h"
        } else {
#line 24 "../hw/vfio/trace-events"
            qemu_log("vfio_pci_size_rom " "%s ROM size 0x%x" "\n", name, size);
#line 1126 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_pci_size_rom(const char * name, int size)
{
    if (true) {
        _nocheck__trace_vfio_pci_size_rom(name, size);
    }
}

#define TRACE_VFIO_VGA_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_VGA_WRITE) || \
    false)

static inline void _nocheck__trace_vfio_vga_write(uint64_t addr, uint64_t data, int size)
{
    if (trace_event_get_state(TRACE_VFIO_VGA_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 25 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_vga_write " " (0x%"PRIx64", 0x%"PRIx64", %d)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, data, size);
#line 1153 "trace/trace-hw_vfio.h"
        } else {
#line 25 "../hw/vfio/trace-events"
            qemu_log("vfio_vga_write " " (0x%"PRIx64", 0x%"PRIx64", %d)" "\n", addr, data, size);
#line 1157 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_vga_write(uint64_t addr, uint64_t data, int size)
{
    if (true) {
        _nocheck__trace_vfio_vga_write(addr, data, size);
    }
}

#define TRACE_VFIO_VGA_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_VGA_READ) || \
    false)

static inline void _nocheck__trace_vfio_vga_read(uint64_t addr, int size, uint64_t data)
{
    if (trace_event_get_state(TRACE_VFIO_VGA_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 26 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_vga_read " " (0x%"PRIx64", %d) = 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, size, data);
#line 1184 "trace/trace-hw_vfio.h"
        } else {
#line 26 "../hw/vfio/trace-events"
            qemu_log("vfio_vga_read " " (0x%"PRIx64", %d) = 0x%"PRIx64 "\n", addr, size, data);
#line 1188 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_vga_read(uint64_t addr, int size, uint64_t data)
{
    if (true) {
        _nocheck__trace_vfio_vga_read(addr, size, data);
    }
}

#define TRACE_VFIO_PCI_READ_CONFIG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_PCI_READ_CONFIG) || \
    false)

static inline void _nocheck__trace_vfio_pci_read_config(const char * name, int addr, int len, int val)
{
    if (trace_event_get_state(TRACE_VFIO_PCI_READ_CONFIG) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 27 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_pci_read_config " " (%s, @0x%x, len=0x%x) 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, addr, len, val);
#line 1215 "trace/trace-hw_vfio.h"
        } else {
#line 27 "../hw/vfio/trace-events"
            qemu_log("vfio_pci_read_config " " (%s, @0x%x, len=0x%x) 0x%x" "\n", name, addr, len, val);
#line 1219 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_pci_read_config(const char * name, int addr, int len, int val)
{
    if (true) {
        _nocheck__trace_vfio_pci_read_config(name, addr, len, val);
    }
}

#define TRACE_VFIO_PCI_WRITE_CONFIG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_PCI_WRITE_CONFIG) || \
    false)

static inline void _nocheck__trace_vfio_pci_write_config(const char * name, int addr, int val, int len)
{
    if (trace_event_get_state(TRACE_VFIO_PCI_WRITE_CONFIG) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 28 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_pci_write_config " " (%s, @0x%x, 0x%x, len=0x%x)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, addr, val, len);
#line 1246 "trace/trace-hw_vfio.h"
        } else {
#line 28 "../hw/vfio/trace-events"
            qemu_log("vfio_pci_write_config " " (%s, @0x%x, 0x%x, len=0x%x)" "\n", name, addr, val, len);
#line 1250 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_pci_write_config(const char * name, int addr, int val, int len)
{
    if (true) {
        _nocheck__trace_vfio_pci_write_config(name, addr, val, len);
    }
}

#define TRACE_VFIO_MSI_SETUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_MSI_SETUP) || \
    false)

static inline void _nocheck__trace_vfio_msi_setup(const char * name, int pos)
{
    if (trace_event_get_state(TRACE_VFIO_MSI_SETUP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 29 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_msi_setup " "%s PCI MSI CAP @0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, pos);
#line 1277 "trace/trace-hw_vfio.h"
        } else {
#line 29 "../hw/vfio/trace-events"
            qemu_log("vfio_msi_setup " "%s PCI MSI CAP @0x%x" "\n", name, pos);
#line 1281 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_msi_setup(const char * name, int pos)
{
    if (true) {
        _nocheck__trace_vfio_msi_setup(name, pos);
    }
}

#define TRACE_VFIO_MSIX_EARLY_SETUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_MSIX_EARLY_SETUP) || \
    false)

static inline void _nocheck__trace_vfio_msix_early_setup(const char * name, int pos, int table_bar, int offset, int entries, bool noresize)
{
    if (trace_event_get_state(TRACE_VFIO_MSIX_EARLY_SETUP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 30 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_msix_early_setup " "%s PCI MSI-X CAP @0x%x, BAR %d, offset 0x%x, entries %d, noresize %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, pos, table_bar, offset, entries, noresize);
#line 1308 "trace/trace-hw_vfio.h"
        } else {
#line 30 "../hw/vfio/trace-events"
            qemu_log("vfio_msix_early_setup " "%s PCI MSI-X CAP @0x%x, BAR %d, offset 0x%x, entries %d, noresize %d" "\n", name, pos, table_bar, offset, entries, noresize);
#line 1312 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_msix_early_setup(const char * name, int pos, int table_bar, int offset, int entries, bool noresize)
{
    if (true) {
        _nocheck__trace_vfio_msix_early_setup(name, pos, table_bar, offset, entries, noresize);
    }
}

#define TRACE_VFIO_CHECK_PCIE_FLR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_CHECK_PCIE_FLR) || \
    false)

static inline void _nocheck__trace_vfio_check_pcie_flr(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_CHECK_PCIE_FLR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 31 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_check_pcie_flr " "%s Supports FLR via PCIe cap" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 1339 "trace/trace-hw_vfio.h"
        } else {
#line 31 "../hw/vfio/trace-events"
            qemu_log("vfio_check_pcie_flr " "%s Supports FLR via PCIe cap" "\n", name);
#line 1343 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_check_pcie_flr(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_check_pcie_flr(name);
    }
}

#define TRACE_VFIO_CHECK_PM_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_CHECK_PM_RESET) || \
    false)

static inline void _nocheck__trace_vfio_check_pm_reset(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_CHECK_PM_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 32 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_check_pm_reset " "%s Supports PM reset" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 1370 "trace/trace-hw_vfio.h"
        } else {
#line 32 "../hw/vfio/trace-events"
            qemu_log("vfio_check_pm_reset " "%s Supports PM reset" "\n", name);
#line 1374 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_check_pm_reset(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_check_pm_reset(name);
    }
}

#define TRACE_VFIO_CHECK_AF_FLR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_CHECK_AF_FLR) || \
    false)

static inline void _nocheck__trace_vfio_check_af_flr(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_CHECK_AF_FLR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 33 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_check_af_flr " "%s Supports FLR via AF cap" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 1401 "trace/trace-hw_vfio.h"
        } else {
#line 33 "../hw/vfio/trace-events"
            qemu_log("vfio_check_af_flr " "%s Supports FLR via AF cap" "\n", name);
#line 1405 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_check_af_flr(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_check_af_flr(name);
    }
}

#define TRACE_VFIO_PCI_HOT_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_PCI_HOT_RESET) || \
    false)

static inline void _nocheck__trace_vfio_pci_hot_reset(const char * name, const char * type)
{
    if (trace_event_get_state(TRACE_VFIO_PCI_HOT_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 34 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_pci_hot_reset " " (%s) %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, type);
#line 1432 "trace/trace-hw_vfio.h"
        } else {
#line 34 "../hw/vfio/trace-events"
            qemu_log("vfio_pci_hot_reset " " (%s) %s" "\n", name, type);
#line 1436 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_pci_hot_reset(const char * name, const char * type)
{
    if (true) {
        _nocheck__trace_vfio_pci_hot_reset(name, type);
    }
}

#define TRACE_VFIO_PCI_HOT_RESET_HAS_DEP_DEVICES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_PCI_HOT_RESET_HAS_DEP_DEVICES) || \
    false)

static inline void _nocheck__trace_vfio_pci_hot_reset_has_dep_devices(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_PCI_HOT_RESET_HAS_DEP_DEVICES) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 35 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_pci_hot_reset_has_dep_devices " "%s: hot reset dependent devices:" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 1463 "trace/trace-hw_vfio.h"
        } else {
#line 35 "../hw/vfio/trace-events"
            qemu_log("vfio_pci_hot_reset_has_dep_devices " "%s: hot reset dependent devices:" "\n", name);
#line 1467 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_pci_hot_reset_has_dep_devices(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_pci_hot_reset_has_dep_devices(name);
    }
}

#define TRACE_VFIO_PCI_HOT_RESET_DEP_DEVICES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_PCI_HOT_RESET_DEP_DEVICES) || \
    false)

static inline void _nocheck__trace_vfio_pci_hot_reset_dep_devices(int domain, int bus, int slot, int function, int group_id)
{
    if (trace_event_get_state(TRACE_VFIO_PCI_HOT_RESET_DEP_DEVICES) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 36 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_pci_hot_reset_dep_devices " "\t%04x:%02x:%02x.%x group %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , domain, bus, slot, function, group_id);
#line 1494 "trace/trace-hw_vfio.h"
        } else {
#line 36 "../hw/vfio/trace-events"
            qemu_log("vfio_pci_hot_reset_dep_devices " "\t%04x:%02x:%02x.%x group %d" "\n", domain, bus, slot, function, group_id);
#line 1498 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_pci_hot_reset_dep_devices(int domain, int bus, int slot, int function, int group_id)
{
    if (true) {
        _nocheck__trace_vfio_pci_hot_reset_dep_devices(domain, bus, slot, function, group_id);
    }
}

#define TRACE_VFIO_PCI_HOT_RESET_RESULT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_PCI_HOT_RESET_RESULT) || \
    false)

static inline void _nocheck__trace_vfio_pci_hot_reset_result(const char * name, const char * result)
{
    if (trace_event_get_state(TRACE_VFIO_PCI_HOT_RESET_RESULT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 37 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_pci_hot_reset_result " "%s hot reset: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, result);
#line 1525 "trace/trace-hw_vfio.h"
        } else {
#line 37 "../hw/vfio/trace-events"
            qemu_log("vfio_pci_hot_reset_result " "%s hot reset: %s" "\n", name, result);
#line 1529 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_pci_hot_reset_result(const char * name, const char * result)
{
    if (true) {
        _nocheck__trace_vfio_pci_hot_reset_result(name, result);
    }
}

#define TRACE_VFIO_POPULATE_DEVICE_CONFIG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_POPULATE_DEVICE_CONFIG) || \
    false)

static inline void _nocheck__trace_vfio_populate_device_config(const char * name, unsigned long size, unsigned long offset, unsigned long flags)
{
    if (trace_event_get_state(TRACE_VFIO_POPULATE_DEVICE_CONFIG) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 38 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_populate_device_config " "Device '%s' config: size: 0x%lx, offset: 0x%lx, flags: 0x%lx" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, size, offset, flags);
#line 1556 "trace/trace-hw_vfio.h"
        } else {
#line 38 "../hw/vfio/trace-events"
            qemu_log("vfio_populate_device_config " "Device '%s' config: size: 0x%lx, offset: 0x%lx, flags: 0x%lx" "\n", name, size, offset, flags);
#line 1560 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_populate_device_config(const char * name, unsigned long size, unsigned long offset, unsigned long flags)
{
    if (true) {
        _nocheck__trace_vfio_populate_device_config(name, size, offset, flags);
    }
}

#define TRACE_VFIO_POPULATE_DEVICE_GET_IRQ_INFO_FAILURE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_POPULATE_DEVICE_GET_IRQ_INFO_FAILURE) || \
    false)

static inline void _nocheck__trace_vfio_populate_device_get_irq_info_failure(const char * errstr)
{
    if (trace_event_get_state(TRACE_VFIO_POPULATE_DEVICE_GET_IRQ_INFO_FAILURE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 39 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_populate_device_get_irq_info_failure " "VFIO_DEVICE_GET_IRQ_INFO failure: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , errstr);
#line 1587 "trace/trace-hw_vfio.h"
        } else {
#line 39 "../hw/vfio/trace-events"
            qemu_log("vfio_populate_device_get_irq_info_failure " "VFIO_DEVICE_GET_IRQ_INFO failure: %s" "\n", errstr);
#line 1591 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_populate_device_get_irq_info_failure(const char * errstr)
{
    if (true) {
        _nocheck__trace_vfio_populate_device_get_irq_info_failure(errstr);
    }
}

#define TRACE_VFIO_ATTACH_DEVICE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_ATTACH_DEVICE) || \
    false)

static inline void _nocheck__trace_vfio_attach_device(const char * name, int group_id)
{
    if (trace_event_get_state(TRACE_VFIO_ATTACH_DEVICE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 40 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_attach_device " " (%s) group %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, group_id);
#line 1618 "trace/trace-hw_vfio.h"
        } else {
#line 40 "../hw/vfio/trace-events"
            qemu_log("vfio_attach_device " " (%s) group %d" "\n", name, group_id);
#line 1622 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_attach_device(const char * name, int group_id)
{
    if (true) {
        _nocheck__trace_vfio_attach_device(name, group_id);
    }
}

#define TRACE_VFIO_DETACH_DEVICE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_DETACH_DEVICE) || \
    false)

static inline void _nocheck__trace_vfio_detach_device(const char * name, int group_id)
{
    if (trace_event_get_state(TRACE_VFIO_DETACH_DEVICE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 41 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_detach_device " " (%s) group %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, group_id);
#line 1649 "trace/trace-hw_vfio.h"
        } else {
#line 41 "../hw/vfio/trace-events"
            qemu_log("vfio_detach_device " " (%s) group %d" "\n", name, group_id);
#line 1653 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_detach_device(const char * name, int group_id)
{
    if (true) {
        _nocheck__trace_vfio_detach_device(name, group_id);
    }
}

#define TRACE_VFIO_MDEV_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_MDEV) || \
    false)

static inline void _nocheck__trace_vfio_mdev(const char * name, bool is_mdev)
{
    if (trace_event_get_state(TRACE_VFIO_MDEV) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 42 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_mdev " " (%s) is_mdev %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, is_mdev);
#line 1680 "trace/trace-hw_vfio.h"
        } else {
#line 42 "../hw/vfio/trace-events"
            qemu_log("vfio_mdev " " (%s) is_mdev %d" "\n", name, is_mdev);
#line 1684 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_mdev(const char * name, bool is_mdev)
{
    if (true) {
        _nocheck__trace_vfio_mdev(name, is_mdev);
    }
}

#define TRACE_VFIO_ADD_EXT_CAP_DROPPED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_ADD_EXT_CAP_DROPPED) || \
    false)

static inline void _nocheck__trace_vfio_add_ext_cap_dropped(const char * name, uint16_t cap, uint16_t offset)
{
    if (trace_event_get_state(TRACE_VFIO_ADD_EXT_CAP_DROPPED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 43 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_add_ext_cap_dropped " "%s 0x%x@0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, cap, offset);
#line 1711 "trace/trace-hw_vfio.h"
        } else {
#line 43 "../hw/vfio/trace-events"
            qemu_log("vfio_add_ext_cap_dropped " "%s 0x%x@0x%x" "\n", name, cap, offset);
#line 1715 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_add_ext_cap_dropped(const char * name, uint16_t cap, uint16_t offset)
{
    if (true) {
        _nocheck__trace_vfio_add_ext_cap_dropped(name, cap, offset);
    }
}

#define TRACE_VFIO_PCI_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_PCI_RESET) || \
    false)

static inline void _nocheck__trace_vfio_pci_reset(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_PCI_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 44 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_pci_reset " " (%s)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 1742 "trace/trace-hw_vfio.h"
        } else {
#line 44 "../hw/vfio/trace-events"
            qemu_log("vfio_pci_reset " " (%s)" "\n", name);
#line 1746 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_pci_reset(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_pci_reset(name);
    }
}

#define TRACE_VFIO_PCI_RESET_FLR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_PCI_RESET_FLR) || \
    false)

static inline void _nocheck__trace_vfio_pci_reset_flr(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_PCI_RESET_FLR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 45 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_pci_reset_flr " "%s FLR/VFIO_DEVICE_RESET" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 1773 "trace/trace-hw_vfio.h"
        } else {
#line 45 "../hw/vfio/trace-events"
            qemu_log("vfio_pci_reset_flr " "%s FLR/VFIO_DEVICE_RESET" "\n", name);
#line 1777 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_pci_reset_flr(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_pci_reset_flr(name);
    }
}

#define TRACE_VFIO_PCI_RESET_PM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_PCI_RESET_PM) || \
    false)

static inline void _nocheck__trace_vfio_pci_reset_pm(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_PCI_RESET_PM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 46 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_pci_reset_pm " "%s PCI PM Reset" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 1804 "trace/trace-hw_vfio.h"
        } else {
#line 46 "../hw/vfio/trace-events"
            qemu_log("vfio_pci_reset_pm " "%s PCI PM Reset" "\n", name);
#line 1808 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_pci_reset_pm(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_pci_reset_pm(name);
    }
}

#define TRACE_VFIO_PCI_EMULATED_VENDOR_ID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_PCI_EMULATED_VENDOR_ID) || \
    false)

static inline void _nocheck__trace_vfio_pci_emulated_vendor_id(const char * name, uint16_t val)
{
    if (trace_event_get_state(TRACE_VFIO_PCI_EMULATED_VENDOR_ID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 47 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_pci_emulated_vendor_id " "%s 0x%04x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, val);
#line 1835 "trace/trace-hw_vfio.h"
        } else {
#line 47 "../hw/vfio/trace-events"
            qemu_log("vfio_pci_emulated_vendor_id " "%s 0x%04x" "\n", name, val);
#line 1839 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_pci_emulated_vendor_id(const char * name, uint16_t val)
{
    if (true) {
        _nocheck__trace_vfio_pci_emulated_vendor_id(name, val);
    }
}

#define TRACE_VFIO_PCI_EMULATED_DEVICE_ID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_PCI_EMULATED_DEVICE_ID) || \
    false)

static inline void _nocheck__trace_vfio_pci_emulated_device_id(const char * name, uint16_t val)
{
    if (trace_event_get_state(TRACE_VFIO_PCI_EMULATED_DEVICE_ID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 48 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_pci_emulated_device_id " "%s 0x%04x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, val);
#line 1866 "trace/trace-hw_vfio.h"
        } else {
#line 48 "../hw/vfio/trace-events"
            qemu_log("vfio_pci_emulated_device_id " "%s 0x%04x" "\n", name, val);
#line 1870 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_pci_emulated_device_id(const char * name, uint16_t val)
{
    if (true) {
        _nocheck__trace_vfio_pci_emulated_device_id(name, val);
    }
}

#define TRACE_VFIO_PCI_EMULATED_SUB_VENDOR_ID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_PCI_EMULATED_SUB_VENDOR_ID) || \
    false)

static inline void _nocheck__trace_vfio_pci_emulated_sub_vendor_id(const char * name, uint16_t val)
{
    if (trace_event_get_state(TRACE_VFIO_PCI_EMULATED_SUB_VENDOR_ID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 49 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_pci_emulated_sub_vendor_id " "%s 0x%04x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, val);
#line 1897 "trace/trace-hw_vfio.h"
        } else {
#line 49 "../hw/vfio/trace-events"
            qemu_log("vfio_pci_emulated_sub_vendor_id " "%s 0x%04x" "\n", name, val);
#line 1901 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_pci_emulated_sub_vendor_id(const char * name, uint16_t val)
{
    if (true) {
        _nocheck__trace_vfio_pci_emulated_sub_vendor_id(name, val);
    }
}

#define TRACE_VFIO_PCI_EMULATED_SUB_DEVICE_ID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_PCI_EMULATED_SUB_DEVICE_ID) || \
    false)

static inline void _nocheck__trace_vfio_pci_emulated_sub_device_id(const char * name, uint16_t val)
{
    if (trace_event_get_state(TRACE_VFIO_PCI_EMULATED_SUB_DEVICE_ID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 50 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_pci_emulated_sub_device_id " "%s 0x%04x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, val);
#line 1928 "trace/trace-hw_vfio.h"
        } else {
#line 50 "../hw/vfio/trace-events"
            qemu_log("vfio_pci_emulated_sub_device_id " "%s 0x%04x" "\n", name, val);
#line 1932 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_pci_emulated_sub_device_id(const char * name, uint16_t val)
{
    if (true) {
        _nocheck__trace_vfio_pci_emulated_sub_device_id(name, val);
    }
}

#define TRACE_VFIO_QUIRK_ROM_IN_DENYLIST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_QUIRK_ROM_IN_DENYLIST) || \
    false)

static inline void _nocheck__trace_vfio_quirk_rom_in_denylist(const char * name, uint16_t vid, uint16_t did)
{
    if (trace_event_get_state(TRACE_VFIO_QUIRK_ROM_IN_DENYLIST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 53 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_quirk_rom_in_denylist " "%s %04x:%04x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, vid, did);
#line 1959 "trace/trace-hw_vfio.h"
        } else {
#line 53 "../hw/vfio/trace-events"
            qemu_log("vfio_quirk_rom_in_denylist " "%s %04x:%04x" "\n", name, vid, did);
#line 1963 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_quirk_rom_in_denylist(const char * name, uint16_t vid, uint16_t did)
{
    if (true) {
        _nocheck__trace_vfio_quirk_rom_in_denylist(name, vid, did);
    }
}

#define TRACE_VFIO_QUIRK_GENERIC_WINDOW_ADDRESS_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_QUIRK_GENERIC_WINDOW_ADDRESS_WRITE) || \
    false)

static inline void _nocheck__trace_vfio_quirk_generic_window_address_write(const char * name, const char * region_name, uint64_t data)
{
    if (trace_event_get_state(TRACE_VFIO_QUIRK_GENERIC_WINDOW_ADDRESS_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 54 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_quirk_generic_window_address_write " "%s %s 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, region_name, data);
#line 1990 "trace/trace-hw_vfio.h"
        } else {
#line 54 "../hw/vfio/trace-events"
            qemu_log("vfio_quirk_generic_window_address_write " "%s %s 0x%"PRIx64 "\n", name, region_name, data);
#line 1994 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_quirk_generic_window_address_write(const char * name, const char * region_name, uint64_t data)
{
    if (true) {
        _nocheck__trace_vfio_quirk_generic_window_address_write(name, region_name, data);
    }
}

#define TRACE_VFIO_QUIRK_GENERIC_WINDOW_DATA_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_QUIRK_GENERIC_WINDOW_DATA_READ) || \
    false)

static inline void _nocheck__trace_vfio_quirk_generic_window_data_read(const char * name, const char * region_name, uint64_t data)
{
    if (trace_event_get_state(TRACE_VFIO_QUIRK_GENERIC_WINDOW_DATA_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 55 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_quirk_generic_window_data_read " "%s %s 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, region_name, data);
#line 2021 "trace/trace-hw_vfio.h"
        } else {
#line 55 "../hw/vfio/trace-events"
            qemu_log("vfio_quirk_generic_window_data_read " "%s %s 0x%"PRIx64 "\n", name, region_name, data);
#line 2025 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_quirk_generic_window_data_read(const char * name, const char * region_name, uint64_t data)
{
    if (true) {
        _nocheck__trace_vfio_quirk_generic_window_data_read(name, region_name, data);
    }
}

#define TRACE_VFIO_QUIRK_GENERIC_WINDOW_DATA_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_QUIRK_GENERIC_WINDOW_DATA_WRITE) || \
    false)

static inline void _nocheck__trace_vfio_quirk_generic_window_data_write(const char * name, const char * region_name, uint64_t data)
{
    if (trace_event_get_state(TRACE_VFIO_QUIRK_GENERIC_WINDOW_DATA_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 56 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_quirk_generic_window_data_write " "%s %s 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, region_name, data);
#line 2052 "trace/trace-hw_vfio.h"
        } else {
#line 56 "../hw/vfio/trace-events"
            qemu_log("vfio_quirk_generic_window_data_write " "%s %s 0x%"PRIx64 "\n", name, region_name, data);
#line 2056 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_quirk_generic_window_data_write(const char * name, const char * region_name, uint64_t data)
{
    if (true) {
        _nocheck__trace_vfio_quirk_generic_window_data_write(name, region_name, data);
    }
}

#define TRACE_VFIO_QUIRK_GENERIC_MIRROR_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_QUIRK_GENERIC_MIRROR_READ) || \
    false)

static inline void _nocheck__trace_vfio_quirk_generic_mirror_read(const char * name, const char * region_name, uint64_t addr, uint64_t data)
{
    if (trace_event_get_state(TRACE_VFIO_QUIRK_GENERIC_MIRROR_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 57 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_quirk_generic_mirror_read " "%s %s 0x%"PRIx64": 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, region_name, addr, data);
#line 2083 "trace/trace-hw_vfio.h"
        } else {
#line 57 "../hw/vfio/trace-events"
            qemu_log("vfio_quirk_generic_mirror_read " "%s %s 0x%"PRIx64": 0x%"PRIx64 "\n", name, region_name, addr, data);
#line 2087 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_quirk_generic_mirror_read(const char * name, const char * region_name, uint64_t addr, uint64_t data)
{
    if (true) {
        _nocheck__trace_vfio_quirk_generic_mirror_read(name, region_name, addr, data);
    }
}

#define TRACE_VFIO_QUIRK_GENERIC_MIRROR_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_QUIRK_GENERIC_MIRROR_WRITE) || \
    false)

static inline void _nocheck__trace_vfio_quirk_generic_mirror_write(const char * name, const char * region_name, uint64_t addr, uint64_t data)
{
    if (trace_event_get_state(TRACE_VFIO_QUIRK_GENERIC_MIRROR_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 58 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_quirk_generic_mirror_write " "%s %s 0x%"PRIx64": 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, region_name, addr, data);
#line 2114 "trace/trace-hw_vfio.h"
        } else {
#line 58 "../hw/vfio/trace-events"
            qemu_log("vfio_quirk_generic_mirror_write " "%s %s 0x%"PRIx64": 0x%"PRIx64 "\n", name, region_name, addr, data);
#line 2118 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_quirk_generic_mirror_write(const char * name, const char * region_name, uint64_t addr, uint64_t data)
{
    if (true) {
        _nocheck__trace_vfio_quirk_generic_mirror_write(name, region_name, addr, data);
    }
}

#define TRACE_VFIO_QUIRK_ATI_3C3_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_QUIRK_ATI_3C3_READ) || \
    false)

static inline void _nocheck__trace_vfio_quirk_ati_3c3_read(const char * name, uint64_t data)
{
    if (trace_event_get_state(TRACE_VFIO_QUIRK_ATI_3C3_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 59 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_quirk_ati_3c3_read " "%s 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, data);
#line 2145 "trace/trace-hw_vfio.h"
        } else {
#line 59 "../hw/vfio/trace-events"
            qemu_log("vfio_quirk_ati_3c3_read " "%s 0x%"PRIx64 "\n", name, data);
#line 2149 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_quirk_ati_3c3_read(const char * name, uint64_t data)
{
    if (true) {
        _nocheck__trace_vfio_quirk_ati_3c3_read(name, data);
    }
}

#define TRACE_VFIO_QUIRK_ATI_3C3_PROBE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_QUIRK_ATI_3C3_PROBE) || \
    false)

static inline void _nocheck__trace_vfio_quirk_ati_3c3_probe(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_QUIRK_ATI_3C3_PROBE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 60 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_quirk_ati_3c3_probe " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 2176 "trace/trace-hw_vfio.h"
        } else {
#line 60 "../hw/vfio/trace-events"
            qemu_log("vfio_quirk_ati_3c3_probe " "%s" "\n", name);
#line 2180 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_quirk_ati_3c3_probe(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_quirk_ati_3c3_probe(name);
    }
}

#define TRACE_VFIO_QUIRK_ATI_BAR4_PROBE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_QUIRK_ATI_BAR4_PROBE) || \
    false)

static inline void _nocheck__trace_vfio_quirk_ati_bar4_probe(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_QUIRK_ATI_BAR4_PROBE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 61 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_quirk_ati_bar4_probe " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 2207 "trace/trace-hw_vfio.h"
        } else {
#line 61 "../hw/vfio/trace-events"
            qemu_log("vfio_quirk_ati_bar4_probe " "%s" "\n", name);
#line 2211 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_quirk_ati_bar4_probe(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_quirk_ati_bar4_probe(name);
    }
}

#define TRACE_VFIO_QUIRK_ATI_BAR2_PROBE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_QUIRK_ATI_BAR2_PROBE) || \
    false)

static inline void _nocheck__trace_vfio_quirk_ati_bar2_probe(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_QUIRK_ATI_BAR2_PROBE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 62 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_quirk_ati_bar2_probe " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 2238 "trace/trace-hw_vfio.h"
        } else {
#line 62 "../hw/vfio/trace-events"
            qemu_log("vfio_quirk_ati_bar2_probe " "%s" "\n", name);
#line 2242 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_quirk_ati_bar2_probe(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_quirk_ati_bar2_probe(name);
    }
}

#define TRACE_VFIO_QUIRK_NVIDIA_3D0_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_QUIRK_NVIDIA_3D0_STATE) || \
    false)

static inline void _nocheck__trace_vfio_quirk_nvidia_3d0_state(const char * name, const char * state)
{
    if (trace_event_get_state(TRACE_VFIO_QUIRK_NVIDIA_3D0_STATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 63 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_quirk_nvidia_3d0_state " "%s %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, state);
#line 2269 "trace/trace-hw_vfio.h"
        } else {
#line 63 "../hw/vfio/trace-events"
            qemu_log("vfio_quirk_nvidia_3d0_state " "%s %s" "\n", name, state);
#line 2273 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_quirk_nvidia_3d0_state(const char * name, const char * state)
{
    if (true) {
        _nocheck__trace_vfio_quirk_nvidia_3d0_state(name, state);
    }
}

#define TRACE_VFIO_QUIRK_NVIDIA_3D0_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_QUIRK_NVIDIA_3D0_READ) || \
    false)

static inline void _nocheck__trace_vfio_quirk_nvidia_3d0_read(const char * name, uint8_t offset, unsigned size, uint64_t val)
{
    if (trace_event_get_state(TRACE_VFIO_QUIRK_NVIDIA_3D0_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 64 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_quirk_nvidia_3d0_read " " (%s, @0x%x, len=0x%x) 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset, size, val);
#line 2300 "trace/trace-hw_vfio.h"
        } else {
#line 64 "../hw/vfio/trace-events"
            qemu_log("vfio_quirk_nvidia_3d0_read " " (%s, @0x%x, len=0x%x) 0x%"PRIx64 "\n", name, offset, size, val);
#line 2304 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_quirk_nvidia_3d0_read(const char * name, uint8_t offset, unsigned size, uint64_t val)
{
    if (true) {
        _nocheck__trace_vfio_quirk_nvidia_3d0_read(name, offset, size, val);
    }
}

#define TRACE_VFIO_QUIRK_NVIDIA_3D0_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_QUIRK_NVIDIA_3D0_WRITE) || \
    false)

static inline void _nocheck__trace_vfio_quirk_nvidia_3d0_write(const char * name, uint8_t offset, uint64_t data, unsigned size)
{
    if (trace_event_get_state(TRACE_VFIO_QUIRK_NVIDIA_3D0_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 65 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_quirk_nvidia_3d0_write " "(%s, @0x%x, 0x%"PRIx64", len=0x%x)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset, data, size);
#line 2331 "trace/trace-hw_vfio.h"
        } else {
#line 65 "../hw/vfio/trace-events"
            qemu_log("vfio_quirk_nvidia_3d0_write " "(%s, @0x%x, 0x%"PRIx64", len=0x%x)" "\n", name, offset, data, size);
#line 2335 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_quirk_nvidia_3d0_write(const char * name, uint8_t offset, uint64_t data, unsigned size)
{
    if (true) {
        _nocheck__trace_vfio_quirk_nvidia_3d0_write(name, offset, data, size);
    }
}

#define TRACE_VFIO_QUIRK_NVIDIA_3D0_PROBE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_QUIRK_NVIDIA_3D0_PROBE) || \
    false)

static inline void _nocheck__trace_vfio_quirk_nvidia_3d0_probe(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_QUIRK_NVIDIA_3D0_PROBE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 66 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_quirk_nvidia_3d0_probe " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 2362 "trace/trace-hw_vfio.h"
        } else {
#line 66 "../hw/vfio/trace-events"
            qemu_log("vfio_quirk_nvidia_3d0_probe " "%s" "\n", name);
#line 2366 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_quirk_nvidia_3d0_probe(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_quirk_nvidia_3d0_probe(name);
    }
}

#define TRACE_VFIO_QUIRK_NVIDIA_BAR5_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_QUIRK_NVIDIA_BAR5_STATE) || \
    false)

static inline void _nocheck__trace_vfio_quirk_nvidia_bar5_state(const char * name, const char * state)
{
    if (trace_event_get_state(TRACE_VFIO_QUIRK_NVIDIA_BAR5_STATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 67 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_quirk_nvidia_bar5_state " "%s %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, state);
#line 2393 "trace/trace-hw_vfio.h"
        } else {
#line 67 "../hw/vfio/trace-events"
            qemu_log("vfio_quirk_nvidia_bar5_state " "%s %s" "\n", name, state);
#line 2397 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_quirk_nvidia_bar5_state(const char * name, const char * state)
{
    if (true) {
        _nocheck__trace_vfio_quirk_nvidia_bar5_state(name, state);
    }
}

#define TRACE_VFIO_QUIRK_NVIDIA_BAR5_PROBE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_QUIRK_NVIDIA_BAR5_PROBE) || \
    false)

static inline void _nocheck__trace_vfio_quirk_nvidia_bar5_probe(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_QUIRK_NVIDIA_BAR5_PROBE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 68 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_quirk_nvidia_bar5_probe " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 2424 "trace/trace-hw_vfio.h"
        } else {
#line 68 "../hw/vfio/trace-events"
            qemu_log("vfio_quirk_nvidia_bar5_probe " "%s" "\n", name);
#line 2428 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_quirk_nvidia_bar5_probe(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_quirk_nvidia_bar5_probe(name);
    }
}

#define TRACE_VFIO_QUIRK_NVIDIA_BAR0_MSI_ACK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_QUIRK_NVIDIA_BAR0_MSI_ACK) || \
    false)

static inline void _nocheck__trace_vfio_quirk_nvidia_bar0_msi_ack(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_QUIRK_NVIDIA_BAR0_MSI_ACK) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 69 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_quirk_nvidia_bar0_msi_ack " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 2455 "trace/trace-hw_vfio.h"
        } else {
#line 69 "../hw/vfio/trace-events"
            qemu_log("vfio_quirk_nvidia_bar0_msi_ack " "%s" "\n", name);
#line 2459 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_quirk_nvidia_bar0_msi_ack(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_quirk_nvidia_bar0_msi_ack(name);
    }
}

#define TRACE_VFIO_QUIRK_NVIDIA_BAR0_PROBE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_QUIRK_NVIDIA_BAR0_PROBE) || \
    false)

static inline void _nocheck__trace_vfio_quirk_nvidia_bar0_probe(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_QUIRK_NVIDIA_BAR0_PROBE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 70 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_quirk_nvidia_bar0_probe " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 2486 "trace/trace-hw_vfio.h"
        } else {
#line 70 "../hw/vfio/trace-events"
            qemu_log("vfio_quirk_nvidia_bar0_probe " "%s" "\n", name);
#line 2490 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_quirk_nvidia_bar0_probe(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_quirk_nvidia_bar0_probe(name);
    }
}

#define TRACE_VFIO_QUIRK_RTL8168_FAKE_LATCH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_QUIRK_RTL8168_FAKE_LATCH) || \
    false)

static inline void _nocheck__trace_vfio_quirk_rtl8168_fake_latch(const char * name, uint64_t val)
{
    if (trace_event_get_state(TRACE_VFIO_QUIRK_RTL8168_FAKE_LATCH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 71 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_quirk_rtl8168_fake_latch " "%s 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, val);
#line 2517 "trace/trace-hw_vfio.h"
        } else {
#line 71 "../hw/vfio/trace-events"
            qemu_log("vfio_quirk_rtl8168_fake_latch " "%s 0x%"PRIx64 "\n", name, val);
#line 2521 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_quirk_rtl8168_fake_latch(const char * name, uint64_t val)
{
    if (true) {
        _nocheck__trace_vfio_quirk_rtl8168_fake_latch(name, val);
    }
}

#define TRACE_VFIO_QUIRK_RTL8168_MSIX_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_QUIRK_RTL8168_MSIX_WRITE) || \
    false)

static inline void _nocheck__trace_vfio_quirk_rtl8168_msix_write(const char * name, uint16_t offset, uint64_t val)
{
    if (trace_event_get_state(TRACE_VFIO_QUIRK_RTL8168_MSIX_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 72 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_quirk_rtl8168_msix_write " "%s MSI-X table write[0x%x]: 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset, val);
#line 2548 "trace/trace-hw_vfio.h"
        } else {
#line 72 "../hw/vfio/trace-events"
            qemu_log("vfio_quirk_rtl8168_msix_write " "%s MSI-X table write[0x%x]: 0x%"PRIx64 "\n", name, offset, val);
#line 2552 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_quirk_rtl8168_msix_write(const char * name, uint16_t offset, uint64_t val)
{
    if (true) {
        _nocheck__trace_vfio_quirk_rtl8168_msix_write(name, offset, val);
    }
}

#define TRACE_VFIO_QUIRK_RTL8168_MSIX_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_QUIRK_RTL8168_MSIX_READ) || \
    false)

static inline void _nocheck__trace_vfio_quirk_rtl8168_msix_read(const char * name, uint16_t offset, uint64_t val)
{
    if (trace_event_get_state(TRACE_VFIO_QUIRK_RTL8168_MSIX_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 73 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_quirk_rtl8168_msix_read " "%s MSI-X table read[0x%x]: 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset, val);
#line 2579 "trace/trace-hw_vfio.h"
        } else {
#line 73 "../hw/vfio/trace-events"
            qemu_log("vfio_quirk_rtl8168_msix_read " "%s MSI-X table read[0x%x]: 0x%"PRIx64 "\n", name, offset, val);
#line 2583 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_quirk_rtl8168_msix_read(const char * name, uint16_t offset, uint64_t val)
{
    if (true) {
        _nocheck__trace_vfio_quirk_rtl8168_msix_read(name, offset, val);
    }
}

#define TRACE_VFIO_QUIRK_RTL8168_PROBE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_QUIRK_RTL8168_PROBE) || \
    false)

static inline void _nocheck__trace_vfio_quirk_rtl8168_probe(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_QUIRK_RTL8168_PROBE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 74 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_quirk_rtl8168_probe " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 2610 "trace/trace-hw_vfio.h"
        } else {
#line 74 "../hw/vfio/trace-events"
            qemu_log("vfio_quirk_rtl8168_probe " "%s" "\n", name);
#line 2614 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_quirk_rtl8168_probe(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_quirk_rtl8168_probe(name);
    }
}

#define TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_SKIPPED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_SKIPPED) || \
    false)

static inline void _nocheck__trace_vfio_quirk_ati_bonaire_reset_skipped(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_SKIPPED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 76 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_quirk_ati_bonaire_reset_skipped " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 2641 "trace/trace-hw_vfio.h"
        } else {
#line 76 "../hw/vfio/trace-events"
            qemu_log("vfio_quirk_ati_bonaire_reset_skipped " "%s" "\n", name);
#line 2645 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_quirk_ati_bonaire_reset_skipped(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_quirk_ati_bonaire_reset_skipped(name);
    }
}

#define TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_NO_SMC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_NO_SMC) || \
    false)

static inline void _nocheck__trace_vfio_quirk_ati_bonaire_reset_no_smc(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_NO_SMC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 77 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_quirk_ati_bonaire_reset_no_smc " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 2672 "trace/trace-hw_vfio.h"
        } else {
#line 77 "../hw/vfio/trace-events"
            qemu_log("vfio_quirk_ati_bonaire_reset_no_smc " "%s" "\n", name);
#line 2676 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_quirk_ati_bonaire_reset_no_smc(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_quirk_ati_bonaire_reset_no_smc(name);
    }
}

#define TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_TIMEOUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_TIMEOUT) || \
    false)

static inline void _nocheck__trace_vfio_quirk_ati_bonaire_reset_timeout(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_TIMEOUT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 78 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_quirk_ati_bonaire_reset_timeout " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 2703 "trace/trace-hw_vfio.h"
        } else {
#line 78 "../hw/vfio/trace-events"
            qemu_log("vfio_quirk_ati_bonaire_reset_timeout " "%s" "\n", name);
#line 2707 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_quirk_ati_bonaire_reset_timeout(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_quirk_ati_bonaire_reset_timeout(name);
    }
}

#define TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_DONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_DONE) || \
    false)

static inline void _nocheck__trace_vfio_quirk_ati_bonaire_reset_done(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_DONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 79 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_quirk_ati_bonaire_reset_done " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 2734 "trace/trace-hw_vfio.h"
        } else {
#line 79 "../hw/vfio/trace-events"
            qemu_log("vfio_quirk_ati_bonaire_reset_done " "%s" "\n", name);
#line 2738 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_quirk_ati_bonaire_reset_done(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_quirk_ati_bonaire_reset_done(name);
    }
}

#define TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET) || \
    false)

static inline void _nocheck__trace_vfio_quirk_ati_bonaire_reset(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 80 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_quirk_ati_bonaire_reset " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 2765 "trace/trace-hw_vfio.h"
        } else {
#line 80 "../hw/vfio/trace-events"
            qemu_log("vfio_quirk_ati_bonaire_reset " "%s" "\n", name);
#line 2769 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_quirk_ati_bonaire_reset(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_quirk_ati_bonaire_reset(name);
    }
}

#define TRACE_VFIO_IOEVENTFD_EXIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_IOEVENTFD_EXIT) || \
    false)

static inline void _nocheck__trace_vfio_ioeventfd_exit(const char * name, uint64_t addr, unsigned size, uint64_t data)
{
    if (trace_event_get_state(TRACE_VFIO_IOEVENTFD_EXIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 81 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_ioeventfd_exit " "%s+0x%"PRIx64"[%d]:0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, addr, size, data);
#line 2796 "trace/trace-hw_vfio.h"
        } else {
#line 81 "../hw/vfio/trace-events"
            qemu_log("vfio_ioeventfd_exit " "%s+0x%"PRIx64"[%d]:0x%"PRIx64 "\n", name, addr, size, data);
#line 2800 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_ioeventfd_exit(const char * name, uint64_t addr, unsigned size, uint64_t data)
{
    if (true) {
        _nocheck__trace_vfio_ioeventfd_exit(name, addr, size, data);
    }
}

#define TRACE_VFIO_IOEVENTFD_HANDLER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_IOEVENTFD_HANDLER) || \
    false)

static inline void _nocheck__trace_vfio_ioeventfd_handler(const char * name, uint64_t addr, unsigned size, uint64_t data)
{
    if (trace_event_get_state(TRACE_VFIO_IOEVENTFD_HANDLER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 82 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_ioeventfd_handler " "%s+0x%"PRIx64"[%d] -> 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, addr, size, data);
#line 2827 "trace/trace-hw_vfio.h"
        } else {
#line 82 "../hw/vfio/trace-events"
            qemu_log("vfio_ioeventfd_handler " "%s+0x%"PRIx64"[%d] -> 0x%"PRIx64 "\n", name, addr, size, data);
#line 2831 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_ioeventfd_handler(const char * name, uint64_t addr, unsigned size, uint64_t data)
{
    if (true) {
        _nocheck__trace_vfio_ioeventfd_handler(name, addr, size, data);
    }
}

#define TRACE_VFIO_IOEVENTFD_INIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_IOEVENTFD_INIT) || \
    false)

static inline void _nocheck__trace_vfio_ioeventfd_init(const char * name, uint64_t addr, unsigned size, uint64_t data, bool vfio)
{
    if (trace_event_get_state(TRACE_VFIO_IOEVENTFD_INIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 83 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_ioeventfd_init " "%s+0x%"PRIx64"[%d]:0x%"PRIx64" vfio:%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, addr, size, data, vfio);
#line 2858 "trace/trace-hw_vfio.h"
        } else {
#line 83 "../hw/vfio/trace-events"
            qemu_log("vfio_ioeventfd_init " "%s+0x%"PRIx64"[%d]:0x%"PRIx64" vfio:%d" "\n", name, addr, size, data, vfio);
#line 2862 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_ioeventfd_init(const char * name, uint64_t addr, unsigned size, uint64_t data, bool vfio)
{
    if (true) {
        _nocheck__trace_vfio_ioeventfd_init(name, addr, size, data, vfio);
    }
}

#define TRACE_VFIO_PCI_IGD_OPREGION_ENABLED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_PCI_IGD_OPREGION_ENABLED) || \
    false)

static inline void _nocheck__trace_vfio_pci_igd_opregion_enabled(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_PCI_IGD_OPREGION_ENABLED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 84 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_pci_igd_opregion_enabled " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 2889 "trace/trace-hw_vfio.h"
        } else {
#line 84 "../hw/vfio/trace-events"
            qemu_log("vfio_pci_igd_opregion_enabled " "%s" "\n", name);
#line 2893 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_pci_igd_opregion_enabled(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_pci_igd_opregion_enabled(name);
    }
}

#define TRACE_VFIO_PCI_IGD_BAR4_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_PCI_IGD_BAR4_WRITE) || \
    false)

static inline void _nocheck__trace_vfio_pci_igd_bar4_write(const char * name, uint32_t index, uint32_t data, uint32_t base)
{
    if (trace_event_get_state(TRACE_VFIO_PCI_IGD_BAR4_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 87 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_pci_igd_bar4_write " "%s [0x%03x] 0x%08x -> 0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, index, data, base);
#line 2920 "trace/trace-hw_vfio.h"
        } else {
#line 87 "../hw/vfio/trace-events"
            qemu_log("vfio_pci_igd_bar4_write " "%s [0x%03x] 0x%08x -> 0x%08x" "\n", name, index, data, base);
#line 2924 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_pci_igd_bar4_write(const char * name, uint32_t index, uint32_t data, uint32_t base)
{
    if (true) {
        _nocheck__trace_vfio_pci_igd_bar4_write(name, index, data, base);
    }
}

#define TRACE_VFIO_PCI_IGD_BDSM_ENABLED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_PCI_IGD_BDSM_ENABLED) || \
    false)

static inline void _nocheck__trace_vfio_pci_igd_bdsm_enabled(const char * name, int size)
{
    if (trace_event_get_state(TRACE_VFIO_PCI_IGD_BDSM_ENABLED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 88 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_pci_igd_bdsm_enabled " "%s %dMB" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, size);
#line 2951 "trace/trace-hw_vfio.h"
        } else {
#line 88 "../hw/vfio/trace-events"
            qemu_log("vfio_pci_igd_bdsm_enabled " "%s %dMB" "\n", name, size);
#line 2955 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_pci_igd_bdsm_enabled(const char * name, int size)
{
    if (true) {
        _nocheck__trace_vfio_pci_igd_bdsm_enabled(name, size);
    }
}

#define TRACE_VFIO_PCI_IGD_HOST_BRIDGE_ENABLED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_PCI_IGD_HOST_BRIDGE_ENABLED) || \
    false)

static inline void _nocheck__trace_vfio_pci_igd_host_bridge_enabled(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_PCI_IGD_HOST_BRIDGE_ENABLED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 89 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_pci_igd_host_bridge_enabled " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 2982 "trace/trace-hw_vfio.h"
        } else {
#line 89 "../hw/vfio/trace-events"
            qemu_log("vfio_pci_igd_host_bridge_enabled " "%s" "\n", name);
#line 2986 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_pci_igd_host_bridge_enabled(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_pci_igd_host_bridge_enabled(name);
    }
}

#define TRACE_VFIO_PCI_IGD_LPC_BRIDGE_ENABLED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_PCI_IGD_LPC_BRIDGE_ENABLED) || \
    false)

static inline void _nocheck__trace_vfio_pci_igd_lpc_bridge_enabled(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_PCI_IGD_LPC_BRIDGE_ENABLED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 90 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_pci_igd_lpc_bridge_enabled " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 3013 "trace/trace-hw_vfio.h"
        } else {
#line 90 "../hw/vfio/trace-events"
            qemu_log("vfio_pci_igd_lpc_bridge_enabled " "%s" "\n", name);
#line 3017 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_pci_igd_lpc_bridge_enabled(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_pci_igd_lpc_bridge_enabled(name);
    }
}

#define TRACE_VFIO_REGION_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_REGION_WRITE) || \
    false)

static inline void _nocheck__trace_vfio_region_write(const char * name, int index, uint64_t addr, uint64_t data, unsigned size)
{
    if (trace_event_get_state(TRACE_VFIO_REGION_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 93 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_region_write " " (%s:region%d+0x%"PRIx64", 0x%"PRIx64 ", %d)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, index, addr, data, size);
#line 3044 "trace/trace-hw_vfio.h"
        } else {
#line 93 "../hw/vfio/trace-events"
            qemu_log("vfio_region_write " " (%s:region%d+0x%"PRIx64", 0x%"PRIx64 ", %d)" "\n", name, index, addr, data, size);
#line 3048 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_region_write(const char * name, int index, uint64_t addr, uint64_t data, unsigned size)
{
    if (true) {
        _nocheck__trace_vfio_region_write(name, index, addr, data, size);
    }
}

#define TRACE_VFIO_REGION_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_REGION_READ) || \
    false)

static inline void _nocheck__trace_vfio_region_read(char * name, int index, uint64_t addr, unsigned size, uint64_t data)
{
    if (trace_event_get_state(TRACE_VFIO_REGION_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 94 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_region_read " " (%s:region%d+0x%"PRIx64", %d) = 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, index, addr, size, data);
#line 3075 "trace/trace-hw_vfio.h"
        } else {
#line 94 "../hw/vfio/trace-events"
            qemu_log("vfio_region_read " " (%s:region%d+0x%"PRIx64", %d) = 0x%"PRIx64 "\n", name, index, addr, size, data);
#line 3079 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_region_read(char * name, int index, uint64_t addr, unsigned size, uint64_t data)
{
    if (true) {
        _nocheck__trace_vfio_region_read(name, index, addr, size, data);
    }
}

#define TRACE_VFIO_IOMMU_MAP_NOTIFY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_IOMMU_MAP_NOTIFY) || \
    false)

static inline void _nocheck__trace_vfio_iommu_map_notify(const char * op, uint64_t iova_start, uint64_t iova_end)
{
    if (trace_event_get_state(TRACE_VFIO_IOMMU_MAP_NOTIFY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 95 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_iommu_map_notify " "iommu %s @ 0x%"PRIx64" - 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , op, iova_start, iova_end);
#line 3106 "trace/trace-hw_vfio.h"
        } else {
#line 95 "../hw/vfio/trace-events"
            qemu_log("vfio_iommu_map_notify " "iommu %s @ 0x%"PRIx64" - 0x%"PRIx64 "\n", op, iova_start, iova_end);
#line 3110 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_iommu_map_notify(const char * op, uint64_t iova_start, uint64_t iova_end)
{
    if (true) {
        _nocheck__trace_vfio_iommu_map_notify(op, iova_start, iova_end);
    }
}

#define TRACE_VFIO_LISTENER_REGION_SKIP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_LISTENER_REGION_SKIP) || \
    false)

static inline void _nocheck__trace_vfio_listener_region_skip(const char * name, uint64_t start, uint64_t end)
{
    if (trace_event_get_state(TRACE_VFIO_LISTENER_REGION_SKIP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 96 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_listener_region_skip " "SKIPPING %s 0x%"PRIx64" - 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, start, end);
#line 3137 "trace/trace-hw_vfio.h"
        } else {
#line 96 "../hw/vfio/trace-events"
            qemu_log("vfio_listener_region_skip " "SKIPPING %s 0x%"PRIx64" - 0x%"PRIx64 "\n", name, start, end);
#line 3141 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_listener_region_skip(const char * name, uint64_t start, uint64_t end)
{
    if (true) {
        _nocheck__trace_vfio_listener_region_skip(name, start, end);
    }
}

#define TRACE_VFIO_SPAPR_GROUP_ATTACH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_SPAPR_GROUP_ATTACH) || \
    false)

static inline void _nocheck__trace_vfio_spapr_group_attach(int groupfd, int tablefd)
{
    if (trace_event_get_state(TRACE_VFIO_SPAPR_GROUP_ATTACH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 97 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_spapr_group_attach " "Attached groupfd %d to liobn fd %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , groupfd, tablefd);
#line 3168 "trace/trace-hw_vfio.h"
        } else {
#line 97 "../hw/vfio/trace-events"
            qemu_log("vfio_spapr_group_attach " "Attached groupfd %d to liobn fd %d" "\n", groupfd, tablefd);
#line 3172 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_spapr_group_attach(int groupfd, int tablefd)
{
    if (true) {
        _nocheck__trace_vfio_spapr_group_attach(groupfd, tablefd);
    }
}

#define TRACE_VFIO_LISTENER_REGION_ADD_IOMMU_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_LISTENER_REGION_ADD_IOMMU) || \
    false)

static inline void _nocheck__trace_vfio_listener_region_add_iommu(const char* name, uint64_t start, uint64_t end)
{
    if (trace_event_get_state(TRACE_VFIO_LISTENER_REGION_ADD_IOMMU) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 98 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_listener_region_add_iommu " "region_add [iommu] %s 0x%"PRIx64" - 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, start, end);
#line 3199 "trace/trace-hw_vfio.h"
        } else {
#line 98 "../hw/vfio/trace-events"
            qemu_log("vfio_listener_region_add_iommu " "region_add [iommu] %s 0x%"PRIx64" - 0x%"PRIx64 "\n", name, start, end);
#line 3203 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_listener_region_add_iommu(const char* name, uint64_t start, uint64_t end)
{
    if (true) {
        _nocheck__trace_vfio_listener_region_add_iommu(name, start, end);
    }
}

#define TRACE_VFIO_LISTENER_REGION_DEL_IOMMU_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_LISTENER_REGION_DEL_IOMMU) || \
    false)

static inline void _nocheck__trace_vfio_listener_region_del_iommu(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_LISTENER_REGION_DEL_IOMMU) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 99 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_listener_region_del_iommu " "region_del [iommu] %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 3230 "trace/trace-hw_vfio.h"
        } else {
#line 99 "../hw/vfio/trace-events"
            qemu_log("vfio_listener_region_del_iommu " "region_del [iommu] %s" "\n", name);
#line 3234 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_listener_region_del_iommu(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_listener_region_del_iommu(name);
    }
}

#define TRACE_VFIO_LISTENER_REGION_ADD_RAM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_LISTENER_REGION_ADD_RAM) || \
    false)

static inline void _nocheck__trace_vfio_listener_region_add_ram(uint64_t iova_start, uint64_t iova_end, void * vaddr)
{
    if (trace_event_get_state(TRACE_VFIO_LISTENER_REGION_ADD_RAM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 100 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_listener_region_add_ram " "region_add [ram] 0x%"PRIx64" - 0x%"PRIx64" [%p]" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , iova_start, iova_end, vaddr);
#line 3261 "trace/trace-hw_vfio.h"
        } else {
#line 100 "../hw/vfio/trace-events"
            qemu_log("vfio_listener_region_add_ram " "region_add [ram] 0x%"PRIx64" - 0x%"PRIx64" [%p]" "\n", iova_start, iova_end, vaddr);
#line 3265 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_listener_region_add_ram(uint64_t iova_start, uint64_t iova_end, void * vaddr)
{
    if (true) {
        _nocheck__trace_vfio_listener_region_add_ram(iova_start, iova_end, vaddr);
    }
}

#define TRACE_VFIO_KNOWN_SAFE_MISALIGNMENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_KNOWN_SAFE_MISALIGNMENT) || \
    false)

static inline void _nocheck__trace_vfio_known_safe_misalignment(const char * name, uint64_t iova, uint64_t offset_within_region, uintptr_t page_size)
{
    if (trace_event_get_state(TRACE_VFIO_KNOWN_SAFE_MISALIGNMENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 101 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_known_safe_misalignment " "Region \"%s\" iova=0x%"PRIx64" offset_within_region=0x%"PRIx64" qemu_real_host_page_size=0x%"PRIxPTR "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, iova, offset_within_region, page_size);
#line 3292 "trace/trace-hw_vfio.h"
        } else {
#line 101 "../hw/vfio/trace-events"
            qemu_log("vfio_known_safe_misalignment " "Region \"%s\" iova=0x%"PRIx64" offset_within_region=0x%"PRIx64" qemu_real_host_page_size=0x%"PRIxPTR "\n", name, iova, offset_within_region, page_size);
#line 3296 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_known_safe_misalignment(const char * name, uint64_t iova, uint64_t offset_within_region, uintptr_t page_size)
{
    if (true) {
        _nocheck__trace_vfio_known_safe_misalignment(name, iova, offset_within_region, page_size);
    }
}

#define TRACE_VFIO_LISTENER_REGION_ADD_NO_DMA_MAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_LISTENER_REGION_ADD_NO_DMA_MAP) || \
    false)

static inline void _nocheck__trace_vfio_listener_region_add_no_dma_map(const char * name, uint64_t iova, uint64_t size, uint64_t page_size)
{
    if (trace_event_get_state(TRACE_VFIO_LISTENER_REGION_ADD_NO_DMA_MAP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 102 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_listener_region_add_no_dma_map " "Region \"%s\" 0x%"PRIx64" size=0x%"PRIx64" is not aligned to 0x%"PRIx64" and cannot be mapped for DMA" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, iova, size, page_size);
#line 3323 "trace/trace-hw_vfio.h"
        } else {
#line 102 "../hw/vfio/trace-events"
            qemu_log("vfio_listener_region_add_no_dma_map " "Region \"%s\" 0x%"PRIx64" size=0x%"PRIx64" is not aligned to 0x%"PRIx64" and cannot be mapped for DMA" "\n", name, iova, size, page_size);
#line 3327 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_listener_region_add_no_dma_map(const char * name, uint64_t iova, uint64_t size, uint64_t page_size)
{
    if (true) {
        _nocheck__trace_vfio_listener_region_add_no_dma_map(name, iova, size, page_size);
    }
}

#define TRACE_VFIO_LISTENER_REGION_DEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_LISTENER_REGION_DEL) || \
    false)

static inline void _nocheck__trace_vfio_listener_region_del(uint64_t start, uint64_t end)
{
    if (trace_event_get_state(TRACE_VFIO_LISTENER_REGION_DEL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 103 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_listener_region_del " "region_del 0x%"PRIx64" - 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , start, end);
#line 3354 "trace/trace-hw_vfio.h"
        } else {
#line 103 "../hw/vfio/trace-events"
            qemu_log("vfio_listener_region_del " "region_del 0x%"PRIx64" - 0x%"PRIx64 "\n", start, end);
#line 3358 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_listener_region_del(uint64_t start, uint64_t end)
{
    if (true) {
        _nocheck__trace_vfio_listener_region_del(start, end);
    }
}

#define TRACE_VFIO_DEVICE_DIRTY_TRACKING_UPDATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_DEVICE_DIRTY_TRACKING_UPDATE) || \
    false)

static inline void _nocheck__trace_vfio_device_dirty_tracking_update(uint64_t start, uint64_t end, uint64_t min, uint64_t max)
{
    if (trace_event_get_state(TRACE_VFIO_DEVICE_DIRTY_TRACKING_UPDATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 104 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_device_dirty_tracking_update " "section 0x%"PRIx64" - 0x%"PRIx64" -> update [0x%"PRIx64" - 0x%"PRIx64"]" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , start, end, min, max);
#line 3385 "trace/trace-hw_vfio.h"
        } else {
#line 104 "../hw/vfio/trace-events"
            qemu_log("vfio_device_dirty_tracking_update " "section 0x%"PRIx64" - 0x%"PRIx64" -> update [0x%"PRIx64" - 0x%"PRIx64"]" "\n", start, end, min, max);
#line 3389 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_device_dirty_tracking_update(uint64_t start, uint64_t end, uint64_t min, uint64_t max)
{
    if (true) {
        _nocheck__trace_vfio_device_dirty_tracking_update(start, end, min, max);
    }
}

#define TRACE_VFIO_DEVICE_DIRTY_TRACKING_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_DEVICE_DIRTY_TRACKING_START) || \
    false)

static inline void _nocheck__trace_vfio_device_dirty_tracking_start(int nr_ranges, uint64_t min32, uint64_t max32, uint64_t min64, uint64_t max64, uint64_t minpci, uint64_t maxpci)
{
    if (trace_event_get_state(TRACE_VFIO_DEVICE_DIRTY_TRACKING_START) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 105 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_device_dirty_tracking_start " "nr_ranges %d 32:[0x%"PRIx64" - 0x%"PRIx64"], 64:[0x%"PRIx64" - 0x%"PRIx64"], pci64:[0x%"PRIx64" - 0x%"PRIx64"]" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , nr_ranges, min32, max32, min64, max64, minpci, maxpci);
#line 3416 "trace/trace-hw_vfio.h"
        } else {
#line 105 "../hw/vfio/trace-events"
            qemu_log("vfio_device_dirty_tracking_start " "nr_ranges %d 32:[0x%"PRIx64" - 0x%"PRIx64"], 64:[0x%"PRIx64" - 0x%"PRIx64"], pci64:[0x%"PRIx64" - 0x%"PRIx64"]" "\n", nr_ranges, min32, max32, min64, max64, minpci, maxpci);
#line 3420 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_device_dirty_tracking_start(int nr_ranges, uint64_t min32, uint64_t max32, uint64_t min64, uint64_t max64, uint64_t minpci, uint64_t maxpci)
{
    if (true) {
        _nocheck__trace_vfio_device_dirty_tracking_start(nr_ranges, min32, max32, min64, max64, minpci, maxpci);
    }
}

#define TRACE_VFIO_DISCONNECT_CONTAINER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_DISCONNECT_CONTAINER) || \
    false)

static inline void _nocheck__trace_vfio_disconnect_container(int fd)
{
    if (trace_event_get_state(TRACE_VFIO_DISCONNECT_CONTAINER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 106 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_disconnect_container " "close container->fd=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , fd);
#line 3447 "trace/trace-hw_vfio.h"
        } else {
#line 106 "../hw/vfio/trace-events"
            qemu_log("vfio_disconnect_container " "close container->fd=%d" "\n", fd);
#line 3451 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_disconnect_container(int fd)
{
    if (true) {
        _nocheck__trace_vfio_disconnect_container(fd);
    }
}

#define TRACE_VFIO_PUT_GROUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_PUT_GROUP) || \
    false)

static inline void _nocheck__trace_vfio_put_group(int fd)
{
    if (trace_event_get_state(TRACE_VFIO_PUT_GROUP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 107 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_put_group " "close group->fd=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , fd);
#line 3478 "trace/trace-hw_vfio.h"
        } else {
#line 107 "../hw/vfio/trace-events"
            qemu_log("vfio_put_group " "close group->fd=%d" "\n", fd);
#line 3482 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_put_group(int fd)
{
    if (true) {
        _nocheck__trace_vfio_put_group(fd);
    }
}

#define TRACE_VFIO_GET_DEVICE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_GET_DEVICE) || \
    false)

static inline void _nocheck__trace_vfio_get_device(const char * name, unsigned int flags, unsigned int num_regions, unsigned int num_irqs)
{
    if (trace_event_get_state(TRACE_VFIO_GET_DEVICE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 108 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_get_device " "Device %s flags: %u, regions: %u, irqs: %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, flags, num_regions, num_irqs);
#line 3509 "trace/trace-hw_vfio.h"
        } else {
#line 108 "../hw/vfio/trace-events"
            qemu_log("vfio_get_device " "Device %s flags: %u, regions: %u, irqs: %u" "\n", name, flags, num_regions, num_irqs);
#line 3513 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_get_device(const char * name, unsigned int flags, unsigned int num_regions, unsigned int num_irqs)
{
    if (true) {
        _nocheck__trace_vfio_get_device(name, flags, num_regions, num_irqs);
    }
}

#define TRACE_VFIO_PUT_BASE_DEVICE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_PUT_BASE_DEVICE) || \
    false)

static inline void _nocheck__trace_vfio_put_base_device(int fd)
{
    if (trace_event_get_state(TRACE_VFIO_PUT_BASE_DEVICE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 109 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_put_base_device " "close vdev->fd=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , fd);
#line 3540 "trace/trace-hw_vfio.h"
        } else {
#line 109 "../hw/vfio/trace-events"
            qemu_log("vfio_put_base_device " "close vdev->fd=%d" "\n", fd);
#line 3544 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_put_base_device(int fd)
{
    if (true) {
        _nocheck__trace_vfio_put_base_device(fd);
    }
}

#define TRACE_VFIO_REGION_SETUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_REGION_SETUP) || \
    false)

static inline void _nocheck__trace_vfio_region_setup(const char * dev, int index, const char * name, unsigned long flags, unsigned long offset, unsigned long size)
{
    if (trace_event_get_state(TRACE_VFIO_REGION_SETUP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 110 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_region_setup " "Device %s, region %d \"%s\", flags: 0x%lx, offset: 0x%lx, size: 0x%lx" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, index, name, flags, offset, size);
#line 3571 "trace/trace-hw_vfio.h"
        } else {
#line 110 "../hw/vfio/trace-events"
            qemu_log("vfio_region_setup " "Device %s, region %d \"%s\", flags: 0x%lx, offset: 0x%lx, size: 0x%lx" "\n", dev, index, name, flags, offset, size);
#line 3575 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_region_setup(const char * dev, int index, const char * name, unsigned long flags, unsigned long offset, unsigned long size)
{
    if (true) {
        _nocheck__trace_vfio_region_setup(dev, index, name, flags, offset, size);
    }
}

#define TRACE_VFIO_REGION_MMAP_FAULT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_REGION_MMAP_FAULT) || \
    false)

static inline void _nocheck__trace_vfio_region_mmap_fault(const char * name, int index, unsigned long offset, unsigned long size, int fault)
{
    if (trace_event_get_state(TRACE_VFIO_REGION_MMAP_FAULT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 111 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_region_mmap_fault " "Region %s mmaps[%d], [0x%lx - 0x%lx], fault: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, index, offset, size, fault);
#line 3602 "trace/trace-hw_vfio.h"
        } else {
#line 111 "../hw/vfio/trace-events"
            qemu_log("vfio_region_mmap_fault " "Region %s mmaps[%d], [0x%lx - 0x%lx], fault: %d" "\n", name, index, offset, size, fault);
#line 3606 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_region_mmap_fault(const char * name, int index, unsigned long offset, unsigned long size, int fault)
{
    if (true) {
        _nocheck__trace_vfio_region_mmap_fault(name, index, offset, size, fault);
    }
}

#define TRACE_VFIO_REGION_MMAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_REGION_MMAP) || \
    false)

static inline void _nocheck__trace_vfio_region_mmap(const char * name, unsigned long offset, unsigned long end)
{
    if (trace_event_get_state(TRACE_VFIO_REGION_MMAP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 112 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_region_mmap " "Region %s [0x%lx - 0x%lx]" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset, end);
#line 3633 "trace/trace-hw_vfio.h"
        } else {
#line 112 "../hw/vfio/trace-events"
            qemu_log("vfio_region_mmap " "Region %s [0x%lx - 0x%lx]" "\n", name, offset, end);
#line 3637 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_region_mmap(const char * name, unsigned long offset, unsigned long end)
{
    if (true) {
        _nocheck__trace_vfio_region_mmap(name, offset, end);
    }
}

#define TRACE_VFIO_REGION_EXIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_REGION_EXIT) || \
    false)

static inline void _nocheck__trace_vfio_region_exit(const char * name, int index)
{
    if (trace_event_get_state(TRACE_VFIO_REGION_EXIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 113 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_region_exit " "Device %s, region %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, index);
#line 3664 "trace/trace-hw_vfio.h"
        } else {
#line 113 "../hw/vfio/trace-events"
            qemu_log("vfio_region_exit " "Device %s, region %d" "\n", name, index);
#line 3668 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_region_exit(const char * name, int index)
{
    if (true) {
        _nocheck__trace_vfio_region_exit(name, index);
    }
}

#define TRACE_VFIO_REGION_FINALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_REGION_FINALIZE) || \
    false)

static inline void _nocheck__trace_vfio_region_finalize(const char * name, int index)
{
    if (trace_event_get_state(TRACE_VFIO_REGION_FINALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 114 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_region_finalize " "Device %s, region %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, index);
#line 3695 "trace/trace-hw_vfio.h"
        } else {
#line 114 "../hw/vfio/trace-events"
            qemu_log("vfio_region_finalize " "Device %s, region %d" "\n", name, index);
#line 3699 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_region_finalize(const char * name, int index)
{
    if (true) {
        _nocheck__trace_vfio_region_finalize(name, index);
    }
}

#define TRACE_VFIO_REGION_MMAPS_SET_ENABLED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_REGION_MMAPS_SET_ENABLED) || \
    false)

static inline void _nocheck__trace_vfio_region_mmaps_set_enabled(const char * name, bool enabled)
{
    if (trace_event_get_state(TRACE_VFIO_REGION_MMAPS_SET_ENABLED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 115 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_region_mmaps_set_enabled " "Region %s mmaps enabled: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, enabled);
#line 3726 "trace/trace-hw_vfio.h"
        } else {
#line 115 "../hw/vfio/trace-events"
            qemu_log("vfio_region_mmaps_set_enabled " "Region %s mmaps enabled: %d" "\n", name, enabled);
#line 3730 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_region_mmaps_set_enabled(const char * name, bool enabled)
{
    if (true) {
        _nocheck__trace_vfio_region_mmaps_set_enabled(name, enabled);
    }
}

#define TRACE_VFIO_REGION_UNMAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_REGION_UNMAP) || \
    false)

static inline void _nocheck__trace_vfio_region_unmap(const char * name, unsigned long offset, unsigned long end)
{
    if (trace_event_get_state(TRACE_VFIO_REGION_UNMAP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 116 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_region_unmap " "Region %s unmap [0x%lx - 0x%lx]" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset, end);
#line 3757 "trace/trace-hw_vfio.h"
        } else {
#line 116 "../hw/vfio/trace-events"
            qemu_log("vfio_region_unmap " "Region %s unmap [0x%lx - 0x%lx]" "\n", name, offset, end);
#line 3761 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_region_unmap(const char * name, unsigned long offset, unsigned long end)
{
    if (true) {
        _nocheck__trace_vfio_region_unmap(name, offset, end);
    }
}

#define TRACE_VFIO_REGION_SPARSE_MMAP_HEADER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_REGION_SPARSE_MMAP_HEADER) || \
    false)

static inline void _nocheck__trace_vfio_region_sparse_mmap_header(const char * name, int index, int nr_areas)
{
    if (trace_event_get_state(TRACE_VFIO_REGION_SPARSE_MMAP_HEADER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 117 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_region_sparse_mmap_header " "Device %s region %d: %d sparse mmap entries" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, index, nr_areas);
#line 3788 "trace/trace-hw_vfio.h"
        } else {
#line 117 "../hw/vfio/trace-events"
            qemu_log("vfio_region_sparse_mmap_header " "Device %s region %d: %d sparse mmap entries" "\n", name, index, nr_areas);
#line 3792 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_region_sparse_mmap_header(const char * name, int index, int nr_areas)
{
    if (true) {
        _nocheck__trace_vfio_region_sparse_mmap_header(name, index, nr_areas);
    }
}

#define TRACE_VFIO_REGION_SPARSE_MMAP_ENTRY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_REGION_SPARSE_MMAP_ENTRY) || \
    false)

static inline void _nocheck__trace_vfio_region_sparse_mmap_entry(int i, unsigned long start, unsigned long end)
{
    if (trace_event_get_state(TRACE_VFIO_REGION_SPARSE_MMAP_ENTRY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 118 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_region_sparse_mmap_entry " "sparse entry %d [0x%lx - 0x%lx]" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , i, start, end);
#line 3819 "trace/trace-hw_vfio.h"
        } else {
#line 118 "../hw/vfio/trace-events"
            qemu_log("vfio_region_sparse_mmap_entry " "sparse entry %d [0x%lx - 0x%lx]" "\n", i, start, end);
#line 3823 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_region_sparse_mmap_entry(int i, unsigned long start, unsigned long end)
{
    if (true) {
        _nocheck__trace_vfio_region_sparse_mmap_entry(i, start, end);
    }
}

#define TRACE_VFIO_GET_DEV_REGION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_GET_DEV_REGION) || \
    false)

static inline void _nocheck__trace_vfio_get_dev_region(const char * name, int index, uint32_t type, uint32_t subtype)
{
    if (trace_event_get_state(TRACE_VFIO_GET_DEV_REGION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 119 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_get_dev_region " "%s index %d, %08x/%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, index, type, subtype);
#line 3850 "trace/trace-hw_vfio.h"
        } else {
#line 119 "../hw/vfio/trace-events"
            qemu_log("vfio_get_dev_region " "%s index %d, %08x/%08x" "\n", name, index, type, subtype);
#line 3854 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_get_dev_region(const char * name, int index, uint32_t type, uint32_t subtype)
{
    if (true) {
        _nocheck__trace_vfio_get_dev_region(name, index, type, subtype);
    }
}

#define TRACE_VFIO_LEGACY_DMA_UNMAP_OVERFLOW_WORKAROUND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_LEGACY_DMA_UNMAP_OVERFLOW_WORKAROUND) || \
    false)

static inline void _nocheck__trace_vfio_legacy_dma_unmap_overflow_workaround(void)
{
    if (trace_event_get_state(TRACE_VFIO_LEGACY_DMA_UNMAP_OVERFLOW_WORKAROUND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 120 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_legacy_dma_unmap_overflow_workaround " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 3881 "trace/trace-hw_vfio.h"
        } else {
#line 120 "../hw/vfio/trace-events"
            qemu_log("vfio_legacy_dma_unmap_overflow_workaround " "" "\n");
#line 3885 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_legacy_dma_unmap_overflow_workaround(void)
{
    if (true) {
        _nocheck__trace_vfio_legacy_dma_unmap_overflow_workaround();
    }
}

#define TRACE_VFIO_GET_DIRTY_BITMAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_GET_DIRTY_BITMAP) || \
    false)

static inline void _nocheck__trace_vfio_get_dirty_bitmap(uint64_t iova, uint64_t size, uint64_t bitmap_size, uint64_t start, uint64_t dirty_pages)
{
    if (trace_event_get_state(TRACE_VFIO_GET_DIRTY_BITMAP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 121 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_get_dirty_bitmap " "iova=0x%"PRIx64" size= 0x%"PRIx64" bitmap_size=0x%"PRIx64" start=0x%"PRIx64" dirty_pages=%"PRIu64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , iova, size, bitmap_size, start, dirty_pages);
#line 3912 "trace/trace-hw_vfio.h"
        } else {
#line 121 "../hw/vfio/trace-events"
            qemu_log("vfio_get_dirty_bitmap " "iova=0x%"PRIx64" size= 0x%"PRIx64" bitmap_size=0x%"PRIx64" start=0x%"PRIx64" dirty_pages=%"PRIu64 "\n", iova, size, bitmap_size, start, dirty_pages);
#line 3916 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_get_dirty_bitmap(uint64_t iova, uint64_t size, uint64_t bitmap_size, uint64_t start, uint64_t dirty_pages)
{
    if (true) {
        _nocheck__trace_vfio_get_dirty_bitmap(iova, size, bitmap_size, start, dirty_pages);
    }
}

#define TRACE_VFIO_IOMMU_MAP_DIRTY_NOTIFY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_IOMMU_MAP_DIRTY_NOTIFY) || \
    false)

static inline void _nocheck__trace_vfio_iommu_map_dirty_notify(uint64_t iova_start, uint64_t iova_end)
{
    if (trace_event_get_state(TRACE_VFIO_IOMMU_MAP_DIRTY_NOTIFY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 122 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_iommu_map_dirty_notify " "iommu dirty @ 0x%"PRIx64" - 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , iova_start, iova_end);
#line 3943 "trace/trace-hw_vfio.h"
        } else {
#line 122 "../hw/vfio/trace-events"
            qemu_log("vfio_iommu_map_dirty_notify " "iommu dirty @ 0x%"PRIx64" - 0x%"PRIx64 "\n", iova_start, iova_end);
#line 3947 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_iommu_map_dirty_notify(uint64_t iova_start, uint64_t iova_end)
{
    if (true) {
        _nocheck__trace_vfio_iommu_map_dirty_notify(iova_start, iova_end);
    }
}

#define TRACE_VFIO_PLATFORM_REALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_PLATFORM_REALIZE) || \
    false)

static inline void _nocheck__trace_vfio_platform_realize(char * name, char * compat)
{
    if (trace_event_get_state(TRACE_VFIO_PLATFORM_REALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 125 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_platform_realize " "vfio device %s, compat = %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, compat);
#line 3974 "trace/trace-hw_vfio.h"
        } else {
#line 125 "../hw/vfio/trace-events"
            qemu_log("vfio_platform_realize " "vfio device %s, compat = %s" "\n", name, compat);
#line 3978 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_platform_realize(char * name, char * compat)
{
    if (true) {
        _nocheck__trace_vfio_platform_realize(name, compat);
    }
}

#define TRACE_VFIO_PLATFORM_EOI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_PLATFORM_EOI) || \
    false)

static inline void _nocheck__trace_vfio_platform_eoi(int pin, int fd)
{
    if (trace_event_get_state(TRACE_VFIO_PLATFORM_EOI) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 126 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_platform_eoi " "EOI IRQ pin %d (fd=%d)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , pin, fd);
#line 4005 "trace/trace-hw_vfio.h"
        } else {
#line 126 "../hw/vfio/trace-events"
            qemu_log("vfio_platform_eoi " "EOI IRQ pin %d (fd=%d)" "\n", pin, fd);
#line 4009 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_platform_eoi(int pin, int fd)
{
    if (true) {
        _nocheck__trace_vfio_platform_eoi(pin, fd);
    }
}

#define TRACE_VFIO_PLATFORM_INTP_MMAP_ENABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_PLATFORM_INTP_MMAP_ENABLE) || \
    false)

static inline void _nocheck__trace_vfio_platform_intp_mmap_enable(int pin)
{
    if (trace_event_get_state(TRACE_VFIO_PLATFORM_INTP_MMAP_ENABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 127 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_platform_intp_mmap_enable " "IRQ #%d still active, stay in slow path" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , pin);
#line 4036 "trace/trace-hw_vfio.h"
        } else {
#line 127 "../hw/vfio/trace-events"
            qemu_log("vfio_platform_intp_mmap_enable " "IRQ #%d still active, stay in slow path" "\n", pin);
#line 4040 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_platform_intp_mmap_enable(int pin)
{
    if (true) {
        _nocheck__trace_vfio_platform_intp_mmap_enable(pin);
    }
}

#define TRACE_VFIO_PLATFORM_INTP_INTERRUPT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_PLATFORM_INTP_INTERRUPT) || \
    false)

static inline void _nocheck__trace_vfio_platform_intp_interrupt(int pin, int fd)
{
    if (trace_event_get_state(TRACE_VFIO_PLATFORM_INTP_INTERRUPT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 128 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_platform_intp_interrupt " "Inject IRQ #%d (fd = %d)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , pin, fd);
#line 4067 "trace/trace-hw_vfio.h"
        } else {
#line 128 "../hw/vfio/trace-events"
            qemu_log("vfio_platform_intp_interrupt " "Inject IRQ #%d (fd = %d)" "\n", pin, fd);
#line 4071 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_platform_intp_interrupt(int pin, int fd)
{
    if (true) {
        _nocheck__trace_vfio_platform_intp_interrupt(pin, fd);
    }
}

#define TRACE_VFIO_PLATFORM_INTP_INJECT_PENDING_LOCKHELD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_PLATFORM_INTP_INJECT_PENDING_LOCKHELD) || \
    false)

static inline void _nocheck__trace_vfio_platform_intp_inject_pending_lockheld(int pin, int fd)
{
    if (trace_event_get_state(TRACE_VFIO_PLATFORM_INTP_INJECT_PENDING_LOCKHELD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 129 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_platform_intp_inject_pending_lockheld " "Inject pending IRQ #%d (fd = %d)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , pin, fd);
#line 4098 "trace/trace-hw_vfio.h"
        } else {
#line 129 "../hw/vfio/trace-events"
            qemu_log("vfio_platform_intp_inject_pending_lockheld " "Inject pending IRQ #%d (fd = %d)" "\n", pin, fd);
#line 4102 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_platform_intp_inject_pending_lockheld(int pin, int fd)
{
    if (true) {
        _nocheck__trace_vfio_platform_intp_inject_pending_lockheld(pin, fd);
    }
}

#define TRACE_VFIO_PLATFORM_POPULATE_INTERRUPTS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_PLATFORM_POPULATE_INTERRUPTS) || \
    false)

static inline void _nocheck__trace_vfio_platform_populate_interrupts(int pin, int count, int flags)
{
    if (trace_event_get_state(TRACE_VFIO_PLATFORM_POPULATE_INTERRUPTS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 130 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_platform_populate_interrupts " "- IRQ index %d: count %d, flags=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , pin, count, flags);
#line 4129 "trace/trace-hw_vfio.h"
        } else {
#line 130 "../hw/vfio/trace-events"
            qemu_log("vfio_platform_populate_interrupts " "- IRQ index %d: count %d, flags=0x%x" "\n", pin, count, flags);
#line 4133 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_platform_populate_interrupts(int pin, int count, int flags)
{
    if (true) {
        _nocheck__trace_vfio_platform_populate_interrupts(pin, count, flags);
    }
}

#define TRACE_VFIO_INTP_INTERRUPT_SET_PENDING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_INTP_INTERRUPT_SET_PENDING) || \
    false)

static inline void _nocheck__trace_vfio_intp_interrupt_set_pending(int index)
{
    if (trace_event_get_state(TRACE_VFIO_INTP_INTERRUPT_SET_PENDING) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 131 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_intp_interrupt_set_pending " "irq %d is set PENDING" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index);
#line 4160 "trace/trace-hw_vfio.h"
        } else {
#line 131 "../hw/vfio/trace-events"
            qemu_log("vfio_intp_interrupt_set_pending " "irq %d is set PENDING" "\n", index);
#line 4164 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_intp_interrupt_set_pending(int index)
{
    if (true) {
        _nocheck__trace_vfio_intp_interrupt_set_pending(index);
    }
}

#define TRACE_VFIO_PLATFORM_START_LEVEL_IRQFD_INJECTION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_PLATFORM_START_LEVEL_IRQFD_INJECTION) || \
    false)

static inline void _nocheck__trace_vfio_platform_start_level_irqfd_injection(int index, int fd, int resamplefd)
{
    if (trace_event_get_state(TRACE_VFIO_PLATFORM_START_LEVEL_IRQFD_INJECTION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 132 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_platform_start_level_irqfd_injection " "IRQ index=%d, fd = %d, resamplefd = %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index, fd, resamplefd);
#line 4191 "trace/trace-hw_vfio.h"
        } else {
#line 132 "../hw/vfio/trace-events"
            qemu_log("vfio_platform_start_level_irqfd_injection " "IRQ index=%d, fd = %d, resamplefd = %d" "\n", index, fd, resamplefd);
#line 4195 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_platform_start_level_irqfd_injection(int index, int fd, int resamplefd)
{
    if (true) {
        _nocheck__trace_vfio_platform_start_level_irqfd_injection(index, fd, resamplefd);
    }
}

#define TRACE_VFIO_PLATFORM_START_EDGE_IRQFD_INJECTION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_PLATFORM_START_EDGE_IRQFD_INJECTION) || \
    false)

static inline void _nocheck__trace_vfio_platform_start_edge_irqfd_injection(int index, int fd)
{
    if (trace_event_get_state(TRACE_VFIO_PLATFORM_START_EDGE_IRQFD_INJECTION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 133 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_platform_start_edge_irqfd_injection " "IRQ index=%d, fd = %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index, fd);
#line 4222 "trace/trace-hw_vfio.h"
        } else {
#line 133 "../hw/vfio/trace-events"
            qemu_log("vfio_platform_start_edge_irqfd_injection " "IRQ index=%d, fd = %d" "\n", index, fd);
#line 4226 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_platform_start_edge_irqfd_injection(int index, int fd)
{
    if (true) {
        _nocheck__trace_vfio_platform_start_edge_irqfd_injection(index, fd);
    }
}

#define TRACE_VFIO_PREREG_LISTENER_REGION_ADD_SKIP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_PREREG_LISTENER_REGION_ADD_SKIP) || \
    false)

static inline void _nocheck__trace_vfio_prereg_listener_region_add_skip(uint64_t start, uint64_t end)
{
    if (trace_event_get_state(TRACE_VFIO_PREREG_LISTENER_REGION_ADD_SKIP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 136 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_prereg_listener_region_add_skip " "0x%"PRIx64" - 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , start, end);
#line 4253 "trace/trace-hw_vfio.h"
        } else {
#line 136 "../hw/vfio/trace-events"
            qemu_log("vfio_prereg_listener_region_add_skip " "0x%"PRIx64" - 0x%"PRIx64 "\n", start, end);
#line 4257 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_prereg_listener_region_add_skip(uint64_t start, uint64_t end)
{
    if (true) {
        _nocheck__trace_vfio_prereg_listener_region_add_skip(start, end);
    }
}

#define TRACE_VFIO_PREREG_LISTENER_REGION_DEL_SKIP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_PREREG_LISTENER_REGION_DEL_SKIP) || \
    false)

static inline void _nocheck__trace_vfio_prereg_listener_region_del_skip(uint64_t start, uint64_t end)
{
    if (trace_event_get_state(TRACE_VFIO_PREREG_LISTENER_REGION_DEL_SKIP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 137 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_prereg_listener_region_del_skip " "0x%"PRIx64" - 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , start, end);
#line 4284 "trace/trace-hw_vfio.h"
        } else {
#line 137 "../hw/vfio/trace-events"
            qemu_log("vfio_prereg_listener_region_del_skip " "0x%"PRIx64" - 0x%"PRIx64 "\n", start, end);
#line 4288 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_prereg_listener_region_del_skip(uint64_t start, uint64_t end)
{
    if (true) {
        _nocheck__trace_vfio_prereg_listener_region_del_skip(start, end);
    }
}

#define TRACE_VFIO_PREREG_REGISTER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_PREREG_REGISTER) || \
    false)

static inline void _nocheck__trace_vfio_prereg_register(uint64_t va, uint64_t size, int ret)
{
    if (trace_event_get_state(TRACE_VFIO_PREREG_REGISTER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 138 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_prereg_register " "va=0x%"PRIx64" size=0x%"PRIx64" ret=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , va, size, ret);
#line 4315 "trace/trace-hw_vfio.h"
        } else {
#line 138 "../hw/vfio/trace-events"
            qemu_log("vfio_prereg_register " "va=0x%"PRIx64" size=0x%"PRIx64" ret=%d" "\n", va, size, ret);
#line 4319 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_prereg_register(uint64_t va, uint64_t size, int ret)
{
    if (true) {
        _nocheck__trace_vfio_prereg_register(va, size, ret);
    }
}

#define TRACE_VFIO_PREREG_UNREGISTER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_PREREG_UNREGISTER) || \
    false)

static inline void _nocheck__trace_vfio_prereg_unregister(uint64_t va, uint64_t size, int ret)
{
    if (trace_event_get_state(TRACE_VFIO_PREREG_UNREGISTER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 139 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_prereg_unregister " "va=0x%"PRIx64" size=0x%"PRIx64" ret=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , va, size, ret);
#line 4346 "trace/trace-hw_vfio.h"
        } else {
#line 139 "../hw/vfio/trace-events"
            qemu_log("vfio_prereg_unregister " "va=0x%"PRIx64" size=0x%"PRIx64" ret=%d" "\n", va, size, ret);
#line 4350 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_prereg_unregister(uint64_t va, uint64_t size, int ret)
{
    if (true) {
        _nocheck__trace_vfio_prereg_unregister(va, size, ret);
    }
}

#define TRACE_VFIO_SPAPR_CREATE_WINDOW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_SPAPR_CREATE_WINDOW) || \
    false)

static inline void _nocheck__trace_vfio_spapr_create_window(int ps, unsigned int levels, uint64_t ws, uint64_t off)
{
    if (trace_event_get_state(TRACE_VFIO_SPAPR_CREATE_WINDOW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 140 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_spapr_create_window " "pageshift=0x%x levels=%u winsize=0x%"PRIx64" offset=0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ps, levels, ws, off);
#line 4377 "trace/trace-hw_vfio.h"
        } else {
#line 140 "../hw/vfio/trace-events"
            qemu_log("vfio_spapr_create_window " "pageshift=0x%x levels=%u winsize=0x%"PRIx64" offset=0x%"PRIx64 "\n", ps, levels, ws, off);
#line 4381 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_spapr_create_window(int ps, unsigned int levels, uint64_t ws, uint64_t off)
{
    if (true) {
        _nocheck__trace_vfio_spapr_create_window(ps, levels, ws, off);
    }
}

#define TRACE_VFIO_SPAPR_REMOVE_WINDOW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_SPAPR_REMOVE_WINDOW) || \
    false)

static inline void _nocheck__trace_vfio_spapr_remove_window(uint64_t off)
{
    if (trace_event_get_state(TRACE_VFIO_SPAPR_REMOVE_WINDOW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 141 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_spapr_remove_window " "offset=0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , off);
#line 4408 "trace/trace-hw_vfio.h"
        } else {
#line 141 "../hw/vfio/trace-events"
            qemu_log("vfio_spapr_remove_window " "offset=0x%"PRIx64 "\n", off);
#line 4412 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_spapr_remove_window(uint64_t off)
{
    if (true) {
        _nocheck__trace_vfio_spapr_remove_window(off);
    }
}

#define TRACE_VFIO_DISPLAY_EDID_AVAILABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_DISPLAY_EDID_AVAILABLE) || \
    false)

static inline void _nocheck__trace_vfio_display_edid_available(void)
{
    if (trace_event_get_state(TRACE_VFIO_DISPLAY_EDID_AVAILABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 144 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_display_edid_available " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 4439 "trace/trace-hw_vfio.h"
        } else {
#line 144 "../hw/vfio/trace-events"
            qemu_log("vfio_display_edid_available " "" "\n");
#line 4443 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_display_edid_available(void)
{
    if (true) {
        _nocheck__trace_vfio_display_edid_available();
    }
}

#define TRACE_VFIO_DISPLAY_EDID_LINK_UP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_DISPLAY_EDID_LINK_UP) || \
    false)

static inline void _nocheck__trace_vfio_display_edid_link_up(void)
{
    if (trace_event_get_state(TRACE_VFIO_DISPLAY_EDID_LINK_UP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 145 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_display_edid_link_up " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 4470 "trace/trace-hw_vfio.h"
        } else {
#line 145 "../hw/vfio/trace-events"
            qemu_log("vfio_display_edid_link_up " "" "\n");
#line 4474 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_display_edid_link_up(void)
{
    if (true) {
        _nocheck__trace_vfio_display_edid_link_up();
    }
}

#define TRACE_VFIO_DISPLAY_EDID_LINK_DOWN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_DISPLAY_EDID_LINK_DOWN) || \
    false)

static inline void _nocheck__trace_vfio_display_edid_link_down(void)
{
    if (trace_event_get_state(TRACE_VFIO_DISPLAY_EDID_LINK_DOWN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 146 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_display_edid_link_down " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 4501 "trace/trace-hw_vfio.h"
        } else {
#line 146 "../hw/vfio/trace-events"
            qemu_log("vfio_display_edid_link_down " "" "\n");
#line 4505 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_display_edid_link_down(void)
{
    if (true) {
        _nocheck__trace_vfio_display_edid_link_down();
    }
}

#define TRACE_VFIO_DISPLAY_EDID_UPDATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_DISPLAY_EDID_UPDATE) || \
    false)

static inline void _nocheck__trace_vfio_display_edid_update(uint32_t prefx, uint32_t prefy)
{
    if (trace_event_get_state(TRACE_VFIO_DISPLAY_EDID_UPDATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 147 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_display_edid_update " "%ux%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , prefx, prefy);
#line 4532 "trace/trace-hw_vfio.h"
        } else {
#line 147 "../hw/vfio/trace-events"
            qemu_log("vfio_display_edid_update " "%ux%u" "\n", prefx, prefy);
#line 4536 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_display_edid_update(uint32_t prefx, uint32_t prefy)
{
    if (true) {
        _nocheck__trace_vfio_display_edid_update(prefx, prefy);
    }
}

#define TRACE_VFIO_DISPLAY_EDID_WRITE_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_DISPLAY_EDID_WRITE_ERROR) || \
    false)

static inline void _nocheck__trace_vfio_display_edid_write_error(void)
{
    if (trace_event_get_state(TRACE_VFIO_DISPLAY_EDID_WRITE_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 148 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_display_edid_write_error " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 4563 "trace/trace-hw_vfio.h"
        } else {
#line 148 "../hw/vfio/trace-events"
            qemu_log("vfio_display_edid_write_error " "" "\n");
#line 4567 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_display_edid_write_error(void)
{
    if (true) {
        _nocheck__trace_vfio_display_edid_write_error();
    }
}

#define TRACE_VFIO_LOAD_CLEANUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_LOAD_CLEANUP) || \
    false)

static inline void _nocheck__trace_vfio_load_cleanup(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_LOAD_CLEANUP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 151 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_load_cleanup " " (%s)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 4594 "trace/trace-hw_vfio.h"
        } else {
#line 151 "../hw/vfio/trace-events"
            qemu_log("vfio_load_cleanup " " (%s)" "\n", name);
#line 4598 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_load_cleanup(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_load_cleanup(name);
    }
}

#define TRACE_VFIO_LOAD_DEVICE_CONFIG_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_LOAD_DEVICE_CONFIG_STATE) || \
    false)

static inline void _nocheck__trace_vfio_load_device_config_state(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_LOAD_DEVICE_CONFIG_STATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 152 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_load_device_config_state " " (%s)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 4625 "trace/trace-hw_vfio.h"
        } else {
#line 152 "../hw/vfio/trace-events"
            qemu_log("vfio_load_device_config_state " " (%s)" "\n", name);
#line 4629 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_load_device_config_state(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_load_device_config_state(name);
    }
}

#define TRACE_VFIO_LOAD_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_LOAD_STATE) || \
    false)

static inline void _nocheck__trace_vfio_load_state(const char * name, uint64_t data)
{
    if (trace_event_get_state(TRACE_VFIO_LOAD_STATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 153 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_load_state " " (%s) data 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, data);
#line 4656 "trace/trace-hw_vfio.h"
        } else {
#line 153 "../hw/vfio/trace-events"
            qemu_log("vfio_load_state " " (%s) data 0x%"PRIx64 "\n", name, data);
#line 4660 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_load_state(const char * name, uint64_t data)
{
    if (true) {
        _nocheck__trace_vfio_load_state(name, data);
    }
}

#define TRACE_VFIO_LOAD_STATE_DEVICE_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_LOAD_STATE_DEVICE_DATA) || \
    false)

static inline void _nocheck__trace_vfio_load_state_device_data(const char * name, uint64_t data_size, int ret)
{
    if (trace_event_get_state(TRACE_VFIO_LOAD_STATE_DEVICE_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 154 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_load_state_device_data " " (%s) size 0x%"PRIx64" ret %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, data_size, ret);
#line 4687 "trace/trace-hw_vfio.h"
        } else {
#line 154 "../hw/vfio/trace-events"
            qemu_log("vfio_load_state_device_data " " (%s) size 0x%"PRIx64" ret %d" "\n", name, data_size, ret);
#line 4691 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_load_state_device_data(const char * name, uint64_t data_size, int ret)
{
    if (true) {
        _nocheck__trace_vfio_load_state_device_data(name, data_size, ret);
    }
}

#define TRACE_VFIO_MIGRATION_REALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_MIGRATION_REALIZE) || \
    false)

static inline void _nocheck__trace_vfio_migration_realize(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_MIGRATION_REALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 155 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_migration_realize " " (%s)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 4718 "trace/trace-hw_vfio.h"
        } else {
#line 155 "../hw/vfio/trace-events"
            qemu_log("vfio_migration_realize " " (%s)" "\n", name);
#line 4722 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_migration_realize(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_migration_realize(name);
    }
}

#define TRACE_VFIO_MIGRATION_SET_DEVICE_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_MIGRATION_SET_DEVICE_STATE) || \
    false)

static inline void _nocheck__trace_vfio_migration_set_device_state(const char * name, const char * state)
{
    if (trace_event_get_state(TRACE_VFIO_MIGRATION_SET_DEVICE_STATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 156 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_migration_set_device_state " " (%s) state %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, state);
#line 4749 "trace/trace-hw_vfio.h"
        } else {
#line 156 "../hw/vfio/trace-events"
            qemu_log("vfio_migration_set_device_state " " (%s) state %s" "\n", name, state);
#line 4753 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_migration_set_device_state(const char * name, const char * state)
{
    if (true) {
        _nocheck__trace_vfio_migration_set_device_state(name, state);
    }
}

#define TRACE_VFIO_MIGRATION_SET_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_MIGRATION_SET_STATE) || \
    false)

static inline void _nocheck__trace_vfio_migration_set_state(const char * name, const char * new_state, const char * recover_state)
{
    if (trace_event_get_state(TRACE_VFIO_MIGRATION_SET_STATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 157 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_migration_set_state " " (%s) new state %s, recover state %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, new_state, recover_state);
#line 4780 "trace/trace-hw_vfio.h"
        } else {
#line 157 "../hw/vfio/trace-events"
            qemu_log("vfio_migration_set_state " " (%s) new state %s, recover state %s" "\n", name, new_state, recover_state);
#line 4784 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_migration_set_state(const char * name, const char * new_state, const char * recover_state)
{
    if (true) {
        _nocheck__trace_vfio_migration_set_state(name, new_state, recover_state);
    }
}

#define TRACE_VFIO_MIGRATION_STATE_NOTIFIER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_MIGRATION_STATE_NOTIFIER) || \
    false)

static inline void _nocheck__trace_vfio_migration_state_notifier(const char * name, int state)
{
    if (trace_event_get_state(TRACE_VFIO_MIGRATION_STATE_NOTIFIER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 158 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_migration_state_notifier " " (%s) state %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, state);
#line 4811 "trace/trace-hw_vfio.h"
        } else {
#line 158 "../hw/vfio/trace-events"
            qemu_log("vfio_migration_state_notifier " " (%s) state %d" "\n", name, state);
#line 4815 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_migration_state_notifier(const char * name, int state)
{
    if (true) {
        _nocheck__trace_vfio_migration_state_notifier(name, state);
    }
}

#define TRACE_VFIO_SAVE_BLOCK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_SAVE_BLOCK) || \
    false)

static inline void _nocheck__trace_vfio_save_block(const char * name, int data_size)
{
    if (trace_event_get_state(TRACE_VFIO_SAVE_BLOCK) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 159 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_save_block " " (%s) data_size %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, data_size);
#line 4842 "trace/trace-hw_vfio.h"
        } else {
#line 159 "../hw/vfio/trace-events"
            qemu_log("vfio_save_block " " (%s) data_size %d" "\n", name, data_size);
#line 4846 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_save_block(const char * name, int data_size)
{
    if (true) {
        _nocheck__trace_vfio_save_block(name, data_size);
    }
}

#define TRACE_VFIO_SAVE_CLEANUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_SAVE_CLEANUP) || \
    false)

static inline void _nocheck__trace_vfio_save_cleanup(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_SAVE_CLEANUP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 160 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_save_cleanup " " (%s)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 4873 "trace/trace-hw_vfio.h"
        } else {
#line 160 "../hw/vfio/trace-events"
            qemu_log("vfio_save_cleanup " " (%s)" "\n", name);
#line 4877 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_save_cleanup(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_save_cleanup(name);
    }
}

#define TRACE_VFIO_SAVE_COMPLETE_PRECOPY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_SAVE_COMPLETE_PRECOPY) || \
    false)

static inline void _nocheck__trace_vfio_save_complete_precopy(const char * name, int ret)
{
    if (trace_event_get_state(TRACE_VFIO_SAVE_COMPLETE_PRECOPY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 161 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_save_complete_precopy " " (%s) ret %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, ret);
#line 4904 "trace/trace-hw_vfio.h"
        } else {
#line 161 "../hw/vfio/trace-events"
            qemu_log("vfio_save_complete_precopy " " (%s) ret %d" "\n", name, ret);
#line 4908 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_save_complete_precopy(const char * name, int ret)
{
    if (true) {
        _nocheck__trace_vfio_save_complete_precopy(name, ret);
    }
}

#define TRACE_VFIO_SAVE_DEVICE_CONFIG_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_SAVE_DEVICE_CONFIG_STATE) || \
    false)

static inline void _nocheck__trace_vfio_save_device_config_state(const char * name)
{
    if (trace_event_get_state(TRACE_VFIO_SAVE_DEVICE_CONFIG_STATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 162 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_save_device_config_state " " (%s)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 4935 "trace/trace-hw_vfio.h"
        } else {
#line 162 "../hw/vfio/trace-events"
            qemu_log("vfio_save_device_config_state " " (%s)" "\n", name);
#line 4939 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_save_device_config_state(const char * name)
{
    if (true) {
        _nocheck__trace_vfio_save_device_config_state(name);
    }
}

#define TRACE_VFIO_SAVE_ITERATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_SAVE_ITERATE) || \
    false)

static inline void _nocheck__trace_vfio_save_iterate(const char * name, uint64_t precopy_init_size, uint64_t precopy_dirty_size)
{
    if (trace_event_get_state(TRACE_VFIO_SAVE_ITERATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 163 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_save_iterate " " (%s) precopy initial size 0x%"PRIx64" precopy dirty size 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, precopy_init_size, precopy_dirty_size);
#line 4966 "trace/trace-hw_vfio.h"
        } else {
#line 163 "../hw/vfio/trace-events"
            qemu_log("vfio_save_iterate " " (%s) precopy initial size 0x%"PRIx64" precopy dirty size 0x%"PRIx64 "\n", name, precopy_init_size, precopy_dirty_size);
#line 4970 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_save_iterate(const char * name, uint64_t precopy_init_size, uint64_t precopy_dirty_size)
{
    if (true) {
        _nocheck__trace_vfio_save_iterate(name, precopy_init_size, precopy_dirty_size);
    }
}

#define TRACE_VFIO_SAVE_SETUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_SAVE_SETUP) || \
    false)

static inline void _nocheck__trace_vfio_save_setup(const char * name, uint64_t data_buffer_size)
{
    if (trace_event_get_state(TRACE_VFIO_SAVE_SETUP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 164 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_save_setup " " (%s) data buffer size 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, data_buffer_size);
#line 4997 "trace/trace-hw_vfio.h"
        } else {
#line 164 "../hw/vfio/trace-events"
            qemu_log("vfio_save_setup " " (%s) data buffer size 0x%"PRIx64 "\n", name, data_buffer_size);
#line 5001 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_save_setup(const char * name, uint64_t data_buffer_size)
{
    if (true) {
        _nocheck__trace_vfio_save_setup(name, data_buffer_size);
    }
}

#define TRACE_VFIO_STATE_PENDING_ESTIMATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_STATE_PENDING_ESTIMATE) || \
    false)

static inline void _nocheck__trace_vfio_state_pending_estimate(const char * name, uint64_t precopy, uint64_t postcopy, uint64_t precopy_init_size, uint64_t precopy_dirty_size)
{
    if (trace_event_get_state(TRACE_VFIO_STATE_PENDING_ESTIMATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 165 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_state_pending_estimate " " (%s) precopy 0x%"PRIx64" postcopy 0x%"PRIx64" precopy initial size 0x%"PRIx64" precopy dirty size 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, precopy, postcopy, precopy_init_size, precopy_dirty_size);
#line 5028 "trace/trace-hw_vfio.h"
        } else {
#line 165 "../hw/vfio/trace-events"
            qemu_log("vfio_state_pending_estimate " " (%s) precopy 0x%"PRIx64" postcopy 0x%"PRIx64" precopy initial size 0x%"PRIx64" precopy dirty size 0x%"PRIx64 "\n", name, precopy, postcopy, precopy_init_size, precopy_dirty_size);
#line 5032 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_state_pending_estimate(const char * name, uint64_t precopy, uint64_t postcopy, uint64_t precopy_init_size, uint64_t precopy_dirty_size)
{
    if (true) {
        _nocheck__trace_vfio_state_pending_estimate(name, precopy, postcopy, precopy_init_size, precopy_dirty_size);
    }
}

#define TRACE_VFIO_STATE_PENDING_EXACT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_STATE_PENDING_EXACT) || \
    false)

static inline void _nocheck__trace_vfio_state_pending_exact(const char * name, uint64_t precopy, uint64_t postcopy, uint64_t stopcopy_size, uint64_t precopy_init_size, uint64_t precopy_dirty_size)
{
    if (trace_event_get_state(TRACE_VFIO_STATE_PENDING_EXACT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 166 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_state_pending_exact " " (%s) precopy 0x%"PRIx64" postcopy 0x%"PRIx64" stopcopy size 0x%"PRIx64" precopy initial size 0x%"PRIx64" precopy dirty size 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, precopy, postcopy, stopcopy_size, precopy_init_size, precopy_dirty_size);
#line 5059 "trace/trace-hw_vfio.h"
        } else {
#line 166 "../hw/vfio/trace-events"
            qemu_log("vfio_state_pending_exact " " (%s) precopy 0x%"PRIx64" postcopy 0x%"PRIx64" stopcopy size 0x%"PRIx64" precopy initial size 0x%"PRIx64" precopy dirty size 0x%"PRIx64 "\n", name, precopy, postcopy, stopcopy_size, precopy_init_size, precopy_dirty_size);
#line 5063 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_state_pending_exact(const char * name, uint64_t precopy, uint64_t postcopy, uint64_t stopcopy_size, uint64_t precopy_init_size, uint64_t precopy_dirty_size)
{
    if (true) {
        _nocheck__trace_vfio_state_pending_exact(name, precopy, postcopy, stopcopy_size, precopy_init_size, precopy_dirty_size);
    }
}

#define TRACE_VFIO_VMSTATE_CHANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_VMSTATE_CHANGE) || \
    false)

static inline void _nocheck__trace_vfio_vmstate_change(const char * name, int running, const char * reason, const char * dev_state)
{
    if (trace_event_get_state(TRACE_VFIO_VMSTATE_CHANGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 167 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_vmstate_change " " (%s) running %d reason %s device state %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, running, reason, dev_state);
#line 5090 "trace/trace-hw_vfio.h"
        } else {
#line 167 "../hw/vfio/trace-events"
            qemu_log("vfio_vmstate_change " " (%s) running %d reason %s device state %s" "\n", name, running, reason, dev_state);
#line 5094 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_vmstate_change(const char * name, int running, const char * reason, const char * dev_state)
{
    if (true) {
        _nocheck__trace_vfio_vmstate_change(name, running, reason, dev_state);
    }
}

#define TRACE_VFIO_VMSTATE_CHANGE_PREPARE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_VMSTATE_CHANGE_PREPARE) || \
    false)

static inline void _nocheck__trace_vfio_vmstate_change_prepare(const char * name, int running, const char * reason, const char * dev_state)
{
    if (trace_event_get_state(TRACE_VFIO_VMSTATE_CHANGE_PREPARE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 168 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:vfio_vmstate_change_prepare " " (%s) running %d reason %s device state %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, running, reason, dev_state);
#line 5121 "trace/trace-hw_vfio.h"
        } else {
#line 168 "../hw/vfio/trace-events"
            qemu_log("vfio_vmstate_change_prepare " " (%s) running %d reason %s device state %s" "\n", name, running, reason, dev_state);
#line 5125 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_vfio_vmstate_change_prepare(const char * name, int running, const char * reason, const char * dev_state)
{
    if (true) {
        _nocheck__trace_vfio_vmstate_change_prepare(name, running, reason, dev_state);
    }
}

#define TRACE_IOMMUFD_CDEV_CONNECT_AND_BIND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IOMMUFD_CDEV_CONNECT_AND_BIND) || \
    false)

static inline void _nocheck__trace_iommufd_cdev_connect_and_bind(int iommufd, const char * name, int devfd, int devid)
{
    if (trace_event_get_state(TRACE_IOMMUFD_CDEV_CONNECT_AND_BIND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 172 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:iommufd_cdev_connect_and_bind " " [iommufd=%d] Successfully bound device %s (fd=%d): output devid=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , iommufd, name, devfd, devid);
#line 5152 "trace/trace-hw_vfio.h"
        } else {
#line 172 "../hw/vfio/trace-events"
            qemu_log("iommufd_cdev_connect_and_bind " " [iommufd=%d] Successfully bound device %s (fd=%d): output devid=%d" "\n", iommufd, name, devfd, devid);
#line 5156 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_iommufd_cdev_connect_and_bind(int iommufd, const char * name, int devfd, int devid)
{
    if (true) {
        _nocheck__trace_iommufd_cdev_connect_and_bind(iommufd, name, devfd, devid);
    }
}

#define TRACE_IOMMUFD_CDEV_GETFD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IOMMUFD_CDEV_GETFD) || \
    false)

static inline void _nocheck__trace_iommufd_cdev_getfd(const char * dev, int devfd)
{
    if (trace_event_get_state(TRACE_IOMMUFD_CDEV_GETFD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 173 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:iommufd_cdev_getfd " " %s (fd=%d)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, devfd);
#line 5183 "trace/trace-hw_vfio.h"
        } else {
#line 173 "../hw/vfio/trace-events"
            qemu_log("iommufd_cdev_getfd " " %s (fd=%d)" "\n", dev, devfd);
#line 5187 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_iommufd_cdev_getfd(const char * dev, int devfd)
{
    if (true) {
        _nocheck__trace_iommufd_cdev_getfd(dev, devfd);
    }
}

#define TRACE_IOMMUFD_CDEV_ATTACH_IOAS_HWPT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IOMMUFD_CDEV_ATTACH_IOAS_HWPT) || \
    false)

static inline void _nocheck__trace_iommufd_cdev_attach_ioas_hwpt(int iommufd, const char * name, int devfd, int id)
{
    if (trace_event_get_state(TRACE_IOMMUFD_CDEV_ATTACH_IOAS_HWPT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 174 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:iommufd_cdev_attach_ioas_hwpt " " [iommufd=%d] Successfully attached device %s (%d) to id=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , iommufd, name, devfd, id);
#line 5214 "trace/trace-hw_vfio.h"
        } else {
#line 174 "../hw/vfio/trace-events"
            qemu_log("iommufd_cdev_attach_ioas_hwpt " " [iommufd=%d] Successfully attached device %s (%d) to id=%d" "\n", iommufd, name, devfd, id);
#line 5218 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_iommufd_cdev_attach_ioas_hwpt(int iommufd, const char * name, int devfd, int id)
{
    if (true) {
        _nocheck__trace_iommufd_cdev_attach_ioas_hwpt(iommufd, name, devfd, id);
    }
}

#define TRACE_IOMMUFD_CDEV_DETACH_IOAS_HWPT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IOMMUFD_CDEV_DETACH_IOAS_HWPT) || \
    false)

static inline void _nocheck__trace_iommufd_cdev_detach_ioas_hwpt(int iommufd, const char * name)
{
    if (trace_event_get_state(TRACE_IOMMUFD_CDEV_DETACH_IOAS_HWPT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 175 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:iommufd_cdev_detach_ioas_hwpt " " [iommufd=%d] Successfully detached %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , iommufd, name);
#line 5245 "trace/trace-hw_vfio.h"
        } else {
#line 175 "../hw/vfio/trace-events"
            qemu_log("iommufd_cdev_detach_ioas_hwpt " " [iommufd=%d] Successfully detached %s" "\n", iommufd, name);
#line 5249 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_iommufd_cdev_detach_ioas_hwpt(int iommufd, const char * name)
{
    if (true) {
        _nocheck__trace_iommufd_cdev_detach_ioas_hwpt(iommufd, name);
    }
}

#define TRACE_IOMMUFD_CDEV_FAIL_ATTACH_EXISTING_CONTAINER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IOMMUFD_CDEV_FAIL_ATTACH_EXISTING_CONTAINER) || \
    false)

static inline void _nocheck__trace_iommufd_cdev_fail_attach_existing_container(const char * msg)
{
    if (trace_event_get_state(TRACE_IOMMUFD_CDEV_FAIL_ATTACH_EXISTING_CONTAINER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 176 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:iommufd_cdev_fail_attach_existing_container " " %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , msg);
#line 5276 "trace/trace-hw_vfio.h"
        } else {
#line 176 "../hw/vfio/trace-events"
            qemu_log("iommufd_cdev_fail_attach_existing_container " " %s" "\n", msg);
#line 5280 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_iommufd_cdev_fail_attach_existing_container(const char * msg)
{
    if (true) {
        _nocheck__trace_iommufd_cdev_fail_attach_existing_container(msg);
    }
}

#define TRACE_IOMMUFD_CDEV_ALLOC_IOAS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IOMMUFD_CDEV_ALLOC_IOAS) || \
    false)

static inline void _nocheck__trace_iommufd_cdev_alloc_ioas(int iommufd, int ioas_id)
{
    if (trace_event_get_state(TRACE_IOMMUFD_CDEV_ALLOC_IOAS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 177 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:iommufd_cdev_alloc_ioas " " [iommufd=%d] new IOMMUFD container with ioasid=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , iommufd, ioas_id);
#line 5307 "trace/trace-hw_vfio.h"
        } else {
#line 177 "../hw/vfio/trace-events"
            qemu_log("iommufd_cdev_alloc_ioas " " [iommufd=%d] new IOMMUFD container with ioasid=%d" "\n", iommufd, ioas_id);
#line 5311 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_iommufd_cdev_alloc_ioas(int iommufd, int ioas_id)
{
    if (true) {
        _nocheck__trace_iommufd_cdev_alloc_ioas(iommufd, ioas_id);
    }
}

#define TRACE_IOMMUFD_CDEV_DEVICE_INFO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IOMMUFD_CDEV_DEVICE_INFO) || \
    false)

static inline void _nocheck__trace_iommufd_cdev_device_info(char * name, int devfd, int num_irqs, int num_regions, int flags)
{
    if (trace_event_get_state(TRACE_IOMMUFD_CDEV_DEVICE_INFO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 178 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:iommufd_cdev_device_info " " %s (%d) num_irqs=%d num_regions=%d flags=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, devfd, num_irqs, num_regions, flags);
#line 5338 "trace/trace-hw_vfio.h"
        } else {
#line 178 "../hw/vfio/trace-events"
            qemu_log("iommufd_cdev_device_info " " %s (%d) num_irqs=%d num_regions=%d flags=%d" "\n", name, devfd, num_irqs, num_regions, flags);
#line 5342 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_iommufd_cdev_device_info(char * name, int devfd, int num_irqs, int num_regions, int flags)
{
    if (true) {
        _nocheck__trace_iommufd_cdev_device_info(name, devfd, num_irqs, num_regions, flags);
    }
}

#define TRACE_IOMMUFD_CDEV_PCI_HOT_RESET_DEP_DEVICES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IOMMUFD_CDEV_PCI_HOT_RESET_DEP_DEVICES) || \
    false)

static inline void _nocheck__trace_iommufd_cdev_pci_hot_reset_dep_devices(int domain, int bus, int slot, int function, int dev_id)
{
    if (trace_event_get_state(TRACE_IOMMUFD_CDEV_PCI_HOT_RESET_DEP_DEVICES) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 179 "../hw/vfio/trace-events"
            qemu_log("%d@%zu.%06zu:iommufd_cdev_pci_hot_reset_dep_devices " "\t%04x:%02x:%02x.%x devid %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , domain, bus, slot, function, dev_id);
#line 5369 "trace/trace-hw_vfio.h"
        } else {
#line 179 "../hw/vfio/trace-events"
            qemu_log("iommufd_cdev_pci_hot_reset_dep_devices " "\t%04x:%02x:%02x.%x devid %d" "\n", domain, bus, slot, function, dev_id);
#line 5373 "trace/trace-hw_vfio.h"
        }
    }
}

static inline void trace_iommufd_cdev_pci_hot_reset_dep_devices(int domain, int bus, int slot, int function, int dev_id)
{
    if (true) {
        _nocheck__trace_iommufd_cdev_pci_hot_reset_dep_devices(domain, bus, slot, function, dev_id);
    }
}
#endif /* TRACE_HW_VFIO_GENERATED_TRACERS_H */
