/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_I386_KVM_GENERATED_TRACERS_H
#define TRACE_HW_I386_KVM_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_KVM_XEN_MAP_PIRQ_EVENT;
extern TraceEvent _TRACE_KVM_XEN_UNMAP_PIRQ_EVENT;
extern TraceEvent _TRACE_KVM_XEN_GET_FREE_PIRQ_EVENT;
extern TraceEvent _TRACE_KVM_XEN_BIND_PIRQ_EVENT;
extern TraceEvent _TRACE_KVM_XEN_UNMASK_PIRQ_EVENT;
extern TraceEvent _TRACE_XENSTORE_ERROR_EVENT;
extern TraceEvent _TRACE_XENSTORE_READ_EVENT;
extern TraceEvent _TRACE_XENSTORE_WRITE_EVENT;
extern TraceEvent _TRACE_XENSTORE_MKDIR_EVENT;
extern TraceEvent _TRACE_XENSTORE_DIRECTORY_EVENT;
extern TraceEvent _TRACE_XENSTORE_DIRECTORY_PART_EVENT;
extern TraceEvent _TRACE_XENSTORE_TRANSACTION_START_EVENT;
extern TraceEvent _TRACE_XENSTORE_TRANSACTION_END_EVENT;
extern TraceEvent _TRACE_XENSTORE_RM_EVENT;
extern TraceEvent _TRACE_XENSTORE_GET_PERMS_EVENT;
extern TraceEvent _TRACE_XENSTORE_SET_PERMS_EVENT;
extern TraceEvent _TRACE_XENSTORE_WATCH_EVENT;
extern TraceEvent _TRACE_XENSTORE_UNWATCH_EVENT;
extern TraceEvent _TRACE_XENSTORE_RESET_WATCHES_EVENT;
extern TraceEvent _TRACE_XENSTORE_WATCH_EVENT_EVENT;
extern TraceEvent _TRACE_XEN_PRIMARY_CONSOLE_CREATE_EVENT;
extern TraceEvent _TRACE_XEN_PRIMARY_CONSOLE_RESET_EVENT;
extern uint16_t _TRACE_KVM_XEN_MAP_PIRQ_DSTATE;
extern uint16_t _TRACE_KVM_XEN_UNMAP_PIRQ_DSTATE;
extern uint16_t _TRACE_KVM_XEN_GET_FREE_PIRQ_DSTATE;
extern uint16_t _TRACE_KVM_XEN_BIND_PIRQ_DSTATE;
extern uint16_t _TRACE_KVM_XEN_UNMASK_PIRQ_DSTATE;
extern uint16_t _TRACE_XENSTORE_ERROR_DSTATE;
extern uint16_t _TRACE_XENSTORE_READ_DSTATE;
extern uint16_t _TRACE_XENSTORE_WRITE_DSTATE;
extern uint16_t _TRACE_XENSTORE_MKDIR_DSTATE;
extern uint16_t _TRACE_XENSTORE_DIRECTORY_DSTATE;
extern uint16_t _TRACE_XENSTORE_DIRECTORY_PART_DSTATE;
extern uint16_t _TRACE_XENSTORE_TRANSACTION_START_DSTATE;
extern uint16_t _TRACE_XENSTORE_TRANSACTION_END_DSTATE;
extern uint16_t _TRACE_XENSTORE_RM_DSTATE;
extern uint16_t _TRACE_XENSTORE_GET_PERMS_DSTATE;
extern uint16_t _TRACE_XENSTORE_SET_PERMS_DSTATE;
extern uint16_t _TRACE_XENSTORE_WATCH_DSTATE;
extern uint16_t _TRACE_XENSTORE_UNWATCH_DSTATE;
extern uint16_t _TRACE_XENSTORE_RESET_WATCHES_DSTATE;
extern uint16_t _TRACE_XENSTORE_WATCH_EVENT_DSTATE;
extern uint16_t _TRACE_XEN_PRIMARY_CONSOLE_CREATE_DSTATE;
extern uint16_t _TRACE_XEN_PRIMARY_CONSOLE_RESET_DSTATE;
#define TRACE_KVM_XEN_MAP_PIRQ_ENABLED 1
#define TRACE_KVM_XEN_UNMAP_PIRQ_ENABLED 1
#define TRACE_KVM_XEN_GET_FREE_PIRQ_ENABLED 1
#define TRACE_KVM_XEN_BIND_PIRQ_ENABLED 1
#define TRACE_KVM_XEN_UNMASK_PIRQ_ENABLED 1
#define TRACE_XENSTORE_ERROR_ENABLED 1
#define TRACE_XENSTORE_READ_ENABLED 1
#define TRACE_XENSTORE_WRITE_ENABLED 1
#define TRACE_XENSTORE_MKDIR_ENABLED 1
#define TRACE_XENSTORE_DIRECTORY_ENABLED 1
#define TRACE_XENSTORE_DIRECTORY_PART_ENABLED 1
#define TRACE_XENSTORE_TRANSACTION_START_ENABLED 1
#define TRACE_XENSTORE_TRANSACTION_END_ENABLED 1
#define TRACE_XENSTORE_RM_ENABLED 1
#define TRACE_XENSTORE_GET_PERMS_ENABLED 1
#define TRACE_XENSTORE_SET_PERMS_ENABLED 1
#define TRACE_XENSTORE_WATCH_ENABLED 1
#define TRACE_XENSTORE_UNWATCH_ENABLED 1
#define TRACE_XENSTORE_RESET_WATCHES_ENABLED 1
#define TRACE_XENSTORE_WATCH_EVENT_ENABLED 1
#define TRACE_XEN_PRIMARY_CONSOLE_CREATE_ENABLED 1
#define TRACE_XEN_PRIMARY_CONSOLE_RESET_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_KVM_XEN_MAP_PIRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_KVM_XEN_MAP_PIRQ) || \
    false)

static inline void _nocheck__trace_kvm_xen_map_pirq(int pirq, int gsi)
{
    if (trace_event_get_state(TRACE_KVM_XEN_MAP_PIRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 1 "../hw/i386/kvm/trace-events"
            qemu_log("%d@%zu.%06zu:kvm_xen_map_pirq " "pirq %d gsi %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , pirq, gsi);
#line 94 "trace/trace-hw_i386_kvm.h"
        } else {
#line 1 "../hw/i386/kvm/trace-events"
            qemu_log("kvm_xen_map_pirq " "pirq %d gsi %d" "\n", pirq, gsi);
#line 98 "trace/trace-hw_i386_kvm.h"
        }
    }
}

static inline void trace_kvm_xen_map_pirq(int pirq, int gsi)
{
    if (true) {
        _nocheck__trace_kvm_xen_map_pirq(pirq, gsi);
    }
}

#define TRACE_KVM_XEN_UNMAP_PIRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_KVM_XEN_UNMAP_PIRQ) || \
    false)

static inline void _nocheck__trace_kvm_xen_unmap_pirq(int pirq, int gsi)
{
    if (trace_event_get_state(TRACE_KVM_XEN_UNMAP_PIRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 2 "../hw/i386/kvm/trace-events"
            qemu_log("%d@%zu.%06zu:kvm_xen_unmap_pirq " "pirq %d gsi %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , pirq, gsi);
#line 125 "trace/trace-hw_i386_kvm.h"
        } else {
#line 2 "../hw/i386/kvm/trace-events"
            qemu_log("kvm_xen_unmap_pirq " "pirq %d gsi %d" "\n", pirq, gsi);
#line 129 "trace/trace-hw_i386_kvm.h"
        }
    }
}

static inline void trace_kvm_xen_unmap_pirq(int pirq, int gsi)
{
    if (true) {
        _nocheck__trace_kvm_xen_unmap_pirq(pirq, gsi);
    }
}

#define TRACE_KVM_XEN_GET_FREE_PIRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_KVM_XEN_GET_FREE_PIRQ) || \
    false)

static inline void _nocheck__trace_kvm_xen_get_free_pirq(int pirq, int type)
{
    if (trace_event_get_state(TRACE_KVM_XEN_GET_FREE_PIRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 3 "../hw/i386/kvm/trace-events"
            qemu_log("%d@%zu.%06zu:kvm_xen_get_free_pirq " "pirq %d type %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , pirq, type);
#line 156 "trace/trace-hw_i386_kvm.h"
        } else {
#line 3 "../hw/i386/kvm/trace-events"
            qemu_log("kvm_xen_get_free_pirq " "pirq %d type %d" "\n", pirq, type);
#line 160 "trace/trace-hw_i386_kvm.h"
        }
    }
}

static inline void trace_kvm_xen_get_free_pirq(int pirq, int type)
{
    if (true) {
        _nocheck__trace_kvm_xen_get_free_pirq(pirq, type);
    }
}

#define TRACE_KVM_XEN_BIND_PIRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_KVM_XEN_BIND_PIRQ) || \
    false)

static inline void _nocheck__trace_kvm_xen_bind_pirq(int pirq, int port)
{
    if (trace_event_get_state(TRACE_KVM_XEN_BIND_PIRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 4 "../hw/i386/kvm/trace-events"
            qemu_log("%d@%zu.%06zu:kvm_xen_bind_pirq " "pirq %d port %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , pirq, port);
#line 187 "trace/trace-hw_i386_kvm.h"
        } else {
#line 4 "../hw/i386/kvm/trace-events"
            qemu_log("kvm_xen_bind_pirq " "pirq %d port %d" "\n", pirq, port);
#line 191 "trace/trace-hw_i386_kvm.h"
        }
    }
}

static inline void trace_kvm_xen_bind_pirq(int pirq, int port)
{
    if (true) {
        _nocheck__trace_kvm_xen_bind_pirq(pirq, port);
    }
}

#define TRACE_KVM_XEN_UNMASK_PIRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_KVM_XEN_UNMASK_PIRQ) || \
    false)

static inline void _nocheck__trace_kvm_xen_unmask_pirq(int pirq, char * dev, int vector)
{
    if (trace_event_get_state(TRACE_KVM_XEN_UNMASK_PIRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 5 "../hw/i386/kvm/trace-events"
            qemu_log("%d@%zu.%06zu:kvm_xen_unmask_pirq " "pirq %d dev %s vector %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , pirq, dev, vector);
#line 218 "trace/trace-hw_i386_kvm.h"
        } else {
#line 5 "../hw/i386/kvm/trace-events"
            qemu_log("kvm_xen_unmask_pirq " "pirq %d dev %s vector %d" "\n", pirq, dev, vector);
#line 222 "trace/trace-hw_i386_kvm.h"
        }
    }
}

static inline void trace_kvm_xen_unmask_pirq(int pirq, char * dev, int vector)
{
    if (true) {
        _nocheck__trace_kvm_xen_unmask_pirq(pirq, dev, vector);
    }
}

#define TRACE_XENSTORE_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XENSTORE_ERROR) || \
    false)

static inline void _nocheck__trace_xenstore_error(unsigned int id, unsigned int tx_id, const char * err)
{
    if (trace_event_get_state(TRACE_XENSTORE_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 6 "../hw/i386/kvm/trace-events"
            qemu_log("%d@%zu.%06zu:xenstore_error " "req %u tx %u err %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, tx_id, err);
#line 249 "trace/trace-hw_i386_kvm.h"
        } else {
#line 6 "../hw/i386/kvm/trace-events"
            qemu_log("xenstore_error " "req %u tx %u err %s" "\n", id, tx_id, err);
#line 253 "trace/trace-hw_i386_kvm.h"
        }
    }
}

static inline void trace_xenstore_error(unsigned int id, unsigned int tx_id, const char * err)
{
    if (true) {
        _nocheck__trace_xenstore_error(id, tx_id, err);
    }
}

#define TRACE_XENSTORE_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XENSTORE_READ) || \
    false)

static inline void _nocheck__trace_xenstore_read(unsigned int tx_id, const char * path)
{
    if (trace_event_get_state(TRACE_XENSTORE_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 7 "../hw/i386/kvm/trace-events"
            qemu_log("%d@%zu.%06zu:xenstore_read " "tx %u path %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tx_id, path);
#line 280 "trace/trace-hw_i386_kvm.h"
        } else {
#line 7 "../hw/i386/kvm/trace-events"
            qemu_log("xenstore_read " "tx %u path %s" "\n", tx_id, path);
#line 284 "trace/trace-hw_i386_kvm.h"
        }
    }
}

static inline void trace_xenstore_read(unsigned int tx_id, const char * path)
{
    if (true) {
        _nocheck__trace_xenstore_read(tx_id, path);
    }
}

#define TRACE_XENSTORE_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XENSTORE_WRITE) || \
    false)

static inline void _nocheck__trace_xenstore_write(unsigned int tx_id, const char * path)
{
    if (trace_event_get_state(TRACE_XENSTORE_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 8 "../hw/i386/kvm/trace-events"
            qemu_log("%d@%zu.%06zu:xenstore_write " "tx %u path %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tx_id, path);
#line 311 "trace/trace-hw_i386_kvm.h"
        } else {
#line 8 "../hw/i386/kvm/trace-events"
            qemu_log("xenstore_write " "tx %u path %s" "\n", tx_id, path);
#line 315 "trace/trace-hw_i386_kvm.h"
        }
    }
}

static inline void trace_xenstore_write(unsigned int tx_id, const char * path)
{
    if (true) {
        _nocheck__trace_xenstore_write(tx_id, path);
    }
}

#define TRACE_XENSTORE_MKDIR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XENSTORE_MKDIR) || \
    false)

static inline void _nocheck__trace_xenstore_mkdir(unsigned int tx_id, const char * path)
{
    if (trace_event_get_state(TRACE_XENSTORE_MKDIR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 9 "../hw/i386/kvm/trace-events"
            qemu_log("%d@%zu.%06zu:xenstore_mkdir " "tx %u path %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tx_id, path);
#line 342 "trace/trace-hw_i386_kvm.h"
        } else {
#line 9 "../hw/i386/kvm/trace-events"
            qemu_log("xenstore_mkdir " "tx %u path %s" "\n", tx_id, path);
#line 346 "trace/trace-hw_i386_kvm.h"
        }
    }
}

static inline void trace_xenstore_mkdir(unsigned int tx_id, const char * path)
{
    if (true) {
        _nocheck__trace_xenstore_mkdir(tx_id, path);
    }
}

#define TRACE_XENSTORE_DIRECTORY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XENSTORE_DIRECTORY) || \
    false)

static inline void _nocheck__trace_xenstore_directory(unsigned int tx_id, const char * path)
{
    if (trace_event_get_state(TRACE_XENSTORE_DIRECTORY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 10 "../hw/i386/kvm/trace-events"
            qemu_log("%d@%zu.%06zu:xenstore_directory " "tx %u path %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tx_id, path);
#line 373 "trace/trace-hw_i386_kvm.h"
        } else {
#line 10 "../hw/i386/kvm/trace-events"
            qemu_log("xenstore_directory " "tx %u path %s" "\n", tx_id, path);
#line 377 "trace/trace-hw_i386_kvm.h"
        }
    }
}

static inline void trace_xenstore_directory(unsigned int tx_id, const char * path)
{
    if (true) {
        _nocheck__trace_xenstore_directory(tx_id, path);
    }
}

#define TRACE_XENSTORE_DIRECTORY_PART_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XENSTORE_DIRECTORY_PART) || \
    false)

static inline void _nocheck__trace_xenstore_directory_part(unsigned int tx_id, const char * path, unsigned int offset)
{
    if (trace_event_get_state(TRACE_XENSTORE_DIRECTORY_PART) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 11 "../hw/i386/kvm/trace-events"
            qemu_log("%d@%zu.%06zu:xenstore_directory_part " "tx %u path %s offset %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tx_id, path, offset);
#line 404 "trace/trace-hw_i386_kvm.h"
        } else {
#line 11 "../hw/i386/kvm/trace-events"
            qemu_log("xenstore_directory_part " "tx %u path %s offset %u" "\n", tx_id, path, offset);
#line 408 "trace/trace-hw_i386_kvm.h"
        }
    }
}

static inline void trace_xenstore_directory_part(unsigned int tx_id, const char * path, unsigned int offset)
{
    if (true) {
        _nocheck__trace_xenstore_directory_part(tx_id, path, offset);
    }
}

#define TRACE_XENSTORE_TRANSACTION_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XENSTORE_TRANSACTION_START) || \
    false)

static inline void _nocheck__trace_xenstore_transaction_start(unsigned int new_tx)
{
    if (trace_event_get_state(TRACE_XENSTORE_TRANSACTION_START) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 12 "../hw/i386/kvm/trace-events"
            qemu_log("%d@%zu.%06zu:xenstore_transaction_start " "new_tx %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , new_tx);
#line 435 "trace/trace-hw_i386_kvm.h"
        } else {
#line 12 "../hw/i386/kvm/trace-events"
            qemu_log("xenstore_transaction_start " "new_tx %u" "\n", new_tx);
#line 439 "trace/trace-hw_i386_kvm.h"
        }
    }
}

static inline void trace_xenstore_transaction_start(unsigned int new_tx)
{
    if (true) {
        _nocheck__trace_xenstore_transaction_start(new_tx);
    }
}

#define TRACE_XENSTORE_TRANSACTION_END_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XENSTORE_TRANSACTION_END) || \
    false)

static inline void _nocheck__trace_xenstore_transaction_end(unsigned int tx_id, bool commit)
{
    if (trace_event_get_state(TRACE_XENSTORE_TRANSACTION_END) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 13 "../hw/i386/kvm/trace-events"
            qemu_log("%d@%zu.%06zu:xenstore_transaction_end " "tx %u commit %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tx_id, commit);
#line 466 "trace/trace-hw_i386_kvm.h"
        } else {
#line 13 "../hw/i386/kvm/trace-events"
            qemu_log("xenstore_transaction_end " "tx %u commit %d" "\n", tx_id, commit);
#line 470 "trace/trace-hw_i386_kvm.h"
        }
    }
}

static inline void trace_xenstore_transaction_end(unsigned int tx_id, bool commit)
{
    if (true) {
        _nocheck__trace_xenstore_transaction_end(tx_id, commit);
    }
}

#define TRACE_XENSTORE_RM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XENSTORE_RM) || \
    false)

static inline void _nocheck__trace_xenstore_rm(unsigned int tx_id, const char * path)
{
    if (trace_event_get_state(TRACE_XENSTORE_RM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 14 "../hw/i386/kvm/trace-events"
            qemu_log("%d@%zu.%06zu:xenstore_rm " "tx %u path %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tx_id, path);
#line 497 "trace/trace-hw_i386_kvm.h"
        } else {
#line 14 "../hw/i386/kvm/trace-events"
            qemu_log("xenstore_rm " "tx %u path %s" "\n", tx_id, path);
#line 501 "trace/trace-hw_i386_kvm.h"
        }
    }
}

static inline void trace_xenstore_rm(unsigned int tx_id, const char * path)
{
    if (true) {
        _nocheck__trace_xenstore_rm(tx_id, path);
    }
}

#define TRACE_XENSTORE_GET_PERMS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XENSTORE_GET_PERMS) || \
    false)

static inline void _nocheck__trace_xenstore_get_perms(unsigned int tx_id, const char * path)
{
    if (trace_event_get_state(TRACE_XENSTORE_GET_PERMS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 15 "../hw/i386/kvm/trace-events"
            qemu_log("%d@%zu.%06zu:xenstore_get_perms " "tx %u path %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tx_id, path);
#line 528 "trace/trace-hw_i386_kvm.h"
        } else {
#line 15 "../hw/i386/kvm/trace-events"
            qemu_log("xenstore_get_perms " "tx %u path %s" "\n", tx_id, path);
#line 532 "trace/trace-hw_i386_kvm.h"
        }
    }
}

static inline void trace_xenstore_get_perms(unsigned int tx_id, const char * path)
{
    if (true) {
        _nocheck__trace_xenstore_get_perms(tx_id, path);
    }
}

#define TRACE_XENSTORE_SET_PERMS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XENSTORE_SET_PERMS) || \
    false)

static inline void _nocheck__trace_xenstore_set_perms(unsigned int tx_id, const char * path)
{
    if (trace_event_get_state(TRACE_XENSTORE_SET_PERMS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 16 "../hw/i386/kvm/trace-events"
            qemu_log("%d@%zu.%06zu:xenstore_set_perms " "tx %u path %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tx_id, path);
#line 559 "trace/trace-hw_i386_kvm.h"
        } else {
#line 16 "../hw/i386/kvm/trace-events"
            qemu_log("xenstore_set_perms " "tx %u path %s" "\n", tx_id, path);
#line 563 "trace/trace-hw_i386_kvm.h"
        }
    }
}

static inline void trace_xenstore_set_perms(unsigned int tx_id, const char * path)
{
    if (true) {
        _nocheck__trace_xenstore_set_perms(tx_id, path);
    }
}

#define TRACE_XENSTORE_WATCH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XENSTORE_WATCH) || \
    false)

static inline void _nocheck__trace_xenstore_watch(const char * path, const char * token)
{
    if (trace_event_get_state(TRACE_XENSTORE_WATCH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 17 "../hw/i386/kvm/trace-events"
            qemu_log("%d@%zu.%06zu:xenstore_watch " "path %s token %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , path, token);
#line 590 "trace/trace-hw_i386_kvm.h"
        } else {
#line 17 "../hw/i386/kvm/trace-events"
            qemu_log("xenstore_watch " "path %s token %s" "\n", path, token);
#line 594 "trace/trace-hw_i386_kvm.h"
        }
    }
}

static inline void trace_xenstore_watch(const char * path, const char * token)
{
    if (true) {
        _nocheck__trace_xenstore_watch(path, token);
    }
}

#define TRACE_XENSTORE_UNWATCH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XENSTORE_UNWATCH) || \
    false)

static inline void _nocheck__trace_xenstore_unwatch(const char * path, const char * token)
{
    if (trace_event_get_state(TRACE_XENSTORE_UNWATCH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 18 "../hw/i386/kvm/trace-events"
            qemu_log("%d@%zu.%06zu:xenstore_unwatch " "path %s token %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , path, token);
#line 621 "trace/trace-hw_i386_kvm.h"
        } else {
#line 18 "../hw/i386/kvm/trace-events"
            qemu_log("xenstore_unwatch " "path %s token %s" "\n", path, token);
#line 625 "trace/trace-hw_i386_kvm.h"
        }
    }
}

static inline void trace_xenstore_unwatch(const char * path, const char * token)
{
    if (true) {
        _nocheck__trace_xenstore_unwatch(path, token);
    }
}

#define TRACE_XENSTORE_RESET_WATCHES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XENSTORE_RESET_WATCHES) || \
    false)

static inline void _nocheck__trace_xenstore_reset_watches(void)
{
    if (trace_event_get_state(TRACE_XENSTORE_RESET_WATCHES) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 19 "../hw/i386/kvm/trace-events"
            qemu_log("%d@%zu.%06zu:xenstore_reset_watches " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 652 "trace/trace-hw_i386_kvm.h"
        } else {
#line 19 "../hw/i386/kvm/trace-events"
            qemu_log("xenstore_reset_watches " "" "\n");
#line 656 "trace/trace-hw_i386_kvm.h"
        }
    }
}

static inline void trace_xenstore_reset_watches(void)
{
    if (true) {
        _nocheck__trace_xenstore_reset_watches();
    }
}

#define TRACE_XENSTORE_WATCH_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XENSTORE_WATCH_EVENT) || \
    false)

static inline void _nocheck__trace_xenstore_watch_event(const char * path, const char * token)
{
    if (trace_event_get_state(TRACE_XENSTORE_WATCH_EVENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 20 "../hw/i386/kvm/trace-events"
            qemu_log("%d@%zu.%06zu:xenstore_watch_event " "path %s token %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , path, token);
#line 683 "trace/trace-hw_i386_kvm.h"
        } else {
#line 20 "../hw/i386/kvm/trace-events"
            qemu_log("xenstore_watch_event " "path %s token %s" "\n", path, token);
#line 687 "trace/trace-hw_i386_kvm.h"
        }
    }
}

static inline void trace_xenstore_watch_event(const char * path, const char * token)
{
    if (true) {
        _nocheck__trace_xenstore_watch_event(path, token);
    }
}

#define TRACE_XEN_PRIMARY_CONSOLE_CREATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_PRIMARY_CONSOLE_CREATE) || \
    false)

static inline void _nocheck__trace_xen_primary_console_create(void)
{
    if (trace_event_get_state(TRACE_XEN_PRIMARY_CONSOLE_CREATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 21 "../hw/i386/kvm/trace-events"
            qemu_log("%d@%zu.%06zu:xen_primary_console_create " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 714 "trace/trace-hw_i386_kvm.h"
        } else {
#line 21 "../hw/i386/kvm/trace-events"
            qemu_log("xen_primary_console_create " "" "\n");
#line 718 "trace/trace-hw_i386_kvm.h"
        }
    }
}

static inline void trace_xen_primary_console_create(void)
{
    if (true) {
        _nocheck__trace_xen_primary_console_create();
    }
}

#define TRACE_XEN_PRIMARY_CONSOLE_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_PRIMARY_CONSOLE_RESET) || \
    false)

static inline void _nocheck__trace_xen_primary_console_reset(int port)
{
    if (trace_event_get_state(TRACE_XEN_PRIMARY_CONSOLE_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 22 "../hw/i386/kvm/trace-events"
            qemu_log("%d@%zu.%06zu:xen_primary_console_reset " "port %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , port);
#line 745 "trace/trace-hw_i386_kvm.h"
        } else {
#line 22 "../hw/i386/kvm/trace-events"
            qemu_log("xen_primary_console_reset " "port %u" "\n", port);
#line 749 "trace/trace-hw_i386_kvm.h"
        }
    }
}

static inline void trace_xen_primary_console_reset(int port)
{
    if (true) {
        _nocheck__trace_xen_primary_console_reset(port);
    }
}
#endif /* TRACE_HW_I386_KVM_GENERATED_TRACERS_H */
