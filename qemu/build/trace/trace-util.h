/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_UTIL_GENERATED_TRACERS_H
#define TRACE_UTIL_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_RUN_POLL_HANDLERS_BEGIN_EVENT;
extern TraceEvent _TRACE_RUN_POLL_HANDLERS_END_EVENT;
extern TraceEvent _TRACE_POLL_SHRINK_EVENT;
extern TraceEvent _TRACE_POLL_GROW_EVENT;
extern TraceEvent _TRACE_POLL_ADD_EVENT;
extern TraceEvent _TRACE_POLL_REMOVE_EVENT;
extern TraceEvent _TRACE_AIO_CO_SCHEDULE_EVENT;
extern TraceEvent _TRACE_AIO_CO_SCHEDULE_BH_CB_EVENT;
extern TraceEvent _TRACE_REENTRANT_AIO_EVENT;
extern TraceEvent _TRACE_THREAD_POOL_SUBMIT_EVENT;
extern TraceEvent _TRACE_THREAD_POOL_COMPLETE_EVENT;
extern TraceEvent _TRACE_THREAD_POOL_CANCEL_EVENT;
extern TraceEvent _TRACE_BUFFER_RESIZE_EVENT;
extern TraceEvent _TRACE_BUFFER_MOVE_EMPTY_EVENT;
extern TraceEvent _TRACE_BUFFER_MOVE_EVENT;
extern TraceEvent _TRACE_BUFFER_FREE_EVENT;
extern TraceEvent _TRACE_QEMU_FILE_MONITOR_ADD_WATCH_EVENT;
extern TraceEvent _TRACE_QEMU_FILE_MONITOR_REMOVE_WATCH_EVENT;
extern TraceEvent _TRACE_QEMU_FILE_MONITOR_NEW_EVENT;
extern TraceEvent _TRACE_QEMU_FILE_MONITOR_ENABLE_WATCH_EVENT;
extern TraceEvent _TRACE_QEMU_FILE_MONITOR_DISABLE_WATCH_EVENT;
extern TraceEvent _TRACE_QEMU_FILE_MONITOR_EVENT_EVENT;
extern TraceEvent _TRACE_QEMU_FILE_MONITOR_DISPATCH_EVENT;
extern TraceEvent _TRACE_QEMU_AIO_COROUTINE_ENTER_EVENT;
extern TraceEvent _TRACE_QEMU_COROUTINE_YIELD_EVENT;
extern TraceEvent _TRACE_QEMU_COROUTINE_TERMINATE_EVENT;
extern TraceEvent _TRACE_QEMU_CO_MUTEX_LOCK_UNCONTENDED_EVENT;
extern TraceEvent _TRACE_QEMU_CO_MUTEX_LOCK_ENTRY_EVENT;
extern TraceEvent _TRACE_QEMU_CO_MUTEX_LOCK_RETURN_EVENT;
extern TraceEvent _TRACE_QEMU_CO_MUTEX_UNLOCK_ENTRY_EVENT;
extern TraceEvent _TRACE_QEMU_CO_MUTEX_UNLOCK_RETURN_EVENT;
extern TraceEvent _TRACE_QEMU_MEMALIGN_EVENT;
extern TraceEvent _TRACE_QEMU_ANON_RAM_ALLOC_EVENT;
extern TraceEvent _TRACE_QEMU_VFREE_EVENT;
extern TraceEvent _TRACE_QEMU_ANON_RAM_FREE_EVENT;
extern TraceEvent _TRACE_WIN32_MAP_ALLOC_EVENT;
extern TraceEvent _TRACE_WIN32_MAP_FREE_EVENT;
extern TraceEvent _TRACE_HBITMAP_ITER_SKIP_WORDS_EVENT;
extern TraceEvent _TRACE_HBITMAP_RESET_EVENT;
extern TraceEvent _TRACE_HBITMAP_SET_EVENT;
extern TraceEvent _TRACE_LOCKCNT_FAST_PATH_ATTEMPT_EVENT;
extern TraceEvent _TRACE_LOCKCNT_FAST_PATH_SUCCESS_EVENT;
extern TraceEvent _TRACE_LOCKCNT_UNLOCK_ATTEMPT_EVENT;
extern TraceEvent _TRACE_LOCKCNT_UNLOCK_SUCCESS_EVENT;
extern TraceEvent _TRACE_LOCKCNT_FUTEX_WAIT_PREPARE_EVENT;
extern TraceEvent _TRACE_LOCKCNT_FUTEX_WAIT_EVENT;
extern TraceEvent _TRACE_LOCKCNT_FUTEX_WAIT_RESUME_EVENT;
extern TraceEvent _TRACE_LOCKCNT_FUTEX_WAKE_EVENT;
extern TraceEvent _TRACE_SOCKET_LISTEN_EVENT;
extern TraceEvent _TRACE_QEMU_MUTEX_LOCK_EVENT;
extern TraceEvent _TRACE_QEMU_MUTEX_LOCKED_EVENT;
extern TraceEvent _TRACE_QEMU_MUTEX_UNLOCK_EVENT;
extern TraceEvent _TRACE_QEMU_VFIO_DMA_RESET_TEMPORARY_EVENT;
extern TraceEvent _TRACE_QEMU_VFIO_RAM_BLOCK_ADDED_EVENT;
extern TraceEvent _TRACE_QEMU_VFIO_RAM_BLOCK_REMOVED_EVENT;
extern TraceEvent _TRACE_QEMU_VFIO_DUMP_MAPPING_EVENT;
extern TraceEvent _TRACE_QEMU_VFIO_FIND_MAPPING_EVENT;
extern TraceEvent _TRACE_QEMU_VFIO_NEW_MAPPING_EVENT;
extern TraceEvent _TRACE_QEMU_VFIO_DO_MAPPING_EVENT;
extern TraceEvent _TRACE_QEMU_VFIO_DMA_MAP_EVENT;
extern TraceEvent _TRACE_QEMU_VFIO_DMA_MAPPED_EVENT;
extern TraceEvent _TRACE_QEMU_VFIO_DMA_UNMAP_EVENT;
extern TraceEvent _TRACE_QEMU_VFIO_PCI_READ_CONFIG_EVENT;
extern TraceEvent _TRACE_QEMU_VFIO_PCI_WRITE_CONFIG_EVENT;
extern TraceEvent _TRACE_QEMU_VFIO_REGION_INFO_EVENT;
extern TraceEvent _TRACE_QEMU_VFIO_PCI_MAP_BAR_EVENT;
extern TraceEvent _TRACE_UFFD_DETECT_OPEN_MODE_EVENT;
extern TraceEvent _TRACE_UFFD_QUERY_FEATURES_NOSYS_EVENT;
extern TraceEvent _TRACE_UFFD_QUERY_FEATURES_API_FAILED_EVENT;
extern TraceEvent _TRACE_UFFD_CREATE_FD_NOSYS_EVENT;
extern TraceEvent _TRACE_UFFD_CREATE_FD_API_FAILED_EVENT;
extern TraceEvent _TRACE_UFFD_CREATE_FD_API_NOIOCTL_EVENT;
extern TraceEvent _TRACE_UFFD_REGISTER_MEMORY_FAILED_EVENT;
extern TraceEvent _TRACE_UFFD_UNREGISTER_MEMORY_FAILED_EVENT;
extern TraceEvent _TRACE_MODULE_LOAD_MODULE_EVENT;
extern TraceEvent _TRACE_MODULE_LOOKUP_OBJECT_TYPE_EVENT;
extern uint16_t _TRACE_RUN_POLL_HANDLERS_BEGIN_DSTATE;
extern uint16_t _TRACE_RUN_POLL_HANDLERS_END_DSTATE;
extern uint16_t _TRACE_POLL_SHRINK_DSTATE;
extern uint16_t _TRACE_POLL_GROW_DSTATE;
extern uint16_t _TRACE_POLL_ADD_DSTATE;
extern uint16_t _TRACE_POLL_REMOVE_DSTATE;
extern uint16_t _TRACE_AIO_CO_SCHEDULE_DSTATE;
extern uint16_t _TRACE_AIO_CO_SCHEDULE_BH_CB_DSTATE;
extern uint16_t _TRACE_REENTRANT_AIO_DSTATE;
extern uint16_t _TRACE_THREAD_POOL_SUBMIT_DSTATE;
extern uint16_t _TRACE_THREAD_POOL_COMPLETE_DSTATE;
extern uint16_t _TRACE_THREAD_POOL_CANCEL_DSTATE;
extern uint16_t _TRACE_BUFFER_RESIZE_DSTATE;
extern uint16_t _TRACE_BUFFER_MOVE_EMPTY_DSTATE;
extern uint16_t _TRACE_BUFFER_MOVE_DSTATE;
extern uint16_t _TRACE_BUFFER_FREE_DSTATE;
extern uint16_t _TRACE_QEMU_FILE_MONITOR_ADD_WATCH_DSTATE;
extern uint16_t _TRACE_QEMU_FILE_MONITOR_REMOVE_WATCH_DSTATE;
extern uint16_t _TRACE_QEMU_FILE_MONITOR_NEW_DSTATE;
extern uint16_t _TRACE_QEMU_FILE_MONITOR_ENABLE_WATCH_DSTATE;
extern uint16_t _TRACE_QEMU_FILE_MONITOR_DISABLE_WATCH_DSTATE;
extern uint16_t _TRACE_QEMU_FILE_MONITOR_EVENT_DSTATE;
extern uint16_t _TRACE_QEMU_FILE_MONITOR_DISPATCH_DSTATE;
extern uint16_t _TRACE_QEMU_AIO_COROUTINE_ENTER_DSTATE;
extern uint16_t _TRACE_QEMU_COROUTINE_YIELD_DSTATE;
extern uint16_t _TRACE_QEMU_COROUTINE_TERMINATE_DSTATE;
extern uint16_t _TRACE_QEMU_CO_MUTEX_LOCK_UNCONTENDED_DSTATE;
extern uint16_t _TRACE_QEMU_CO_MUTEX_LOCK_ENTRY_DSTATE;
extern uint16_t _TRACE_QEMU_CO_MUTEX_LOCK_RETURN_DSTATE;
extern uint16_t _TRACE_QEMU_CO_MUTEX_UNLOCK_ENTRY_DSTATE;
extern uint16_t _TRACE_QEMU_CO_MUTEX_UNLOCK_RETURN_DSTATE;
extern uint16_t _TRACE_QEMU_MEMALIGN_DSTATE;
extern uint16_t _TRACE_QEMU_ANON_RAM_ALLOC_DSTATE;
extern uint16_t _TRACE_QEMU_VFREE_DSTATE;
extern uint16_t _TRACE_QEMU_ANON_RAM_FREE_DSTATE;
extern uint16_t _TRACE_WIN32_MAP_ALLOC_DSTATE;
extern uint16_t _TRACE_WIN32_MAP_FREE_DSTATE;
extern uint16_t _TRACE_HBITMAP_ITER_SKIP_WORDS_DSTATE;
extern uint16_t _TRACE_HBITMAP_RESET_DSTATE;
extern uint16_t _TRACE_HBITMAP_SET_DSTATE;
extern uint16_t _TRACE_LOCKCNT_FAST_PATH_ATTEMPT_DSTATE;
extern uint16_t _TRACE_LOCKCNT_FAST_PATH_SUCCESS_DSTATE;
extern uint16_t _TRACE_LOCKCNT_UNLOCK_ATTEMPT_DSTATE;
extern uint16_t _TRACE_LOCKCNT_UNLOCK_SUCCESS_DSTATE;
extern uint16_t _TRACE_LOCKCNT_FUTEX_WAIT_PREPARE_DSTATE;
extern uint16_t _TRACE_LOCKCNT_FUTEX_WAIT_DSTATE;
extern uint16_t _TRACE_LOCKCNT_FUTEX_WAIT_RESUME_DSTATE;
extern uint16_t _TRACE_LOCKCNT_FUTEX_WAKE_DSTATE;
extern uint16_t _TRACE_SOCKET_LISTEN_DSTATE;
extern uint16_t _TRACE_QEMU_MUTEX_LOCK_DSTATE;
extern uint16_t _TRACE_QEMU_MUTEX_LOCKED_DSTATE;
extern uint16_t _TRACE_QEMU_MUTEX_UNLOCK_DSTATE;
extern uint16_t _TRACE_QEMU_VFIO_DMA_RESET_TEMPORARY_DSTATE;
extern uint16_t _TRACE_QEMU_VFIO_RAM_BLOCK_ADDED_DSTATE;
extern uint16_t _TRACE_QEMU_VFIO_RAM_BLOCK_REMOVED_DSTATE;
extern uint16_t _TRACE_QEMU_VFIO_DUMP_MAPPING_DSTATE;
extern uint16_t _TRACE_QEMU_VFIO_FIND_MAPPING_DSTATE;
extern uint16_t _TRACE_QEMU_VFIO_NEW_MAPPING_DSTATE;
extern uint16_t _TRACE_QEMU_VFIO_DO_MAPPING_DSTATE;
extern uint16_t _TRACE_QEMU_VFIO_DMA_MAP_DSTATE;
extern uint16_t _TRACE_QEMU_VFIO_DMA_MAPPED_DSTATE;
extern uint16_t _TRACE_QEMU_VFIO_DMA_UNMAP_DSTATE;
extern uint16_t _TRACE_QEMU_VFIO_PCI_READ_CONFIG_DSTATE;
extern uint16_t _TRACE_QEMU_VFIO_PCI_WRITE_CONFIG_DSTATE;
extern uint16_t _TRACE_QEMU_VFIO_REGION_INFO_DSTATE;
extern uint16_t _TRACE_QEMU_VFIO_PCI_MAP_BAR_DSTATE;
extern uint16_t _TRACE_UFFD_DETECT_OPEN_MODE_DSTATE;
extern uint16_t _TRACE_UFFD_QUERY_FEATURES_NOSYS_DSTATE;
extern uint16_t _TRACE_UFFD_QUERY_FEATURES_API_FAILED_DSTATE;
extern uint16_t _TRACE_UFFD_CREATE_FD_NOSYS_DSTATE;
extern uint16_t _TRACE_UFFD_CREATE_FD_API_FAILED_DSTATE;
extern uint16_t _TRACE_UFFD_CREATE_FD_API_NOIOCTL_DSTATE;
extern uint16_t _TRACE_UFFD_REGISTER_MEMORY_FAILED_DSTATE;
extern uint16_t _TRACE_UFFD_UNREGISTER_MEMORY_FAILED_DSTATE;
extern uint16_t _TRACE_MODULE_LOAD_MODULE_DSTATE;
extern uint16_t _TRACE_MODULE_LOOKUP_OBJECT_TYPE_DSTATE;
#define TRACE_RUN_POLL_HANDLERS_BEGIN_ENABLED 1
#define TRACE_RUN_POLL_HANDLERS_END_ENABLED 1
#define TRACE_POLL_SHRINK_ENABLED 1
#define TRACE_POLL_GROW_ENABLED 1
#define TRACE_POLL_ADD_ENABLED 1
#define TRACE_POLL_REMOVE_ENABLED 1
#define TRACE_AIO_CO_SCHEDULE_ENABLED 1
#define TRACE_AIO_CO_SCHEDULE_BH_CB_ENABLED 1
#define TRACE_REENTRANT_AIO_ENABLED 1
#define TRACE_THREAD_POOL_SUBMIT_ENABLED 1
#define TRACE_THREAD_POOL_COMPLETE_ENABLED 1
#define TRACE_THREAD_POOL_CANCEL_ENABLED 1
#define TRACE_BUFFER_RESIZE_ENABLED 1
#define TRACE_BUFFER_MOVE_EMPTY_ENABLED 1
#define TRACE_BUFFER_MOVE_ENABLED 1
#define TRACE_BUFFER_FREE_ENABLED 1
#define TRACE_QEMU_FILE_MONITOR_ADD_WATCH_ENABLED 1
#define TRACE_QEMU_FILE_MONITOR_REMOVE_WATCH_ENABLED 1
#define TRACE_QEMU_FILE_MONITOR_NEW_ENABLED 1
#define TRACE_QEMU_FILE_MONITOR_ENABLE_WATCH_ENABLED 1
#define TRACE_QEMU_FILE_MONITOR_DISABLE_WATCH_ENABLED 1
#define TRACE_QEMU_FILE_MONITOR_EVENT_ENABLED 1
#define TRACE_QEMU_FILE_MONITOR_DISPATCH_ENABLED 1
#define TRACE_QEMU_AIO_COROUTINE_ENTER_ENABLED 1
#define TRACE_QEMU_COROUTINE_YIELD_ENABLED 1
#define TRACE_QEMU_COROUTINE_TERMINATE_ENABLED 1
#define TRACE_QEMU_CO_MUTEX_LOCK_UNCONTENDED_ENABLED 1
#define TRACE_QEMU_CO_MUTEX_LOCK_ENTRY_ENABLED 1
#define TRACE_QEMU_CO_MUTEX_LOCK_RETURN_ENABLED 1
#define TRACE_QEMU_CO_MUTEX_UNLOCK_ENTRY_ENABLED 1
#define TRACE_QEMU_CO_MUTEX_UNLOCK_RETURN_ENABLED 1
#define TRACE_QEMU_MEMALIGN_ENABLED 1
#define TRACE_QEMU_ANON_RAM_ALLOC_ENABLED 1
#define TRACE_QEMU_VFREE_ENABLED 1
#define TRACE_QEMU_ANON_RAM_FREE_ENABLED 1
#define TRACE_WIN32_MAP_ALLOC_ENABLED 1
#define TRACE_WIN32_MAP_FREE_ENABLED 1
#define TRACE_HBITMAP_ITER_SKIP_WORDS_ENABLED 1
#define TRACE_HBITMAP_RESET_ENABLED 1
#define TRACE_HBITMAP_SET_ENABLED 1
#define TRACE_LOCKCNT_FAST_PATH_ATTEMPT_ENABLED 1
#define TRACE_LOCKCNT_FAST_PATH_SUCCESS_ENABLED 1
#define TRACE_LOCKCNT_UNLOCK_ATTEMPT_ENABLED 1
#define TRACE_LOCKCNT_UNLOCK_SUCCESS_ENABLED 1
#define TRACE_LOCKCNT_FUTEX_WAIT_PREPARE_ENABLED 1
#define TRACE_LOCKCNT_FUTEX_WAIT_ENABLED 1
#define TRACE_LOCKCNT_FUTEX_WAIT_RESUME_ENABLED 1
#define TRACE_LOCKCNT_FUTEX_WAKE_ENABLED 1
#define TRACE_SOCKET_LISTEN_ENABLED 1
#define TRACE_QEMU_MUTEX_LOCK_ENABLED 1
#define TRACE_QEMU_MUTEX_LOCKED_ENABLED 1
#define TRACE_QEMU_MUTEX_UNLOCK_ENABLED 1
#define TRACE_QEMU_VFIO_DMA_RESET_TEMPORARY_ENABLED 1
#define TRACE_QEMU_VFIO_RAM_BLOCK_ADDED_ENABLED 1
#define TRACE_QEMU_VFIO_RAM_BLOCK_REMOVED_ENABLED 1
#define TRACE_QEMU_VFIO_DUMP_MAPPING_ENABLED 1
#define TRACE_QEMU_VFIO_FIND_MAPPING_ENABLED 1
#define TRACE_QEMU_VFIO_NEW_MAPPING_ENABLED 1
#define TRACE_QEMU_VFIO_DO_MAPPING_ENABLED 1
#define TRACE_QEMU_VFIO_DMA_MAP_ENABLED 1
#define TRACE_QEMU_VFIO_DMA_MAPPED_ENABLED 1
#define TRACE_QEMU_VFIO_DMA_UNMAP_ENABLED 1
#define TRACE_QEMU_VFIO_PCI_READ_CONFIG_ENABLED 1
#define TRACE_QEMU_VFIO_PCI_WRITE_CONFIG_ENABLED 1
#define TRACE_QEMU_VFIO_REGION_INFO_ENABLED 1
#define TRACE_QEMU_VFIO_PCI_MAP_BAR_ENABLED 1
#define TRACE_UFFD_DETECT_OPEN_MODE_ENABLED 1
#define TRACE_UFFD_QUERY_FEATURES_NOSYS_ENABLED 1
#define TRACE_UFFD_QUERY_FEATURES_API_FAILED_ENABLED 1
#define TRACE_UFFD_CREATE_FD_NOSYS_ENABLED 1
#define TRACE_UFFD_CREATE_FD_API_FAILED_ENABLED 1
#define TRACE_UFFD_CREATE_FD_API_NOIOCTL_ENABLED 1
#define TRACE_UFFD_REGISTER_MEMORY_FAILED_ENABLED 1
#define TRACE_UFFD_UNREGISTER_MEMORY_FAILED_ENABLED 1
#define TRACE_MODULE_LOAD_MODULE_ENABLED 1
#define TRACE_MODULE_LOOKUP_OBJECT_TYPE_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_RUN_POLL_HANDLERS_BEGIN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RUN_POLL_HANDLERS_BEGIN) || \
    false)

static inline void _nocheck__trace_run_poll_handlers_begin(void * ctx, int64_t max_ns, int64_t timeout)
{
    if (trace_event_get_state(TRACE_RUN_POLL_HANDLERS_BEGIN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 4 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:run_poll_handlers_begin " "ctx %p max_ns %"PRId64 " timeout %"PRId64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ctx, max_ns, timeout);
#line 256 "trace/trace-util.h"
        } else {
#line 4 "../util/trace-events"
            qemu_log("run_poll_handlers_begin " "ctx %p max_ns %"PRId64 " timeout %"PRId64 "\n", ctx, max_ns, timeout);
#line 260 "trace/trace-util.h"
        }
    }
}

static inline void trace_run_poll_handlers_begin(void * ctx, int64_t max_ns, int64_t timeout)
{
    if (true) {
        _nocheck__trace_run_poll_handlers_begin(ctx, max_ns, timeout);
    }
}

#define TRACE_RUN_POLL_HANDLERS_END_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RUN_POLL_HANDLERS_END) || \
    false)

static inline void _nocheck__trace_run_poll_handlers_end(void * ctx, bool progress, int64_t timeout)
{
    if (trace_event_get_state(TRACE_RUN_POLL_HANDLERS_END) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 5 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:run_poll_handlers_end " "ctx %p progress %d new timeout %"PRId64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ctx, progress, timeout);
#line 287 "trace/trace-util.h"
        } else {
#line 5 "../util/trace-events"
            qemu_log("run_poll_handlers_end " "ctx %p progress %d new timeout %"PRId64 "\n", ctx, progress, timeout);
#line 291 "trace/trace-util.h"
        }
    }
}

static inline void trace_run_poll_handlers_end(void * ctx, bool progress, int64_t timeout)
{
    if (true) {
        _nocheck__trace_run_poll_handlers_end(ctx, progress, timeout);
    }
}

#define TRACE_POLL_SHRINK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_POLL_SHRINK) || \
    false)

static inline void _nocheck__trace_poll_shrink(void * ctx, int64_t old, int64_t new)
{
    if (trace_event_get_state(TRACE_POLL_SHRINK) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 6 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:poll_shrink " "ctx %p old %"PRId64" new %"PRId64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ctx, old, new);
#line 318 "trace/trace-util.h"
        } else {
#line 6 "../util/trace-events"
            qemu_log("poll_shrink " "ctx %p old %"PRId64" new %"PRId64 "\n", ctx, old, new);
#line 322 "trace/trace-util.h"
        }
    }
}

static inline void trace_poll_shrink(void * ctx, int64_t old, int64_t new)
{
    if (true) {
        _nocheck__trace_poll_shrink(ctx, old, new);
    }
}

#define TRACE_POLL_GROW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_POLL_GROW) || \
    false)

static inline void _nocheck__trace_poll_grow(void * ctx, int64_t old, int64_t new)
{
    if (trace_event_get_state(TRACE_POLL_GROW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 7 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:poll_grow " "ctx %p old %"PRId64" new %"PRId64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ctx, old, new);
#line 349 "trace/trace-util.h"
        } else {
#line 7 "../util/trace-events"
            qemu_log("poll_grow " "ctx %p old %"PRId64" new %"PRId64 "\n", ctx, old, new);
#line 353 "trace/trace-util.h"
        }
    }
}

static inline void trace_poll_grow(void * ctx, int64_t old, int64_t new)
{
    if (true) {
        _nocheck__trace_poll_grow(ctx, old, new);
    }
}

#define TRACE_POLL_ADD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_POLL_ADD) || \
    false)

static inline void _nocheck__trace_poll_add(void * ctx, void * node, int fd, unsigned revents)
{
    if (trace_event_get_state(TRACE_POLL_ADD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 8 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:poll_add " "ctx %p node %p fd %d revents 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ctx, node, fd, revents);
#line 380 "trace/trace-util.h"
        } else {
#line 8 "../util/trace-events"
            qemu_log("poll_add " "ctx %p node %p fd %d revents 0x%x" "\n", ctx, node, fd, revents);
#line 384 "trace/trace-util.h"
        }
    }
}

static inline void trace_poll_add(void * ctx, void * node, int fd, unsigned revents)
{
    if (true) {
        _nocheck__trace_poll_add(ctx, node, fd, revents);
    }
}

#define TRACE_POLL_REMOVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_POLL_REMOVE) || \
    false)

static inline void _nocheck__trace_poll_remove(void * ctx, void * node, int fd)
{
    if (trace_event_get_state(TRACE_POLL_REMOVE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 9 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:poll_remove " "ctx %p node %p fd %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ctx, node, fd);
#line 411 "trace/trace-util.h"
        } else {
#line 9 "../util/trace-events"
            qemu_log("poll_remove " "ctx %p node %p fd %d" "\n", ctx, node, fd);
#line 415 "trace/trace-util.h"
        }
    }
}

static inline void trace_poll_remove(void * ctx, void * node, int fd)
{
    if (true) {
        _nocheck__trace_poll_remove(ctx, node, fd);
    }
}

#define TRACE_AIO_CO_SCHEDULE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AIO_CO_SCHEDULE) || \
    false)

static inline void _nocheck__trace_aio_co_schedule(void * ctx, void * co)
{
    if (trace_event_get_state(TRACE_AIO_CO_SCHEDULE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 12 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:aio_co_schedule " "ctx %p co %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ctx, co);
#line 442 "trace/trace-util.h"
        } else {
#line 12 "../util/trace-events"
            qemu_log("aio_co_schedule " "ctx %p co %p" "\n", ctx, co);
#line 446 "trace/trace-util.h"
        }
    }
}

static inline void trace_aio_co_schedule(void * ctx, void * co)
{
    if (true) {
        _nocheck__trace_aio_co_schedule(ctx, co);
    }
}

#define TRACE_AIO_CO_SCHEDULE_BH_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AIO_CO_SCHEDULE_BH_CB) || \
    false)

static inline void _nocheck__trace_aio_co_schedule_bh_cb(void * ctx, void * co)
{
    if (trace_event_get_state(TRACE_AIO_CO_SCHEDULE_BH_CB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 13 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:aio_co_schedule_bh_cb " "ctx %p co %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ctx, co);
#line 473 "trace/trace-util.h"
        } else {
#line 13 "../util/trace-events"
            qemu_log("aio_co_schedule_bh_cb " "ctx %p co %p" "\n", ctx, co);
#line 477 "trace/trace-util.h"
        }
    }
}

static inline void trace_aio_co_schedule_bh_cb(void * ctx, void * co)
{
    if (true) {
        _nocheck__trace_aio_co_schedule_bh_cb(ctx, co);
    }
}

#define TRACE_REENTRANT_AIO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_REENTRANT_AIO) || \
    false)

static inline void _nocheck__trace_reentrant_aio(void * ctx, const char * name)
{
    if (trace_event_get_state(TRACE_REENTRANT_AIO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 14 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:reentrant_aio " "ctx %p name %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ctx, name);
#line 504 "trace/trace-util.h"
        } else {
#line 14 "../util/trace-events"
            qemu_log("reentrant_aio " "ctx %p name %s" "\n", ctx, name);
#line 508 "trace/trace-util.h"
        }
    }
}

static inline void trace_reentrant_aio(void * ctx, const char * name)
{
    if (true) {
        _nocheck__trace_reentrant_aio(ctx, name);
    }
}

#define TRACE_THREAD_POOL_SUBMIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_THREAD_POOL_SUBMIT) || \
    false)

static inline void _nocheck__trace_thread_pool_submit(void * pool, void * req, void * opaque)
{
    if (trace_event_get_state(TRACE_THREAD_POOL_SUBMIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 17 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:thread_pool_submit " "pool %p req %p opaque %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , pool, req, opaque);
#line 535 "trace/trace-util.h"
        } else {
#line 17 "../util/trace-events"
            qemu_log("thread_pool_submit " "pool %p req %p opaque %p" "\n", pool, req, opaque);
#line 539 "trace/trace-util.h"
        }
    }
}

static inline void trace_thread_pool_submit(void * pool, void * req, void * opaque)
{
    if (true) {
        _nocheck__trace_thread_pool_submit(pool, req, opaque);
    }
}

#define TRACE_THREAD_POOL_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_THREAD_POOL_COMPLETE) || \
    false)

static inline void _nocheck__trace_thread_pool_complete(void * pool, void * req, void * opaque, int ret)
{
    if (trace_event_get_state(TRACE_THREAD_POOL_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 18 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:thread_pool_complete " "pool %p req %p opaque %p ret %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , pool, req, opaque, ret);
#line 566 "trace/trace-util.h"
        } else {
#line 18 "../util/trace-events"
            qemu_log("thread_pool_complete " "pool %p req %p opaque %p ret %d" "\n", pool, req, opaque, ret);
#line 570 "trace/trace-util.h"
        }
    }
}

static inline void trace_thread_pool_complete(void * pool, void * req, void * opaque, int ret)
{
    if (true) {
        _nocheck__trace_thread_pool_complete(pool, req, opaque, ret);
    }
}

#define TRACE_THREAD_POOL_CANCEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_THREAD_POOL_CANCEL) || \
    false)

static inline void _nocheck__trace_thread_pool_cancel(void * req, void * opaque)
{
    if (trace_event_get_state(TRACE_THREAD_POOL_CANCEL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 19 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:thread_pool_cancel " "req %p opaque %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , req, opaque);
#line 597 "trace/trace-util.h"
        } else {
#line 19 "../util/trace-events"
            qemu_log("thread_pool_cancel " "req %p opaque %p" "\n", req, opaque);
#line 601 "trace/trace-util.h"
        }
    }
}

static inline void trace_thread_pool_cancel(void * req, void * opaque)
{
    if (true) {
        _nocheck__trace_thread_pool_cancel(req, opaque);
    }
}

#define TRACE_BUFFER_RESIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BUFFER_RESIZE) || \
    false)

static inline void _nocheck__trace_buffer_resize(const char * buf, size_t olen, size_t len)
{
    if (trace_event_get_state(TRACE_BUFFER_RESIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 22 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:buffer_resize " "%s: old %zd, new %zd" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , buf, olen, len);
#line 628 "trace/trace-util.h"
        } else {
#line 22 "../util/trace-events"
            qemu_log("buffer_resize " "%s: old %zd, new %zd" "\n", buf, olen, len);
#line 632 "trace/trace-util.h"
        }
    }
}

static inline void trace_buffer_resize(const char * buf, size_t olen, size_t len)
{
    if (true) {
        _nocheck__trace_buffer_resize(buf, olen, len);
    }
}

#define TRACE_BUFFER_MOVE_EMPTY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BUFFER_MOVE_EMPTY) || \
    false)

static inline void _nocheck__trace_buffer_move_empty(const char * buf, size_t len, const char * from)
{
    if (trace_event_get_state(TRACE_BUFFER_MOVE_EMPTY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 23 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:buffer_move_empty " "%s: %zd bytes from %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , buf, len, from);
#line 659 "trace/trace-util.h"
        } else {
#line 23 "../util/trace-events"
            qemu_log("buffer_move_empty " "%s: %zd bytes from %s" "\n", buf, len, from);
#line 663 "trace/trace-util.h"
        }
    }
}

static inline void trace_buffer_move_empty(const char * buf, size_t len, const char * from)
{
    if (true) {
        _nocheck__trace_buffer_move_empty(buf, len, from);
    }
}

#define TRACE_BUFFER_MOVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BUFFER_MOVE) || \
    false)

static inline void _nocheck__trace_buffer_move(const char * buf, size_t len, const char * from)
{
    if (trace_event_get_state(TRACE_BUFFER_MOVE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 24 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:buffer_move " "%s: %zd bytes from %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , buf, len, from);
#line 690 "trace/trace-util.h"
        } else {
#line 24 "../util/trace-events"
            qemu_log("buffer_move " "%s: %zd bytes from %s" "\n", buf, len, from);
#line 694 "trace/trace-util.h"
        }
    }
}

static inline void trace_buffer_move(const char * buf, size_t len, const char * from)
{
    if (true) {
        _nocheck__trace_buffer_move(buf, len, from);
    }
}

#define TRACE_BUFFER_FREE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BUFFER_FREE) || \
    false)

static inline void _nocheck__trace_buffer_free(const char * buf, size_t len)
{
    if (trace_event_get_state(TRACE_BUFFER_FREE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 25 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:buffer_free " "%s: capacity %zd" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , buf, len);
#line 721 "trace/trace-util.h"
        } else {
#line 25 "../util/trace-events"
            qemu_log("buffer_free " "%s: capacity %zd" "\n", buf, len);
#line 725 "trace/trace-util.h"
        }
    }
}

static inline void trace_buffer_free(const char * buf, size_t len)
{
    if (true) {
        _nocheck__trace_buffer_free(buf, len);
    }
}

#define TRACE_QEMU_FILE_MONITOR_ADD_WATCH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_FILE_MONITOR_ADD_WATCH) || \
    false)

static inline void _nocheck__trace_qemu_file_monitor_add_watch(void * mon, const char * dirpath, const char * filename, void * cb, void * opaque, int64_t id)
{
    if (trace_event_get_state(TRACE_QEMU_FILE_MONITOR_ADD_WATCH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 28 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_file_monitor_add_watch " "File monitor %p add watch dir='%s' file='%s' cb=%p opaque=%p id=%" PRId64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , mon, dirpath, filename, cb, opaque, id);
#line 752 "trace/trace-util.h"
        } else {
#line 28 "../util/trace-events"
            qemu_log("qemu_file_monitor_add_watch " "File monitor %p add watch dir='%s' file='%s' cb=%p opaque=%p id=%" PRId64 "\n", mon, dirpath, filename, cb, opaque, id);
#line 756 "trace/trace-util.h"
        }
    }
}

static inline void trace_qemu_file_monitor_add_watch(void * mon, const char * dirpath, const char * filename, void * cb, void * opaque, int64_t id)
{
    if (true) {
        _nocheck__trace_qemu_file_monitor_add_watch(mon, dirpath, filename, cb, opaque, id);
    }
}

#define TRACE_QEMU_FILE_MONITOR_REMOVE_WATCH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_FILE_MONITOR_REMOVE_WATCH) || \
    false)

static inline void _nocheck__trace_qemu_file_monitor_remove_watch(void * mon, const char * dirpath, int64_t id)
{
    if (trace_event_get_state(TRACE_QEMU_FILE_MONITOR_REMOVE_WATCH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 29 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_file_monitor_remove_watch " "File monitor %p remove watch dir='%s' id=%" PRId64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , mon, dirpath, id);
#line 783 "trace/trace-util.h"
        } else {
#line 29 "../util/trace-events"
            qemu_log("qemu_file_monitor_remove_watch " "File monitor %p remove watch dir='%s' id=%" PRId64 "\n", mon, dirpath, id);
#line 787 "trace/trace-util.h"
        }
    }
}

static inline void trace_qemu_file_monitor_remove_watch(void * mon, const char * dirpath, int64_t id)
{
    if (true) {
        _nocheck__trace_qemu_file_monitor_remove_watch(mon, dirpath, id);
    }
}

#define TRACE_QEMU_FILE_MONITOR_NEW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_FILE_MONITOR_NEW) || \
    false)

static inline void _nocheck__trace_qemu_file_monitor_new(void * mon, int fd)
{
    if (trace_event_get_state(TRACE_QEMU_FILE_MONITOR_NEW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 30 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_file_monitor_new " "File monitor %p created fd=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , mon, fd);
#line 814 "trace/trace-util.h"
        } else {
#line 30 "../util/trace-events"
            qemu_log("qemu_file_monitor_new " "File monitor %p created fd=%d" "\n", mon, fd);
#line 818 "trace/trace-util.h"
        }
    }
}

static inline void trace_qemu_file_monitor_new(void * mon, int fd)
{
    if (true) {
        _nocheck__trace_qemu_file_monitor_new(mon, fd);
    }
}

#define TRACE_QEMU_FILE_MONITOR_ENABLE_WATCH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_FILE_MONITOR_ENABLE_WATCH) || \
    false)

static inline void _nocheck__trace_qemu_file_monitor_enable_watch(void * mon, const char * dirpath, int id)
{
    if (trace_event_get_state(TRACE_QEMU_FILE_MONITOR_ENABLE_WATCH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 31 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_file_monitor_enable_watch " "File monitor %p enable watch dir='%s' id=%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , mon, dirpath, id);
#line 845 "trace/trace-util.h"
        } else {
#line 31 "../util/trace-events"
            qemu_log("qemu_file_monitor_enable_watch " "File monitor %p enable watch dir='%s' id=%u" "\n", mon, dirpath, id);
#line 849 "trace/trace-util.h"
        }
    }
}

static inline void trace_qemu_file_monitor_enable_watch(void * mon, const char * dirpath, int id)
{
    if (true) {
        _nocheck__trace_qemu_file_monitor_enable_watch(mon, dirpath, id);
    }
}

#define TRACE_QEMU_FILE_MONITOR_DISABLE_WATCH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_FILE_MONITOR_DISABLE_WATCH) || \
    false)

static inline void _nocheck__trace_qemu_file_monitor_disable_watch(void * mon, const char * dirpath, int id)
{
    if (trace_event_get_state(TRACE_QEMU_FILE_MONITOR_DISABLE_WATCH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 32 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_file_monitor_disable_watch " "File monitor %p disable watch dir='%s' id=%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , mon, dirpath, id);
#line 876 "trace/trace-util.h"
        } else {
#line 32 "../util/trace-events"
            qemu_log("qemu_file_monitor_disable_watch " "File monitor %p disable watch dir='%s' id=%u" "\n", mon, dirpath, id);
#line 880 "trace/trace-util.h"
        }
    }
}

static inline void trace_qemu_file_monitor_disable_watch(void * mon, const char * dirpath, int id)
{
    if (true) {
        _nocheck__trace_qemu_file_monitor_disable_watch(mon, dirpath, id);
    }
}

#define TRACE_QEMU_FILE_MONITOR_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_FILE_MONITOR_EVENT) || \
    false)

static inline void _nocheck__trace_qemu_file_monitor_event(void * mon, const char * dirpath, const char * filename, int mask, unsigned int id)
{
    if (trace_event_get_state(TRACE_QEMU_FILE_MONITOR_EVENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 33 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_file_monitor_event " "File monitor %p event dir='%s' file='%s' mask=0x%x id=%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , mon, dirpath, filename, mask, id);
#line 907 "trace/trace-util.h"
        } else {
#line 33 "../util/trace-events"
            qemu_log("qemu_file_monitor_event " "File monitor %p event dir='%s' file='%s' mask=0x%x id=%u" "\n", mon, dirpath, filename, mask, id);
#line 911 "trace/trace-util.h"
        }
    }
}

static inline void trace_qemu_file_monitor_event(void * mon, const char * dirpath, const char * filename, int mask, unsigned int id)
{
    if (true) {
        _nocheck__trace_qemu_file_monitor_event(mon, dirpath, filename, mask, id);
    }
}

#define TRACE_QEMU_FILE_MONITOR_DISPATCH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_FILE_MONITOR_DISPATCH) || \
    false)

static inline void _nocheck__trace_qemu_file_monitor_dispatch(void * mon, const char * dirpath, const char * filename, int ev, void * cb, void * opaque, int64_t id)
{
    if (trace_event_get_state(TRACE_QEMU_FILE_MONITOR_DISPATCH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 34 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_file_monitor_dispatch " "File monitor %p dispatch dir='%s' file='%s' ev=%d cb=%p opaque=%p id=%" PRId64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , mon, dirpath, filename, ev, cb, opaque, id);
#line 938 "trace/trace-util.h"
        } else {
#line 34 "../util/trace-events"
            qemu_log("qemu_file_monitor_dispatch " "File monitor %p dispatch dir='%s' file='%s' ev=%d cb=%p opaque=%p id=%" PRId64 "\n", mon, dirpath, filename, ev, cb, opaque, id);
#line 942 "trace/trace-util.h"
        }
    }
}

static inline void trace_qemu_file_monitor_dispatch(void * mon, const char * dirpath, const char * filename, int ev, void * cb, void * opaque, int64_t id)
{
    if (true) {
        _nocheck__trace_qemu_file_monitor_dispatch(mon, dirpath, filename, ev, cb, opaque, id);
    }
}

#define TRACE_QEMU_AIO_COROUTINE_ENTER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_AIO_COROUTINE_ENTER) || \
    false)

static inline void _nocheck__trace_qemu_aio_coroutine_enter(void * ctx, void * from, void * to, void * opaque)
{
    if (trace_event_get_state(TRACE_QEMU_AIO_COROUTINE_ENTER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 37 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_aio_coroutine_enter " "ctx %p from %p to %p opaque %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ctx, from, to, opaque);
#line 969 "trace/trace-util.h"
        } else {
#line 37 "../util/trace-events"
            qemu_log("qemu_aio_coroutine_enter " "ctx %p from %p to %p opaque %p" "\n", ctx, from, to, opaque);
#line 973 "trace/trace-util.h"
        }
    }
}

static inline void trace_qemu_aio_coroutine_enter(void * ctx, void * from, void * to, void * opaque)
{
    if (true) {
        _nocheck__trace_qemu_aio_coroutine_enter(ctx, from, to, opaque);
    }
}

#define TRACE_QEMU_COROUTINE_YIELD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_COROUTINE_YIELD) || \
    false)

static inline void _nocheck__trace_qemu_coroutine_yield(void * from, void * to)
{
    if (trace_event_get_state(TRACE_QEMU_COROUTINE_YIELD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 38 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_coroutine_yield " "from %p to %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , from, to);
#line 1000 "trace/trace-util.h"
        } else {
#line 38 "../util/trace-events"
            qemu_log("qemu_coroutine_yield " "from %p to %p" "\n", from, to);
#line 1004 "trace/trace-util.h"
        }
    }
}

static inline void trace_qemu_coroutine_yield(void * from, void * to)
{
    if (true) {
        _nocheck__trace_qemu_coroutine_yield(from, to);
    }
}

#define TRACE_QEMU_COROUTINE_TERMINATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_COROUTINE_TERMINATE) || \
    false)

static inline void _nocheck__trace_qemu_coroutine_terminate(void * co)
{
    if (trace_event_get_state(TRACE_QEMU_COROUTINE_TERMINATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 39 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_coroutine_terminate " "self %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , co);
#line 1031 "trace/trace-util.h"
        } else {
#line 39 "../util/trace-events"
            qemu_log("qemu_coroutine_terminate " "self %p" "\n", co);
#line 1035 "trace/trace-util.h"
        }
    }
}

static inline void trace_qemu_coroutine_terminate(void * co)
{
    if (true) {
        _nocheck__trace_qemu_coroutine_terminate(co);
    }
}

#define TRACE_QEMU_CO_MUTEX_LOCK_UNCONTENDED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_CO_MUTEX_LOCK_UNCONTENDED) || \
    false)

static inline void _nocheck__trace_qemu_co_mutex_lock_uncontended(void * mutex, void * self)
{
    if (trace_event_get_state(TRACE_QEMU_CO_MUTEX_LOCK_UNCONTENDED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 42 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_co_mutex_lock_uncontended " "mutex %p self %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , mutex, self);
#line 1062 "trace/trace-util.h"
        } else {
#line 42 "../util/trace-events"
            qemu_log("qemu_co_mutex_lock_uncontended " "mutex %p self %p" "\n", mutex, self);
#line 1066 "trace/trace-util.h"
        }
    }
}

static inline void trace_qemu_co_mutex_lock_uncontended(void * mutex, void * self)
{
    if (true) {
        _nocheck__trace_qemu_co_mutex_lock_uncontended(mutex, self);
    }
}

#define TRACE_QEMU_CO_MUTEX_LOCK_ENTRY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_CO_MUTEX_LOCK_ENTRY) || \
    false)

static inline void _nocheck__trace_qemu_co_mutex_lock_entry(void * mutex, void * self)
{
    if (trace_event_get_state(TRACE_QEMU_CO_MUTEX_LOCK_ENTRY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 43 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_co_mutex_lock_entry " "mutex %p self %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , mutex, self);
#line 1093 "trace/trace-util.h"
        } else {
#line 43 "../util/trace-events"
            qemu_log("qemu_co_mutex_lock_entry " "mutex %p self %p" "\n", mutex, self);
#line 1097 "trace/trace-util.h"
        }
    }
}

static inline void trace_qemu_co_mutex_lock_entry(void * mutex, void * self)
{
    if (true) {
        _nocheck__trace_qemu_co_mutex_lock_entry(mutex, self);
    }
}

#define TRACE_QEMU_CO_MUTEX_LOCK_RETURN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_CO_MUTEX_LOCK_RETURN) || \
    false)

static inline void _nocheck__trace_qemu_co_mutex_lock_return(void * mutex, void * self)
{
    if (trace_event_get_state(TRACE_QEMU_CO_MUTEX_LOCK_RETURN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 44 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_co_mutex_lock_return " "mutex %p self %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , mutex, self);
#line 1124 "trace/trace-util.h"
        } else {
#line 44 "../util/trace-events"
            qemu_log("qemu_co_mutex_lock_return " "mutex %p self %p" "\n", mutex, self);
#line 1128 "trace/trace-util.h"
        }
    }
}

static inline void trace_qemu_co_mutex_lock_return(void * mutex, void * self)
{
    if (true) {
        _nocheck__trace_qemu_co_mutex_lock_return(mutex, self);
    }
}

#define TRACE_QEMU_CO_MUTEX_UNLOCK_ENTRY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_CO_MUTEX_UNLOCK_ENTRY) || \
    false)

static inline void _nocheck__trace_qemu_co_mutex_unlock_entry(void * mutex, void * self)
{
    if (trace_event_get_state(TRACE_QEMU_CO_MUTEX_UNLOCK_ENTRY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 45 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_co_mutex_unlock_entry " "mutex %p self %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , mutex, self);
#line 1155 "trace/trace-util.h"
        } else {
#line 45 "../util/trace-events"
            qemu_log("qemu_co_mutex_unlock_entry " "mutex %p self %p" "\n", mutex, self);
#line 1159 "trace/trace-util.h"
        }
    }
}

static inline void trace_qemu_co_mutex_unlock_entry(void * mutex, void * self)
{
    if (true) {
        _nocheck__trace_qemu_co_mutex_unlock_entry(mutex, self);
    }
}

#define TRACE_QEMU_CO_MUTEX_UNLOCK_RETURN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_CO_MUTEX_UNLOCK_RETURN) || \
    false)

static inline void _nocheck__trace_qemu_co_mutex_unlock_return(void * mutex, void * self)
{
    if (trace_event_get_state(TRACE_QEMU_CO_MUTEX_UNLOCK_RETURN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 46 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_co_mutex_unlock_return " "mutex %p self %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , mutex, self);
#line 1186 "trace/trace-util.h"
        } else {
#line 46 "../util/trace-events"
            qemu_log("qemu_co_mutex_unlock_return " "mutex %p self %p" "\n", mutex, self);
#line 1190 "trace/trace-util.h"
        }
    }
}

static inline void trace_qemu_co_mutex_unlock_return(void * mutex, void * self)
{
    if (true) {
        _nocheck__trace_qemu_co_mutex_unlock_return(mutex, self);
    }
}

#define TRACE_QEMU_MEMALIGN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_MEMALIGN) || \
    false)

static inline void _nocheck__trace_qemu_memalign(size_t alignment, size_t size, void * ptr)
{
    if (trace_event_get_state(TRACE_QEMU_MEMALIGN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 50 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_memalign " "alignment %zu size %zu ptr %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , alignment, size, ptr);
#line 1217 "trace/trace-util.h"
        } else {
#line 50 "../util/trace-events"
            qemu_log("qemu_memalign " "alignment %zu size %zu ptr %p" "\n", alignment, size, ptr);
#line 1221 "trace/trace-util.h"
        }
    }
}

static inline void trace_qemu_memalign(size_t alignment, size_t size, void * ptr)
{
    if (true) {
        _nocheck__trace_qemu_memalign(alignment, size, ptr);
    }
}

#define TRACE_QEMU_ANON_RAM_ALLOC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_ANON_RAM_ALLOC) || \
    false)

static inline void _nocheck__trace_qemu_anon_ram_alloc(size_t size, void * ptr)
{
    if (trace_event_get_state(TRACE_QEMU_ANON_RAM_ALLOC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 51 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_anon_ram_alloc " "size %zu ptr %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , size, ptr);
#line 1248 "trace/trace-util.h"
        } else {
#line 51 "../util/trace-events"
            qemu_log("qemu_anon_ram_alloc " "size %zu ptr %p" "\n", size, ptr);
#line 1252 "trace/trace-util.h"
        }
    }
}

static inline void trace_qemu_anon_ram_alloc(size_t size, void * ptr)
{
    if (true) {
        _nocheck__trace_qemu_anon_ram_alloc(size, ptr);
    }
}

#define TRACE_QEMU_VFREE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_VFREE) || \
    false)

static inline void _nocheck__trace_qemu_vfree(void * ptr)
{
    if (trace_event_get_state(TRACE_QEMU_VFREE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 52 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_vfree " "ptr %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ptr);
#line 1279 "trace/trace-util.h"
        } else {
#line 52 "../util/trace-events"
            qemu_log("qemu_vfree " "ptr %p" "\n", ptr);
#line 1283 "trace/trace-util.h"
        }
    }
}

static inline void trace_qemu_vfree(void * ptr)
{
    if (true) {
        _nocheck__trace_qemu_vfree(ptr);
    }
}

#define TRACE_QEMU_ANON_RAM_FREE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_ANON_RAM_FREE) || \
    false)

static inline void _nocheck__trace_qemu_anon_ram_free(void * ptr, size_t size)
{
    if (trace_event_get_state(TRACE_QEMU_ANON_RAM_FREE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 53 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_anon_ram_free " "ptr %p size %zu" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ptr, size);
#line 1310 "trace/trace-util.h"
        } else {
#line 53 "../util/trace-events"
            qemu_log("qemu_anon_ram_free " "ptr %p size %zu" "\n", ptr, size);
#line 1314 "trace/trace-util.h"
        }
    }
}

static inline void trace_qemu_anon_ram_free(void * ptr, size_t size)
{
    if (true) {
        _nocheck__trace_qemu_anon_ram_free(ptr, size);
    }
}

#define TRACE_WIN32_MAP_ALLOC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_WIN32_MAP_ALLOC) || \
    false)

static inline void _nocheck__trace_win32_map_alloc(size_t size)
{
    if (trace_event_get_state(TRACE_WIN32_MAP_ALLOC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 56 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:win32_map_alloc " "size:%zd" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , size);
#line 1341 "trace/trace-util.h"
        } else {
#line 56 "../util/trace-events"
            qemu_log("win32_map_alloc " "size:%zd" "\n", size);
#line 1345 "trace/trace-util.h"
        }
    }
}

static inline void trace_win32_map_alloc(size_t size)
{
    if (true) {
        _nocheck__trace_win32_map_alloc(size);
    }
}

#define TRACE_WIN32_MAP_FREE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_WIN32_MAP_FREE) || \
    false)

static inline void _nocheck__trace_win32_map_free(void * ptr, void * h)
{
    if (trace_event_get_state(TRACE_WIN32_MAP_FREE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 57 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:win32_map_free " "ptr:%p handle:%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ptr, h);
#line 1372 "trace/trace-util.h"
        } else {
#line 57 "../util/trace-events"
            qemu_log("win32_map_free " "ptr:%p handle:%p" "\n", ptr, h);
#line 1376 "trace/trace-util.h"
        }
    }
}

static inline void trace_win32_map_free(void * ptr, void * h)
{
    if (true) {
        _nocheck__trace_win32_map_free(ptr, h);
    }
}

#define TRACE_HBITMAP_ITER_SKIP_WORDS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HBITMAP_ITER_SKIP_WORDS) || \
    false)

static inline void _nocheck__trace_hbitmap_iter_skip_words(const void * hb, void * hbi, uint64_t pos, unsigned long cur)
{
    if (trace_event_get_state(TRACE_HBITMAP_ITER_SKIP_WORDS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 60 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:hbitmap_iter_skip_words " "hb %p hbi %p pos %"PRId64" cur 0x%lx" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , hb, hbi, pos, cur);
#line 1403 "trace/trace-util.h"
        } else {
#line 60 "../util/trace-events"
            qemu_log("hbitmap_iter_skip_words " "hb %p hbi %p pos %"PRId64" cur 0x%lx" "\n", hb, hbi, pos, cur);
#line 1407 "trace/trace-util.h"
        }
    }
}

static inline void trace_hbitmap_iter_skip_words(const void * hb, void * hbi, uint64_t pos, unsigned long cur)
{
    if (true) {
        _nocheck__trace_hbitmap_iter_skip_words(hb, hbi, pos, cur);
    }
}

#define TRACE_HBITMAP_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HBITMAP_RESET) || \
    false)

static inline void _nocheck__trace_hbitmap_reset(void * hb, uint64_t start, uint64_t count, uint64_t sbit, uint64_t ebit)
{
    if (trace_event_get_state(TRACE_HBITMAP_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 61 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:hbitmap_reset " "hb %p items %"PRIu64",%"PRIu64" bits %"PRIu64"..%"PRIu64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , hb, start, count, sbit, ebit);
#line 1434 "trace/trace-util.h"
        } else {
#line 61 "../util/trace-events"
            qemu_log("hbitmap_reset " "hb %p items %"PRIu64",%"PRIu64" bits %"PRIu64"..%"PRIu64 "\n", hb, start, count, sbit, ebit);
#line 1438 "trace/trace-util.h"
        }
    }
}

static inline void trace_hbitmap_reset(void * hb, uint64_t start, uint64_t count, uint64_t sbit, uint64_t ebit)
{
    if (true) {
        _nocheck__trace_hbitmap_reset(hb, start, count, sbit, ebit);
    }
}

#define TRACE_HBITMAP_SET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HBITMAP_SET) || \
    false)

static inline void _nocheck__trace_hbitmap_set(void * hb, uint64_t start, uint64_t count, uint64_t sbit, uint64_t ebit)
{
    if (trace_event_get_state(TRACE_HBITMAP_SET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 62 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:hbitmap_set " "hb %p items %"PRIu64",%"PRIu64" bits %"PRIu64"..%"PRIu64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , hb, start, count, sbit, ebit);
#line 1465 "trace/trace-util.h"
        } else {
#line 62 "../util/trace-events"
            qemu_log("hbitmap_set " "hb %p items %"PRIu64",%"PRIu64" bits %"PRIu64"..%"PRIu64 "\n", hb, start, count, sbit, ebit);
#line 1469 "trace/trace-util.h"
        }
    }
}

static inline void trace_hbitmap_set(void * hb, uint64_t start, uint64_t count, uint64_t sbit, uint64_t ebit)
{
    if (true) {
        _nocheck__trace_hbitmap_set(hb, start, count, sbit, ebit);
    }
}

#define TRACE_LOCKCNT_FAST_PATH_ATTEMPT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LOCKCNT_FAST_PATH_ATTEMPT) || \
    false)

static inline void _nocheck__trace_lockcnt_fast_path_attempt(const void * lockcnt, int expected, int new)
{
    if (trace_event_get_state(TRACE_LOCKCNT_FAST_PATH_ATTEMPT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 65 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:lockcnt_fast_path_attempt " "lockcnt %p fast path %d->%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , lockcnt, expected, new);
#line 1496 "trace/trace-util.h"
        } else {
#line 65 "../util/trace-events"
            qemu_log("lockcnt_fast_path_attempt " "lockcnt %p fast path %d->%d" "\n", lockcnt, expected, new);
#line 1500 "trace/trace-util.h"
        }
    }
}

static inline void trace_lockcnt_fast_path_attempt(const void * lockcnt, int expected, int new)
{
    if (true) {
        _nocheck__trace_lockcnt_fast_path_attempt(lockcnt, expected, new);
    }
}

#define TRACE_LOCKCNT_FAST_PATH_SUCCESS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LOCKCNT_FAST_PATH_SUCCESS) || \
    false)

static inline void _nocheck__trace_lockcnt_fast_path_success(const void * lockcnt, int expected, int new)
{
    if (trace_event_get_state(TRACE_LOCKCNT_FAST_PATH_SUCCESS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 66 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:lockcnt_fast_path_success " "lockcnt %p fast path %d->%d succeeded" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , lockcnt, expected, new);
#line 1527 "trace/trace-util.h"
        } else {
#line 66 "../util/trace-events"
            qemu_log("lockcnt_fast_path_success " "lockcnt %p fast path %d->%d succeeded" "\n", lockcnt, expected, new);
#line 1531 "trace/trace-util.h"
        }
    }
}

static inline void trace_lockcnt_fast_path_success(const void * lockcnt, int expected, int new)
{
    if (true) {
        _nocheck__trace_lockcnt_fast_path_success(lockcnt, expected, new);
    }
}

#define TRACE_LOCKCNT_UNLOCK_ATTEMPT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LOCKCNT_UNLOCK_ATTEMPT) || \
    false)

static inline void _nocheck__trace_lockcnt_unlock_attempt(const void * lockcnt, int expected, int new)
{
    if (trace_event_get_state(TRACE_LOCKCNT_UNLOCK_ATTEMPT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 67 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:lockcnt_unlock_attempt " "lockcnt %p unlock %d->%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , lockcnt, expected, new);
#line 1558 "trace/trace-util.h"
        } else {
#line 67 "../util/trace-events"
            qemu_log("lockcnt_unlock_attempt " "lockcnt %p unlock %d->%d" "\n", lockcnt, expected, new);
#line 1562 "trace/trace-util.h"
        }
    }
}

static inline void trace_lockcnt_unlock_attempt(const void * lockcnt, int expected, int new)
{
    if (true) {
        _nocheck__trace_lockcnt_unlock_attempt(lockcnt, expected, new);
    }
}

#define TRACE_LOCKCNT_UNLOCK_SUCCESS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LOCKCNT_UNLOCK_SUCCESS) || \
    false)

static inline void _nocheck__trace_lockcnt_unlock_success(const void * lockcnt, int expected, int new)
{
    if (trace_event_get_state(TRACE_LOCKCNT_UNLOCK_SUCCESS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 68 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:lockcnt_unlock_success " "lockcnt %p unlock %d->%d succeeded" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , lockcnt, expected, new);
#line 1589 "trace/trace-util.h"
        } else {
#line 68 "../util/trace-events"
            qemu_log("lockcnt_unlock_success " "lockcnt %p unlock %d->%d succeeded" "\n", lockcnt, expected, new);
#line 1593 "trace/trace-util.h"
        }
    }
}

static inline void trace_lockcnt_unlock_success(const void * lockcnt, int expected, int new)
{
    if (true) {
        _nocheck__trace_lockcnt_unlock_success(lockcnt, expected, new);
    }
}

#define TRACE_LOCKCNT_FUTEX_WAIT_PREPARE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LOCKCNT_FUTEX_WAIT_PREPARE) || \
    false)

static inline void _nocheck__trace_lockcnt_futex_wait_prepare(const void * lockcnt, int expected, int new)
{
    if (trace_event_get_state(TRACE_LOCKCNT_FUTEX_WAIT_PREPARE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 69 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:lockcnt_futex_wait_prepare " "lockcnt %p preparing slow path %d->%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , lockcnt, expected, new);
#line 1620 "trace/trace-util.h"
        } else {
#line 69 "../util/trace-events"
            qemu_log("lockcnt_futex_wait_prepare " "lockcnt %p preparing slow path %d->%d" "\n", lockcnt, expected, new);
#line 1624 "trace/trace-util.h"
        }
    }
}

static inline void trace_lockcnt_futex_wait_prepare(const void * lockcnt, int expected, int new)
{
    if (true) {
        _nocheck__trace_lockcnt_futex_wait_prepare(lockcnt, expected, new);
    }
}

#define TRACE_LOCKCNT_FUTEX_WAIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LOCKCNT_FUTEX_WAIT) || \
    false)

static inline void _nocheck__trace_lockcnt_futex_wait(const void * lockcnt, int val)
{
    if (trace_event_get_state(TRACE_LOCKCNT_FUTEX_WAIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 70 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:lockcnt_futex_wait " "lockcnt %p waiting on %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , lockcnt, val);
#line 1651 "trace/trace-util.h"
        } else {
#line 70 "../util/trace-events"
            qemu_log("lockcnt_futex_wait " "lockcnt %p waiting on %d" "\n", lockcnt, val);
#line 1655 "trace/trace-util.h"
        }
    }
}

static inline void trace_lockcnt_futex_wait(const void * lockcnt, int val)
{
    if (true) {
        _nocheck__trace_lockcnt_futex_wait(lockcnt, val);
    }
}

#define TRACE_LOCKCNT_FUTEX_WAIT_RESUME_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LOCKCNT_FUTEX_WAIT_RESUME) || \
    false)

static inline void _nocheck__trace_lockcnt_futex_wait_resume(const void * lockcnt, int new)
{
    if (trace_event_get_state(TRACE_LOCKCNT_FUTEX_WAIT_RESUME) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 71 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:lockcnt_futex_wait_resume " "lockcnt %p after wait: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , lockcnt, new);
#line 1682 "trace/trace-util.h"
        } else {
#line 71 "../util/trace-events"
            qemu_log("lockcnt_futex_wait_resume " "lockcnt %p after wait: %d" "\n", lockcnt, new);
#line 1686 "trace/trace-util.h"
        }
    }
}

static inline void trace_lockcnt_futex_wait_resume(const void * lockcnt, int new)
{
    if (true) {
        _nocheck__trace_lockcnt_futex_wait_resume(lockcnt, new);
    }
}

#define TRACE_LOCKCNT_FUTEX_WAKE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LOCKCNT_FUTEX_WAKE) || \
    false)

static inline void _nocheck__trace_lockcnt_futex_wake(const void * lockcnt)
{
    if (trace_event_get_state(TRACE_LOCKCNT_FUTEX_WAKE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 72 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:lockcnt_futex_wake " "lockcnt %p waking up one waiter" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , lockcnt);
#line 1713 "trace/trace-util.h"
        } else {
#line 72 "../util/trace-events"
            qemu_log("lockcnt_futex_wake " "lockcnt %p waking up one waiter" "\n", lockcnt);
#line 1717 "trace/trace-util.h"
        }
    }
}

static inline void trace_lockcnt_futex_wake(const void * lockcnt)
{
    if (true) {
        _nocheck__trace_lockcnt_futex_wake(lockcnt);
    }
}

#define TRACE_SOCKET_LISTEN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SOCKET_LISTEN) || \
    false)

static inline void _nocheck__trace_socket_listen(int num)
{
    if (trace_event_get_state(TRACE_SOCKET_LISTEN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 75 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:socket_listen " "backlog: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , num);
#line 1744 "trace/trace-util.h"
        } else {
#line 75 "../util/trace-events"
            qemu_log("socket_listen " "backlog: %d" "\n", num);
#line 1748 "trace/trace-util.h"
        }
    }
}

static inline void trace_socket_listen(int num)
{
    if (true) {
        _nocheck__trace_socket_listen(num);
    }
}

#define TRACE_QEMU_MUTEX_LOCK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_MUTEX_LOCK) || \
    false)

static inline void _nocheck__trace_qemu_mutex_lock(void * mutex, const char * file, const int line)
{
    if (trace_event_get_state(TRACE_QEMU_MUTEX_LOCK) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 80 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_mutex_lock " "waiting on mutex %p (%s:%d)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , mutex, file, line);
#line 1775 "trace/trace-util.h"
        } else {
#line 80 "../util/trace-events"
            qemu_log("qemu_mutex_lock " "waiting on mutex %p (%s:%d)" "\n", mutex, file, line);
#line 1779 "trace/trace-util.h"
        }
    }
}

static inline void trace_qemu_mutex_lock(void * mutex, const char * file, const int line)
{
    if (true) {
        _nocheck__trace_qemu_mutex_lock(mutex, file, line);
    }
}

#define TRACE_QEMU_MUTEX_LOCKED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_MUTEX_LOCKED) || \
    false)

static inline void _nocheck__trace_qemu_mutex_locked(void * mutex, const char * file, const int line)
{
    if (trace_event_get_state(TRACE_QEMU_MUTEX_LOCKED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 81 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_mutex_locked " "taken mutex %p (%s:%d)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , mutex, file, line);
#line 1806 "trace/trace-util.h"
        } else {
#line 81 "../util/trace-events"
            qemu_log("qemu_mutex_locked " "taken mutex %p (%s:%d)" "\n", mutex, file, line);
#line 1810 "trace/trace-util.h"
        }
    }
}

static inline void trace_qemu_mutex_locked(void * mutex, const char * file, const int line)
{
    if (true) {
        _nocheck__trace_qemu_mutex_locked(mutex, file, line);
    }
}

#define TRACE_QEMU_MUTEX_UNLOCK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_MUTEX_UNLOCK) || \
    false)

static inline void _nocheck__trace_qemu_mutex_unlock(void * mutex, const char * file, const int line)
{
    if (trace_event_get_state(TRACE_QEMU_MUTEX_UNLOCK) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 82 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_mutex_unlock " "released mutex %p (%s:%d)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , mutex, file, line);
#line 1837 "trace/trace-util.h"
        } else {
#line 82 "../util/trace-events"
            qemu_log("qemu_mutex_unlock " "released mutex %p (%s:%d)" "\n", mutex, file, line);
#line 1841 "trace/trace-util.h"
        }
    }
}

static inline void trace_qemu_mutex_unlock(void * mutex, const char * file, const int line)
{
    if (true) {
        _nocheck__trace_qemu_mutex_unlock(mutex, file, line);
    }
}

#define TRACE_QEMU_VFIO_DMA_RESET_TEMPORARY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_VFIO_DMA_RESET_TEMPORARY) || \
    false)

static inline void _nocheck__trace_qemu_vfio_dma_reset_temporary(void * s)
{
    if (trace_event_get_state(TRACE_QEMU_VFIO_DMA_RESET_TEMPORARY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 85 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_vfio_dma_reset_temporary " "s %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s);
#line 1868 "trace/trace-util.h"
        } else {
#line 85 "../util/trace-events"
            qemu_log("qemu_vfio_dma_reset_temporary " "s %p" "\n", s);
#line 1872 "trace/trace-util.h"
        }
    }
}

static inline void trace_qemu_vfio_dma_reset_temporary(void * s)
{
    if (true) {
        _nocheck__trace_qemu_vfio_dma_reset_temporary(s);
    }
}

#define TRACE_QEMU_VFIO_RAM_BLOCK_ADDED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_VFIO_RAM_BLOCK_ADDED) || \
    false)

static inline void _nocheck__trace_qemu_vfio_ram_block_added(void * s, void * p, size_t size)
{
    if (trace_event_get_state(TRACE_QEMU_VFIO_RAM_BLOCK_ADDED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 86 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_vfio_ram_block_added " "s %p host %p size 0x%zx" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, p, size);
#line 1899 "trace/trace-util.h"
        } else {
#line 86 "../util/trace-events"
            qemu_log("qemu_vfio_ram_block_added " "s %p host %p size 0x%zx" "\n", s, p, size);
#line 1903 "trace/trace-util.h"
        }
    }
}

static inline void trace_qemu_vfio_ram_block_added(void * s, void * p, size_t size)
{
    if (true) {
        _nocheck__trace_qemu_vfio_ram_block_added(s, p, size);
    }
}

#define TRACE_QEMU_VFIO_RAM_BLOCK_REMOVED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_VFIO_RAM_BLOCK_REMOVED) || \
    false)

static inline void _nocheck__trace_qemu_vfio_ram_block_removed(void * s, void * p, size_t size)
{
    if (trace_event_get_state(TRACE_QEMU_VFIO_RAM_BLOCK_REMOVED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 87 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_vfio_ram_block_removed " "s %p host %p size 0x%zx" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, p, size);
#line 1930 "trace/trace-util.h"
        } else {
#line 87 "../util/trace-events"
            qemu_log("qemu_vfio_ram_block_removed " "s %p host %p size 0x%zx" "\n", s, p, size);
#line 1934 "trace/trace-util.h"
        }
    }
}

static inline void trace_qemu_vfio_ram_block_removed(void * s, void * p, size_t size)
{
    if (true) {
        _nocheck__trace_qemu_vfio_ram_block_removed(s, p, size);
    }
}

#define TRACE_QEMU_VFIO_DUMP_MAPPING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_VFIO_DUMP_MAPPING) || \
    false)

static inline void _nocheck__trace_qemu_vfio_dump_mapping(void * host, uint64_t iova, size_t size)
{
    if (trace_event_get_state(TRACE_QEMU_VFIO_DUMP_MAPPING) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 88 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_vfio_dump_mapping " "vfio mapping %p to iova 0x%08" PRIx64 " size 0x%zx" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , host, iova, size);
#line 1961 "trace/trace-util.h"
        } else {
#line 88 "../util/trace-events"
            qemu_log("qemu_vfio_dump_mapping " "vfio mapping %p to iova 0x%08" PRIx64 " size 0x%zx" "\n", host, iova, size);
#line 1965 "trace/trace-util.h"
        }
    }
}

static inline void trace_qemu_vfio_dump_mapping(void * host, uint64_t iova, size_t size)
{
    if (true) {
        _nocheck__trace_qemu_vfio_dump_mapping(host, iova, size);
    }
}

#define TRACE_QEMU_VFIO_FIND_MAPPING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_VFIO_FIND_MAPPING) || \
    false)

static inline void _nocheck__trace_qemu_vfio_find_mapping(void * s, void * p)
{
    if (trace_event_get_state(TRACE_QEMU_VFIO_FIND_MAPPING) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 89 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_vfio_find_mapping " "s %p host %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, p);
#line 1992 "trace/trace-util.h"
        } else {
#line 89 "../util/trace-events"
            qemu_log("qemu_vfio_find_mapping " "s %p host %p" "\n", s, p);
#line 1996 "trace/trace-util.h"
        }
    }
}

static inline void trace_qemu_vfio_find_mapping(void * s, void * p)
{
    if (true) {
        _nocheck__trace_qemu_vfio_find_mapping(s, p);
    }
}

#define TRACE_QEMU_VFIO_NEW_MAPPING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_VFIO_NEW_MAPPING) || \
    false)

static inline void _nocheck__trace_qemu_vfio_new_mapping(void * s, void * host, size_t size, int index, uint64_t iova)
{
    if (trace_event_get_state(TRACE_QEMU_VFIO_NEW_MAPPING) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 90 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_vfio_new_mapping " "s %p host %p size 0x%zx index %d iova 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, host, size, index, iova);
#line 2023 "trace/trace-util.h"
        } else {
#line 90 "../util/trace-events"
            qemu_log("qemu_vfio_new_mapping " "s %p host %p size 0x%zx index %d iova 0x%"PRIx64 "\n", s, host, size, index, iova);
#line 2027 "trace/trace-util.h"
        }
    }
}

static inline void trace_qemu_vfio_new_mapping(void * s, void * host, size_t size, int index, uint64_t iova)
{
    if (true) {
        _nocheck__trace_qemu_vfio_new_mapping(s, host, size, index, iova);
    }
}

#define TRACE_QEMU_VFIO_DO_MAPPING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_VFIO_DO_MAPPING) || \
    false)

static inline void _nocheck__trace_qemu_vfio_do_mapping(void * s, void * host, uint64_t iova, size_t size)
{
    if (trace_event_get_state(TRACE_QEMU_VFIO_DO_MAPPING) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 91 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_vfio_do_mapping " "s %p host %p <-> iova 0x%"PRIx64 " size 0x%zx" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, host, iova, size);
#line 2054 "trace/trace-util.h"
        } else {
#line 91 "../util/trace-events"
            qemu_log("qemu_vfio_do_mapping " "s %p host %p <-> iova 0x%"PRIx64 " size 0x%zx" "\n", s, host, iova, size);
#line 2058 "trace/trace-util.h"
        }
    }
}

static inline void trace_qemu_vfio_do_mapping(void * s, void * host, uint64_t iova, size_t size)
{
    if (true) {
        _nocheck__trace_qemu_vfio_do_mapping(s, host, iova, size);
    }
}

#define TRACE_QEMU_VFIO_DMA_MAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_VFIO_DMA_MAP) || \
    false)

static inline void _nocheck__trace_qemu_vfio_dma_map(void * s, void * host, size_t size, bool temporary, uint64_t * iova)
{
    if (trace_event_get_state(TRACE_QEMU_VFIO_DMA_MAP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 92 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_vfio_dma_map " "s %p host %p size 0x%zx temporary %d &iova %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, host, size, temporary, iova);
#line 2085 "trace/trace-util.h"
        } else {
#line 92 "../util/trace-events"
            qemu_log("qemu_vfio_dma_map " "s %p host %p size 0x%zx temporary %d &iova %p" "\n", s, host, size, temporary, iova);
#line 2089 "trace/trace-util.h"
        }
    }
}

static inline void trace_qemu_vfio_dma_map(void * s, void * host, size_t size, bool temporary, uint64_t * iova)
{
    if (true) {
        _nocheck__trace_qemu_vfio_dma_map(s, host, size, temporary, iova);
    }
}

#define TRACE_QEMU_VFIO_DMA_MAPPED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_VFIO_DMA_MAPPED) || \
    false)

static inline void _nocheck__trace_qemu_vfio_dma_mapped(void * s, void * host, uint64_t iova, size_t size)
{
    if (trace_event_get_state(TRACE_QEMU_VFIO_DMA_MAPPED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 93 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_vfio_dma_mapped " "s %p host %p <-> iova 0x%"PRIx64" size 0x%zx" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, host, iova, size);
#line 2116 "trace/trace-util.h"
        } else {
#line 93 "../util/trace-events"
            qemu_log("qemu_vfio_dma_mapped " "s %p host %p <-> iova 0x%"PRIx64" size 0x%zx" "\n", s, host, iova, size);
#line 2120 "trace/trace-util.h"
        }
    }
}

static inline void trace_qemu_vfio_dma_mapped(void * s, void * host, uint64_t iova, size_t size)
{
    if (true) {
        _nocheck__trace_qemu_vfio_dma_mapped(s, host, iova, size);
    }
}

#define TRACE_QEMU_VFIO_DMA_UNMAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_VFIO_DMA_UNMAP) || \
    false)

static inline void _nocheck__trace_qemu_vfio_dma_unmap(void * s, void * host)
{
    if (trace_event_get_state(TRACE_QEMU_VFIO_DMA_UNMAP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 94 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_vfio_dma_unmap " "s %p host %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, host);
#line 2147 "trace/trace-util.h"
        } else {
#line 94 "../util/trace-events"
            qemu_log("qemu_vfio_dma_unmap " "s %p host %p" "\n", s, host);
#line 2151 "trace/trace-util.h"
        }
    }
}

static inline void trace_qemu_vfio_dma_unmap(void * s, void * host)
{
    if (true) {
        _nocheck__trace_qemu_vfio_dma_unmap(s, host);
    }
}

#define TRACE_QEMU_VFIO_PCI_READ_CONFIG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_VFIO_PCI_READ_CONFIG) || \
    false)

static inline void _nocheck__trace_qemu_vfio_pci_read_config(void * buf, int ofs, int size, uint64_t region_ofs, uint64_t region_size)
{
    if (trace_event_get_state(TRACE_QEMU_VFIO_PCI_READ_CONFIG) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 95 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_vfio_pci_read_config " "read cfg ptr %p ofs 0x%x size 0x%x (region addr 0x%"PRIx64" size 0x%"PRIx64")" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , buf, ofs, size, region_ofs, region_size);
#line 2178 "trace/trace-util.h"
        } else {
#line 95 "../util/trace-events"
            qemu_log("qemu_vfio_pci_read_config " "read cfg ptr %p ofs 0x%x size 0x%x (region addr 0x%"PRIx64" size 0x%"PRIx64")" "\n", buf, ofs, size, region_ofs, region_size);
#line 2182 "trace/trace-util.h"
        }
    }
}

static inline void trace_qemu_vfio_pci_read_config(void * buf, int ofs, int size, uint64_t region_ofs, uint64_t region_size)
{
    if (true) {
        _nocheck__trace_qemu_vfio_pci_read_config(buf, ofs, size, region_ofs, region_size);
    }
}

#define TRACE_QEMU_VFIO_PCI_WRITE_CONFIG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_VFIO_PCI_WRITE_CONFIG) || \
    false)

static inline void _nocheck__trace_qemu_vfio_pci_write_config(void * buf, int ofs, int size, uint64_t region_ofs, uint64_t region_size)
{
    if (trace_event_get_state(TRACE_QEMU_VFIO_PCI_WRITE_CONFIG) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 96 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_vfio_pci_write_config " "write cfg ptr %p ofs 0x%x size 0x%x (region addr 0x%"PRIx64" size 0x%"PRIx64")" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , buf, ofs, size, region_ofs, region_size);
#line 2209 "trace/trace-util.h"
        } else {
#line 96 "../util/trace-events"
            qemu_log("qemu_vfio_pci_write_config " "write cfg ptr %p ofs 0x%x size 0x%x (region addr 0x%"PRIx64" size 0x%"PRIx64")" "\n", buf, ofs, size, region_ofs, region_size);
#line 2213 "trace/trace-util.h"
        }
    }
}

static inline void trace_qemu_vfio_pci_write_config(void * buf, int ofs, int size, uint64_t region_ofs, uint64_t region_size)
{
    if (true) {
        _nocheck__trace_qemu_vfio_pci_write_config(buf, ofs, size, region_ofs, region_size);
    }
}

#define TRACE_QEMU_VFIO_REGION_INFO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_VFIO_REGION_INFO) || \
    false)

static inline void _nocheck__trace_qemu_vfio_region_info(const char * desc, uint64_t region_ofs, uint64_t region_size, uint32_t cap_offset)
{
    if (trace_event_get_state(TRACE_QEMU_VFIO_REGION_INFO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 97 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_vfio_region_info " "region '%s' addr 0x%"PRIx64" size 0x%"PRIx64" cap_ofs 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , desc, region_ofs, region_size, cap_offset);
#line 2240 "trace/trace-util.h"
        } else {
#line 97 "../util/trace-events"
            qemu_log("qemu_vfio_region_info " "region '%s' addr 0x%"PRIx64" size 0x%"PRIx64" cap_ofs 0x%"PRIx32 "\n", desc, region_ofs, region_size, cap_offset);
#line 2244 "trace/trace-util.h"
        }
    }
}

static inline void trace_qemu_vfio_region_info(const char * desc, uint64_t region_ofs, uint64_t region_size, uint32_t cap_offset)
{
    if (true) {
        _nocheck__trace_qemu_vfio_region_info(desc, region_ofs, region_size, cap_offset);
    }
}

#define TRACE_QEMU_VFIO_PCI_MAP_BAR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_VFIO_PCI_MAP_BAR) || \
    false)

static inline void _nocheck__trace_qemu_vfio_pci_map_bar(int index, uint64_t region_ofs, uint64_t region_size, int ofs, void * host)
{
    if (trace_event_get_state(TRACE_QEMU_VFIO_PCI_MAP_BAR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 98 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_vfio_pci_map_bar " "map region bar#%d addr 0x%"PRIx64" size 0x%"PRIx64" ofs 0x%x host %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index, region_ofs, region_size, ofs, host);
#line 2271 "trace/trace-util.h"
        } else {
#line 98 "../util/trace-events"
            qemu_log("qemu_vfio_pci_map_bar " "map region bar#%d addr 0x%"PRIx64" size 0x%"PRIx64" ofs 0x%x host %p" "\n", index, region_ofs, region_size, ofs, host);
#line 2275 "trace/trace-util.h"
        }
    }
}

static inline void trace_qemu_vfio_pci_map_bar(int index, uint64_t region_ofs, uint64_t region_size, int ofs, void * host)
{
    if (true) {
        _nocheck__trace_qemu_vfio_pci_map_bar(index, region_ofs, region_size, ofs, host);
    }
}

#define TRACE_UFFD_DETECT_OPEN_MODE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFFD_DETECT_OPEN_MODE) || \
    false)

static inline void _nocheck__trace_uffd_detect_open_mode(int mode)
{
    if (trace_event_get_state(TRACE_UFFD_DETECT_OPEN_MODE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 101 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:uffd_detect_open_mode " "%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , mode);
#line 2302 "trace/trace-util.h"
        } else {
#line 101 "../util/trace-events"
            qemu_log("uffd_detect_open_mode " "%d" "\n", mode);
#line 2306 "trace/trace-util.h"
        }
    }
}

static inline void trace_uffd_detect_open_mode(int mode)
{
    if (true) {
        _nocheck__trace_uffd_detect_open_mode(mode);
    }
}

#define TRACE_UFFD_QUERY_FEATURES_NOSYS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFFD_QUERY_FEATURES_NOSYS) || \
    false)

static inline void _nocheck__trace_uffd_query_features_nosys(int err)
{
    if (trace_event_get_state(TRACE_UFFD_QUERY_FEATURES_NOSYS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 102 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:uffd_query_features_nosys " "errno: %i" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , err);
#line 2333 "trace/trace-util.h"
        } else {
#line 102 "../util/trace-events"
            qemu_log("uffd_query_features_nosys " "errno: %i" "\n", err);
#line 2337 "trace/trace-util.h"
        }
    }
}

static inline void trace_uffd_query_features_nosys(int err)
{
    if (true) {
        _nocheck__trace_uffd_query_features_nosys(err);
    }
}

#define TRACE_UFFD_QUERY_FEATURES_API_FAILED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFFD_QUERY_FEATURES_API_FAILED) || \
    false)

static inline void _nocheck__trace_uffd_query_features_api_failed(int err)
{
    if (trace_event_get_state(TRACE_UFFD_QUERY_FEATURES_API_FAILED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 103 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:uffd_query_features_api_failed " "errno: %i" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , err);
#line 2364 "trace/trace-util.h"
        } else {
#line 103 "../util/trace-events"
            qemu_log("uffd_query_features_api_failed " "errno: %i" "\n", err);
#line 2368 "trace/trace-util.h"
        }
    }
}

static inline void trace_uffd_query_features_api_failed(int err)
{
    if (true) {
        _nocheck__trace_uffd_query_features_api_failed(err);
    }
}

#define TRACE_UFFD_CREATE_FD_NOSYS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFFD_CREATE_FD_NOSYS) || \
    false)

static inline void _nocheck__trace_uffd_create_fd_nosys(int err)
{
    if (trace_event_get_state(TRACE_UFFD_CREATE_FD_NOSYS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 104 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:uffd_create_fd_nosys " "errno: %i" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , err);
#line 2395 "trace/trace-util.h"
        } else {
#line 104 "../util/trace-events"
            qemu_log("uffd_create_fd_nosys " "errno: %i" "\n", err);
#line 2399 "trace/trace-util.h"
        }
    }
}

static inline void trace_uffd_create_fd_nosys(int err)
{
    if (true) {
        _nocheck__trace_uffd_create_fd_nosys(err);
    }
}

#define TRACE_UFFD_CREATE_FD_API_FAILED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFFD_CREATE_FD_API_FAILED) || \
    false)

static inline void _nocheck__trace_uffd_create_fd_api_failed(int err)
{
    if (trace_event_get_state(TRACE_UFFD_CREATE_FD_API_FAILED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 105 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:uffd_create_fd_api_failed " "errno: %i" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , err);
#line 2426 "trace/trace-util.h"
        } else {
#line 105 "../util/trace-events"
            qemu_log("uffd_create_fd_api_failed " "errno: %i" "\n", err);
#line 2430 "trace/trace-util.h"
        }
    }
}

static inline void trace_uffd_create_fd_api_failed(int err)
{
    if (true) {
        _nocheck__trace_uffd_create_fd_api_failed(err);
    }
}

#define TRACE_UFFD_CREATE_FD_API_NOIOCTL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFFD_CREATE_FD_API_NOIOCTL) || \
    false)

static inline void _nocheck__trace_uffd_create_fd_api_noioctl(uint64_t ioctl_req, uint64_t ioctl_supp)
{
    if (trace_event_get_state(TRACE_UFFD_CREATE_FD_API_NOIOCTL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 106 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:uffd_create_fd_api_noioctl " "ioctl_req: 0x%" PRIx64 "ioctl_supp: 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioctl_req, ioctl_supp);
#line 2457 "trace/trace-util.h"
        } else {
#line 106 "../util/trace-events"
            qemu_log("uffd_create_fd_api_noioctl " "ioctl_req: 0x%" PRIx64 "ioctl_supp: 0x%" PRIx64 "\n", ioctl_req, ioctl_supp);
#line 2461 "trace/trace-util.h"
        }
    }
}

static inline void trace_uffd_create_fd_api_noioctl(uint64_t ioctl_req, uint64_t ioctl_supp)
{
    if (true) {
        _nocheck__trace_uffd_create_fd_api_noioctl(ioctl_req, ioctl_supp);
    }
}

#define TRACE_UFFD_REGISTER_MEMORY_FAILED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFFD_REGISTER_MEMORY_FAILED) || \
    false)

static inline void _nocheck__trace_uffd_register_memory_failed(void * addr, uint64_t length, uint64_t mode, int err)
{
    if (trace_event_get_state(TRACE_UFFD_REGISTER_MEMORY_FAILED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 107 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:uffd_register_memory_failed " "addr: %p length: %" PRIu64 " mode: 0x%" PRIx64 " errno: %i" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, length, mode, err);
#line 2488 "trace/trace-util.h"
        } else {
#line 107 "../util/trace-events"
            qemu_log("uffd_register_memory_failed " "addr: %p length: %" PRIu64 " mode: 0x%" PRIx64 " errno: %i" "\n", addr, length, mode, err);
#line 2492 "trace/trace-util.h"
        }
    }
}

static inline void trace_uffd_register_memory_failed(void * addr, uint64_t length, uint64_t mode, int err)
{
    if (true) {
        _nocheck__trace_uffd_register_memory_failed(addr, length, mode, err);
    }
}

#define TRACE_UFFD_UNREGISTER_MEMORY_FAILED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFFD_UNREGISTER_MEMORY_FAILED) || \
    false)

static inline void _nocheck__trace_uffd_unregister_memory_failed(void * addr, uint64_t length, int err)
{
    if (trace_event_get_state(TRACE_UFFD_UNREGISTER_MEMORY_FAILED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 108 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:uffd_unregister_memory_failed " "addr: %p length: %" PRIu64 " errno: %i" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, length, err);
#line 2519 "trace/trace-util.h"
        } else {
#line 108 "../util/trace-events"
            qemu_log("uffd_unregister_memory_failed " "addr: %p length: %" PRIu64 " errno: %i" "\n", addr, length, err);
#line 2523 "trace/trace-util.h"
        }
    }
}

static inline void trace_uffd_unregister_memory_failed(void * addr, uint64_t length, int err)
{
    if (true) {
        _nocheck__trace_uffd_unregister_memory_failed(addr, length, err);
    }
}

#define TRACE_MODULE_LOAD_MODULE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MODULE_LOAD_MODULE) || \
    false)

static inline void _nocheck__trace_module_load_module(const char * name)
{
    if (trace_event_get_state(TRACE_MODULE_LOAD_MODULE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 111 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:module_load_module " "file %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 2550 "trace/trace-util.h"
        } else {
#line 111 "../util/trace-events"
            qemu_log("module_load_module " "file %s" "\n", name);
#line 2554 "trace/trace-util.h"
        }
    }
}

static inline void trace_module_load_module(const char * name)
{
    if (true) {
        _nocheck__trace_module_load_module(name);
    }
}

#define TRACE_MODULE_LOOKUP_OBJECT_TYPE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MODULE_LOOKUP_OBJECT_TYPE) || \
    false)

static inline void _nocheck__trace_module_lookup_object_type(const char * name)
{
    if (trace_event_get_state(TRACE_MODULE_LOOKUP_OBJECT_TYPE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 112 "../util/trace-events"
            qemu_log("%d@%zu.%06zu:module_lookup_object_type " "name %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 2581 "trace/trace-util.h"
        } else {
#line 112 "../util/trace-events"
            qemu_log("module_lookup_object_type " "name %s" "\n", name);
#line 2585 "trace/trace-util.h"
        }
    }
}

static inline void trace_module_lookup_object_type(const char * name)
{
    if (true) {
        _nocheck__trace_module_lookup_object_type(name);
    }
}
#endif /* TRACE_UTIL_GENERATED_TRACERS_H */
