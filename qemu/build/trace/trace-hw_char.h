/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_CHAR_GENERATED_TRACERS_H
#define TRACE_HW_CHAR_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_PARALLEL_IOPORT_READ_EVENT;
extern TraceEvent _TRACE_PARALLEL_IOPORT_WRITE_EVENT;
extern TraceEvent _TRACE_SERIAL_READ_EVENT;
extern TraceEvent _TRACE_SERIAL_WRITE_EVENT;
extern TraceEvent _TRACE_SERIAL_UPDATE_PARAMETERS_EVENT;
extern TraceEvent _TRACE_VIRTIO_SERIAL_SEND_CONTROL_EVENT_EVENT;
extern TraceEvent _TRACE_VIRTIO_SERIAL_THROTTLE_PORT_EVENT;
extern TraceEvent _TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_EVENT;
extern TraceEvent _TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_PORT_EVENT;
extern TraceEvent _TRACE_VIRTIO_CONSOLE_FLUSH_BUF_EVENT;
extern TraceEvent _TRACE_VIRTIO_CONSOLE_CHR_READ_EVENT;
extern TraceEvent _TRACE_VIRTIO_CONSOLE_CHR_EVENT_EVENT;
extern TraceEvent _TRACE_GOLDFISH_TTY_READ_EVENT;
extern TraceEvent _TRACE_GOLDFISH_TTY_WRITE_EVENT;
extern TraceEvent _TRACE_GOLDFISH_TTY_CAN_RECEIVE_EVENT;
extern TraceEvent _TRACE_GOLDFISH_TTY_RECEIVE_EVENT;
extern TraceEvent _TRACE_GOLDFISH_TTY_RESET_EVENT;
extern TraceEvent _TRACE_GOLDFISH_TTY_REALIZE_EVENT;
extern TraceEvent _TRACE_GOLDFISH_TTY_UNREALIZE_EVENT;
extern TraceEvent _TRACE_GOLDFISH_TTY_INSTANCE_INIT_EVENT;
extern TraceEvent _TRACE_GRLIB_APBUART_EVENT_EVENT;
extern TraceEvent _TRACE_GRLIB_APBUART_WRITEL_UNKNOWN_EVENT;
extern TraceEvent _TRACE_GRLIB_APBUART_READL_UNKNOWN_EVENT;
extern TraceEvent _TRACE_ESCC_HARD_RESET_EVENT;
extern TraceEvent _TRACE_ESCC_SOFT_RESET_CHN_EVENT;
extern TraceEvent _TRACE_ESCC_PUT_QUEUE_EVENT;
extern TraceEvent _TRACE_ESCC_GET_QUEUE_EVENT;
extern TraceEvent _TRACE_ESCC_UPDATE_IRQ_EVENT;
extern TraceEvent _TRACE_ESCC_UPDATE_PARAMETERS_EVENT;
extern TraceEvent _TRACE_ESCC_MEM_WRITEB_CTRL_EVENT;
extern TraceEvent _TRACE_ESCC_MEM_WRITEB_DATA_EVENT;
extern TraceEvent _TRACE_ESCC_MEM_READB_CTRL_EVENT;
extern TraceEvent _TRACE_ESCC_MEM_READB_DATA_EVENT;
extern TraceEvent _TRACE_ESCC_SERIAL_RECEIVE_BYTE_EVENT;
extern TraceEvent _TRACE_ESCC_SUNKBD_EVENT_IN_EVENT;
extern TraceEvent _TRACE_ESCC_SUNKBD_EVENT_OUT_EVENT;
extern TraceEvent _TRACE_ESCC_KBD_COMMAND_EVENT;
extern TraceEvent _TRACE_ESCC_SUNMOUSE_EVENT_EVENT;
extern TraceEvent _TRACE_PL011_IRQ_STATE_EVENT;
extern TraceEvent _TRACE_PL011_READ_EVENT;
extern TraceEvent _TRACE_PL011_READ_FIFO_EVENT;
extern TraceEvent _TRACE_PL011_WRITE_EVENT;
extern TraceEvent _TRACE_PL011_CAN_RECEIVE_EVENT;
extern TraceEvent _TRACE_PL011_PUT_FIFO_EVENT;
extern TraceEvent _TRACE_PL011_PUT_FIFO_FULL_EVENT;
extern TraceEvent _TRACE_PL011_BAUDRATE_CHANGE_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_UART_READ_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_UART_WRITE_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_UART_RESET_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_UART_RECEIVE_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_UART_TX_PENDING_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_UART_TX_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_UART_SET_PARAMS_EVENT;
extern TraceEvent _TRACE_NRF51_UART_READ_EVENT;
extern TraceEvent _TRACE_NRF51_UART_WRITE_EVENT;
extern TraceEvent _TRACE_SHAKTI_UART_READ_EVENT;
extern TraceEvent _TRACE_SHAKTI_UART_WRITE_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_DMABUSY_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_DMAREADY_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_IRQ_RAISED_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_IRQ_LOWERED_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_UPDATE_PARAMS_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_WRITE_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_READ_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_RX_FIFO_RESET_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_TX_FIFO_RESET_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_TX_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_INTCLR_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_RO_WRITE_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_RX_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_RX_ERROR_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_WO_READ_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_RXSIZE_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_CHANNEL_ERROR_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_RX_TIMEOUT_EVENT;
extern TraceEvent _TRACE_CADENCE_UART_BAUDRATE_EVENT;
extern TraceEvent _TRACE_SH_SERIAL_READ_EVENT;
extern TraceEvent _TRACE_SH_SERIAL_WRITE_EVENT;
extern TraceEvent _TRACE_STM32L4X5_USART_READ_EVENT;
extern TraceEvent _TRACE_STM32L4X5_USART_WRITE_EVENT;
extern TraceEvent _TRACE_STM32L4X5_USART_RX_EVENT;
extern TraceEvent _TRACE_STM32L4X5_USART_TX_EVENT;
extern TraceEvent _TRACE_STM32L4X5_USART_TX_PENDING_EVENT;
extern TraceEvent _TRACE_STM32L4X5_USART_IRQ_RAISED_EVENT;
extern TraceEvent _TRACE_STM32L4X5_USART_IRQ_LOWERED_EVENT;
extern TraceEvent _TRACE_STM32L4X5_USART_OVERRUN_DETECTED_EVENT;
extern TraceEvent _TRACE_STM32L4X5_USART_RECEIVER_NOT_ENABLED_EVENT;
extern TraceEvent _TRACE_STM32L4X5_USART_UPDATE_PARAMS_EVENT;
extern TraceEvent _TRACE_XEN_CONSOLE_CONNECT_EVENT;
extern TraceEvent _TRACE_XEN_CONSOLE_DISCONNECT_EVENT;
extern TraceEvent _TRACE_XEN_CONSOLE_UNREALIZE_EVENT;
extern TraceEvent _TRACE_XEN_CONSOLE_REALIZE_EVENT;
extern TraceEvent _TRACE_XEN_CONSOLE_DEVICE_CREATE_EVENT;
extern TraceEvent _TRACE_XEN_CONSOLE_DEVICE_DESTROY_EVENT;
extern uint16_t _TRACE_PARALLEL_IOPORT_READ_DSTATE;
extern uint16_t _TRACE_PARALLEL_IOPORT_WRITE_DSTATE;
extern uint16_t _TRACE_SERIAL_READ_DSTATE;
extern uint16_t _TRACE_SERIAL_WRITE_DSTATE;
extern uint16_t _TRACE_SERIAL_UPDATE_PARAMETERS_DSTATE;
extern uint16_t _TRACE_VIRTIO_SERIAL_SEND_CONTROL_EVENT_DSTATE;
extern uint16_t _TRACE_VIRTIO_SERIAL_THROTTLE_PORT_DSTATE;
extern uint16_t _TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_DSTATE;
extern uint16_t _TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_PORT_DSTATE;
extern uint16_t _TRACE_VIRTIO_CONSOLE_FLUSH_BUF_DSTATE;
extern uint16_t _TRACE_VIRTIO_CONSOLE_CHR_READ_DSTATE;
extern uint16_t _TRACE_VIRTIO_CONSOLE_CHR_EVENT_DSTATE;
extern uint16_t _TRACE_GOLDFISH_TTY_READ_DSTATE;
extern uint16_t _TRACE_GOLDFISH_TTY_WRITE_DSTATE;
extern uint16_t _TRACE_GOLDFISH_TTY_CAN_RECEIVE_DSTATE;
extern uint16_t _TRACE_GOLDFISH_TTY_RECEIVE_DSTATE;
extern uint16_t _TRACE_GOLDFISH_TTY_RESET_DSTATE;
extern uint16_t _TRACE_GOLDFISH_TTY_REALIZE_DSTATE;
extern uint16_t _TRACE_GOLDFISH_TTY_UNREALIZE_DSTATE;
extern uint16_t _TRACE_GOLDFISH_TTY_INSTANCE_INIT_DSTATE;
extern uint16_t _TRACE_GRLIB_APBUART_EVENT_DSTATE;
extern uint16_t _TRACE_GRLIB_APBUART_WRITEL_UNKNOWN_DSTATE;
extern uint16_t _TRACE_GRLIB_APBUART_READL_UNKNOWN_DSTATE;
extern uint16_t _TRACE_ESCC_HARD_RESET_DSTATE;
extern uint16_t _TRACE_ESCC_SOFT_RESET_CHN_DSTATE;
extern uint16_t _TRACE_ESCC_PUT_QUEUE_DSTATE;
extern uint16_t _TRACE_ESCC_GET_QUEUE_DSTATE;
extern uint16_t _TRACE_ESCC_UPDATE_IRQ_DSTATE;
extern uint16_t _TRACE_ESCC_UPDATE_PARAMETERS_DSTATE;
extern uint16_t _TRACE_ESCC_MEM_WRITEB_CTRL_DSTATE;
extern uint16_t _TRACE_ESCC_MEM_WRITEB_DATA_DSTATE;
extern uint16_t _TRACE_ESCC_MEM_READB_CTRL_DSTATE;
extern uint16_t _TRACE_ESCC_MEM_READB_DATA_DSTATE;
extern uint16_t _TRACE_ESCC_SERIAL_RECEIVE_BYTE_DSTATE;
extern uint16_t _TRACE_ESCC_SUNKBD_EVENT_IN_DSTATE;
extern uint16_t _TRACE_ESCC_SUNKBD_EVENT_OUT_DSTATE;
extern uint16_t _TRACE_ESCC_KBD_COMMAND_DSTATE;
extern uint16_t _TRACE_ESCC_SUNMOUSE_EVENT_DSTATE;
extern uint16_t _TRACE_PL011_IRQ_STATE_DSTATE;
extern uint16_t _TRACE_PL011_READ_DSTATE;
extern uint16_t _TRACE_PL011_READ_FIFO_DSTATE;
extern uint16_t _TRACE_PL011_WRITE_DSTATE;
extern uint16_t _TRACE_PL011_CAN_RECEIVE_DSTATE;
extern uint16_t _TRACE_PL011_PUT_FIFO_DSTATE;
extern uint16_t _TRACE_PL011_PUT_FIFO_FULL_DSTATE;
extern uint16_t _TRACE_PL011_BAUDRATE_CHANGE_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_UART_READ_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_UART_WRITE_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_UART_RESET_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_UART_RECEIVE_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_UART_TX_PENDING_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_UART_TX_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_UART_SET_PARAMS_DSTATE;
extern uint16_t _TRACE_NRF51_UART_READ_DSTATE;
extern uint16_t _TRACE_NRF51_UART_WRITE_DSTATE;
extern uint16_t _TRACE_SHAKTI_UART_READ_DSTATE;
extern uint16_t _TRACE_SHAKTI_UART_WRITE_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_DMABUSY_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_DMAREADY_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_IRQ_RAISED_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_IRQ_LOWERED_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_UPDATE_PARAMS_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_WRITE_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_READ_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_RX_FIFO_RESET_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_TX_FIFO_RESET_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_TX_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_INTCLR_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_RO_WRITE_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_RX_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_RX_ERROR_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_WO_READ_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_RXSIZE_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_CHANNEL_ERROR_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_RX_TIMEOUT_DSTATE;
extern uint16_t _TRACE_CADENCE_UART_BAUDRATE_DSTATE;
extern uint16_t _TRACE_SH_SERIAL_READ_DSTATE;
extern uint16_t _TRACE_SH_SERIAL_WRITE_DSTATE;
extern uint16_t _TRACE_STM32L4X5_USART_READ_DSTATE;
extern uint16_t _TRACE_STM32L4X5_USART_WRITE_DSTATE;
extern uint16_t _TRACE_STM32L4X5_USART_RX_DSTATE;
extern uint16_t _TRACE_STM32L4X5_USART_TX_DSTATE;
extern uint16_t _TRACE_STM32L4X5_USART_TX_PENDING_DSTATE;
extern uint16_t _TRACE_STM32L4X5_USART_IRQ_RAISED_DSTATE;
extern uint16_t _TRACE_STM32L4X5_USART_IRQ_LOWERED_DSTATE;
extern uint16_t _TRACE_STM32L4X5_USART_OVERRUN_DETECTED_DSTATE;
extern uint16_t _TRACE_STM32L4X5_USART_RECEIVER_NOT_ENABLED_DSTATE;
extern uint16_t _TRACE_STM32L4X5_USART_UPDATE_PARAMS_DSTATE;
extern uint16_t _TRACE_XEN_CONSOLE_CONNECT_DSTATE;
extern uint16_t _TRACE_XEN_CONSOLE_DISCONNECT_DSTATE;
extern uint16_t _TRACE_XEN_CONSOLE_UNREALIZE_DSTATE;
extern uint16_t _TRACE_XEN_CONSOLE_REALIZE_DSTATE;
extern uint16_t _TRACE_XEN_CONSOLE_DEVICE_CREATE_DSTATE;
extern uint16_t _TRACE_XEN_CONSOLE_DEVICE_DESTROY_DSTATE;
#define TRACE_PARALLEL_IOPORT_READ_ENABLED 1
#define TRACE_PARALLEL_IOPORT_WRITE_ENABLED 1
#define TRACE_SERIAL_READ_ENABLED 1
#define TRACE_SERIAL_WRITE_ENABLED 1
#define TRACE_SERIAL_UPDATE_PARAMETERS_ENABLED 1
#define TRACE_VIRTIO_SERIAL_SEND_CONTROL_EVENT_ENABLED 1
#define TRACE_VIRTIO_SERIAL_THROTTLE_PORT_ENABLED 1
#define TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_ENABLED 1
#define TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_PORT_ENABLED 1
#define TRACE_VIRTIO_CONSOLE_FLUSH_BUF_ENABLED 1
#define TRACE_VIRTIO_CONSOLE_CHR_READ_ENABLED 1
#define TRACE_VIRTIO_CONSOLE_CHR_EVENT_ENABLED 1
#define TRACE_GOLDFISH_TTY_READ_ENABLED 1
#define TRACE_GOLDFISH_TTY_WRITE_ENABLED 1
#define TRACE_GOLDFISH_TTY_CAN_RECEIVE_ENABLED 1
#define TRACE_GOLDFISH_TTY_RECEIVE_ENABLED 1
#define TRACE_GOLDFISH_TTY_RESET_ENABLED 1
#define TRACE_GOLDFISH_TTY_REALIZE_ENABLED 1
#define TRACE_GOLDFISH_TTY_UNREALIZE_ENABLED 1
#define TRACE_GOLDFISH_TTY_INSTANCE_INIT_ENABLED 1
#define TRACE_GRLIB_APBUART_EVENT_ENABLED 1
#define TRACE_GRLIB_APBUART_WRITEL_UNKNOWN_ENABLED 1
#define TRACE_GRLIB_APBUART_READL_UNKNOWN_ENABLED 1
#define TRACE_ESCC_HARD_RESET_ENABLED 1
#define TRACE_ESCC_SOFT_RESET_CHN_ENABLED 1
#define TRACE_ESCC_PUT_QUEUE_ENABLED 1
#define TRACE_ESCC_GET_QUEUE_ENABLED 1
#define TRACE_ESCC_UPDATE_IRQ_ENABLED 1
#define TRACE_ESCC_UPDATE_PARAMETERS_ENABLED 1
#define TRACE_ESCC_MEM_WRITEB_CTRL_ENABLED 1
#define TRACE_ESCC_MEM_WRITEB_DATA_ENABLED 1
#define TRACE_ESCC_MEM_READB_CTRL_ENABLED 1
#define TRACE_ESCC_MEM_READB_DATA_ENABLED 1
#define TRACE_ESCC_SERIAL_RECEIVE_BYTE_ENABLED 1
#define TRACE_ESCC_SUNKBD_EVENT_IN_ENABLED 1
#define TRACE_ESCC_SUNKBD_EVENT_OUT_ENABLED 1
#define TRACE_ESCC_KBD_COMMAND_ENABLED 1
#define TRACE_ESCC_SUNMOUSE_EVENT_ENABLED 1
#define TRACE_PL011_IRQ_STATE_ENABLED 1
#define TRACE_PL011_READ_ENABLED 1
#define TRACE_PL011_READ_FIFO_ENABLED 1
#define TRACE_PL011_WRITE_ENABLED 1
#define TRACE_PL011_CAN_RECEIVE_ENABLED 1
#define TRACE_PL011_PUT_FIFO_ENABLED 1
#define TRACE_PL011_PUT_FIFO_FULL_ENABLED 1
#define TRACE_PL011_BAUDRATE_CHANGE_ENABLED 1
#define TRACE_CMSDK_APB_UART_READ_ENABLED 1
#define TRACE_CMSDK_APB_UART_WRITE_ENABLED 1
#define TRACE_CMSDK_APB_UART_RESET_ENABLED 1
#define TRACE_CMSDK_APB_UART_RECEIVE_ENABLED 1
#define TRACE_CMSDK_APB_UART_TX_PENDING_ENABLED 1
#define TRACE_CMSDK_APB_UART_TX_ENABLED 1
#define TRACE_CMSDK_APB_UART_SET_PARAMS_ENABLED 1
#define TRACE_NRF51_UART_READ_ENABLED 1
#define TRACE_NRF51_UART_WRITE_ENABLED 1
#define TRACE_SHAKTI_UART_READ_ENABLED 1
#define TRACE_SHAKTI_UART_WRITE_ENABLED 1
#define TRACE_EXYNOS_UART_DMABUSY_ENABLED 1
#define TRACE_EXYNOS_UART_DMAREADY_ENABLED 1
#define TRACE_EXYNOS_UART_IRQ_RAISED_ENABLED 1
#define TRACE_EXYNOS_UART_IRQ_LOWERED_ENABLED 1
#define TRACE_EXYNOS_UART_UPDATE_PARAMS_ENABLED 1
#define TRACE_EXYNOS_UART_WRITE_ENABLED 1
#define TRACE_EXYNOS_UART_READ_ENABLED 1
#define TRACE_EXYNOS_UART_RX_FIFO_RESET_ENABLED 1
#define TRACE_EXYNOS_UART_TX_FIFO_RESET_ENABLED 1
#define TRACE_EXYNOS_UART_TX_ENABLED 1
#define TRACE_EXYNOS_UART_INTCLR_ENABLED 1
#define TRACE_EXYNOS_UART_RO_WRITE_ENABLED 1
#define TRACE_EXYNOS_UART_RX_ENABLED 1
#define TRACE_EXYNOS_UART_RX_ERROR_ENABLED 1
#define TRACE_EXYNOS_UART_WO_READ_ENABLED 1
#define TRACE_EXYNOS_UART_RXSIZE_ENABLED 1
#define TRACE_EXYNOS_UART_CHANNEL_ERROR_ENABLED 1
#define TRACE_EXYNOS_UART_RX_TIMEOUT_ENABLED 1
#define TRACE_CADENCE_UART_BAUDRATE_ENABLED 1
#define TRACE_SH_SERIAL_READ_ENABLED 1
#define TRACE_SH_SERIAL_WRITE_ENABLED 1
#define TRACE_STM32L4X5_USART_READ_ENABLED 1
#define TRACE_STM32L4X5_USART_WRITE_ENABLED 1
#define TRACE_STM32L4X5_USART_RX_ENABLED 1
#define TRACE_STM32L4X5_USART_TX_ENABLED 1
#define TRACE_STM32L4X5_USART_TX_PENDING_ENABLED 1
#define TRACE_STM32L4X5_USART_IRQ_RAISED_ENABLED 1
#define TRACE_STM32L4X5_USART_IRQ_LOWERED_ENABLED 1
#define TRACE_STM32L4X5_USART_OVERRUN_DETECTED_ENABLED 1
#define TRACE_STM32L4X5_USART_RECEIVER_NOT_ENABLED_ENABLED 1
#define TRACE_STM32L4X5_USART_UPDATE_PARAMS_ENABLED 1
#define TRACE_XEN_CONSOLE_CONNECT_ENABLED 1
#define TRACE_XEN_CONSOLE_DISCONNECT_ENABLED 1
#define TRACE_XEN_CONSOLE_UNREALIZE_ENABLED 1
#define TRACE_XEN_CONSOLE_REALIZE_ENABLED 1
#define TRACE_XEN_CONSOLE_DEVICE_CREATE_ENABLED 1
#define TRACE_XEN_CONSOLE_DEVICE_DESTROY_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_PARALLEL_IOPORT_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PARALLEL_IOPORT_READ) || \
    false)

static inline void _nocheck__trace_parallel_ioport_read(const char * desc, uint16_t addr, uint8_t value)
{
    if (trace_event_get_state(TRACE_PARALLEL_IOPORT_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 4 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:parallel_ioport_read " "read [%s] addr 0x%02x val 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , desc, addr, value);
#line 310 "trace/trace-hw_char.h"
        } else {
#line 4 "../hw/char/trace-events"
            qemu_log("parallel_ioport_read " "read [%s] addr 0x%02x val 0x%02x" "\n", desc, addr, value);
#line 314 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_parallel_ioport_read(const char * desc, uint16_t addr, uint8_t value)
{
    if (true) {
        _nocheck__trace_parallel_ioport_read(desc, addr, value);
    }
}

#define TRACE_PARALLEL_IOPORT_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PARALLEL_IOPORT_WRITE) || \
    false)

static inline void _nocheck__trace_parallel_ioport_write(const char * desc, uint16_t addr, uint8_t value)
{
    if (trace_event_get_state(TRACE_PARALLEL_IOPORT_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 5 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:parallel_ioport_write " "write [%s] addr 0x%02x val 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , desc, addr, value);
#line 341 "trace/trace-hw_char.h"
        } else {
#line 5 "../hw/char/trace-events"
            qemu_log("parallel_ioport_write " "write [%s] addr 0x%02x val 0x%02x" "\n", desc, addr, value);
#line 345 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_parallel_ioport_write(const char * desc, uint16_t addr, uint8_t value)
{
    if (true) {
        _nocheck__trace_parallel_ioport_write(desc, addr, value);
    }
}

#define TRACE_SERIAL_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SERIAL_READ) || \
    false)

static inline void _nocheck__trace_serial_read(uint16_t addr, uint8_t value)
{
    if (trace_event_get_state(TRACE_SERIAL_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 8 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:serial_read " "read addr 0x%02x val 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value);
#line 372 "trace/trace-hw_char.h"
        } else {
#line 8 "../hw/char/trace-events"
            qemu_log("serial_read " "read addr 0x%02x val 0x%02x" "\n", addr, value);
#line 376 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_serial_read(uint16_t addr, uint8_t value)
{
    if (true) {
        _nocheck__trace_serial_read(addr, value);
    }
}

#define TRACE_SERIAL_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SERIAL_WRITE) || \
    false)

static inline void _nocheck__trace_serial_write(uint16_t addr, uint8_t value)
{
    if (trace_event_get_state(TRACE_SERIAL_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 9 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:serial_write " "write addr 0x%02x val 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value);
#line 403 "trace/trace-hw_char.h"
        } else {
#line 9 "../hw/char/trace-events"
            qemu_log("serial_write " "write addr 0x%02x val 0x%02x" "\n", addr, value);
#line 407 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_serial_write(uint16_t addr, uint8_t value)
{
    if (true) {
        _nocheck__trace_serial_write(addr, value);
    }
}

#define TRACE_SERIAL_UPDATE_PARAMETERS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SERIAL_UPDATE_PARAMETERS) || \
    false)

static inline void _nocheck__trace_serial_update_parameters(uint64_t baudrate, char parity, int data_bits, int stop_bits)
{
    if (trace_event_get_state(TRACE_SERIAL_UPDATE_PARAMETERS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 10 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:serial_update_parameters " "baudrate=%"PRIu64" parity='%c' data=%d stop=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , baudrate, parity, data_bits, stop_bits);
#line 434 "trace/trace-hw_char.h"
        } else {
#line 10 "../hw/char/trace-events"
            qemu_log("serial_update_parameters " "baudrate=%"PRIu64" parity='%c' data=%d stop=%d" "\n", baudrate, parity, data_bits, stop_bits);
#line 438 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_serial_update_parameters(uint64_t baudrate, char parity, int data_bits, int stop_bits)
{
    if (true) {
        _nocheck__trace_serial_update_parameters(baudrate, parity, data_bits, stop_bits);
    }
}

#define TRACE_VIRTIO_SERIAL_SEND_CONTROL_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_SERIAL_SEND_CONTROL_EVENT) || \
    false)

static inline void _nocheck__trace_virtio_serial_send_control_event(unsigned int port, uint16_t event, uint16_t value)
{
    if (trace_event_get_state(TRACE_VIRTIO_SERIAL_SEND_CONTROL_EVENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 13 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_serial_send_control_event " "port %u, event %u, value %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , port, event, value);
#line 465 "trace/trace-hw_char.h"
        } else {
#line 13 "../hw/char/trace-events"
            qemu_log("virtio_serial_send_control_event " "port %u, event %u, value %u" "\n", port, event, value);
#line 469 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_virtio_serial_send_control_event(unsigned int port, uint16_t event, uint16_t value)
{
    if (true) {
        _nocheck__trace_virtio_serial_send_control_event(port, event, value);
    }
}

#define TRACE_VIRTIO_SERIAL_THROTTLE_PORT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_SERIAL_THROTTLE_PORT) || \
    false)

static inline void _nocheck__trace_virtio_serial_throttle_port(unsigned int port, bool throttle)
{
    if (trace_event_get_state(TRACE_VIRTIO_SERIAL_THROTTLE_PORT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 14 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_serial_throttle_port " "port %u, throttle %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , port, throttle);
#line 496 "trace/trace-hw_char.h"
        } else {
#line 14 "../hw/char/trace-events"
            qemu_log("virtio_serial_throttle_port " "port %u, throttle %d" "\n", port, throttle);
#line 500 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_virtio_serial_throttle_port(unsigned int port, bool throttle)
{
    if (true) {
        _nocheck__trace_virtio_serial_throttle_port(port, throttle);
    }
}

#define TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE) || \
    false)

static inline void _nocheck__trace_virtio_serial_handle_control_message(uint16_t event, uint16_t value)
{
    if (trace_event_get_state(TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 15 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_serial_handle_control_message " "event %u, value %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , event, value);
#line 527 "trace/trace-hw_char.h"
        } else {
#line 15 "../hw/char/trace-events"
            qemu_log("virtio_serial_handle_control_message " "event %u, value %u" "\n", event, value);
#line 531 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_virtio_serial_handle_control_message(uint16_t event, uint16_t value)
{
    if (true) {
        _nocheck__trace_virtio_serial_handle_control_message(event, value);
    }
}

#define TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_PORT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_PORT) || \
    false)

static inline void _nocheck__trace_virtio_serial_handle_control_message_port(unsigned int port)
{
    if (trace_event_get_state(TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_PORT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 16 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_serial_handle_control_message_port " "port %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , port);
#line 558 "trace/trace-hw_char.h"
        } else {
#line 16 "../hw/char/trace-events"
            qemu_log("virtio_serial_handle_control_message_port " "port %u" "\n", port);
#line 562 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_virtio_serial_handle_control_message_port(unsigned int port)
{
    if (true) {
        _nocheck__trace_virtio_serial_handle_control_message_port(port);
    }
}

#define TRACE_VIRTIO_CONSOLE_FLUSH_BUF_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_CONSOLE_FLUSH_BUF) || \
    false)

static inline void _nocheck__trace_virtio_console_flush_buf(unsigned int port, size_t len, ssize_t ret)
{
    if (trace_event_get_state(TRACE_VIRTIO_CONSOLE_FLUSH_BUF) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 19 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_console_flush_buf " "port %u, in_len %zu, out_len %zd" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , port, len, ret);
#line 589 "trace/trace-hw_char.h"
        } else {
#line 19 "../hw/char/trace-events"
            qemu_log("virtio_console_flush_buf " "port %u, in_len %zu, out_len %zd" "\n", port, len, ret);
#line 593 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_virtio_console_flush_buf(unsigned int port, size_t len, ssize_t ret)
{
    if (true) {
        _nocheck__trace_virtio_console_flush_buf(port, len, ret);
    }
}

#define TRACE_VIRTIO_CONSOLE_CHR_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_CONSOLE_CHR_READ) || \
    false)

static inline void _nocheck__trace_virtio_console_chr_read(unsigned int port, int size)
{
    if (trace_event_get_state(TRACE_VIRTIO_CONSOLE_CHR_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 20 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_console_chr_read " "port %u, size %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , port, size);
#line 620 "trace/trace-hw_char.h"
        } else {
#line 20 "../hw/char/trace-events"
            qemu_log("virtio_console_chr_read " "port %u, size %d" "\n", port, size);
#line 624 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_virtio_console_chr_read(unsigned int port, int size)
{
    if (true) {
        _nocheck__trace_virtio_console_chr_read(port, size);
    }
}

#define TRACE_VIRTIO_CONSOLE_CHR_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_CONSOLE_CHR_EVENT) || \
    false)

static inline void _nocheck__trace_virtio_console_chr_event(unsigned int port, int event)
{
    if (trace_event_get_state(TRACE_VIRTIO_CONSOLE_CHR_EVENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 21 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_console_chr_event " "port %u, event %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , port, event);
#line 651 "trace/trace-hw_char.h"
        } else {
#line 21 "../hw/char/trace-events"
            qemu_log("virtio_console_chr_event " "port %u, event %d" "\n", port, event);
#line 655 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_virtio_console_chr_event(unsigned int port, int event)
{
    if (true) {
        _nocheck__trace_virtio_console_chr_event(port, event);
    }
}

#define TRACE_GOLDFISH_TTY_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GOLDFISH_TTY_READ) || \
    false)

static inline void _nocheck__trace_goldfish_tty_read(void * dev, unsigned int addr, unsigned int size, uint64_t value)
{
    if (trace_event_get_state(TRACE_GOLDFISH_TTY_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 24 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:goldfish_tty_read " "tty: %p reg: 0x%02x size: %d value: 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, addr, size, value);
#line 682 "trace/trace-hw_char.h"
        } else {
#line 24 "../hw/char/trace-events"
            qemu_log("goldfish_tty_read " "tty: %p reg: 0x%02x size: %d value: 0x%"PRIx64 "\n", dev, addr, size, value);
#line 686 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_goldfish_tty_read(void * dev, unsigned int addr, unsigned int size, uint64_t value)
{
    if (true) {
        _nocheck__trace_goldfish_tty_read(dev, addr, size, value);
    }
}

#define TRACE_GOLDFISH_TTY_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GOLDFISH_TTY_WRITE) || \
    false)

static inline void _nocheck__trace_goldfish_tty_write(void * dev, unsigned int addr, unsigned int size, uint64_t value)
{
    if (trace_event_get_state(TRACE_GOLDFISH_TTY_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 25 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:goldfish_tty_write " "tty: %p reg: 0x%02x size: %d value: 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, addr, size, value);
#line 713 "trace/trace-hw_char.h"
        } else {
#line 25 "../hw/char/trace-events"
            qemu_log("goldfish_tty_write " "tty: %p reg: 0x%02x size: %d value: 0x%"PRIx64 "\n", dev, addr, size, value);
#line 717 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_goldfish_tty_write(void * dev, unsigned int addr, unsigned int size, uint64_t value)
{
    if (true) {
        _nocheck__trace_goldfish_tty_write(dev, addr, size, value);
    }
}

#define TRACE_GOLDFISH_TTY_CAN_RECEIVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GOLDFISH_TTY_CAN_RECEIVE) || \
    false)

static inline void _nocheck__trace_goldfish_tty_can_receive(void * dev, unsigned int available)
{
    if (trace_event_get_state(TRACE_GOLDFISH_TTY_CAN_RECEIVE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 26 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:goldfish_tty_can_receive " "tty: %p available: %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, available);
#line 744 "trace/trace-hw_char.h"
        } else {
#line 26 "../hw/char/trace-events"
            qemu_log("goldfish_tty_can_receive " "tty: %p available: %u" "\n", dev, available);
#line 748 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_goldfish_tty_can_receive(void * dev, unsigned int available)
{
    if (true) {
        _nocheck__trace_goldfish_tty_can_receive(dev, available);
    }
}

#define TRACE_GOLDFISH_TTY_RECEIVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GOLDFISH_TTY_RECEIVE) || \
    false)

static inline void _nocheck__trace_goldfish_tty_receive(void * dev, unsigned int size)
{
    if (trace_event_get_state(TRACE_GOLDFISH_TTY_RECEIVE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 27 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:goldfish_tty_receive " "tty: %p size: %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, size);
#line 775 "trace/trace-hw_char.h"
        } else {
#line 27 "../hw/char/trace-events"
            qemu_log("goldfish_tty_receive " "tty: %p size: %u" "\n", dev, size);
#line 779 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_goldfish_tty_receive(void * dev, unsigned int size)
{
    if (true) {
        _nocheck__trace_goldfish_tty_receive(dev, size);
    }
}

#define TRACE_GOLDFISH_TTY_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GOLDFISH_TTY_RESET) || \
    false)

static inline void _nocheck__trace_goldfish_tty_reset(void * dev)
{
    if (trace_event_get_state(TRACE_GOLDFISH_TTY_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 28 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:goldfish_tty_reset " "tty: %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev);
#line 806 "trace/trace-hw_char.h"
        } else {
#line 28 "../hw/char/trace-events"
            qemu_log("goldfish_tty_reset " "tty: %p" "\n", dev);
#line 810 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_goldfish_tty_reset(void * dev)
{
    if (true) {
        _nocheck__trace_goldfish_tty_reset(dev);
    }
}

#define TRACE_GOLDFISH_TTY_REALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GOLDFISH_TTY_REALIZE) || \
    false)

static inline void _nocheck__trace_goldfish_tty_realize(void * dev)
{
    if (trace_event_get_state(TRACE_GOLDFISH_TTY_REALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 29 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:goldfish_tty_realize " "tty: %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev);
#line 837 "trace/trace-hw_char.h"
        } else {
#line 29 "../hw/char/trace-events"
            qemu_log("goldfish_tty_realize " "tty: %p" "\n", dev);
#line 841 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_goldfish_tty_realize(void * dev)
{
    if (true) {
        _nocheck__trace_goldfish_tty_realize(dev);
    }
}

#define TRACE_GOLDFISH_TTY_UNREALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GOLDFISH_TTY_UNREALIZE) || \
    false)

static inline void _nocheck__trace_goldfish_tty_unrealize(void * dev)
{
    if (trace_event_get_state(TRACE_GOLDFISH_TTY_UNREALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 30 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:goldfish_tty_unrealize " "tty: %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev);
#line 868 "trace/trace-hw_char.h"
        } else {
#line 30 "../hw/char/trace-events"
            qemu_log("goldfish_tty_unrealize " "tty: %p" "\n", dev);
#line 872 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_goldfish_tty_unrealize(void * dev)
{
    if (true) {
        _nocheck__trace_goldfish_tty_unrealize(dev);
    }
}

#define TRACE_GOLDFISH_TTY_INSTANCE_INIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GOLDFISH_TTY_INSTANCE_INIT) || \
    false)

static inline void _nocheck__trace_goldfish_tty_instance_init(void * dev)
{
    if (trace_event_get_state(TRACE_GOLDFISH_TTY_INSTANCE_INIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 31 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:goldfish_tty_instance_init " "tty: %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev);
#line 899 "trace/trace-hw_char.h"
        } else {
#line 31 "../hw/char/trace-events"
            qemu_log("goldfish_tty_instance_init " "tty: %p" "\n", dev);
#line 903 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_goldfish_tty_instance_init(void * dev)
{
    if (true) {
        _nocheck__trace_goldfish_tty_instance_init(dev);
    }
}

#define TRACE_GRLIB_APBUART_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GRLIB_APBUART_EVENT) || \
    false)

static inline void _nocheck__trace_grlib_apbuart_event(int event)
{
    if (trace_event_get_state(TRACE_GRLIB_APBUART_EVENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 34 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:grlib_apbuart_event " "event:%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , event);
#line 930 "trace/trace-hw_char.h"
        } else {
#line 34 "../hw/char/trace-events"
            qemu_log("grlib_apbuart_event " "event:%d" "\n", event);
#line 934 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_grlib_apbuart_event(int event)
{
    if (true) {
        _nocheck__trace_grlib_apbuart_event(event);
    }
}

#define TRACE_GRLIB_APBUART_WRITEL_UNKNOWN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GRLIB_APBUART_WRITEL_UNKNOWN) || \
    false)

static inline void _nocheck__trace_grlib_apbuart_writel_unknown(uint64_t addr, uint32_t value)
{
    if (trace_event_get_state(TRACE_GRLIB_APBUART_WRITEL_UNKNOWN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 35 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:grlib_apbuart_writel_unknown " "addr 0x%"PRIx64" value 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value);
#line 961 "trace/trace-hw_char.h"
        } else {
#line 35 "../hw/char/trace-events"
            qemu_log("grlib_apbuart_writel_unknown " "addr 0x%"PRIx64" value 0x%x" "\n", addr, value);
#line 965 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_grlib_apbuart_writel_unknown(uint64_t addr, uint32_t value)
{
    if (true) {
        _nocheck__trace_grlib_apbuart_writel_unknown(addr, value);
    }
}

#define TRACE_GRLIB_APBUART_READL_UNKNOWN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GRLIB_APBUART_READL_UNKNOWN) || \
    false)

static inline void _nocheck__trace_grlib_apbuart_readl_unknown(uint64_t addr)
{
    if (trace_event_get_state(TRACE_GRLIB_APBUART_READL_UNKNOWN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 36 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:grlib_apbuart_readl_unknown " "addr 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 992 "trace/trace-hw_char.h"
        } else {
#line 36 "../hw/char/trace-events"
            qemu_log("grlib_apbuart_readl_unknown " "addr 0x%"PRIx64 "\n", addr);
#line 996 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_grlib_apbuart_readl_unknown(uint64_t addr)
{
    if (true) {
        _nocheck__trace_grlib_apbuart_readl_unknown(addr);
    }
}

#define TRACE_ESCC_HARD_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_HARD_RESET) || \
    false)

static inline void _nocheck__trace_escc_hard_reset(void)
{
    if (trace_event_get_state(TRACE_ESCC_HARD_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 39 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_hard_reset " "hard reset" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1023 "trace/trace-hw_char.h"
        } else {
#line 39 "../hw/char/trace-events"
            qemu_log("escc_hard_reset " "hard reset" "\n");
#line 1027 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_hard_reset(void)
{
    if (true) {
        _nocheck__trace_escc_hard_reset();
    }
}

#define TRACE_ESCC_SOFT_RESET_CHN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_SOFT_RESET_CHN) || \
    false)

static inline void _nocheck__trace_escc_soft_reset_chn(char channel)
{
    if (trace_event_get_state(TRACE_ESCC_SOFT_RESET_CHN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 40 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_soft_reset_chn " "soft reset channel %c" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel);
#line 1054 "trace/trace-hw_char.h"
        } else {
#line 40 "../hw/char/trace-events"
            qemu_log("escc_soft_reset_chn " "soft reset channel %c" "\n", channel);
#line 1058 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_soft_reset_chn(char channel)
{
    if (true) {
        _nocheck__trace_escc_soft_reset_chn(channel);
    }
}

#define TRACE_ESCC_PUT_QUEUE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_PUT_QUEUE) || \
    false)

static inline void _nocheck__trace_escc_put_queue(char channel, int b)
{
    if (trace_event_get_state(TRACE_ESCC_PUT_QUEUE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 41 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_put_queue " "channel %c put: 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, b);
#line 1085 "trace/trace-hw_char.h"
        } else {
#line 41 "../hw/char/trace-events"
            qemu_log("escc_put_queue " "channel %c put: 0x%02x" "\n", channel, b);
#line 1089 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_put_queue(char channel, int b)
{
    if (true) {
        _nocheck__trace_escc_put_queue(channel, b);
    }
}

#define TRACE_ESCC_GET_QUEUE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_GET_QUEUE) || \
    false)

static inline void _nocheck__trace_escc_get_queue(char channel, int val)
{
    if (trace_event_get_state(TRACE_ESCC_GET_QUEUE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 42 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_get_queue " "channel %c get 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, val);
#line 1116 "trace/trace-hw_char.h"
        } else {
#line 42 "../hw/char/trace-events"
            qemu_log("escc_get_queue " "channel %c get 0x%02x" "\n", channel, val);
#line 1120 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_get_queue(char channel, int val)
{
    if (true) {
        _nocheck__trace_escc_get_queue(channel, val);
    }
}

#define TRACE_ESCC_UPDATE_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_UPDATE_IRQ) || \
    false)

static inline void _nocheck__trace_escc_update_irq(int irq)
{
    if (trace_event_get_state(TRACE_ESCC_UPDATE_IRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 43 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_update_irq " "IRQ = %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , irq);
#line 1147 "trace/trace-hw_char.h"
        } else {
#line 43 "../hw/char/trace-events"
            qemu_log("escc_update_irq " "IRQ = %d" "\n", irq);
#line 1151 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_update_irq(int irq)
{
    if (true) {
        _nocheck__trace_escc_update_irq(irq);
    }
}

#define TRACE_ESCC_UPDATE_PARAMETERS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_UPDATE_PARAMETERS) || \
    false)

static inline void _nocheck__trace_escc_update_parameters(char channel, int speed, int parity, int data_bits, int stop_bits)
{
    if (trace_event_get_state(TRACE_ESCC_UPDATE_PARAMETERS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 44 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_update_parameters " "channel %c: speed=%d parity=%c data=%d stop=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, speed, parity, data_bits, stop_bits);
#line 1178 "trace/trace-hw_char.h"
        } else {
#line 44 "../hw/char/trace-events"
            qemu_log("escc_update_parameters " "channel %c: speed=%d parity=%c data=%d stop=%d" "\n", channel, speed, parity, data_bits, stop_bits);
#line 1182 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_update_parameters(char channel, int speed, int parity, int data_bits, int stop_bits)
{
    if (true) {
        _nocheck__trace_escc_update_parameters(channel, speed, parity, data_bits, stop_bits);
    }
}

#define TRACE_ESCC_MEM_WRITEB_CTRL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_MEM_WRITEB_CTRL) || \
    false)

static inline void _nocheck__trace_escc_mem_writeb_ctrl(char channel, uint32_t reg, uint32_t val)
{
    if (trace_event_get_state(TRACE_ESCC_MEM_WRITEB_CTRL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 45 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_mem_writeb_ctrl " "Write channel %c, reg[%d] = 0x%2.2x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, reg, val);
#line 1209 "trace/trace-hw_char.h"
        } else {
#line 45 "../hw/char/trace-events"
            qemu_log("escc_mem_writeb_ctrl " "Write channel %c, reg[%d] = 0x%2.2x" "\n", channel, reg, val);
#line 1213 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_mem_writeb_ctrl(char channel, uint32_t reg, uint32_t val)
{
    if (true) {
        _nocheck__trace_escc_mem_writeb_ctrl(channel, reg, val);
    }
}

#define TRACE_ESCC_MEM_WRITEB_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_MEM_WRITEB_DATA) || \
    false)

static inline void _nocheck__trace_escc_mem_writeb_data(char channel, uint32_t val)
{
    if (trace_event_get_state(TRACE_ESCC_MEM_WRITEB_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 46 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_mem_writeb_data " "Write channel %c, ch %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, val);
#line 1240 "trace/trace-hw_char.h"
        } else {
#line 46 "../hw/char/trace-events"
            qemu_log("escc_mem_writeb_data " "Write channel %c, ch %d" "\n", channel, val);
#line 1244 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_mem_writeb_data(char channel, uint32_t val)
{
    if (true) {
        _nocheck__trace_escc_mem_writeb_data(channel, val);
    }
}

#define TRACE_ESCC_MEM_READB_CTRL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_MEM_READB_CTRL) || \
    false)

static inline void _nocheck__trace_escc_mem_readb_ctrl(char channel, uint32_t reg, uint8_t val)
{
    if (trace_event_get_state(TRACE_ESCC_MEM_READB_CTRL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 47 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_mem_readb_ctrl " "Read channel %c, reg[%d] = 0x%2.2x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, reg, val);
#line 1271 "trace/trace-hw_char.h"
        } else {
#line 47 "../hw/char/trace-events"
            qemu_log("escc_mem_readb_ctrl " "Read channel %c, reg[%d] = 0x%2.2x" "\n", channel, reg, val);
#line 1275 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_mem_readb_ctrl(char channel, uint32_t reg, uint8_t val)
{
    if (true) {
        _nocheck__trace_escc_mem_readb_ctrl(channel, reg, val);
    }
}

#define TRACE_ESCC_MEM_READB_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_MEM_READB_DATA) || \
    false)

static inline void _nocheck__trace_escc_mem_readb_data(char channel, uint32_t ret)
{
    if (trace_event_get_state(TRACE_ESCC_MEM_READB_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 48 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_mem_readb_data " "Read channel %c, ch %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, ret);
#line 1302 "trace/trace-hw_char.h"
        } else {
#line 48 "../hw/char/trace-events"
            qemu_log("escc_mem_readb_data " "Read channel %c, ch %d" "\n", channel, ret);
#line 1306 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_mem_readb_data(char channel, uint32_t ret)
{
    if (true) {
        _nocheck__trace_escc_mem_readb_data(channel, ret);
    }
}

#define TRACE_ESCC_SERIAL_RECEIVE_BYTE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_SERIAL_RECEIVE_BYTE) || \
    false)

static inline void _nocheck__trace_escc_serial_receive_byte(char channel, int ch)
{
    if (trace_event_get_state(TRACE_ESCC_SERIAL_RECEIVE_BYTE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 49 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_serial_receive_byte " "channel %c put ch %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, ch);
#line 1333 "trace/trace-hw_char.h"
        } else {
#line 49 "../hw/char/trace-events"
            qemu_log("escc_serial_receive_byte " "channel %c put ch %d" "\n", channel, ch);
#line 1337 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_serial_receive_byte(char channel, int ch)
{
    if (true) {
        _nocheck__trace_escc_serial_receive_byte(channel, ch);
    }
}

#define TRACE_ESCC_SUNKBD_EVENT_IN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_SUNKBD_EVENT_IN) || \
    false)

static inline void _nocheck__trace_escc_sunkbd_event_in(int ch, const char * name, int down)
{
    if (trace_event_get_state(TRACE_ESCC_SUNKBD_EVENT_IN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 50 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_sunkbd_event_in " "QKeyCode 0x%2.2x [%s], down %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ch, name, down);
#line 1364 "trace/trace-hw_char.h"
        } else {
#line 50 "../hw/char/trace-events"
            qemu_log("escc_sunkbd_event_in " "QKeyCode 0x%2.2x [%s], down %d" "\n", ch, name, down);
#line 1368 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_sunkbd_event_in(int ch, const char * name, int down)
{
    if (true) {
        _nocheck__trace_escc_sunkbd_event_in(ch, name, down);
    }
}

#define TRACE_ESCC_SUNKBD_EVENT_OUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_SUNKBD_EVENT_OUT) || \
    false)

static inline void _nocheck__trace_escc_sunkbd_event_out(int ch)
{
    if (trace_event_get_state(TRACE_ESCC_SUNKBD_EVENT_OUT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 51 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_sunkbd_event_out " "Translated keycode 0x%2.2x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ch);
#line 1395 "trace/trace-hw_char.h"
        } else {
#line 51 "../hw/char/trace-events"
            qemu_log("escc_sunkbd_event_out " "Translated keycode 0x%2.2x" "\n", ch);
#line 1399 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_sunkbd_event_out(int ch)
{
    if (true) {
        _nocheck__trace_escc_sunkbd_event_out(ch);
    }
}

#define TRACE_ESCC_KBD_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_KBD_COMMAND) || \
    false)

static inline void _nocheck__trace_escc_kbd_command(int val)
{
    if (trace_event_get_state(TRACE_ESCC_KBD_COMMAND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 52 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_kbd_command " "Command %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 1426 "trace/trace-hw_char.h"
        } else {
#line 52 "../hw/char/trace-events"
            qemu_log("escc_kbd_command " "Command %d" "\n", val);
#line 1430 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_kbd_command(int val)
{
    if (true) {
        _nocheck__trace_escc_kbd_command(val);
    }
}

#define TRACE_ESCC_SUNMOUSE_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_SUNMOUSE_EVENT) || \
    false)

static inline void _nocheck__trace_escc_sunmouse_event(int dx, int dy, int buttons_state)
{
    if (trace_event_get_state(TRACE_ESCC_SUNMOUSE_EVENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 53 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_sunmouse_event " "dx=%d dy=%d buttons=0x%01x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dx, dy, buttons_state);
#line 1457 "trace/trace-hw_char.h"
        } else {
#line 53 "../hw/char/trace-events"
            qemu_log("escc_sunmouse_event " "dx=%d dy=%d buttons=0x%01x" "\n", dx, dy, buttons_state);
#line 1461 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_sunmouse_event(int dx, int dy, int buttons_state)
{
    if (true) {
        _nocheck__trace_escc_sunmouse_event(dx, dy, buttons_state);
    }
}

#define TRACE_PL011_IRQ_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_IRQ_STATE) || \
    false)

static inline void _nocheck__trace_pl011_irq_state(int level)
{
    if (trace_event_get_state(TRACE_PL011_IRQ_STATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 56 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:pl011_irq_state " "irq state %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , level);
#line 1488 "trace/trace-hw_char.h"
        } else {
#line 56 "../hw/char/trace-events"
            qemu_log("pl011_irq_state " "irq state %d" "\n", level);
#line 1492 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_pl011_irq_state(int level)
{
    if (true) {
        _nocheck__trace_pl011_irq_state(level);
    }
}

#define TRACE_PL011_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_READ) || \
    false)

static inline void _nocheck__trace_pl011_read(uint32_t addr, uint32_t value, const char * regname)
{
    if (trace_event_get_state(TRACE_PL011_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 57 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:pl011_read " "addr 0x%03x value 0x%08x reg %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value, regname);
#line 1519 "trace/trace-hw_char.h"
        } else {
#line 57 "../hw/char/trace-events"
            qemu_log("pl011_read " "addr 0x%03x value 0x%08x reg %s" "\n", addr, value, regname);
#line 1523 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_pl011_read(uint32_t addr, uint32_t value, const char * regname)
{
    if (true) {
        _nocheck__trace_pl011_read(addr, value, regname);
    }
}

#define TRACE_PL011_READ_FIFO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_READ_FIFO) || \
    false)

static inline void _nocheck__trace_pl011_read_fifo(int read_count)
{
    if (trace_event_get_state(TRACE_PL011_READ_FIFO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 58 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:pl011_read_fifo " "FIFO read, read_count now %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , read_count);
#line 1550 "trace/trace-hw_char.h"
        } else {
#line 58 "../hw/char/trace-events"
            qemu_log("pl011_read_fifo " "FIFO read, read_count now %d" "\n", read_count);
#line 1554 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_pl011_read_fifo(int read_count)
{
    if (true) {
        _nocheck__trace_pl011_read_fifo(read_count);
    }
}

#define TRACE_PL011_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_WRITE) || \
    false)

static inline void _nocheck__trace_pl011_write(uint32_t addr, uint32_t value, const char * regname)
{
    if (trace_event_get_state(TRACE_PL011_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 59 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:pl011_write " "addr 0x%03x value 0x%08x reg %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value, regname);
#line 1581 "trace/trace-hw_char.h"
        } else {
#line 59 "../hw/char/trace-events"
            qemu_log("pl011_write " "addr 0x%03x value 0x%08x reg %s" "\n", addr, value, regname);
#line 1585 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_pl011_write(uint32_t addr, uint32_t value, const char * regname)
{
    if (true) {
        _nocheck__trace_pl011_write(addr, value, regname);
    }
}

#define TRACE_PL011_CAN_RECEIVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_CAN_RECEIVE) || \
    false)

static inline void _nocheck__trace_pl011_can_receive(uint32_t lcr, int read_count, int r)
{
    if (trace_event_get_state(TRACE_PL011_CAN_RECEIVE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 60 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:pl011_can_receive " "LCR 0x%08x read_count %d returning %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , lcr, read_count, r);
#line 1612 "trace/trace-hw_char.h"
        } else {
#line 60 "../hw/char/trace-events"
            qemu_log("pl011_can_receive " "LCR 0x%08x read_count %d returning %d" "\n", lcr, read_count, r);
#line 1616 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_pl011_can_receive(uint32_t lcr, int read_count, int r)
{
    if (true) {
        _nocheck__trace_pl011_can_receive(lcr, read_count, r);
    }
}

#define TRACE_PL011_PUT_FIFO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_PUT_FIFO) || \
    false)

static inline void _nocheck__trace_pl011_put_fifo(uint32_t c, int read_count)
{
    if (trace_event_get_state(TRACE_PL011_PUT_FIFO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 61 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:pl011_put_fifo " "new char 0x%x read_count now %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , c, read_count);
#line 1643 "trace/trace-hw_char.h"
        } else {
#line 61 "../hw/char/trace-events"
            qemu_log("pl011_put_fifo " "new char 0x%x read_count now %d" "\n", c, read_count);
#line 1647 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_pl011_put_fifo(uint32_t c, int read_count)
{
    if (true) {
        _nocheck__trace_pl011_put_fifo(c, read_count);
    }
}

#define TRACE_PL011_PUT_FIFO_FULL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_PUT_FIFO_FULL) || \
    false)

static inline void _nocheck__trace_pl011_put_fifo_full(void)
{
    if (trace_event_get_state(TRACE_PL011_PUT_FIFO_FULL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 62 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:pl011_put_fifo_full " "FIFO now full, RXFF set" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1674 "trace/trace-hw_char.h"
        } else {
#line 62 "../hw/char/trace-events"
            qemu_log("pl011_put_fifo_full " "FIFO now full, RXFF set" "\n");
#line 1678 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_pl011_put_fifo_full(void)
{
    if (true) {
        _nocheck__trace_pl011_put_fifo_full();
    }
}

#define TRACE_PL011_BAUDRATE_CHANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_BAUDRATE_CHANGE) || \
    false)

static inline void _nocheck__trace_pl011_baudrate_change(unsigned int baudrate, uint64_t clock, uint32_t ibrd, uint32_t fbrd)
{
    if (trace_event_get_state(TRACE_PL011_BAUDRATE_CHANGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 63 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:pl011_baudrate_change " "new baudrate %u (clk: %" PRIu64 "hz, ibrd: %" PRIu32 ", fbrd: %" PRIu32 ")" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , baudrate, clock, ibrd, fbrd);
#line 1705 "trace/trace-hw_char.h"
        } else {
#line 63 "../hw/char/trace-events"
            qemu_log("pl011_baudrate_change " "new baudrate %u (clk: %" PRIu64 "hz, ibrd: %" PRIu32 ", fbrd: %" PRIu32 ")" "\n", baudrate, clock, ibrd, fbrd);
#line 1709 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_pl011_baudrate_change(unsigned int baudrate, uint64_t clock, uint32_t ibrd, uint32_t fbrd)
{
    if (true) {
        _nocheck__trace_pl011_baudrate_change(baudrate, clock, ibrd, fbrd);
    }
}

#define TRACE_CMSDK_APB_UART_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_UART_READ) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_uart_read(uint64_t offset, uint64_t data, unsigned size)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_UART_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 66 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:cmsdk_apb_uart_read " "CMSDK APB UART read: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, data, size);
#line 1736 "trace/trace-hw_char.h"
        } else {
#line 66 "../hw/char/trace-events"
            qemu_log("cmsdk_apb_uart_read " "CMSDK APB UART read: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n", offset, data, size);
#line 1740 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_cmsdk_apb_uart_read(uint64_t offset, uint64_t data, unsigned size)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_uart_read(offset, data, size);
    }
}

#define TRACE_CMSDK_APB_UART_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_UART_WRITE) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_uart_write(uint64_t offset, uint64_t data, unsigned size)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_UART_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 67 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:cmsdk_apb_uart_write " "CMSDK APB UART write: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, data, size);
#line 1767 "trace/trace-hw_char.h"
        } else {
#line 67 "../hw/char/trace-events"
            qemu_log("cmsdk_apb_uart_write " "CMSDK APB UART write: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n", offset, data, size);
#line 1771 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_cmsdk_apb_uart_write(uint64_t offset, uint64_t data, unsigned size)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_uart_write(offset, data, size);
    }
}

#define TRACE_CMSDK_APB_UART_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_UART_RESET) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_uart_reset(void)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_UART_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 68 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:cmsdk_apb_uart_reset " "CMSDK APB UART: reset" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1798 "trace/trace-hw_char.h"
        } else {
#line 68 "../hw/char/trace-events"
            qemu_log("cmsdk_apb_uart_reset " "CMSDK APB UART: reset" "\n");
#line 1802 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_cmsdk_apb_uart_reset(void)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_uart_reset();
    }
}

#define TRACE_CMSDK_APB_UART_RECEIVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_UART_RECEIVE) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_uart_receive(uint8_t c)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_UART_RECEIVE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 69 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:cmsdk_apb_uart_receive " "CMSDK APB UART: got character 0x%x from backend" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , c);
#line 1829 "trace/trace-hw_char.h"
        } else {
#line 69 "../hw/char/trace-events"
            qemu_log("cmsdk_apb_uart_receive " "CMSDK APB UART: got character 0x%x from backend" "\n", c);
#line 1833 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_cmsdk_apb_uart_receive(uint8_t c)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_uart_receive(c);
    }
}

#define TRACE_CMSDK_APB_UART_TX_PENDING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_UART_TX_PENDING) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_uart_tx_pending(void)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_UART_TX_PENDING) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 70 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:cmsdk_apb_uart_tx_pending " "CMSDK APB UART: character send to backend pending" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1860 "trace/trace-hw_char.h"
        } else {
#line 70 "../hw/char/trace-events"
            qemu_log("cmsdk_apb_uart_tx_pending " "CMSDK APB UART: character send to backend pending" "\n");
#line 1864 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_cmsdk_apb_uart_tx_pending(void)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_uart_tx_pending();
    }
}

#define TRACE_CMSDK_APB_UART_TX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_UART_TX) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_uart_tx(uint8_t c)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_UART_TX) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 71 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:cmsdk_apb_uart_tx " "CMSDK APB UART: character 0x%x sent to backend" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , c);
#line 1891 "trace/trace-hw_char.h"
        } else {
#line 71 "../hw/char/trace-events"
            qemu_log("cmsdk_apb_uart_tx " "CMSDK APB UART: character 0x%x sent to backend" "\n", c);
#line 1895 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_cmsdk_apb_uart_tx(uint8_t c)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_uart_tx(c);
    }
}

#define TRACE_CMSDK_APB_UART_SET_PARAMS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_UART_SET_PARAMS) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_uart_set_params(int speed)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_UART_SET_PARAMS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 72 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:cmsdk_apb_uart_set_params " "CMSDK APB UART: params set to %d 8N1" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , speed);
#line 1922 "trace/trace-hw_char.h"
        } else {
#line 72 "../hw/char/trace-events"
            qemu_log("cmsdk_apb_uart_set_params " "CMSDK APB UART: params set to %d 8N1" "\n", speed);
#line 1926 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_cmsdk_apb_uart_set_params(int speed)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_uart_set_params(speed);
    }
}

#define TRACE_NRF51_UART_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NRF51_UART_READ) || \
    false)

static inline void _nocheck__trace_nrf51_uart_read(uint64_t addr, uint64_t r, unsigned int size)
{
    if (trace_event_get_state(TRACE_NRF51_UART_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 75 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:nrf51_uart_read " "addr 0x%" PRIx64 " value 0x%" PRIx64 " size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, r, size);
#line 1953 "trace/trace-hw_char.h"
        } else {
#line 75 "../hw/char/trace-events"
            qemu_log("nrf51_uart_read " "addr 0x%" PRIx64 " value 0x%" PRIx64 " size %u" "\n", addr, r, size);
#line 1957 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_nrf51_uart_read(uint64_t addr, uint64_t r, unsigned int size)
{
    if (true) {
        _nocheck__trace_nrf51_uart_read(addr, r, size);
    }
}

#define TRACE_NRF51_UART_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NRF51_UART_WRITE) || \
    false)

static inline void _nocheck__trace_nrf51_uart_write(uint64_t addr, uint64_t value, unsigned int size)
{
    if (trace_event_get_state(TRACE_NRF51_UART_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 76 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:nrf51_uart_write " "addr 0x%" PRIx64 " value 0x%" PRIx64 " size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value, size);
#line 1984 "trace/trace-hw_char.h"
        } else {
#line 76 "../hw/char/trace-events"
            qemu_log("nrf51_uart_write " "addr 0x%" PRIx64 " value 0x%" PRIx64 " size %u" "\n", addr, value, size);
#line 1988 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_nrf51_uart_write(uint64_t addr, uint64_t value, unsigned int size)
{
    if (true) {
        _nocheck__trace_nrf51_uart_write(addr, value, size);
    }
}

#define TRACE_SHAKTI_UART_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SHAKTI_UART_READ) || \
    false)

static inline void _nocheck__trace_shakti_uart_read(uint64_t addr, uint16_t r, unsigned int size)
{
    if (trace_event_get_state(TRACE_SHAKTI_UART_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 79 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:shakti_uart_read " "addr 0x%" PRIx64 " value 0x%" PRIx16 " size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, r, size);
#line 2015 "trace/trace-hw_char.h"
        } else {
#line 79 "../hw/char/trace-events"
            qemu_log("shakti_uart_read " "addr 0x%" PRIx64 " value 0x%" PRIx16 " size %u" "\n", addr, r, size);
#line 2019 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_shakti_uart_read(uint64_t addr, uint16_t r, unsigned int size)
{
    if (true) {
        _nocheck__trace_shakti_uart_read(addr, r, size);
    }
}

#define TRACE_SHAKTI_UART_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SHAKTI_UART_WRITE) || \
    false)

static inline void _nocheck__trace_shakti_uart_write(uint64_t addr, uint64_t value, unsigned int size)
{
    if (trace_event_get_state(TRACE_SHAKTI_UART_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 80 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:shakti_uart_write " "addr 0x%" PRIx64 " value 0x%" PRIx64 " size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value, size);
#line 2046 "trace/trace-hw_char.h"
        } else {
#line 80 "../hw/char/trace-events"
            qemu_log("shakti_uart_write " "addr 0x%" PRIx64 " value 0x%" PRIx64 " size %u" "\n", addr, value, size);
#line 2050 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_shakti_uart_write(uint64_t addr, uint64_t value, unsigned int size)
{
    if (true) {
        _nocheck__trace_shakti_uart_write(addr, value, size);
    }
}

#define TRACE_EXYNOS_UART_DMABUSY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_DMABUSY) || \
    false)

static inline void _nocheck__trace_exynos_uart_dmabusy(uint32_t channel)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_DMABUSY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 83 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_dmabusy " "UART%d: DMA busy (Rx buffer empty)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel);
#line 2077 "trace/trace-hw_char.h"
        } else {
#line 83 "../hw/char/trace-events"
            qemu_log("exynos_uart_dmabusy " "UART%d: DMA busy (Rx buffer empty)" "\n", channel);
#line 2081 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_dmabusy(uint32_t channel)
{
    if (true) {
        _nocheck__trace_exynos_uart_dmabusy(channel);
    }
}

#define TRACE_EXYNOS_UART_DMAREADY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_DMAREADY) || \
    false)

static inline void _nocheck__trace_exynos_uart_dmaready(uint32_t channel)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_DMAREADY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 84 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_dmaready " "UART%d: DMA ready" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel);
#line 2108 "trace/trace-hw_char.h"
        } else {
#line 84 "../hw/char/trace-events"
            qemu_log("exynos_uart_dmaready " "UART%d: DMA ready" "\n", channel);
#line 2112 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_dmaready(uint32_t channel)
{
    if (true) {
        _nocheck__trace_exynos_uart_dmaready(channel);
    }
}

#define TRACE_EXYNOS_UART_IRQ_RAISED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_IRQ_RAISED) || \
    false)

static inline void _nocheck__trace_exynos_uart_irq_raised(uint32_t channel, uint32_t reg)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_IRQ_RAISED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 85 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_irq_raised " "UART%d: IRQ raised: 0x%08"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, reg);
#line 2139 "trace/trace-hw_char.h"
        } else {
#line 85 "../hw/char/trace-events"
            qemu_log("exynos_uart_irq_raised " "UART%d: IRQ raised: 0x%08"PRIx32 "\n", channel, reg);
#line 2143 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_irq_raised(uint32_t channel, uint32_t reg)
{
    if (true) {
        _nocheck__trace_exynos_uart_irq_raised(channel, reg);
    }
}

#define TRACE_EXYNOS_UART_IRQ_LOWERED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_IRQ_LOWERED) || \
    false)

static inline void _nocheck__trace_exynos_uart_irq_lowered(uint32_t channel)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_IRQ_LOWERED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 86 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_irq_lowered " "UART%d: IRQ lowered" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel);
#line 2170 "trace/trace-hw_char.h"
        } else {
#line 86 "../hw/char/trace-events"
            qemu_log("exynos_uart_irq_lowered " "UART%d: IRQ lowered" "\n", channel);
#line 2174 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_irq_lowered(uint32_t channel)
{
    if (true) {
        _nocheck__trace_exynos_uart_irq_lowered(channel);
    }
}

#define TRACE_EXYNOS_UART_UPDATE_PARAMS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_UPDATE_PARAMS) || \
    false)

static inline void _nocheck__trace_exynos_uart_update_params(uint32_t channel, int speed, uint8_t parity, int data, int stop, uint64_t wordtime)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_UPDATE_PARAMS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 87 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_update_params " "UART%d: speed: %d, parity: %c, data bits: %d, stop bits: %d wordtime: %"PRId64"ns" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, speed, parity, data, stop, wordtime);
#line 2201 "trace/trace-hw_char.h"
        } else {
#line 87 "../hw/char/trace-events"
            qemu_log("exynos_uart_update_params " "UART%d: speed: %d, parity: %c, data bits: %d, stop bits: %d wordtime: %"PRId64"ns" "\n", channel, speed, parity, data, stop, wordtime);
#line 2205 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_update_params(uint32_t channel, int speed, uint8_t parity, int data, int stop, uint64_t wordtime)
{
    if (true) {
        _nocheck__trace_exynos_uart_update_params(channel, speed, parity, data, stop, wordtime);
    }
}

#define TRACE_EXYNOS_UART_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_WRITE) || \
    false)

static inline void _nocheck__trace_exynos_uart_write(uint32_t channel, uint32_t offset, const char * name, uint64_t val)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 88 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_write " "UART%d: <0x%04x> %s <- 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, offset, name, val);
#line 2232 "trace/trace-hw_char.h"
        } else {
#line 88 "../hw/char/trace-events"
            qemu_log("exynos_uart_write " "UART%d: <0x%04x> %s <- 0x%" PRIx64 "\n", channel, offset, name, val);
#line 2236 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_write(uint32_t channel, uint32_t offset, const char * name, uint64_t val)
{
    if (true) {
        _nocheck__trace_exynos_uart_write(channel, offset, name, val);
    }
}

#define TRACE_EXYNOS_UART_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_READ) || \
    false)

static inline void _nocheck__trace_exynos_uart_read(uint32_t channel, uint32_t offset, const char * name, uint64_t val)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 89 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_read " "UART%d: <0x%04x> %s -> 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, offset, name, val);
#line 2263 "trace/trace-hw_char.h"
        } else {
#line 89 "../hw/char/trace-events"
            qemu_log("exynos_uart_read " "UART%d: <0x%04x> %s -> 0x%" PRIx64 "\n", channel, offset, name, val);
#line 2267 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_read(uint32_t channel, uint32_t offset, const char * name, uint64_t val)
{
    if (true) {
        _nocheck__trace_exynos_uart_read(channel, offset, name, val);
    }
}

#define TRACE_EXYNOS_UART_RX_FIFO_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_RX_FIFO_RESET) || \
    false)

static inline void _nocheck__trace_exynos_uart_rx_fifo_reset(uint32_t channel)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_RX_FIFO_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 90 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_rx_fifo_reset " "UART%d: Rx FIFO Reset" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel);
#line 2294 "trace/trace-hw_char.h"
        } else {
#line 90 "../hw/char/trace-events"
            qemu_log("exynos_uart_rx_fifo_reset " "UART%d: Rx FIFO Reset" "\n", channel);
#line 2298 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_rx_fifo_reset(uint32_t channel)
{
    if (true) {
        _nocheck__trace_exynos_uart_rx_fifo_reset(channel);
    }
}

#define TRACE_EXYNOS_UART_TX_FIFO_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_TX_FIFO_RESET) || \
    false)

static inline void _nocheck__trace_exynos_uart_tx_fifo_reset(uint32_t channel)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_TX_FIFO_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 91 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_tx_fifo_reset " "UART%d: Tx FIFO Reset" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel);
#line 2325 "trace/trace-hw_char.h"
        } else {
#line 91 "../hw/char/trace-events"
            qemu_log("exynos_uart_tx_fifo_reset " "UART%d: Tx FIFO Reset" "\n", channel);
#line 2329 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_tx_fifo_reset(uint32_t channel)
{
    if (true) {
        _nocheck__trace_exynos_uart_tx_fifo_reset(channel);
    }
}

#define TRACE_EXYNOS_UART_TX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_TX) || \
    false)

static inline void _nocheck__trace_exynos_uart_tx(uint32_t channel, uint8_t ch)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_TX) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 92 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_tx " "UART%d: Tx 0x%02"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, ch);
#line 2356 "trace/trace-hw_char.h"
        } else {
#line 92 "../hw/char/trace-events"
            qemu_log("exynos_uart_tx " "UART%d: Tx 0x%02"PRIx32 "\n", channel, ch);
#line 2360 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_tx(uint32_t channel, uint8_t ch)
{
    if (true) {
        _nocheck__trace_exynos_uart_tx(channel, ch);
    }
}

#define TRACE_EXYNOS_UART_INTCLR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_INTCLR) || \
    false)

static inline void _nocheck__trace_exynos_uart_intclr(uint32_t channel, uint32_t reg)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_INTCLR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 93 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_intclr " "UART%d: interrupts cleared: 0x%08"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, reg);
#line 2387 "trace/trace-hw_char.h"
        } else {
#line 93 "../hw/char/trace-events"
            qemu_log("exynos_uart_intclr " "UART%d: interrupts cleared: 0x%08"PRIx32 "\n", channel, reg);
#line 2391 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_intclr(uint32_t channel, uint32_t reg)
{
    if (true) {
        _nocheck__trace_exynos_uart_intclr(channel, reg);
    }
}

#define TRACE_EXYNOS_UART_RO_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_RO_WRITE) || \
    false)

static inline void _nocheck__trace_exynos_uart_ro_write(uint32_t channel, const char * name, uint32_t reg)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_RO_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 94 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_ro_write " "UART%d: Trying to write into RO register: %s [0x%04"PRIx32"]" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, name, reg);
#line 2418 "trace/trace-hw_char.h"
        } else {
#line 94 "../hw/char/trace-events"
            qemu_log("exynos_uart_ro_write " "UART%d: Trying to write into RO register: %s [0x%04"PRIx32"]" "\n", channel, name, reg);
#line 2422 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_ro_write(uint32_t channel, const char * name, uint32_t reg)
{
    if (true) {
        _nocheck__trace_exynos_uart_ro_write(channel, name, reg);
    }
}

#define TRACE_EXYNOS_UART_RX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_RX) || \
    false)

static inline void _nocheck__trace_exynos_uart_rx(uint32_t channel, uint8_t ch)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_RX) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 95 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_rx " "UART%d: Rx 0x%02"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, ch);
#line 2449 "trace/trace-hw_char.h"
        } else {
#line 95 "../hw/char/trace-events"
            qemu_log("exynos_uart_rx " "UART%d: Rx 0x%02"PRIx32 "\n", channel, ch);
#line 2453 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_rx(uint32_t channel, uint8_t ch)
{
    if (true) {
        _nocheck__trace_exynos_uart_rx(channel, ch);
    }
}

#define TRACE_EXYNOS_UART_RX_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_RX_ERROR) || \
    false)

static inline void _nocheck__trace_exynos_uart_rx_error(uint32_t channel)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_RX_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 96 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_rx_error " "UART%d: Rx error" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel);
#line 2480 "trace/trace-hw_char.h"
        } else {
#line 96 "../hw/char/trace-events"
            qemu_log("exynos_uart_rx_error " "UART%d: Rx error" "\n", channel);
#line 2484 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_rx_error(uint32_t channel)
{
    if (true) {
        _nocheck__trace_exynos_uart_rx_error(channel);
    }
}

#define TRACE_EXYNOS_UART_WO_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_WO_READ) || \
    false)

static inline void _nocheck__trace_exynos_uart_wo_read(uint32_t channel, const char * name, uint32_t reg)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_WO_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 97 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_wo_read " "UART%d: Trying to read from WO register: %s [0x%04"PRIx32"]" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, name, reg);
#line 2511 "trace/trace-hw_char.h"
        } else {
#line 97 "../hw/char/trace-events"
            qemu_log("exynos_uart_wo_read " "UART%d: Trying to read from WO register: %s [0x%04"PRIx32"]" "\n", channel, name, reg);
#line 2515 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_wo_read(uint32_t channel, const char * name, uint32_t reg)
{
    if (true) {
        _nocheck__trace_exynos_uart_wo_read(channel, name, reg);
    }
}

#define TRACE_EXYNOS_UART_RXSIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_RXSIZE) || \
    false)

static inline void _nocheck__trace_exynos_uart_rxsize(uint32_t channel, uint32_t size)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_RXSIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 98 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_rxsize " "UART%d: Rx FIFO size: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, size);
#line 2542 "trace/trace-hw_char.h"
        } else {
#line 98 "../hw/char/trace-events"
            qemu_log("exynos_uart_rxsize " "UART%d: Rx FIFO size: %d" "\n", channel, size);
#line 2546 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_rxsize(uint32_t channel, uint32_t size)
{
    if (true) {
        _nocheck__trace_exynos_uart_rxsize(channel, size);
    }
}

#define TRACE_EXYNOS_UART_CHANNEL_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_CHANNEL_ERROR) || \
    false)

static inline void _nocheck__trace_exynos_uart_channel_error(uint32_t channel)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_CHANNEL_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 99 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_channel_error " "Wrong UART channel number: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel);
#line 2573 "trace/trace-hw_char.h"
        } else {
#line 99 "../hw/char/trace-events"
            qemu_log("exynos_uart_channel_error " "Wrong UART channel number: %d" "\n", channel);
#line 2577 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_channel_error(uint32_t channel)
{
    if (true) {
        _nocheck__trace_exynos_uart_channel_error(channel);
    }
}

#define TRACE_EXYNOS_UART_RX_TIMEOUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_RX_TIMEOUT) || \
    false)

static inline void _nocheck__trace_exynos_uart_rx_timeout(uint32_t channel, uint32_t stat, uint32_t intsp)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_RX_TIMEOUT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 100 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_rx_timeout " "UART%d: Rx timeout stat=0x%x intsp=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, stat, intsp);
#line 2604 "trace/trace-hw_char.h"
        } else {
#line 100 "../hw/char/trace-events"
            qemu_log("exynos_uart_rx_timeout " "UART%d: Rx timeout stat=0x%x intsp=0x%x" "\n", channel, stat, intsp);
#line 2608 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_rx_timeout(uint32_t channel, uint32_t stat, uint32_t intsp)
{
    if (true) {
        _nocheck__trace_exynos_uart_rx_timeout(channel, stat, intsp);
    }
}

#define TRACE_CADENCE_UART_BAUDRATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CADENCE_UART_BAUDRATE) || \
    false)

static inline void _nocheck__trace_cadence_uart_baudrate(unsigned baudrate)
{
    if (trace_event_get_state(TRACE_CADENCE_UART_BAUDRATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 103 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:cadence_uart_baudrate " "baudrate %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , baudrate);
#line 2635 "trace/trace-hw_char.h"
        } else {
#line 103 "../hw/char/trace-events"
            qemu_log("cadence_uart_baudrate " "baudrate %u" "\n", baudrate);
#line 2639 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_cadence_uart_baudrate(unsigned baudrate)
{
    if (true) {
        _nocheck__trace_cadence_uart_baudrate(baudrate);
    }
}

#define TRACE_SH_SERIAL_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SH_SERIAL_READ) || \
    false)

static inline void _nocheck__trace_sh_serial_read(char * id, unsigned size, uint64_t offs, uint64_t val)
{
    if (trace_event_get_state(TRACE_SH_SERIAL_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 106 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:sh_serial_read " " %s size %d offs 0x%02" PRIx64 " -> 0x%02" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, size, offs, val);
#line 2666 "trace/trace-hw_char.h"
        } else {
#line 106 "../hw/char/trace-events"
            qemu_log("sh_serial_read " " %s size %d offs 0x%02" PRIx64 " -> 0x%02" PRIx64 "\n", id, size, offs, val);
#line 2670 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_sh_serial_read(char * id, unsigned size, uint64_t offs, uint64_t val)
{
    if (true) {
        _nocheck__trace_sh_serial_read(id, size, offs, val);
    }
}

#define TRACE_SH_SERIAL_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SH_SERIAL_WRITE) || \
    false)

static inline void _nocheck__trace_sh_serial_write(char * id, unsigned size, uint64_t offs, uint64_t val)
{
    if (trace_event_get_state(TRACE_SH_SERIAL_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 107 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:sh_serial_write " "%s size %d offs 0x%02" PRIx64 " <- 0x%02" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, size, offs, val);
#line 2697 "trace/trace-hw_char.h"
        } else {
#line 107 "../hw/char/trace-events"
            qemu_log("sh_serial_write " "%s size %d offs 0x%02" PRIx64 " <- 0x%02" PRIx64 "\n", id, size, offs, val);
#line 2701 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_sh_serial_write(char * id, unsigned size, uint64_t offs, uint64_t val)
{
    if (true) {
        _nocheck__trace_sh_serial_write(id, size, offs, val);
    }
}

#define TRACE_STM32L4X5_USART_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_STM32L4X5_USART_READ) || \
    false)

static inline void _nocheck__trace_stm32l4x5_usart_read(uint64_t addr, uint32_t data)
{
    if (trace_event_get_state(TRACE_STM32L4X5_USART_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 110 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:stm32l4x5_usart_read " "USART: Read <0x%" PRIx64 "> -> 0x%" PRIx32 "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, data);
#line 2728 "trace/trace-hw_char.h"
        } else {
#line 110 "../hw/char/trace-events"
            qemu_log("stm32l4x5_usart_read " "USART: Read <0x%" PRIx64 "> -> 0x%" PRIx32 "" "\n", addr, data);
#line 2732 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_stm32l4x5_usart_read(uint64_t addr, uint32_t data)
{
    if (true) {
        _nocheck__trace_stm32l4x5_usart_read(addr, data);
    }
}

#define TRACE_STM32L4X5_USART_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_STM32L4X5_USART_WRITE) || \
    false)

static inline void _nocheck__trace_stm32l4x5_usart_write(uint64_t addr, uint32_t data)
{
    if (trace_event_get_state(TRACE_STM32L4X5_USART_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 111 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:stm32l4x5_usart_write " "USART: Write <0x%" PRIx64 "> <- 0x%" PRIx32 "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, data);
#line 2759 "trace/trace-hw_char.h"
        } else {
#line 111 "../hw/char/trace-events"
            qemu_log("stm32l4x5_usart_write " "USART: Write <0x%" PRIx64 "> <- 0x%" PRIx32 "" "\n", addr, data);
#line 2763 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_stm32l4x5_usart_write(uint64_t addr, uint32_t data)
{
    if (true) {
        _nocheck__trace_stm32l4x5_usart_write(addr, data);
    }
}

#define TRACE_STM32L4X5_USART_RX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_STM32L4X5_USART_RX) || \
    false)

static inline void _nocheck__trace_stm32l4x5_usart_rx(uint8_t c)
{
    if (trace_event_get_state(TRACE_STM32L4X5_USART_RX) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 112 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:stm32l4x5_usart_rx " "USART: got character 0x%x from backend" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , c);
#line 2790 "trace/trace-hw_char.h"
        } else {
#line 112 "../hw/char/trace-events"
            qemu_log("stm32l4x5_usart_rx " "USART: got character 0x%x from backend" "\n", c);
#line 2794 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_stm32l4x5_usart_rx(uint8_t c)
{
    if (true) {
        _nocheck__trace_stm32l4x5_usart_rx(c);
    }
}

#define TRACE_STM32L4X5_USART_TX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_STM32L4X5_USART_TX) || \
    false)

static inline void _nocheck__trace_stm32l4x5_usart_tx(uint8_t c)
{
    if (trace_event_get_state(TRACE_STM32L4X5_USART_TX) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 113 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:stm32l4x5_usart_tx " "USART: character 0x%x sent to backend" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , c);
#line 2821 "trace/trace-hw_char.h"
        } else {
#line 113 "../hw/char/trace-events"
            qemu_log("stm32l4x5_usart_tx " "USART: character 0x%x sent to backend" "\n", c);
#line 2825 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_stm32l4x5_usart_tx(uint8_t c)
{
    if (true) {
        _nocheck__trace_stm32l4x5_usart_tx(c);
    }
}

#define TRACE_STM32L4X5_USART_TX_PENDING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_STM32L4X5_USART_TX_PENDING) || \
    false)

static inline void _nocheck__trace_stm32l4x5_usart_tx_pending(void)
{
    if (trace_event_get_state(TRACE_STM32L4X5_USART_TX_PENDING) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 114 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:stm32l4x5_usart_tx_pending " "USART: character send to backend pending" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2852 "trace/trace-hw_char.h"
        } else {
#line 114 "../hw/char/trace-events"
            qemu_log("stm32l4x5_usart_tx_pending " "USART: character send to backend pending" "\n");
#line 2856 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_stm32l4x5_usart_tx_pending(void)
{
    if (true) {
        _nocheck__trace_stm32l4x5_usart_tx_pending();
    }
}

#define TRACE_STM32L4X5_USART_IRQ_RAISED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_STM32L4X5_USART_IRQ_RAISED) || \
    false)

static inline void _nocheck__trace_stm32l4x5_usart_irq_raised(uint32_t reg)
{
    if (trace_event_get_state(TRACE_STM32L4X5_USART_IRQ_RAISED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 115 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:stm32l4x5_usart_irq_raised " "USART: IRQ raised: 0x%08"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reg);
#line 2883 "trace/trace-hw_char.h"
        } else {
#line 115 "../hw/char/trace-events"
            qemu_log("stm32l4x5_usart_irq_raised " "USART: IRQ raised: 0x%08"PRIx32 "\n", reg);
#line 2887 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_stm32l4x5_usart_irq_raised(uint32_t reg)
{
    if (true) {
        _nocheck__trace_stm32l4x5_usart_irq_raised(reg);
    }
}

#define TRACE_STM32L4X5_USART_IRQ_LOWERED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_STM32L4X5_USART_IRQ_LOWERED) || \
    false)

static inline void _nocheck__trace_stm32l4x5_usart_irq_lowered(void)
{
    if (trace_event_get_state(TRACE_STM32L4X5_USART_IRQ_LOWERED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 116 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:stm32l4x5_usart_irq_lowered " "USART: IRQ lowered" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2914 "trace/trace-hw_char.h"
        } else {
#line 116 "../hw/char/trace-events"
            qemu_log("stm32l4x5_usart_irq_lowered " "USART: IRQ lowered" "\n");
#line 2918 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_stm32l4x5_usart_irq_lowered(void)
{
    if (true) {
        _nocheck__trace_stm32l4x5_usart_irq_lowered();
    }
}

#define TRACE_STM32L4X5_USART_OVERRUN_DETECTED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_STM32L4X5_USART_OVERRUN_DETECTED) || \
    false)

static inline void _nocheck__trace_stm32l4x5_usart_overrun_detected(uint8_t current, uint8_t received)
{
    if (trace_event_get_state(TRACE_STM32L4X5_USART_OVERRUN_DETECTED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 117 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:stm32l4x5_usart_overrun_detected " "USART: Overrun detected, RDR='0x%x', received 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , current, received);
#line 2945 "trace/trace-hw_char.h"
        } else {
#line 117 "../hw/char/trace-events"
            qemu_log("stm32l4x5_usart_overrun_detected " "USART: Overrun detected, RDR='0x%x', received 0x%x" "\n", current, received);
#line 2949 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_stm32l4x5_usart_overrun_detected(uint8_t current, uint8_t received)
{
    if (true) {
        _nocheck__trace_stm32l4x5_usart_overrun_detected(current, received);
    }
}

#define TRACE_STM32L4X5_USART_RECEIVER_NOT_ENABLED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_STM32L4X5_USART_RECEIVER_NOT_ENABLED) || \
    false)

static inline void _nocheck__trace_stm32l4x5_usart_receiver_not_enabled(uint8_t ue_bit, uint8_t re_bit)
{
    if (trace_event_get_state(TRACE_STM32L4X5_USART_RECEIVER_NOT_ENABLED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 118 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:stm32l4x5_usart_receiver_not_enabled " "USART: Receiver not enabled, UE=0x%x, RE=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ue_bit, re_bit);
#line 2976 "trace/trace-hw_char.h"
        } else {
#line 118 "../hw/char/trace-events"
            qemu_log("stm32l4x5_usart_receiver_not_enabled " "USART: Receiver not enabled, UE=0x%x, RE=0x%x" "\n", ue_bit, re_bit);
#line 2980 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_stm32l4x5_usart_receiver_not_enabled(uint8_t ue_bit, uint8_t re_bit)
{
    if (true) {
        _nocheck__trace_stm32l4x5_usart_receiver_not_enabled(ue_bit, re_bit);
    }
}

#define TRACE_STM32L4X5_USART_UPDATE_PARAMS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_STM32L4X5_USART_UPDATE_PARAMS) || \
    false)

static inline void _nocheck__trace_stm32l4x5_usart_update_params(int speed, uint8_t parity, int data, int stop)
{
    if (trace_event_get_state(TRACE_STM32L4X5_USART_UPDATE_PARAMS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 119 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:stm32l4x5_usart_update_params " "USART: speed: %d, parity: %c, data bits: %d, stop bits: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , speed, parity, data, stop);
#line 3007 "trace/trace-hw_char.h"
        } else {
#line 119 "../hw/char/trace-events"
            qemu_log("stm32l4x5_usart_update_params " "USART: speed: %d, parity: %c, data bits: %d, stop bits: %d" "\n", speed, parity, data, stop);
#line 3011 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_stm32l4x5_usart_update_params(int speed, uint8_t parity, int data, int stop)
{
    if (true) {
        _nocheck__trace_stm32l4x5_usart_update_params(speed, parity, data, stop);
    }
}

#define TRACE_XEN_CONSOLE_CONNECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_CONSOLE_CONNECT) || \
    false)

static inline void _nocheck__trace_xen_console_connect(unsigned int idx, unsigned int ring_ref, unsigned int port, unsigned int limit)
{
    if (trace_event_get_state(TRACE_XEN_CONSOLE_CONNECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 122 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:xen_console_connect " "idx %u ring_ref %u port %u limit %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , idx, ring_ref, port, limit);
#line 3038 "trace/trace-hw_char.h"
        } else {
#line 122 "../hw/char/trace-events"
            qemu_log("xen_console_connect " "idx %u ring_ref %u port %u limit %u" "\n", idx, ring_ref, port, limit);
#line 3042 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_xen_console_connect(unsigned int idx, unsigned int ring_ref, unsigned int port, unsigned int limit)
{
    if (true) {
        _nocheck__trace_xen_console_connect(idx, ring_ref, port, limit);
    }
}

#define TRACE_XEN_CONSOLE_DISCONNECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_CONSOLE_DISCONNECT) || \
    false)

static inline void _nocheck__trace_xen_console_disconnect(unsigned int idx)
{
    if (trace_event_get_state(TRACE_XEN_CONSOLE_DISCONNECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 123 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:xen_console_disconnect " "idx %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , idx);
#line 3069 "trace/trace-hw_char.h"
        } else {
#line 123 "../hw/char/trace-events"
            qemu_log("xen_console_disconnect " "idx %u" "\n", idx);
#line 3073 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_xen_console_disconnect(unsigned int idx)
{
    if (true) {
        _nocheck__trace_xen_console_disconnect(idx);
    }
}

#define TRACE_XEN_CONSOLE_UNREALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_CONSOLE_UNREALIZE) || \
    false)

static inline void _nocheck__trace_xen_console_unrealize(unsigned int idx)
{
    if (trace_event_get_state(TRACE_XEN_CONSOLE_UNREALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 124 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:xen_console_unrealize " "idx %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , idx);
#line 3100 "trace/trace-hw_char.h"
        } else {
#line 124 "../hw/char/trace-events"
            qemu_log("xen_console_unrealize " "idx %u" "\n", idx);
#line 3104 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_xen_console_unrealize(unsigned int idx)
{
    if (true) {
        _nocheck__trace_xen_console_unrealize(idx);
    }
}

#define TRACE_XEN_CONSOLE_REALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_CONSOLE_REALIZE) || \
    false)

static inline void _nocheck__trace_xen_console_realize(unsigned int idx, const char * chrdev)
{
    if (trace_event_get_state(TRACE_XEN_CONSOLE_REALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 125 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:xen_console_realize " "idx %u chrdev %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , idx, chrdev);
#line 3131 "trace/trace-hw_char.h"
        } else {
#line 125 "../hw/char/trace-events"
            qemu_log("xen_console_realize " "idx %u chrdev %s" "\n", idx, chrdev);
#line 3135 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_xen_console_realize(unsigned int idx, const char * chrdev)
{
    if (true) {
        _nocheck__trace_xen_console_realize(idx, chrdev);
    }
}

#define TRACE_XEN_CONSOLE_DEVICE_CREATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_CONSOLE_DEVICE_CREATE) || \
    false)

static inline void _nocheck__trace_xen_console_device_create(unsigned int idx)
{
    if (trace_event_get_state(TRACE_XEN_CONSOLE_DEVICE_CREATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 126 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:xen_console_device_create " "idx %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , idx);
#line 3162 "trace/trace-hw_char.h"
        } else {
#line 126 "../hw/char/trace-events"
            qemu_log("xen_console_device_create " "idx %u" "\n", idx);
#line 3166 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_xen_console_device_create(unsigned int idx)
{
    if (true) {
        _nocheck__trace_xen_console_device_create(idx);
    }
}

#define TRACE_XEN_CONSOLE_DEVICE_DESTROY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_CONSOLE_DEVICE_DESTROY) || \
    false)

static inline void _nocheck__trace_xen_console_device_destroy(unsigned int idx)
{
    if (trace_event_get_state(TRACE_XEN_CONSOLE_DEVICE_DESTROY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 127 "../hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:xen_console_device_destroy " "idx %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , idx);
#line 3193 "trace/trace-hw_char.h"
        } else {
#line 127 "../hw/char/trace-events"
            qemu_log("xen_console_device_destroy " "idx %u" "\n", idx);
#line 3197 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_xen_console_device_destroy(unsigned int idx)
{
    if (true) {
        _nocheck__trace_xen_console_device_destroy(idx);
    }
}
#endif /* TRACE_HW_CHAR_GENERATED_TRACERS_H */
