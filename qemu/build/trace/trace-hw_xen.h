/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_XEN_GENERATED_TRACERS_H
#define TRACE_HW_XEN_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_XEN_DEFAULT_IOREQ_SERVER_EVENT;
extern TraceEvent _TRACE_XEN_IOREQ_SERVER_CREATE_EVENT;
extern TraceEvent _TRACE_XEN_IOREQ_SERVER_DESTROY_EVENT;
extern TraceEvent _TRACE_XEN_IOREQ_SERVER_STATE_EVENT;
extern TraceEvent _TRACE_XEN_MAP_MMIO_RANGE_EVENT;
extern TraceEvent _TRACE_XEN_UNMAP_MMIO_RANGE_EVENT;
extern TraceEvent _TRACE_XEN_MAP_PORTIO_RANGE_EVENT;
extern TraceEvent _TRACE_XEN_UNMAP_PORTIO_RANGE_EVENT;
extern TraceEvent _TRACE_XEN_MAP_PCIDEV_EVENT;
extern TraceEvent _TRACE_XEN_UNMAP_PCIDEV_EVENT;
extern TraceEvent _TRACE_XEN_DOMID_RESTRICT_EVENT;
extern TraceEvent _TRACE_XEN_BUS_REALIZE_EVENT;
extern TraceEvent _TRACE_XEN_BUS_UNREALIZE_EVENT;
extern TraceEvent _TRACE_XEN_BUS_ENUMERATE_EVENT;
extern TraceEvent _TRACE_XEN_BUS_CLEANUP_EVENT;
extern TraceEvent _TRACE_XEN_BUS_TYPE_ENUMERATE_EVENT;
extern TraceEvent _TRACE_XEN_BUS_BACKEND_CREATE_EVENT;
extern TraceEvent _TRACE_XEN_BUS_DEVICE_CLEANUP_EVENT;
extern TraceEvent _TRACE_XEN_BUS_ADD_WATCH_EVENT;
extern TraceEvent _TRACE_XEN_BUS_REMOVE_WATCH_EVENT;
extern TraceEvent _TRACE_XEN_DEVICE_REALIZE_EVENT;
extern TraceEvent _TRACE_XEN_DEVICE_UNREALIZE_EVENT;
extern TraceEvent _TRACE_XEN_DEVICE_BACKEND_STATE_EVENT;
extern TraceEvent _TRACE_XEN_DEVICE_BACKEND_ONLINE_EVENT;
extern TraceEvent _TRACE_XEN_DEVICE_BACKEND_CHANGED_EVENT;
extern TraceEvent _TRACE_XEN_DEVICE_FRONTEND_STATE_EVENT;
extern TraceEvent _TRACE_XEN_DEVICE_FRONTEND_CHANGED_EVENT;
extern TraceEvent _TRACE_XEN_DEVICE_UNPLUG_EVENT;
extern TraceEvent _TRACE_XEN_DEVICE_ADD_WATCH_EVENT;
extern TraceEvent _TRACE_XEN_DEVICE_REMOVE_WATCH_EVENT;
extern TraceEvent _TRACE_XS_NODE_CREATE_EVENT;
extern TraceEvent _TRACE_XS_NODE_DESTROY_EVENT;
extern TraceEvent _TRACE_XS_NODE_VPRINTF_EVENT;
extern TraceEvent _TRACE_XS_NODE_VSCANF_EVENT;
extern TraceEvent _TRACE_XS_NODE_WATCH_EVENT;
extern TraceEvent _TRACE_XS_NODE_UNWATCH_EVENT;
extern TraceEvent _TRACE_XEN_RAM_ALLOC_EVENT;
extern TraceEvent _TRACE_XEN_CLIENT_SET_MEMORY_EVENT;
extern TraceEvent _TRACE_HANDLE_IOREQ_EVENT;
extern TraceEvent _TRACE_HANDLE_IOREQ_READ_EVENT;
extern TraceEvent _TRACE_HANDLE_IOREQ_WRITE_EVENT;
extern TraceEvent _TRACE_CPU_IOREQ_PIO_EVENT;
extern TraceEvent _TRACE_CPU_IOREQ_PIO_READ_REG_EVENT;
extern TraceEvent _TRACE_CPU_IOREQ_PIO_WRITE_REG_EVENT;
extern TraceEvent _TRACE_CPU_IOREQ_MOVE_EVENT;
extern TraceEvent _TRACE_XEN_MAP_RESOURCE_IOREQ_EVENT;
extern TraceEvent _TRACE_CPU_IOREQ_CONFIG_READ_EVENT;
extern TraceEvent _TRACE_CPU_IOREQ_CONFIG_WRITE_EVENT;
extern TraceEvent _TRACE_CPU_GET_IOREQ_FROM_SHARED_MEMORY_REQ_NOT_READY_EVENT;
extern TraceEvent _TRACE_XEN_MAIN_LOOP_PREPARE_INIT_CPU_EVENT;
extern TraceEvent _TRACE_XEN_MAP_IOREQ_SERVER_SHARED_PAGE_EVENT;
extern TraceEvent _TRACE_XEN_MAP_IOREQ_SERVER_BUFFERED_IO_PAGE_EVENT;
extern TraceEvent _TRACE_XEN_MAP_IOREQ_SERVER_BUFFERED_IO_EVTCHN_EVENT;
extern TraceEvent _TRACE_DESTROY_HVM_DOMAIN_CANNOT_ACQUIRE_HANDLE_EVENT;
extern TraceEvent _TRACE_DESTROY_HVM_DOMAIN_FAILED_ACTION_EVENT;
extern TraceEvent _TRACE_DESTROY_HVM_DOMAIN_ACTION_EVENT;
extern TraceEvent _TRACE_XEN_MAP_CACHE_EVENT;
extern TraceEvent _TRACE_XEN_REMAP_BUCKET_EVENT;
extern TraceEvent _TRACE_XEN_MAP_CACHE_RETURN_EVENT;
extern TraceEvent _TRACE_XEN_MAP_CACHE_INIT_EVENT;
extern TraceEvent _TRACE_XEN_REPLACE_CACHE_ENTRY_DUMMY_EVENT;
extern TraceEvent _TRACE_XEN_INVALIDATE_MAP_CACHE_ENTRY_UNLOCKED_NOT_FOUND_EVENT;
extern TraceEvent _TRACE_XEN_INVALIDATE_MAP_CACHE_ENTRY_UNLOCKED_FOUND_EVENT;
extern TraceEvent _TRACE_XEN_INVALIDATE_MAP_CACHE_ENTRY_UNLOCKED_MISS_EVENT;
extern TraceEvent _TRACE_XEN_REPLACE_CACHE_ENTRY_UNLOCKED_COULD_NOT_UPDATE_ENTRY_EVENT;
extern TraceEvent _TRACE_XEN_RAM_ADDR_FROM_MAPCACHE_NOT_FOUND_EVENT;
extern TraceEvent _TRACE_XEN_RAM_ADDR_FROM_MAPCACHE_FOUND_EVENT;
extern TraceEvent _TRACE_XEN_RAM_ADDR_FROM_MAPCACHE_NOT_IN_CACHE_EVENT;
extern TraceEvent _TRACE_XEN_REPLACE_CACHE_ENTRY_UNLOCKED_EVENT;
extern TraceEvent _TRACE_XEN_INVALIDATE_MAP_CACHE_EVENT;
extern uint16_t _TRACE_XEN_DEFAULT_IOREQ_SERVER_DSTATE;
extern uint16_t _TRACE_XEN_IOREQ_SERVER_CREATE_DSTATE;
extern uint16_t _TRACE_XEN_IOREQ_SERVER_DESTROY_DSTATE;
extern uint16_t _TRACE_XEN_IOREQ_SERVER_STATE_DSTATE;
extern uint16_t _TRACE_XEN_MAP_MMIO_RANGE_DSTATE;
extern uint16_t _TRACE_XEN_UNMAP_MMIO_RANGE_DSTATE;
extern uint16_t _TRACE_XEN_MAP_PORTIO_RANGE_DSTATE;
extern uint16_t _TRACE_XEN_UNMAP_PORTIO_RANGE_DSTATE;
extern uint16_t _TRACE_XEN_MAP_PCIDEV_DSTATE;
extern uint16_t _TRACE_XEN_UNMAP_PCIDEV_DSTATE;
extern uint16_t _TRACE_XEN_DOMID_RESTRICT_DSTATE;
extern uint16_t _TRACE_XEN_BUS_REALIZE_DSTATE;
extern uint16_t _TRACE_XEN_BUS_UNREALIZE_DSTATE;
extern uint16_t _TRACE_XEN_BUS_ENUMERATE_DSTATE;
extern uint16_t _TRACE_XEN_BUS_CLEANUP_DSTATE;
extern uint16_t _TRACE_XEN_BUS_TYPE_ENUMERATE_DSTATE;
extern uint16_t _TRACE_XEN_BUS_BACKEND_CREATE_DSTATE;
extern uint16_t _TRACE_XEN_BUS_DEVICE_CLEANUP_DSTATE;
extern uint16_t _TRACE_XEN_BUS_ADD_WATCH_DSTATE;
extern uint16_t _TRACE_XEN_BUS_REMOVE_WATCH_DSTATE;
extern uint16_t _TRACE_XEN_DEVICE_REALIZE_DSTATE;
extern uint16_t _TRACE_XEN_DEVICE_UNREALIZE_DSTATE;
extern uint16_t _TRACE_XEN_DEVICE_BACKEND_STATE_DSTATE;
extern uint16_t _TRACE_XEN_DEVICE_BACKEND_ONLINE_DSTATE;
extern uint16_t _TRACE_XEN_DEVICE_BACKEND_CHANGED_DSTATE;
extern uint16_t _TRACE_XEN_DEVICE_FRONTEND_STATE_DSTATE;
extern uint16_t _TRACE_XEN_DEVICE_FRONTEND_CHANGED_DSTATE;
extern uint16_t _TRACE_XEN_DEVICE_UNPLUG_DSTATE;
extern uint16_t _TRACE_XEN_DEVICE_ADD_WATCH_DSTATE;
extern uint16_t _TRACE_XEN_DEVICE_REMOVE_WATCH_DSTATE;
extern uint16_t _TRACE_XS_NODE_CREATE_DSTATE;
extern uint16_t _TRACE_XS_NODE_DESTROY_DSTATE;
extern uint16_t _TRACE_XS_NODE_VPRINTF_DSTATE;
extern uint16_t _TRACE_XS_NODE_VSCANF_DSTATE;
extern uint16_t _TRACE_XS_NODE_WATCH_DSTATE;
extern uint16_t _TRACE_XS_NODE_UNWATCH_DSTATE;
extern uint16_t _TRACE_XEN_RAM_ALLOC_DSTATE;
extern uint16_t _TRACE_XEN_CLIENT_SET_MEMORY_DSTATE;
extern uint16_t _TRACE_HANDLE_IOREQ_DSTATE;
extern uint16_t _TRACE_HANDLE_IOREQ_READ_DSTATE;
extern uint16_t _TRACE_HANDLE_IOREQ_WRITE_DSTATE;
extern uint16_t _TRACE_CPU_IOREQ_PIO_DSTATE;
extern uint16_t _TRACE_CPU_IOREQ_PIO_READ_REG_DSTATE;
extern uint16_t _TRACE_CPU_IOREQ_PIO_WRITE_REG_DSTATE;
extern uint16_t _TRACE_CPU_IOREQ_MOVE_DSTATE;
extern uint16_t _TRACE_XEN_MAP_RESOURCE_IOREQ_DSTATE;
extern uint16_t _TRACE_CPU_IOREQ_CONFIG_READ_DSTATE;
extern uint16_t _TRACE_CPU_IOREQ_CONFIG_WRITE_DSTATE;
extern uint16_t _TRACE_CPU_GET_IOREQ_FROM_SHARED_MEMORY_REQ_NOT_READY_DSTATE;
extern uint16_t _TRACE_XEN_MAIN_LOOP_PREPARE_INIT_CPU_DSTATE;
extern uint16_t _TRACE_XEN_MAP_IOREQ_SERVER_SHARED_PAGE_DSTATE;
extern uint16_t _TRACE_XEN_MAP_IOREQ_SERVER_BUFFERED_IO_PAGE_DSTATE;
extern uint16_t _TRACE_XEN_MAP_IOREQ_SERVER_BUFFERED_IO_EVTCHN_DSTATE;
extern uint16_t _TRACE_DESTROY_HVM_DOMAIN_CANNOT_ACQUIRE_HANDLE_DSTATE;
extern uint16_t _TRACE_DESTROY_HVM_DOMAIN_FAILED_ACTION_DSTATE;
extern uint16_t _TRACE_DESTROY_HVM_DOMAIN_ACTION_DSTATE;
extern uint16_t _TRACE_XEN_MAP_CACHE_DSTATE;
extern uint16_t _TRACE_XEN_REMAP_BUCKET_DSTATE;
extern uint16_t _TRACE_XEN_MAP_CACHE_RETURN_DSTATE;
extern uint16_t _TRACE_XEN_MAP_CACHE_INIT_DSTATE;
extern uint16_t _TRACE_XEN_REPLACE_CACHE_ENTRY_DUMMY_DSTATE;
extern uint16_t _TRACE_XEN_INVALIDATE_MAP_CACHE_ENTRY_UNLOCKED_NOT_FOUND_DSTATE;
extern uint16_t _TRACE_XEN_INVALIDATE_MAP_CACHE_ENTRY_UNLOCKED_FOUND_DSTATE;
extern uint16_t _TRACE_XEN_INVALIDATE_MAP_CACHE_ENTRY_UNLOCKED_MISS_DSTATE;
extern uint16_t _TRACE_XEN_REPLACE_CACHE_ENTRY_UNLOCKED_COULD_NOT_UPDATE_ENTRY_DSTATE;
extern uint16_t _TRACE_XEN_RAM_ADDR_FROM_MAPCACHE_NOT_FOUND_DSTATE;
extern uint16_t _TRACE_XEN_RAM_ADDR_FROM_MAPCACHE_FOUND_DSTATE;
extern uint16_t _TRACE_XEN_RAM_ADDR_FROM_MAPCACHE_NOT_IN_CACHE_DSTATE;
extern uint16_t _TRACE_XEN_REPLACE_CACHE_ENTRY_UNLOCKED_DSTATE;
extern uint16_t _TRACE_XEN_INVALIDATE_MAP_CACHE_DSTATE;
#define TRACE_XEN_DEFAULT_IOREQ_SERVER_ENABLED 1
#define TRACE_XEN_IOREQ_SERVER_CREATE_ENABLED 1
#define TRACE_XEN_IOREQ_SERVER_DESTROY_ENABLED 1
#define TRACE_XEN_IOREQ_SERVER_STATE_ENABLED 1
#define TRACE_XEN_MAP_MMIO_RANGE_ENABLED 1
#define TRACE_XEN_UNMAP_MMIO_RANGE_ENABLED 1
#define TRACE_XEN_MAP_PORTIO_RANGE_ENABLED 1
#define TRACE_XEN_UNMAP_PORTIO_RANGE_ENABLED 1
#define TRACE_XEN_MAP_PCIDEV_ENABLED 1
#define TRACE_XEN_UNMAP_PCIDEV_ENABLED 1
#define TRACE_XEN_DOMID_RESTRICT_ENABLED 1
#define TRACE_XEN_BUS_REALIZE_ENABLED 1
#define TRACE_XEN_BUS_UNREALIZE_ENABLED 1
#define TRACE_XEN_BUS_ENUMERATE_ENABLED 1
#define TRACE_XEN_BUS_CLEANUP_ENABLED 1
#define TRACE_XEN_BUS_TYPE_ENUMERATE_ENABLED 1
#define TRACE_XEN_BUS_BACKEND_CREATE_ENABLED 1
#define TRACE_XEN_BUS_DEVICE_CLEANUP_ENABLED 1
#define TRACE_XEN_BUS_ADD_WATCH_ENABLED 1
#define TRACE_XEN_BUS_REMOVE_WATCH_ENABLED 1
#define TRACE_XEN_DEVICE_REALIZE_ENABLED 1
#define TRACE_XEN_DEVICE_UNREALIZE_ENABLED 1
#define TRACE_XEN_DEVICE_BACKEND_STATE_ENABLED 1
#define TRACE_XEN_DEVICE_BACKEND_ONLINE_ENABLED 1
#define TRACE_XEN_DEVICE_BACKEND_CHANGED_ENABLED 1
#define TRACE_XEN_DEVICE_FRONTEND_STATE_ENABLED 1
#define TRACE_XEN_DEVICE_FRONTEND_CHANGED_ENABLED 1
#define TRACE_XEN_DEVICE_UNPLUG_ENABLED 1
#define TRACE_XEN_DEVICE_ADD_WATCH_ENABLED 1
#define TRACE_XEN_DEVICE_REMOVE_WATCH_ENABLED 1
#define TRACE_XS_NODE_CREATE_ENABLED 1
#define TRACE_XS_NODE_DESTROY_ENABLED 1
#define TRACE_XS_NODE_VPRINTF_ENABLED 1
#define TRACE_XS_NODE_VSCANF_ENABLED 1
#define TRACE_XS_NODE_WATCH_ENABLED 1
#define TRACE_XS_NODE_UNWATCH_ENABLED 1
#define TRACE_XEN_RAM_ALLOC_ENABLED 1
#define TRACE_XEN_CLIENT_SET_MEMORY_ENABLED 1
#define TRACE_HANDLE_IOREQ_ENABLED 1
#define TRACE_HANDLE_IOREQ_READ_ENABLED 1
#define TRACE_HANDLE_IOREQ_WRITE_ENABLED 1
#define TRACE_CPU_IOREQ_PIO_ENABLED 1
#define TRACE_CPU_IOREQ_PIO_READ_REG_ENABLED 1
#define TRACE_CPU_IOREQ_PIO_WRITE_REG_ENABLED 1
#define TRACE_CPU_IOREQ_MOVE_ENABLED 1
#define TRACE_XEN_MAP_RESOURCE_IOREQ_ENABLED 1
#define TRACE_CPU_IOREQ_CONFIG_READ_ENABLED 1
#define TRACE_CPU_IOREQ_CONFIG_WRITE_ENABLED 1
#define TRACE_CPU_GET_IOREQ_FROM_SHARED_MEMORY_REQ_NOT_READY_ENABLED 1
#define TRACE_XEN_MAIN_LOOP_PREPARE_INIT_CPU_ENABLED 1
#define TRACE_XEN_MAP_IOREQ_SERVER_SHARED_PAGE_ENABLED 1
#define TRACE_XEN_MAP_IOREQ_SERVER_BUFFERED_IO_PAGE_ENABLED 1
#define TRACE_XEN_MAP_IOREQ_SERVER_BUFFERED_IO_EVTCHN_ENABLED 1
#define TRACE_DESTROY_HVM_DOMAIN_CANNOT_ACQUIRE_HANDLE_ENABLED 1
#define TRACE_DESTROY_HVM_DOMAIN_FAILED_ACTION_ENABLED 1
#define TRACE_DESTROY_HVM_DOMAIN_ACTION_ENABLED 1
#define TRACE_XEN_MAP_CACHE_ENABLED 1
#define TRACE_XEN_REMAP_BUCKET_ENABLED 1
#define TRACE_XEN_MAP_CACHE_RETURN_ENABLED 1
#define TRACE_XEN_MAP_CACHE_INIT_ENABLED 1
#define TRACE_XEN_REPLACE_CACHE_ENTRY_DUMMY_ENABLED 1
#define TRACE_XEN_INVALIDATE_MAP_CACHE_ENTRY_UNLOCKED_NOT_FOUND_ENABLED 1
#define TRACE_XEN_INVALIDATE_MAP_CACHE_ENTRY_UNLOCKED_FOUND_ENABLED 1
#define TRACE_XEN_INVALIDATE_MAP_CACHE_ENTRY_UNLOCKED_MISS_ENABLED 1
#define TRACE_XEN_REPLACE_CACHE_ENTRY_UNLOCKED_COULD_NOT_UPDATE_ENTRY_ENABLED 1
#define TRACE_XEN_RAM_ADDR_FROM_MAPCACHE_NOT_FOUND_ENABLED 1
#define TRACE_XEN_RAM_ADDR_FROM_MAPCACHE_FOUND_ENABLED 1
#define TRACE_XEN_RAM_ADDR_FROM_MAPCACHE_NOT_IN_CACHE_ENABLED 1
#define TRACE_XEN_REPLACE_CACHE_ENTRY_UNLOCKED_ENABLED 1
#define TRACE_XEN_INVALIDATE_MAP_CACHE_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_XEN_DEFAULT_IOREQ_SERVER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DEFAULT_IOREQ_SERVER) || \
    false)

static inline void _nocheck__trace_xen_default_ioreq_server(void)
{
    if (trace_event_get_state(TRACE_XEN_DEFAULT_IOREQ_SERVER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 4 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_default_ioreq_server " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 238 "trace/trace-hw_xen.h"
        } else {
#line 4 "../hw/xen/trace-events"
            qemu_log("xen_default_ioreq_server " "" "\n");
#line 242 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_default_ioreq_server(void)
{
    if (true) {
        _nocheck__trace_xen_default_ioreq_server();
    }
}

#define TRACE_XEN_IOREQ_SERVER_CREATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_IOREQ_SERVER_CREATE) || \
    false)

static inline void _nocheck__trace_xen_ioreq_server_create(uint32_t id)
{
    if (trace_event_get_state(TRACE_XEN_IOREQ_SERVER_CREATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 5 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_ioreq_server_create " "id: %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id);
#line 269 "trace/trace-hw_xen.h"
        } else {
#line 5 "../hw/xen/trace-events"
            qemu_log("xen_ioreq_server_create " "id: %u" "\n", id);
#line 273 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_ioreq_server_create(uint32_t id)
{
    if (true) {
        _nocheck__trace_xen_ioreq_server_create(id);
    }
}

#define TRACE_XEN_IOREQ_SERVER_DESTROY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_IOREQ_SERVER_DESTROY) || \
    false)

static inline void _nocheck__trace_xen_ioreq_server_destroy(uint32_t id)
{
    if (trace_event_get_state(TRACE_XEN_IOREQ_SERVER_DESTROY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 6 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_ioreq_server_destroy " "id: %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id);
#line 300 "trace/trace-hw_xen.h"
        } else {
#line 6 "../hw/xen/trace-events"
            qemu_log("xen_ioreq_server_destroy " "id: %u" "\n", id);
#line 304 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_ioreq_server_destroy(uint32_t id)
{
    if (true) {
        _nocheck__trace_xen_ioreq_server_destroy(id);
    }
}

#define TRACE_XEN_IOREQ_SERVER_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_IOREQ_SERVER_STATE) || \
    false)

static inline void _nocheck__trace_xen_ioreq_server_state(uint32_t id, bool enable)
{
    if (trace_event_get_state(TRACE_XEN_IOREQ_SERVER_STATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 7 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_ioreq_server_state " "id: %u: enable: %i" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, enable);
#line 331 "trace/trace-hw_xen.h"
        } else {
#line 7 "../hw/xen/trace-events"
            qemu_log("xen_ioreq_server_state " "id: %u: enable: %i" "\n", id, enable);
#line 335 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_ioreq_server_state(uint32_t id, bool enable)
{
    if (true) {
        _nocheck__trace_xen_ioreq_server_state(id, enable);
    }
}

#define TRACE_XEN_MAP_MMIO_RANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_MAP_MMIO_RANGE) || \
    false)

static inline void _nocheck__trace_xen_map_mmio_range(uint32_t id, uint64_t start_addr, uint64_t end_addr)
{
    if (trace_event_get_state(TRACE_XEN_MAP_MMIO_RANGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 8 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_map_mmio_range " "id: %u start: 0x%"PRIx64" end: 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, start_addr, end_addr);
#line 362 "trace/trace-hw_xen.h"
        } else {
#line 8 "../hw/xen/trace-events"
            qemu_log("xen_map_mmio_range " "id: %u start: 0x%"PRIx64" end: 0x%"PRIx64 "\n", id, start_addr, end_addr);
#line 366 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_map_mmio_range(uint32_t id, uint64_t start_addr, uint64_t end_addr)
{
    if (true) {
        _nocheck__trace_xen_map_mmio_range(id, start_addr, end_addr);
    }
}

#define TRACE_XEN_UNMAP_MMIO_RANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_UNMAP_MMIO_RANGE) || \
    false)

static inline void _nocheck__trace_xen_unmap_mmio_range(uint32_t id, uint64_t start_addr, uint64_t end_addr)
{
    if (trace_event_get_state(TRACE_XEN_UNMAP_MMIO_RANGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 9 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_unmap_mmio_range " "id: %u start: 0x%"PRIx64" end: 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, start_addr, end_addr);
#line 393 "trace/trace-hw_xen.h"
        } else {
#line 9 "../hw/xen/trace-events"
            qemu_log("xen_unmap_mmio_range " "id: %u start: 0x%"PRIx64" end: 0x%"PRIx64 "\n", id, start_addr, end_addr);
#line 397 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_unmap_mmio_range(uint32_t id, uint64_t start_addr, uint64_t end_addr)
{
    if (true) {
        _nocheck__trace_xen_unmap_mmio_range(id, start_addr, end_addr);
    }
}

#define TRACE_XEN_MAP_PORTIO_RANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_MAP_PORTIO_RANGE) || \
    false)

static inline void _nocheck__trace_xen_map_portio_range(uint32_t id, uint64_t start_addr, uint64_t end_addr)
{
    if (trace_event_get_state(TRACE_XEN_MAP_PORTIO_RANGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 10 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_map_portio_range " "id: %u start: 0x%"PRIx64" end: 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, start_addr, end_addr);
#line 424 "trace/trace-hw_xen.h"
        } else {
#line 10 "../hw/xen/trace-events"
            qemu_log("xen_map_portio_range " "id: %u start: 0x%"PRIx64" end: 0x%"PRIx64 "\n", id, start_addr, end_addr);
#line 428 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_map_portio_range(uint32_t id, uint64_t start_addr, uint64_t end_addr)
{
    if (true) {
        _nocheck__trace_xen_map_portio_range(id, start_addr, end_addr);
    }
}

#define TRACE_XEN_UNMAP_PORTIO_RANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_UNMAP_PORTIO_RANGE) || \
    false)

static inline void _nocheck__trace_xen_unmap_portio_range(uint32_t id, uint64_t start_addr, uint64_t end_addr)
{
    if (trace_event_get_state(TRACE_XEN_UNMAP_PORTIO_RANGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 11 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_unmap_portio_range " "id: %u start: 0x%"PRIx64" end: 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, start_addr, end_addr);
#line 455 "trace/trace-hw_xen.h"
        } else {
#line 11 "../hw/xen/trace-events"
            qemu_log("xen_unmap_portio_range " "id: %u start: 0x%"PRIx64" end: 0x%"PRIx64 "\n", id, start_addr, end_addr);
#line 459 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_unmap_portio_range(uint32_t id, uint64_t start_addr, uint64_t end_addr)
{
    if (true) {
        _nocheck__trace_xen_unmap_portio_range(id, start_addr, end_addr);
    }
}

#define TRACE_XEN_MAP_PCIDEV_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_MAP_PCIDEV) || \
    false)

static inline void _nocheck__trace_xen_map_pcidev(uint32_t id, uint8_t bus, uint8_t dev, uint8_t func)
{
    if (trace_event_get_state(TRACE_XEN_MAP_PCIDEV) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 12 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_map_pcidev " "id: %u bdf: %02x.%02x.%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, bus, dev, func);
#line 486 "trace/trace-hw_xen.h"
        } else {
#line 12 "../hw/xen/trace-events"
            qemu_log("xen_map_pcidev " "id: %u bdf: %02x.%02x.%02x" "\n", id, bus, dev, func);
#line 490 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_map_pcidev(uint32_t id, uint8_t bus, uint8_t dev, uint8_t func)
{
    if (true) {
        _nocheck__trace_xen_map_pcidev(id, bus, dev, func);
    }
}

#define TRACE_XEN_UNMAP_PCIDEV_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_UNMAP_PCIDEV) || \
    false)

static inline void _nocheck__trace_xen_unmap_pcidev(uint32_t id, uint8_t bus, uint8_t dev, uint8_t func)
{
    if (trace_event_get_state(TRACE_XEN_UNMAP_PCIDEV) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 13 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_unmap_pcidev " "id: %u bdf: %02x.%02x.%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, bus, dev, func);
#line 517 "trace/trace-hw_xen.h"
        } else {
#line 13 "../hw/xen/trace-events"
            qemu_log("xen_unmap_pcidev " "id: %u bdf: %02x.%02x.%02x" "\n", id, bus, dev, func);
#line 521 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_unmap_pcidev(uint32_t id, uint8_t bus, uint8_t dev, uint8_t func)
{
    if (true) {
        _nocheck__trace_xen_unmap_pcidev(id, bus, dev, func);
    }
}

#define TRACE_XEN_DOMID_RESTRICT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DOMID_RESTRICT) || \
    false)

static inline void _nocheck__trace_xen_domid_restrict(int err)
{
    if (trace_event_get_state(TRACE_XEN_DOMID_RESTRICT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 14 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_domid_restrict " "err: %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , err);
#line 548 "trace/trace-hw_xen.h"
        } else {
#line 14 "../hw/xen/trace-events"
            qemu_log("xen_domid_restrict " "err: %u" "\n", err);
#line 552 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_domid_restrict(int err)
{
    if (true) {
        _nocheck__trace_xen_domid_restrict(err);
    }
}

#define TRACE_XEN_BUS_REALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BUS_REALIZE) || \
    false)

static inline void _nocheck__trace_xen_bus_realize(void)
{
    if (trace_event_get_state(TRACE_XEN_BUS_REALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 17 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_bus_realize " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 579 "trace/trace-hw_xen.h"
        } else {
#line 17 "../hw/xen/trace-events"
            qemu_log("xen_bus_realize " "" "\n");
#line 583 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_bus_realize(void)
{
    if (true) {
        _nocheck__trace_xen_bus_realize();
    }
}

#define TRACE_XEN_BUS_UNREALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BUS_UNREALIZE) || \
    false)

static inline void _nocheck__trace_xen_bus_unrealize(void)
{
    if (trace_event_get_state(TRACE_XEN_BUS_UNREALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 18 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_bus_unrealize " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 610 "trace/trace-hw_xen.h"
        } else {
#line 18 "../hw/xen/trace-events"
            qemu_log("xen_bus_unrealize " "" "\n");
#line 614 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_bus_unrealize(void)
{
    if (true) {
        _nocheck__trace_xen_bus_unrealize();
    }
}

#define TRACE_XEN_BUS_ENUMERATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BUS_ENUMERATE) || \
    false)

static inline void _nocheck__trace_xen_bus_enumerate(void)
{
    if (trace_event_get_state(TRACE_XEN_BUS_ENUMERATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 19 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_bus_enumerate " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 641 "trace/trace-hw_xen.h"
        } else {
#line 19 "../hw/xen/trace-events"
            qemu_log("xen_bus_enumerate " "" "\n");
#line 645 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_bus_enumerate(void)
{
    if (true) {
        _nocheck__trace_xen_bus_enumerate();
    }
}

#define TRACE_XEN_BUS_CLEANUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BUS_CLEANUP) || \
    false)

static inline void _nocheck__trace_xen_bus_cleanup(void)
{
    if (trace_event_get_state(TRACE_XEN_BUS_CLEANUP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 20 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_bus_cleanup " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 672 "trace/trace-hw_xen.h"
        } else {
#line 20 "../hw/xen/trace-events"
            qemu_log("xen_bus_cleanup " "" "\n");
#line 676 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_bus_cleanup(void)
{
    if (true) {
        _nocheck__trace_xen_bus_cleanup();
    }
}

#define TRACE_XEN_BUS_TYPE_ENUMERATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BUS_TYPE_ENUMERATE) || \
    false)

static inline void _nocheck__trace_xen_bus_type_enumerate(const char * type)
{
    if (trace_event_get_state(TRACE_XEN_BUS_TYPE_ENUMERATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 21 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_bus_type_enumerate " "type: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type);
#line 703 "trace/trace-hw_xen.h"
        } else {
#line 21 "../hw/xen/trace-events"
            qemu_log("xen_bus_type_enumerate " "type: %s" "\n", type);
#line 707 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_bus_type_enumerate(const char * type)
{
    if (true) {
        _nocheck__trace_xen_bus_type_enumerate(type);
    }
}

#define TRACE_XEN_BUS_BACKEND_CREATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BUS_BACKEND_CREATE) || \
    false)

static inline void _nocheck__trace_xen_bus_backend_create(const char * type, const char * path)
{
    if (trace_event_get_state(TRACE_XEN_BUS_BACKEND_CREATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 22 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_bus_backend_create " "type: %s path: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, path);
#line 734 "trace/trace-hw_xen.h"
        } else {
#line 22 "../hw/xen/trace-events"
            qemu_log("xen_bus_backend_create " "type: %s path: %s" "\n", type, path);
#line 738 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_bus_backend_create(const char * type, const char * path)
{
    if (true) {
        _nocheck__trace_xen_bus_backend_create(type, path);
    }
}

#define TRACE_XEN_BUS_DEVICE_CLEANUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BUS_DEVICE_CLEANUP) || \
    false)

static inline void _nocheck__trace_xen_bus_device_cleanup(const char * type, char * name)
{
    if (trace_event_get_state(TRACE_XEN_BUS_DEVICE_CLEANUP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 23 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_bus_device_cleanup " "type: %s name: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, name);
#line 765 "trace/trace-hw_xen.h"
        } else {
#line 23 "../hw/xen/trace-events"
            qemu_log("xen_bus_device_cleanup " "type: %s name: %s" "\n", type, name);
#line 769 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_bus_device_cleanup(const char * type, char * name)
{
    if (true) {
        _nocheck__trace_xen_bus_device_cleanup(type, name);
    }
}

#define TRACE_XEN_BUS_ADD_WATCH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BUS_ADD_WATCH) || \
    false)

static inline void _nocheck__trace_xen_bus_add_watch(const char * node, const char * key)
{
    if (trace_event_get_state(TRACE_XEN_BUS_ADD_WATCH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 24 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_bus_add_watch " "node: %s key: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , node, key);
#line 796 "trace/trace-hw_xen.h"
        } else {
#line 24 "../hw/xen/trace-events"
            qemu_log("xen_bus_add_watch " "node: %s key: %s" "\n", node, key);
#line 800 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_bus_add_watch(const char * node, const char * key)
{
    if (true) {
        _nocheck__trace_xen_bus_add_watch(node, key);
    }
}

#define TRACE_XEN_BUS_REMOVE_WATCH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BUS_REMOVE_WATCH) || \
    false)

static inline void _nocheck__trace_xen_bus_remove_watch(const char * node, const char * key)
{
    if (trace_event_get_state(TRACE_XEN_BUS_REMOVE_WATCH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 25 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_bus_remove_watch " "node: %s key: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , node, key);
#line 827 "trace/trace-hw_xen.h"
        } else {
#line 25 "../hw/xen/trace-events"
            qemu_log("xen_bus_remove_watch " "node: %s key: %s" "\n", node, key);
#line 831 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_bus_remove_watch(const char * node, const char * key)
{
    if (true) {
        _nocheck__trace_xen_bus_remove_watch(node, key);
    }
}

#define TRACE_XEN_DEVICE_REALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DEVICE_REALIZE) || \
    false)

static inline void _nocheck__trace_xen_device_realize(const char * type, char * name)
{
    if (trace_event_get_state(TRACE_XEN_DEVICE_REALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 26 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_device_realize " "type: %s name: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, name);
#line 858 "trace/trace-hw_xen.h"
        } else {
#line 26 "../hw/xen/trace-events"
            qemu_log("xen_device_realize " "type: %s name: %s" "\n", type, name);
#line 862 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_device_realize(const char * type, char * name)
{
    if (true) {
        _nocheck__trace_xen_device_realize(type, name);
    }
}

#define TRACE_XEN_DEVICE_UNREALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DEVICE_UNREALIZE) || \
    false)

static inline void _nocheck__trace_xen_device_unrealize(const char * type, char * name)
{
    if (trace_event_get_state(TRACE_XEN_DEVICE_UNREALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 27 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_device_unrealize " "type: %s name: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, name);
#line 889 "trace/trace-hw_xen.h"
        } else {
#line 27 "../hw/xen/trace-events"
            qemu_log("xen_device_unrealize " "type: %s name: %s" "\n", type, name);
#line 893 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_device_unrealize(const char * type, char * name)
{
    if (true) {
        _nocheck__trace_xen_device_unrealize(type, name);
    }
}

#define TRACE_XEN_DEVICE_BACKEND_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DEVICE_BACKEND_STATE) || \
    false)

static inline void _nocheck__trace_xen_device_backend_state(const char * type, char * name, const char * state)
{
    if (trace_event_get_state(TRACE_XEN_DEVICE_BACKEND_STATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 28 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_device_backend_state " "type: %s name: %s -> %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, name, state);
#line 920 "trace/trace-hw_xen.h"
        } else {
#line 28 "../hw/xen/trace-events"
            qemu_log("xen_device_backend_state " "type: %s name: %s -> %s" "\n", type, name, state);
#line 924 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_device_backend_state(const char * type, char * name, const char * state)
{
    if (true) {
        _nocheck__trace_xen_device_backend_state(type, name, state);
    }
}

#define TRACE_XEN_DEVICE_BACKEND_ONLINE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DEVICE_BACKEND_ONLINE) || \
    false)

static inline void _nocheck__trace_xen_device_backend_online(const char * type, char * name, bool online)
{
    if (trace_event_get_state(TRACE_XEN_DEVICE_BACKEND_ONLINE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 29 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_device_backend_online " "type: %s name: %s -> %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, name, online);
#line 951 "trace/trace-hw_xen.h"
        } else {
#line 29 "../hw/xen/trace-events"
            qemu_log("xen_device_backend_online " "type: %s name: %s -> %u" "\n", type, name, online);
#line 955 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_device_backend_online(const char * type, char * name, bool online)
{
    if (true) {
        _nocheck__trace_xen_device_backend_online(type, name, online);
    }
}

#define TRACE_XEN_DEVICE_BACKEND_CHANGED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DEVICE_BACKEND_CHANGED) || \
    false)

static inline void _nocheck__trace_xen_device_backend_changed(const char * type, char * name)
{
    if (trace_event_get_state(TRACE_XEN_DEVICE_BACKEND_CHANGED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 30 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_device_backend_changed " "type: %s name: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, name);
#line 982 "trace/trace-hw_xen.h"
        } else {
#line 30 "../hw/xen/trace-events"
            qemu_log("xen_device_backend_changed " "type: %s name: %s" "\n", type, name);
#line 986 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_device_backend_changed(const char * type, char * name)
{
    if (true) {
        _nocheck__trace_xen_device_backend_changed(type, name);
    }
}

#define TRACE_XEN_DEVICE_FRONTEND_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DEVICE_FRONTEND_STATE) || \
    false)

static inline void _nocheck__trace_xen_device_frontend_state(const char * type, char * name, const char * state)
{
    if (trace_event_get_state(TRACE_XEN_DEVICE_FRONTEND_STATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 31 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_device_frontend_state " "type: %s name: %s -> %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, name, state);
#line 1013 "trace/trace-hw_xen.h"
        } else {
#line 31 "../hw/xen/trace-events"
            qemu_log("xen_device_frontend_state " "type: %s name: %s -> %s" "\n", type, name, state);
#line 1017 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_device_frontend_state(const char * type, char * name, const char * state)
{
    if (true) {
        _nocheck__trace_xen_device_frontend_state(type, name, state);
    }
}

#define TRACE_XEN_DEVICE_FRONTEND_CHANGED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DEVICE_FRONTEND_CHANGED) || \
    false)

static inline void _nocheck__trace_xen_device_frontend_changed(const char * type, char * name)
{
    if (trace_event_get_state(TRACE_XEN_DEVICE_FRONTEND_CHANGED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 32 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_device_frontend_changed " "type: %s name: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, name);
#line 1044 "trace/trace-hw_xen.h"
        } else {
#line 32 "../hw/xen/trace-events"
            qemu_log("xen_device_frontend_changed " "type: %s name: %s" "\n", type, name);
#line 1048 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_device_frontend_changed(const char * type, char * name)
{
    if (true) {
        _nocheck__trace_xen_device_frontend_changed(type, name);
    }
}

#define TRACE_XEN_DEVICE_UNPLUG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DEVICE_UNPLUG) || \
    false)

static inline void _nocheck__trace_xen_device_unplug(const char * type, char * name)
{
    if (trace_event_get_state(TRACE_XEN_DEVICE_UNPLUG) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 33 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_device_unplug " "type: %s name: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, name);
#line 1075 "trace/trace-hw_xen.h"
        } else {
#line 33 "../hw/xen/trace-events"
            qemu_log("xen_device_unplug " "type: %s name: %s" "\n", type, name);
#line 1079 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_device_unplug(const char * type, char * name)
{
    if (true) {
        _nocheck__trace_xen_device_unplug(type, name);
    }
}

#define TRACE_XEN_DEVICE_ADD_WATCH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DEVICE_ADD_WATCH) || \
    false)

static inline void _nocheck__trace_xen_device_add_watch(const char * type, char * name, const char * node, const char * key)
{
    if (trace_event_get_state(TRACE_XEN_DEVICE_ADD_WATCH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 34 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_device_add_watch " "type: %s name: %s node: %s key: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, name, node, key);
#line 1106 "trace/trace-hw_xen.h"
        } else {
#line 34 "../hw/xen/trace-events"
            qemu_log("xen_device_add_watch " "type: %s name: %s node: %s key: %s" "\n", type, name, node, key);
#line 1110 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_device_add_watch(const char * type, char * name, const char * node, const char * key)
{
    if (true) {
        _nocheck__trace_xen_device_add_watch(type, name, node, key);
    }
}

#define TRACE_XEN_DEVICE_REMOVE_WATCH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DEVICE_REMOVE_WATCH) || \
    false)

static inline void _nocheck__trace_xen_device_remove_watch(const char * type, char * name, const char * node, const char * key)
{
    if (trace_event_get_state(TRACE_XEN_DEVICE_REMOVE_WATCH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 35 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_device_remove_watch " "type: %s name: %s node: %s key: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, name, node, key);
#line 1137 "trace/trace-hw_xen.h"
        } else {
#line 35 "../hw/xen/trace-events"
            qemu_log("xen_device_remove_watch " "type: %s name: %s node: %s key: %s" "\n", type, name, node, key);
#line 1141 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_device_remove_watch(const char * type, char * name, const char * node, const char * key)
{
    if (true) {
        _nocheck__trace_xen_device_remove_watch(type, name, node, key);
    }
}

#define TRACE_XS_NODE_CREATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XS_NODE_CREATE) || \
    false)

static inline void _nocheck__trace_xs_node_create(const char * node)
{
    if (trace_event_get_state(TRACE_XS_NODE_CREATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 38 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xs_node_create " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , node);
#line 1168 "trace/trace-hw_xen.h"
        } else {
#line 38 "../hw/xen/trace-events"
            qemu_log("xs_node_create " "%s" "\n", node);
#line 1172 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xs_node_create(const char * node)
{
    if (true) {
        _nocheck__trace_xs_node_create(node);
    }
}

#define TRACE_XS_NODE_DESTROY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XS_NODE_DESTROY) || \
    false)

static inline void _nocheck__trace_xs_node_destroy(const char * node)
{
    if (trace_event_get_state(TRACE_XS_NODE_DESTROY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 39 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xs_node_destroy " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , node);
#line 1199 "trace/trace-hw_xen.h"
        } else {
#line 39 "../hw/xen/trace-events"
            qemu_log("xs_node_destroy " "%s" "\n", node);
#line 1203 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xs_node_destroy(const char * node)
{
    if (true) {
        _nocheck__trace_xs_node_destroy(node);
    }
}

#define TRACE_XS_NODE_VPRINTF_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XS_NODE_VPRINTF) || \
    false)

static inline void _nocheck__trace_xs_node_vprintf(char * path, char * value)
{
    if (trace_event_get_state(TRACE_XS_NODE_VPRINTF) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 40 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xs_node_vprintf " "%s %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , path, value);
#line 1230 "trace/trace-hw_xen.h"
        } else {
#line 40 "../hw/xen/trace-events"
            qemu_log("xs_node_vprintf " "%s %s" "\n", path, value);
#line 1234 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xs_node_vprintf(char * path, char * value)
{
    if (true) {
        _nocheck__trace_xs_node_vprintf(path, value);
    }
}

#define TRACE_XS_NODE_VSCANF_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XS_NODE_VSCANF) || \
    false)

static inline void _nocheck__trace_xs_node_vscanf(char * path, char * value)
{
    if (trace_event_get_state(TRACE_XS_NODE_VSCANF) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 41 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xs_node_vscanf " "%s %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , path, value);
#line 1261 "trace/trace-hw_xen.h"
        } else {
#line 41 "../hw/xen/trace-events"
            qemu_log("xs_node_vscanf " "%s %s" "\n", path, value);
#line 1265 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xs_node_vscanf(char * path, char * value)
{
    if (true) {
        _nocheck__trace_xs_node_vscanf(path, value);
    }
}

#define TRACE_XS_NODE_WATCH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XS_NODE_WATCH) || \
    false)

static inline void _nocheck__trace_xs_node_watch(char * path)
{
    if (trace_event_get_state(TRACE_XS_NODE_WATCH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 42 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xs_node_watch " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , path);
#line 1292 "trace/trace-hw_xen.h"
        } else {
#line 42 "../hw/xen/trace-events"
            qemu_log("xs_node_watch " "%s" "\n", path);
#line 1296 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xs_node_watch(char * path)
{
    if (true) {
        _nocheck__trace_xs_node_watch(path);
    }
}

#define TRACE_XS_NODE_UNWATCH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XS_NODE_UNWATCH) || \
    false)

static inline void _nocheck__trace_xs_node_unwatch(char * path)
{
    if (trace_event_get_state(TRACE_XS_NODE_UNWATCH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 43 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xs_node_unwatch " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , path);
#line 1323 "trace/trace-hw_xen.h"
        } else {
#line 43 "../hw/xen/trace-events"
            qemu_log("xs_node_unwatch " "%s" "\n", path);
#line 1327 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xs_node_unwatch(char * path)
{
    if (true) {
        _nocheck__trace_xs_node_unwatch(path);
    }
}

#define TRACE_XEN_RAM_ALLOC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_RAM_ALLOC) || \
    false)

static inline void _nocheck__trace_xen_ram_alloc(unsigned long ram_addr, unsigned long size)
{
    if (trace_event_get_state(TRACE_XEN_RAM_ALLOC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 46 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_ram_alloc " "requested: 0x%lx, size 0x%lx" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ram_addr, size);
#line 1354 "trace/trace-hw_xen.h"
        } else {
#line 46 "../hw/xen/trace-events"
            qemu_log("xen_ram_alloc " "requested: 0x%lx, size 0x%lx" "\n", ram_addr, size);
#line 1358 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_ram_alloc(unsigned long ram_addr, unsigned long size)
{
    if (true) {
        _nocheck__trace_xen_ram_alloc(ram_addr, size);
    }
}

#define TRACE_XEN_CLIENT_SET_MEMORY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_CLIENT_SET_MEMORY) || \
    false)

static inline void _nocheck__trace_xen_client_set_memory(uint64_t start_addr, unsigned long size, bool log_dirty)
{
    if (trace_event_get_state(TRACE_XEN_CLIENT_SET_MEMORY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 47 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_client_set_memory " "0x%"PRIx64" size 0x%lx, log_dirty %i" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , start_addr, size, log_dirty);
#line 1385 "trace/trace-hw_xen.h"
        } else {
#line 47 "../hw/xen/trace-events"
            qemu_log("xen_client_set_memory " "0x%"PRIx64" size 0x%lx, log_dirty %i" "\n", start_addr, size, log_dirty);
#line 1389 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_client_set_memory(uint64_t start_addr, unsigned long size, bool log_dirty)
{
    if (true) {
        _nocheck__trace_xen_client_set_memory(start_addr, size, log_dirty);
    }
}

#define TRACE_HANDLE_IOREQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HANDLE_IOREQ) || \
    false)

static inline void _nocheck__trace_handle_ioreq(void * req, uint32_t type, uint32_t dir, uint32_t df, uint32_t data_is_ptr, uint64_t addr, uint64_t data, uint32_t count, uint32_t size)
{
    if (trace_event_get_state(TRACE_HANDLE_IOREQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 48 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:handle_ioreq " "I/O=%p type=%d dir=%d df=%d ptr=%d port=0x%"PRIx64" data=0x%"PRIx64" count=%d size=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , req, type, dir, df, data_is_ptr, addr, data, count, size);
#line 1416 "trace/trace-hw_xen.h"
        } else {
#line 48 "../hw/xen/trace-events"
            qemu_log("handle_ioreq " "I/O=%p type=%d dir=%d df=%d ptr=%d port=0x%"PRIx64" data=0x%"PRIx64" count=%d size=%d" "\n", req, type, dir, df, data_is_ptr, addr, data, count, size);
#line 1420 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_handle_ioreq(void * req, uint32_t type, uint32_t dir, uint32_t df, uint32_t data_is_ptr, uint64_t addr, uint64_t data, uint32_t count, uint32_t size)
{
    if (true) {
        _nocheck__trace_handle_ioreq(req, type, dir, df, data_is_ptr, addr, data, count, size);
    }
}

#define TRACE_HANDLE_IOREQ_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HANDLE_IOREQ_READ) || \
    false)

static inline void _nocheck__trace_handle_ioreq_read(void * req, uint32_t type, uint32_t df, uint32_t data_is_ptr, uint64_t addr, uint64_t data, uint32_t count, uint32_t size)
{
    if (trace_event_get_state(TRACE_HANDLE_IOREQ_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 49 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:handle_ioreq_read " "I/O=%p read type=%d df=%d ptr=%d port=0x%"PRIx64" data=0x%"PRIx64" count=%d size=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , req, type, df, data_is_ptr, addr, data, count, size);
#line 1447 "trace/trace-hw_xen.h"
        } else {
#line 49 "../hw/xen/trace-events"
            qemu_log("handle_ioreq_read " "I/O=%p read type=%d df=%d ptr=%d port=0x%"PRIx64" data=0x%"PRIx64" count=%d size=%d" "\n", req, type, df, data_is_ptr, addr, data, count, size);
#line 1451 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_handle_ioreq_read(void * req, uint32_t type, uint32_t df, uint32_t data_is_ptr, uint64_t addr, uint64_t data, uint32_t count, uint32_t size)
{
    if (true) {
        _nocheck__trace_handle_ioreq_read(req, type, df, data_is_ptr, addr, data, count, size);
    }
}

#define TRACE_HANDLE_IOREQ_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HANDLE_IOREQ_WRITE) || \
    false)

static inline void _nocheck__trace_handle_ioreq_write(void * req, uint32_t type, uint32_t df, uint32_t data_is_ptr, uint64_t addr, uint64_t data, uint32_t count, uint32_t size)
{
    if (trace_event_get_state(TRACE_HANDLE_IOREQ_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 50 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:handle_ioreq_write " "I/O=%p write type=%d df=%d ptr=%d port=0x%"PRIx64" data=0x%"PRIx64" count=%d size=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , req, type, df, data_is_ptr, addr, data, count, size);
#line 1478 "trace/trace-hw_xen.h"
        } else {
#line 50 "../hw/xen/trace-events"
            qemu_log("handle_ioreq_write " "I/O=%p write type=%d df=%d ptr=%d port=0x%"PRIx64" data=0x%"PRIx64" count=%d size=%d" "\n", req, type, df, data_is_ptr, addr, data, count, size);
#line 1482 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_handle_ioreq_write(void * req, uint32_t type, uint32_t df, uint32_t data_is_ptr, uint64_t addr, uint64_t data, uint32_t count, uint32_t size)
{
    if (true) {
        _nocheck__trace_handle_ioreq_write(req, type, df, data_is_ptr, addr, data, count, size);
    }
}

#define TRACE_CPU_IOREQ_PIO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPU_IOREQ_PIO) || \
    false)

static inline void _nocheck__trace_cpu_ioreq_pio(void * req, uint32_t dir, uint32_t df, uint32_t data_is_ptr, uint64_t addr, uint64_t data, uint32_t count, uint32_t size)
{
    if (trace_event_get_state(TRACE_CPU_IOREQ_PIO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 51 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:cpu_ioreq_pio " "I/O=%p pio dir=%d df=%d ptr=%d port=0x%"PRIx64" data=0x%"PRIx64" count=%d size=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , req, dir, df, data_is_ptr, addr, data, count, size);
#line 1509 "trace/trace-hw_xen.h"
        } else {
#line 51 "../hw/xen/trace-events"
            qemu_log("cpu_ioreq_pio " "I/O=%p pio dir=%d df=%d ptr=%d port=0x%"PRIx64" data=0x%"PRIx64" count=%d size=%d" "\n", req, dir, df, data_is_ptr, addr, data, count, size);
#line 1513 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_cpu_ioreq_pio(void * req, uint32_t dir, uint32_t df, uint32_t data_is_ptr, uint64_t addr, uint64_t data, uint32_t count, uint32_t size)
{
    if (true) {
        _nocheck__trace_cpu_ioreq_pio(req, dir, df, data_is_ptr, addr, data, count, size);
    }
}

#define TRACE_CPU_IOREQ_PIO_READ_REG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPU_IOREQ_PIO_READ_REG) || \
    false)

static inline void _nocheck__trace_cpu_ioreq_pio_read_reg(void * req, uint64_t data, uint64_t addr, uint32_t size)
{
    if (trace_event_get_state(TRACE_CPU_IOREQ_PIO_READ_REG) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 52 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:cpu_ioreq_pio_read_reg " "I/O=%p pio read reg data=0x%"PRIx64" port=0x%"PRIx64" size=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , req, data, addr, size);
#line 1540 "trace/trace-hw_xen.h"
        } else {
#line 52 "../hw/xen/trace-events"
            qemu_log("cpu_ioreq_pio_read_reg " "I/O=%p pio read reg data=0x%"PRIx64" port=0x%"PRIx64" size=%d" "\n", req, data, addr, size);
#line 1544 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_cpu_ioreq_pio_read_reg(void * req, uint64_t data, uint64_t addr, uint32_t size)
{
    if (true) {
        _nocheck__trace_cpu_ioreq_pio_read_reg(req, data, addr, size);
    }
}

#define TRACE_CPU_IOREQ_PIO_WRITE_REG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPU_IOREQ_PIO_WRITE_REG) || \
    false)

static inline void _nocheck__trace_cpu_ioreq_pio_write_reg(void * req, uint64_t data, uint64_t addr, uint32_t size)
{
    if (trace_event_get_state(TRACE_CPU_IOREQ_PIO_WRITE_REG) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 53 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:cpu_ioreq_pio_write_reg " "I/O=%p pio write reg data=0x%"PRIx64" port=0x%"PRIx64" size=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , req, data, addr, size);
#line 1571 "trace/trace-hw_xen.h"
        } else {
#line 53 "../hw/xen/trace-events"
            qemu_log("cpu_ioreq_pio_write_reg " "I/O=%p pio write reg data=0x%"PRIx64" port=0x%"PRIx64" size=%d" "\n", req, data, addr, size);
#line 1575 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_cpu_ioreq_pio_write_reg(void * req, uint64_t data, uint64_t addr, uint32_t size)
{
    if (true) {
        _nocheck__trace_cpu_ioreq_pio_write_reg(req, data, addr, size);
    }
}

#define TRACE_CPU_IOREQ_MOVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPU_IOREQ_MOVE) || \
    false)

static inline void _nocheck__trace_cpu_ioreq_move(void * req, uint32_t dir, uint32_t df, uint32_t data_is_ptr, uint64_t addr, uint64_t data, uint32_t count, uint32_t size)
{
    if (trace_event_get_state(TRACE_CPU_IOREQ_MOVE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 54 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:cpu_ioreq_move " "I/O=%p copy dir=%d df=%d ptr=%d port=0x%"PRIx64" data=0x%"PRIx64" count=%d size=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , req, dir, df, data_is_ptr, addr, data, count, size);
#line 1602 "trace/trace-hw_xen.h"
        } else {
#line 54 "../hw/xen/trace-events"
            qemu_log("cpu_ioreq_move " "I/O=%p copy dir=%d df=%d ptr=%d port=0x%"PRIx64" data=0x%"PRIx64" count=%d size=%d" "\n", req, dir, df, data_is_ptr, addr, data, count, size);
#line 1606 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_cpu_ioreq_move(void * req, uint32_t dir, uint32_t df, uint32_t data_is_ptr, uint64_t addr, uint64_t data, uint32_t count, uint32_t size)
{
    if (true) {
        _nocheck__trace_cpu_ioreq_move(req, dir, df, data_is_ptr, addr, data, count, size);
    }
}

#define TRACE_XEN_MAP_RESOURCE_IOREQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_MAP_RESOURCE_IOREQ) || \
    false)

static inline void _nocheck__trace_xen_map_resource_ioreq(uint32_t id, void * addr)
{
    if (trace_event_get_state(TRACE_XEN_MAP_RESOURCE_IOREQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 55 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_map_resource_ioreq " "id: %u addr: %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, addr);
#line 1633 "trace/trace-hw_xen.h"
        } else {
#line 55 "../hw/xen/trace-events"
            qemu_log("xen_map_resource_ioreq " "id: %u addr: %p" "\n", id, addr);
#line 1637 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_map_resource_ioreq(uint32_t id, void * addr)
{
    if (true) {
        _nocheck__trace_xen_map_resource_ioreq(id, addr);
    }
}

#define TRACE_CPU_IOREQ_CONFIG_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPU_IOREQ_CONFIG_READ) || \
    false)

static inline void _nocheck__trace_cpu_ioreq_config_read(void * req, uint32_t sbdf, uint32_t reg, uint32_t size, uint32_t data)
{
    if (trace_event_get_state(TRACE_CPU_IOREQ_CONFIG_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 56 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:cpu_ioreq_config_read " "I/O=%p sbdf=0x%x reg=%u size=%u data=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , req, sbdf, reg, size, data);
#line 1664 "trace/trace-hw_xen.h"
        } else {
#line 56 "../hw/xen/trace-events"
            qemu_log("cpu_ioreq_config_read " "I/O=%p sbdf=0x%x reg=%u size=%u data=0x%x" "\n", req, sbdf, reg, size, data);
#line 1668 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_cpu_ioreq_config_read(void * req, uint32_t sbdf, uint32_t reg, uint32_t size, uint32_t data)
{
    if (true) {
        _nocheck__trace_cpu_ioreq_config_read(req, sbdf, reg, size, data);
    }
}

#define TRACE_CPU_IOREQ_CONFIG_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPU_IOREQ_CONFIG_WRITE) || \
    false)

static inline void _nocheck__trace_cpu_ioreq_config_write(void * req, uint32_t sbdf, uint32_t reg, uint32_t size, uint32_t data)
{
    if (trace_event_get_state(TRACE_CPU_IOREQ_CONFIG_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 57 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:cpu_ioreq_config_write " "I/O=%p sbdf=0x%x reg=%u size=%u data=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , req, sbdf, reg, size, data);
#line 1695 "trace/trace-hw_xen.h"
        } else {
#line 57 "../hw/xen/trace-events"
            qemu_log("cpu_ioreq_config_write " "I/O=%p sbdf=0x%x reg=%u size=%u data=0x%x" "\n", req, sbdf, reg, size, data);
#line 1699 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_cpu_ioreq_config_write(void * req, uint32_t sbdf, uint32_t reg, uint32_t size, uint32_t data)
{
    if (true) {
        _nocheck__trace_cpu_ioreq_config_write(req, sbdf, reg, size, data);
    }
}

#define TRACE_CPU_GET_IOREQ_FROM_SHARED_MEMORY_REQ_NOT_READY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPU_GET_IOREQ_FROM_SHARED_MEMORY_REQ_NOT_READY) || \
    false)

static inline void _nocheck__trace_cpu_get_ioreq_from_shared_memory_req_not_ready(int state, int data_is_ptr, uint64_t addr, uint64_t data, uint32_t count, uint32_t size)
{
    if (trace_event_get_state(TRACE_CPU_GET_IOREQ_FROM_SHARED_MEMORY_REQ_NOT_READY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 58 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:cpu_get_ioreq_from_shared_memory_req_not_ready " "I/O request not ready: 0x%x, ptr: 0x%x, port: 0x%"PRIx64", data: 0x%"PRIx64", count: %u, size: %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, data_is_ptr, addr, data, count, size);
#line 1726 "trace/trace-hw_xen.h"
        } else {
#line 58 "../hw/xen/trace-events"
            qemu_log("cpu_get_ioreq_from_shared_memory_req_not_ready " "I/O request not ready: 0x%x, ptr: 0x%x, port: 0x%"PRIx64", data: 0x%"PRIx64", count: %u, size: %u" "\n", state, data_is_ptr, addr, data, count, size);
#line 1730 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_cpu_get_ioreq_from_shared_memory_req_not_ready(int state, int data_is_ptr, uint64_t addr, uint64_t data, uint32_t count, uint32_t size)
{
    if (true) {
        _nocheck__trace_cpu_get_ioreq_from_shared_memory_req_not_ready(state, data_is_ptr, addr, data, count, size);
    }
}

#define TRACE_XEN_MAIN_LOOP_PREPARE_INIT_CPU_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_MAIN_LOOP_PREPARE_INIT_CPU) || \
    false)

static inline void _nocheck__trace_xen_main_loop_prepare_init_cpu(int id, void * cpu)
{
    if (trace_event_get_state(TRACE_XEN_MAIN_LOOP_PREPARE_INIT_CPU) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 59 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_main_loop_prepare_init_cpu " "cpu_by_vcpu_id[%d]=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, cpu);
#line 1757 "trace/trace-hw_xen.h"
        } else {
#line 59 "../hw/xen/trace-events"
            qemu_log("xen_main_loop_prepare_init_cpu " "cpu_by_vcpu_id[%d]=%p" "\n", id, cpu);
#line 1761 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_main_loop_prepare_init_cpu(int id, void * cpu)
{
    if (true) {
        _nocheck__trace_xen_main_loop_prepare_init_cpu(id, cpu);
    }
}

#define TRACE_XEN_MAP_IOREQ_SERVER_SHARED_PAGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_MAP_IOREQ_SERVER_SHARED_PAGE) || \
    false)

static inline void _nocheck__trace_xen_map_ioreq_server_shared_page(long unsigned int ioreq_pfn)
{
    if (trace_event_get_state(TRACE_XEN_MAP_IOREQ_SERVER_SHARED_PAGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 60 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_map_ioreq_server_shared_page " "shared page at pfn 0x%lx" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioreq_pfn);
#line 1788 "trace/trace-hw_xen.h"
        } else {
#line 60 "../hw/xen/trace-events"
            qemu_log("xen_map_ioreq_server_shared_page " "shared page at pfn 0x%lx" "\n", ioreq_pfn);
#line 1792 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_map_ioreq_server_shared_page(long unsigned int ioreq_pfn)
{
    if (true) {
        _nocheck__trace_xen_map_ioreq_server_shared_page(ioreq_pfn);
    }
}

#define TRACE_XEN_MAP_IOREQ_SERVER_BUFFERED_IO_PAGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_MAP_IOREQ_SERVER_BUFFERED_IO_PAGE) || \
    false)

static inline void _nocheck__trace_xen_map_ioreq_server_buffered_io_page(long unsigned int ioreq_pfn)
{
    if (trace_event_get_state(TRACE_XEN_MAP_IOREQ_SERVER_BUFFERED_IO_PAGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 61 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_map_ioreq_server_buffered_io_page " "buffered io page at pfn 0x%lx" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioreq_pfn);
#line 1819 "trace/trace-hw_xen.h"
        } else {
#line 61 "../hw/xen/trace-events"
            qemu_log("xen_map_ioreq_server_buffered_io_page " "buffered io page at pfn 0x%lx" "\n", ioreq_pfn);
#line 1823 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_map_ioreq_server_buffered_io_page(long unsigned int ioreq_pfn)
{
    if (true) {
        _nocheck__trace_xen_map_ioreq_server_buffered_io_page(ioreq_pfn);
    }
}

#define TRACE_XEN_MAP_IOREQ_SERVER_BUFFERED_IO_EVTCHN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_MAP_IOREQ_SERVER_BUFFERED_IO_EVTCHN) || \
    false)

static inline void _nocheck__trace_xen_map_ioreq_server_buffered_io_evtchn(int bufioreq_evtchn)
{
    if (trace_event_get_state(TRACE_XEN_MAP_IOREQ_SERVER_BUFFERED_IO_EVTCHN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 62 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_map_ioreq_server_buffered_io_evtchn " "buffered io evtchn is 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bufioreq_evtchn);
#line 1850 "trace/trace-hw_xen.h"
        } else {
#line 62 "../hw/xen/trace-events"
            qemu_log("xen_map_ioreq_server_buffered_io_evtchn " "buffered io evtchn is 0x%x" "\n", bufioreq_evtchn);
#line 1854 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_map_ioreq_server_buffered_io_evtchn(int bufioreq_evtchn)
{
    if (true) {
        _nocheck__trace_xen_map_ioreq_server_buffered_io_evtchn(bufioreq_evtchn);
    }
}

#define TRACE_DESTROY_HVM_DOMAIN_CANNOT_ACQUIRE_HANDLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_DESTROY_HVM_DOMAIN_CANNOT_ACQUIRE_HANDLE) || \
    false)

static inline void _nocheck__trace_destroy_hvm_domain_cannot_acquire_handle(void)
{
    if (trace_event_get_state(TRACE_DESTROY_HVM_DOMAIN_CANNOT_ACQUIRE_HANDLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 63 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:destroy_hvm_domain_cannot_acquire_handle " "Cannot acquire xenctrl handle" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1881 "trace/trace-hw_xen.h"
        } else {
#line 63 "../hw/xen/trace-events"
            qemu_log("destroy_hvm_domain_cannot_acquire_handle " "Cannot acquire xenctrl handle" "\n");
#line 1885 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_destroy_hvm_domain_cannot_acquire_handle(void)
{
    if (true) {
        _nocheck__trace_destroy_hvm_domain_cannot_acquire_handle();
    }
}

#define TRACE_DESTROY_HVM_DOMAIN_FAILED_ACTION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_DESTROY_HVM_DOMAIN_FAILED_ACTION) || \
    false)

static inline void _nocheck__trace_destroy_hvm_domain_failed_action(const char * action, int sts, char * errno_s)
{
    if (trace_event_get_state(TRACE_DESTROY_HVM_DOMAIN_FAILED_ACTION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 64 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:destroy_hvm_domain_failed_action " "xc_domain_shutdown failed to issue %s, sts %d, %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , action, sts, errno_s);
#line 1912 "trace/trace-hw_xen.h"
        } else {
#line 64 "../hw/xen/trace-events"
            qemu_log("destroy_hvm_domain_failed_action " "xc_domain_shutdown failed to issue %s, sts %d, %s" "\n", action, sts, errno_s);
#line 1916 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_destroy_hvm_domain_failed_action(const char * action, int sts, char * errno_s)
{
    if (true) {
        _nocheck__trace_destroy_hvm_domain_failed_action(action, sts, errno_s);
    }
}

#define TRACE_DESTROY_HVM_DOMAIN_ACTION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_DESTROY_HVM_DOMAIN_ACTION) || \
    false)

static inline void _nocheck__trace_destroy_hvm_domain_action(int xen_domid, const char * action)
{
    if (trace_event_get_state(TRACE_DESTROY_HVM_DOMAIN_ACTION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 65 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:destroy_hvm_domain_action " "Issued domain %d %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , xen_domid, action);
#line 1943 "trace/trace-hw_xen.h"
        } else {
#line 65 "../hw/xen/trace-events"
            qemu_log("destroy_hvm_domain_action " "Issued domain %d %s" "\n", xen_domid, action);
#line 1947 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_destroy_hvm_domain_action(int xen_domid, const char * action)
{
    if (true) {
        _nocheck__trace_destroy_hvm_domain_action(xen_domid, action);
    }
}

#define TRACE_XEN_MAP_CACHE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_MAP_CACHE) || \
    false)

static inline void _nocheck__trace_xen_map_cache(uint64_t phys_addr)
{
    if (trace_event_get_state(TRACE_XEN_MAP_CACHE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 68 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_map_cache " "want 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , phys_addr);
#line 1974 "trace/trace-hw_xen.h"
        } else {
#line 68 "../hw/xen/trace-events"
            qemu_log("xen_map_cache " "want 0x%"PRIx64 "\n", phys_addr);
#line 1978 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_map_cache(uint64_t phys_addr)
{
    if (true) {
        _nocheck__trace_xen_map_cache(phys_addr);
    }
}

#define TRACE_XEN_REMAP_BUCKET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_REMAP_BUCKET) || \
    false)

static inline void _nocheck__trace_xen_remap_bucket(uint64_t index)
{
    if (trace_event_get_state(TRACE_XEN_REMAP_BUCKET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 69 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_remap_bucket " "index 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index);
#line 2005 "trace/trace-hw_xen.h"
        } else {
#line 69 "../hw/xen/trace-events"
            qemu_log("xen_remap_bucket " "index 0x%"PRIx64 "\n", index);
#line 2009 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_remap_bucket(uint64_t index)
{
    if (true) {
        _nocheck__trace_xen_remap_bucket(index);
    }
}

#define TRACE_XEN_MAP_CACHE_RETURN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_MAP_CACHE_RETURN) || \
    false)

static inline void _nocheck__trace_xen_map_cache_return(void* ptr)
{
    if (trace_event_get_state(TRACE_XEN_MAP_CACHE_RETURN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 70 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_map_cache_return " "%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ptr);
#line 2036 "trace/trace-hw_xen.h"
        } else {
#line 70 "../hw/xen/trace-events"
            qemu_log("xen_map_cache_return " "%p" "\n", ptr);
#line 2040 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_map_cache_return(void* ptr)
{
    if (true) {
        _nocheck__trace_xen_map_cache_return(ptr);
    }
}

#define TRACE_XEN_MAP_CACHE_INIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_MAP_CACHE_INIT) || \
    false)

static inline void _nocheck__trace_xen_map_cache_init(uint64_t nr_buckets, uint64_t size)
{
    if (trace_event_get_state(TRACE_XEN_MAP_CACHE_INIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 71 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_map_cache_init " "nr_buckets = 0x%"PRIx64" size 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , nr_buckets, size);
#line 2067 "trace/trace-hw_xen.h"
        } else {
#line 71 "../hw/xen/trace-events"
            qemu_log("xen_map_cache_init " "nr_buckets = 0x%"PRIx64" size 0x%"PRIx64 "\n", nr_buckets, size);
#line 2071 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_map_cache_init(uint64_t nr_buckets, uint64_t size)
{
    if (true) {
        _nocheck__trace_xen_map_cache_init(nr_buckets, size);
    }
}

#define TRACE_XEN_REPLACE_CACHE_ENTRY_DUMMY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_REPLACE_CACHE_ENTRY_DUMMY) || \
    false)

static inline void _nocheck__trace_xen_replace_cache_entry_dummy(uint64_t old_phys_addr, uint64_t new_phys_addr)
{
    if (trace_event_get_state(TRACE_XEN_REPLACE_CACHE_ENTRY_DUMMY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 72 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_replace_cache_entry_dummy " "Replacing a dummy mapcache entry for 0x%"PRIx64" with 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , old_phys_addr, new_phys_addr);
#line 2098 "trace/trace-hw_xen.h"
        } else {
#line 72 "../hw/xen/trace-events"
            qemu_log("xen_replace_cache_entry_dummy " "Replacing a dummy mapcache entry for 0x%"PRIx64" with 0x%"PRIx64 "\n", old_phys_addr, new_phys_addr);
#line 2102 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_replace_cache_entry_dummy(uint64_t old_phys_addr, uint64_t new_phys_addr)
{
    if (true) {
        _nocheck__trace_xen_replace_cache_entry_dummy(old_phys_addr, new_phys_addr);
    }
}

#define TRACE_XEN_INVALIDATE_MAP_CACHE_ENTRY_UNLOCKED_NOT_FOUND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_INVALIDATE_MAP_CACHE_ENTRY_UNLOCKED_NOT_FOUND) || \
    false)

static inline void _nocheck__trace_xen_invalidate_map_cache_entry_unlocked_not_found(void * p)
{
    if (trace_event_get_state(TRACE_XEN_INVALIDATE_MAP_CACHE_ENTRY_UNLOCKED_NOT_FOUND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 73 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_invalidate_map_cache_entry_unlocked_not_found " "could not find %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , p);
#line 2129 "trace/trace-hw_xen.h"
        } else {
#line 73 "../hw/xen/trace-events"
            qemu_log("xen_invalidate_map_cache_entry_unlocked_not_found " "could not find %p" "\n", p);
#line 2133 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_invalidate_map_cache_entry_unlocked_not_found(void * p)
{
    if (true) {
        _nocheck__trace_xen_invalidate_map_cache_entry_unlocked_not_found(p);
    }
}

#define TRACE_XEN_INVALIDATE_MAP_CACHE_ENTRY_UNLOCKED_FOUND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_INVALIDATE_MAP_CACHE_ENTRY_UNLOCKED_FOUND) || \
    false)

static inline void _nocheck__trace_xen_invalidate_map_cache_entry_unlocked_found(uint64_t addr, void * p)
{
    if (trace_event_get_state(TRACE_XEN_INVALIDATE_MAP_CACHE_ENTRY_UNLOCKED_FOUND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 74 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_invalidate_map_cache_entry_unlocked_found " "   0x%"PRIx64" -> %p is present" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, p);
#line 2160 "trace/trace-hw_xen.h"
        } else {
#line 74 "../hw/xen/trace-events"
            qemu_log("xen_invalidate_map_cache_entry_unlocked_found " "   0x%"PRIx64" -> %p is present" "\n", addr, p);
#line 2164 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_invalidate_map_cache_entry_unlocked_found(uint64_t addr, void * p)
{
    if (true) {
        _nocheck__trace_xen_invalidate_map_cache_entry_unlocked_found(addr, p);
    }
}

#define TRACE_XEN_INVALIDATE_MAP_CACHE_ENTRY_UNLOCKED_MISS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_INVALIDATE_MAP_CACHE_ENTRY_UNLOCKED_MISS) || \
    false)

static inline void _nocheck__trace_xen_invalidate_map_cache_entry_unlocked_miss(void * buffer)
{
    if (trace_event_get_state(TRACE_XEN_INVALIDATE_MAP_CACHE_ENTRY_UNLOCKED_MISS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 75 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_invalidate_map_cache_entry_unlocked_miss " "Trying to unmap address %p that is not in the mapcache" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , buffer);
#line 2191 "trace/trace-hw_xen.h"
        } else {
#line 75 "../hw/xen/trace-events"
            qemu_log("xen_invalidate_map_cache_entry_unlocked_miss " "Trying to unmap address %p that is not in the mapcache" "\n", buffer);
#line 2195 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_invalidate_map_cache_entry_unlocked_miss(void * buffer)
{
    if (true) {
        _nocheck__trace_xen_invalidate_map_cache_entry_unlocked_miss(buffer);
    }
}

#define TRACE_XEN_REPLACE_CACHE_ENTRY_UNLOCKED_COULD_NOT_UPDATE_ENTRY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_REPLACE_CACHE_ENTRY_UNLOCKED_COULD_NOT_UPDATE_ENTRY) || \
    false)

static inline void _nocheck__trace_xen_replace_cache_entry_unlocked_could_not_update_entry(uint64_t old_phys_addr)
{
    if (trace_event_get_state(TRACE_XEN_REPLACE_CACHE_ENTRY_UNLOCKED_COULD_NOT_UPDATE_ENTRY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 76 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_replace_cache_entry_unlocked_could_not_update_entry " "Unable to update a mapcache entry for 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , old_phys_addr);
#line 2222 "trace/trace-hw_xen.h"
        } else {
#line 76 "../hw/xen/trace-events"
            qemu_log("xen_replace_cache_entry_unlocked_could_not_update_entry " "Unable to update a mapcache entry for 0x%"PRIx64 "\n", old_phys_addr);
#line 2226 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_replace_cache_entry_unlocked_could_not_update_entry(uint64_t old_phys_addr)
{
    if (true) {
        _nocheck__trace_xen_replace_cache_entry_unlocked_could_not_update_entry(old_phys_addr);
    }
}

#define TRACE_XEN_RAM_ADDR_FROM_MAPCACHE_NOT_FOUND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_RAM_ADDR_FROM_MAPCACHE_NOT_FOUND) || \
    false)

static inline void _nocheck__trace_xen_ram_addr_from_mapcache_not_found(void * p)
{
    if (trace_event_get_state(TRACE_XEN_RAM_ADDR_FROM_MAPCACHE_NOT_FOUND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 77 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_ram_addr_from_mapcache_not_found " "could not find %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , p);
#line 2253 "trace/trace-hw_xen.h"
        } else {
#line 77 "../hw/xen/trace-events"
            qemu_log("xen_ram_addr_from_mapcache_not_found " "could not find %p" "\n", p);
#line 2257 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_ram_addr_from_mapcache_not_found(void * p)
{
    if (true) {
        _nocheck__trace_xen_ram_addr_from_mapcache_not_found(p);
    }
}

#define TRACE_XEN_RAM_ADDR_FROM_MAPCACHE_FOUND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_RAM_ADDR_FROM_MAPCACHE_FOUND) || \
    false)

static inline void _nocheck__trace_xen_ram_addr_from_mapcache_found(uint64_t addr, void * p)
{
    if (trace_event_get_state(TRACE_XEN_RAM_ADDR_FROM_MAPCACHE_FOUND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 78 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_ram_addr_from_mapcache_found " "   0x%"PRIx64" -> %p is present" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, p);
#line 2284 "trace/trace-hw_xen.h"
        } else {
#line 78 "../hw/xen/trace-events"
            qemu_log("xen_ram_addr_from_mapcache_found " "   0x%"PRIx64" -> %p is present" "\n", addr, p);
#line 2288 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_ram_addr_from_mapcache_found(uint64_t addr, void * p)
{
    if (true) {
        _nocheck__trace_xen_ram_addr_from_mapcache_found(addr, p);
    }
}

#define TRACE_XEN_RAM_ADDR_FROM_MAPCACHE_NOT_IN_CACHE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_RAM_ADDR_FROM_MAPCACHE_NOT_IN_CACHE) || \
    false)

static inline void _nocheck__trace_xen_ram_addr_from_mapcache_not_in_cache(void * p)
{
    if (trace_event_get_state(TRACE_XEN_RAM_ADDR_FROM_MAPCACHE_NOT_IN_CACHE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 79 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_ram_addr_from_mapcache_not_in_cache " "Trying to find address %p that is not in the mapcache" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , p);
#line 2315 "trace/trace-hw_xen.h"
        } else {
#line 79 "../hw/xen/trace-events"
            qemu_log("xen_ram_addr_from_mapcache_not_in_cache " "Trying to find address %p that is not in the mapcache" "\n", p);
#line 2319 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_ram_addr_from_mapcache_not_in_cache(void * p)
{
    if (true) {
        _nocheck__trace_xen_ram_addr_from_mapcache_not_in_cache(p);
    }
}

#define TRACE_XEN_REPLACE_CACHE_ENTRY_UNLOCKED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_REPLACE_CACHE_ENTRY_UNLOCKED) || \
    false)

static inline void _nocheck__trace_xen_replace_cache_entry_unlocked(uint64_t old_phys_addr)
{
    if (trace_event_get_state(TRACE_XEN_REPLACE_CACHE_ENTRY_UNLOCKED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 80 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_replace_cache_entry_unlocked " "Trying to update an entry for 0x%"PRIx64" that is not in the mapcache" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , old_phys_addr);
#line 2346 "trace/trace-hw_xen.h"
        } else {
#line 80 "../hw/xen/trace-events"
            qemu_log("xen_replace_cache_entry_unlocked " "Trying to update an entry for 0x%"PRIx64" that is not in the mapcache" "\n", old_phys_addr);
#line 2350 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_replace_cache_entry_unlocked(uint64_t old_phys_addr)
{
    if (true) {
        _nocheck__trace_xen_replace_cache_entry_unlocked(old_phys_addr);
    }
}

#define TRACE_XEN_INVALIDATE_MAP_CACHE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_INVALIDATE_MAP_CACHE) || \
    false)

static inline void _nocheck__trace_xen_invalidate_map_cache(uint64_t paddr_index, void * vaddr_req)
{
    if (trace_event_get_state(TRACE_XEN_INVALIDATE_MAP_CACHE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 81 "../hw/xen/trace-events"
            qemu_log("%d@%zu.%06zu:xen_invalidate_map_cache " "Locked DMA mapping while invalidating mapcache 0x%"PRIx64" -> %p is present" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , paddr_index, vaddr_req);
#line 2377 "trace/trace-hw_xen.h"
        } else {
#line 81 "../hw/xen/trace-events"
            qemu_log("xen_invalidate_map_cache " "Locked DMA mapping while invalidating mapcache 0x%"PRIx64" -> %p is present" "\n", paddr_index, vaddr_req);
#line 2381 "trace/trace-hw_xen.h"
        }
    }
}

static inline void trace_xen_invalidate_map_cache(uint64_t paddr_index, void * vaddr_req)
{
    if (true) {
        _nocheck__trace_xen_invalidate_map_cache(paddr_index, vaddr_req);
    }
}
#endif /* TRACE_HW_XEN_GENERATED_TRACERS_H */
