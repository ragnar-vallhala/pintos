/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_BLOCK_GENERATED_TRACERS_H
#define TRACE_HW_BLOCK_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_FDC_IOPORT_READ_EVENT;
extern TraceEvent _TRACE_FDC_IOPORT_WRITE_EVENT;
extern TraceEvent _TRACE_FDCTRL_TC_PULSE_EVENT;
extern TraceEvent _TRACE_PFLASH_CHIP_ERASE_INVALID_EVENT;
extern TraceEvent _TRACE_PFLASH_CHIP_ERASE_START_EVENT;
extern TraceEvent _TRACE_PFLASH_DATA_READ_EVENT;
extern TraceEvent _TRACE_PFLASH_DATA_WRITE_EVENT;
extern TraceEvent _TRACE_PFLASH_DATA_WRITE_BLOCK_EVENT;
extern TraceEvent _TRACE_PFLASH_DEVICE_ID_EVENT;
extern TraceEvent _TRACE_PFLASH_DEVICE_INFO_EVENT;
extern TraceEvent _TRACE_PFLASH_ERASE_COMPLETE_EVENT;
extern TraceEvent _TRACE_PFLASH_ERASE_TIMEOUT_EVENT;
extern TraceEvent _TRACE_PFLASH_IO_READ_EVENT;
extern TraceEvent _TRACE_PFLASH_IO_WRITE_EVENT;
extern TraceEvent _TRACE_PFLASH_MANUFACTURER_ID_EVENT;
extern TraceEvent _TRACE_PFLASH_MODE_READ_ARRAY_EVENT;
extern TraceEvent _TRACE_PFLASH_POSTLOAD_CB_EVENT;
extern TraceEvent _TRACE_PFLASH_READ_DONE_EVENT;
extern TraceEvent _TRACE_PFLASH_READ_STATUS_EVENT;
extern TraceEvent _TRACE_PFLASH_READ_UNKNOWN_STATE_EVENT;
extern TraceEvent _TRACE_PFLASH_RESET_EVENT;
extern TraceEvent _TRACE_PFLASH_SECTOR_ERASE_START_EVENT;
extern TraceEvent _TRACE_PFLASH_TIMER_EXPIRED_EVENT;
extern TraceEvent _TRACE_PFLASH_UNLOCK0_FAILED_EVENT;
extern TraceEvent _TRACE_PFLASH_UNLOCK1_FAILED_EVENT;
extern TraceEvent _TRACE_PFLASH_UNSUPPORTED_DEVICE_CONFIGURATION_EVENT;
extern TraceEvent _TRACE_PFLASH_WRITE_EVENT;
extern TraceEvent _TRACE_PFLASH_WRITE_BLOCK_START_EVENT;
extern TraceEvent _TRACE_PFLASH_WRITE_BLOCK_FLUSH_EVENT;
extern TraceEvent _TRACE_PFLASH_WRITE_BLOCK_ABORT_EVENT;
extern TraceEvent _TRACE_PFLASH_WRITE_BLOCK_ERASE_EVENT;
extern TraceEvent _TRACE_PFLASH_WRITE_FAILED_EVENT;
extern TraceEvent _TRACE_PFLASH_WRITE_INVALID_EVENT;
extern TraceEvent _TRACE_PFLASH_WRITE_INVALID_COMMAND_EVENT;
extern TraceEvent _TRACE_PFLASH_WRITE_INVALID_STATE_EVENT;
extern TraceEvent _TRACE_PFLASH_WRITE_START_EVENT;
extern TraceEvent _TRACE_PFLASH_WRITE_UNKNOWN_EVENT;
extern TraceEvent _TRACE_VIRTIO_BLK_REQ_COMPLETE_EVENT;
extern TraceEvent _TRACE_VIRTIO_BLK_RW_COMPLETE_EVENT;
extern TraceEvent _TRACE_VIRTIO_BLK_ZONE_REPORT_COMPLETE_EVENT;
extern TraceEvent _TRACE_VIRTIO_BLK_ZONE_MGMT_COMPLETE_EVENT;
extern TraceEvent _TRACE_VIRTIO_BLK_ZONE_APPEND_COMPLETE_EVENT;
extern TraceEvent _TRACE_VIRTIO_BLK_HANDLE_WRITE_EVENT;
extern TraceEvent _TRACE_VIRTIO_BLK_HANDLE_READ_EVENT;
extern TraceEvent _TRACE_VIRTIO_BLK_SUBMIT_MULTIREQ_EVENT;
extern TraceEvent _TRACE_VIRTIO_BLK_HANDLE_ZONE_REPORT_EVENT;
extern TraceEvent _TRACE_VIRTIO_BLK_HANDLE_ZONE_MGMT_EVENT;
extern TraceEvent _TRACE_VIRTIO_BLK_HANDLE_ZONE_RESET_ALL_EVENT;
extern TraceEvent _TRACE_VIRTIO_BLK_HANDLE_ZONE_APPEND_EVENT;
extern TraceEvent _TRACE_HD_GEOMETRY_LCHS_GUESS_EVENT;
extern TraceEvent _TRACE_HD_GEOMETRY_GUESS_EVENT;
extern TraceEvent _TRACE_XEN_BLOCK_REALIZE_EVENT;
extern TraceEvent _TRACE_XEN_BLOCK_CONNECT_EVENT;
extern TraceEvent _TRACE_XEN_BLOCK_DISCONNECT_EVENT;
extern TraceEvent _TRACE_XEN_BLOCK_UNREALIZE_EVENT;
extern TraceEvent _TRACE_XEN_BLOCK_SIZE_EVENT;
extern TraceEvent _TRACE_XEN_DISK_REALIZE_EVENT;
extern TraceEvent _TRACE_XEN_DISK_UNREALIZE_EVENT;
extern TraceEvent _TRACE_XEN_CDROM_REALIZE_EVENT;
extern TraceEvent _TRACE_XEN_CDROM_UNREALIZE_EVENT;
extern TraceEvent _TRACE_XEN_BLOCK_BLOCKDEV_ADD_EVENT;
extern TraceEvent _TRACE_XEN_BLOCK_BLOCKDEV_DEL_EVENT;
extern TraceEvent _TRACE_XEN_BLOCK_DEVICE_CREATE_EVENT;
extern TraceEvent _TRACE_XEN_BLOCK_DEVICE_DESTROY_EVENT;
extern TraceEvent _TRACE_M25P80_FLASH_ERASE_EVENT;
extern TraceEvent _TRACE_M25P80_PROGRAMMING_ZERO_TO_ONE_EVENT;
extern TraceEvent _TRACE_M25P80_RESET_DONE_EVENT;
extern TraceEvent _TRACE_M25P80_COMMAND_DECODED_EVENT;
extern TraceEvent _TRACE_M25P80_COMPLETE_COLLECTING_EVENT;
extern TraceEvent _TRACE_M25P80_POPULATED_JEDEC_EVENT;
extern TraceEvent _TRACE_M25P80_CHIP_ERASE_EVENT;
extern TraceEvent _TRACE_M25P80_SELECT_EVENT;
extern TraceEvent _TRACE_M25P80_PAGE_PROGRAM_EVENT;
extern TraceEvent _TRACE_M25P80_TRANSFER_EVENT;
extern TraceEvent _TRACE_M25P80_READ_BYTE_EVENT;
extern TraceEvent _TRACE_M25P80_READ_DATA_EVENT;
extern TraceEvent _TRACE_M25P80_READ_SFDP_EVENT;
extern TraceEvent _TRACE_M25P80_BINDING_EVENT;
extern TraceEvent _TRACE_M25P80_BINDING_NO_BDRV_EVENT;
extern TraceEvent _TRACE_SWIM_ISMCTRL_READ_EVENT;
extern TraceEvent _TRACE_SWIM_ISMCTRL_WRITE_EVENT;
extern TraceEvent _TRACE_SWIM_IWMCTRL_READ_EVENT;
extern TraceEvent _TRACE_SWIM_IWMCTRL_WRITE_EVENT;
extern TraceEvent _TRACE_SWIM_SWITCH_TO_ISM_EVENT;
extern TraceEvent _TRACE_SWIM_SWITCH_TO_IWM_EVENT;
extern uint16_t _TRACE_FDC_IOPORT_READ_DSTATE;
extern uint16_t _TRACE_FDC_IOPORT_WRITE_DSTATE;
extern uint16_t _TRACE_FDCTRL_TC_PULSE_DSTATE;
extern uint16_t _TRACE_PFLASH_CHIP_ERASE_INVALID_DSTATE;
extern uint16_t _TRACE_PFLASH_CHIP_ERASE_START_DSTATE;
extern uint16_t _TRACE_PFLASH_DATA_READ_DSTATE;
extern uint16_t _TRACE_PFLASH_DATA_WRITE_DSTATE;
extern uint16_t _TRACE_PFLASH_DATA_WRITE_BLOCK_DSTATE;
extern uint16_t _TRACE_PFLASH_DEVICE_ID_DSTATE;
extern uint16_t _TRACE_PFLASH_DEVICE_INFO_DSTATE;
extern uint16_t _TRACE_PFLASH_ERASE_COMPLETE_DSTATE;
extern uint16_t _TRACE_PFLASH_ERASE_TIMEOUT_DSTATE;
extern uint16_t _TRACE_PFLASH_IO_READ_DSTATE;
extern uint16_t _TRACE_PFLASH_IO_WRITE_DSTATE;
extern uint16_t _TRACE_PFLASH_MANUFACTURER_ID_DSTATE;
extern uint16_t _TRACE_PFLASH_MODE_READ_ARRAY_DSTATE;
extern uint16_t _TRACE_PFLASH_POSTLOAD_CB_DSTATE;
extern uint16_t _TRACE_PFLASH_READ_DONE_DSTATE;
extern uint16_t _TRACE_PFLASH_READ_STATUS_DSTATE;
extern uint16_t _TRACE_PFLASH_READ_UNKNOWN_STATE_DSTATE;
extern uint16_t _TRACE_PFLASH_RESET_DSTATE;
extern uint16_t _TRACE_PFLASH_SECTOR_ERASE_START_DSTATE;
extern uint16_t _TRACE_PFLASH_TIMER_EXPIRED_DSTATE;
extern uint16_t _TRACE_PFLASH_UNLOCK0_FAILED_DSTATE;
extern uint16_t _TRACE_PFLASH_UNLOCK1_FAILED_DSTATE;
extern uint16_t _TRACE_PFLASH_UNSUPPORTED_DEVICE_CONFIGURATION_DSTATE;
extern uint16_t _TRACE_PFLASH_WRITE_DSTATE;
extern uint16_t _TRACE_PFLASH_WRITE_BLOCK_START_DSTATE;
extern uint16_t _TRACE_PFLASH_WRITE_BLOCK_FLUSH_DSTATE;
extern uint16_t _TRACE_PFLASH_WRITE_BLOCK_ABORT_DSTATE;
extern uint16_t _TRACE_PFLASH_WRITE_BLOCK_ERASE_DSTATE;
extern uint16_t _TRACE_PFLASH_WRITE_FAILED_DSTATE;
extern uint16_t _TRACE_PFLASH_WRITE_INVALID_DSTATE;
extern uint16_t _TRACE_PFLASH_WRITE_INVALID_COMMAND_DSTATE;
extern uint16_t _TRACE_PFLASH_WRITE_INVALID_STATE_DSTATE;
extern uint16_t _TRACE_PFLASH_WRITE_START_DSTATE;
extern uint16_t _TRACE_PFLASH_WRITE_UNKNOWN_DSTATE;
extern uint16_t _TRACE_VIRTIO_BLK_REQ_COMPLETE_DSTATE;
extern uint16_t _TRACE_VIRTIO_BLK_RW_COMPLETE_DSTATE;
extern uint16_t _TRACE_VIRTIO_BLK_ZONE_REPORT_COMPLETE_DSTATE;
extern uint16_t _TRACE_VIRTIO_BLK_ZONE_MGMT_COMPLETE_DSTATE;
extern uint16_t _TRACE_VIRTIO_BLK_ZONE_APPEND_COMPLETE_DSTATE;
extern uint16_t _TRACE_VIRTIO_BLK_HANDLE_WRITE_DSTATE;
extern uint16_t _TRACE_VIRTIO_BLK_HANDLE_READ_DSTATE;
extern uint16_t _TRACE_VIRTIO_BLK_SUBMIT_MULTIREQ_DSTATE;
extern uint16_t _TRACE_VIRTIO_BLK_HANDLE_ZONE_REPORT_DSTATE;
extern uint16_t _TRACE_VIRTIO_BLK_HANDLE_ZONE_MGMT_DSTATE;
extern uint16_t _TRACE_VIRTIO_BLK_HANDLE_ZONE_RESET_ALL_DSTATE;
extern uint16_t _TRACE_VIRTIO_BLK_HANDLE_ZONE_APPEND_DSTATE;
extern uint16_t _TRACE_HD_GEOMETRY_LCHS_GUESS_DSTATE;
extern uint16_t _TRACE_HD_GEOMETRY_GUESS_DSTATE;
extern uint16_t _TRACE_XEN_BLOCK_REALIZE_DSTATE;
extern uint16_t _TRACE_XEN_BLOCK_CONNECT_DSTATE;
extern uint16_t _TRACE_XEN_BLOCK_DISCONNECT_DSTATE;
extern uint16_t _TRACE_XEN_BLOCK_UNREALIZE_DSTATE;
extern uint16_t _TRACE_XEN_BLOCK_SIZE_DSTATE;
extern uint16_t _TRACE_XEN_DISK_REALIZE_DSTATE;
extern uint16_t _TRACE_XEN_DISK_UNREALIZE_DSTATE;
extern uint16_t _TRACE_XEN_CDROM_REALIZE_DSTATE;
extern uint16_t _TRACE_XEN_CDROM_UNREALIZE_DSTATE;
extern uint16_t _TRACE_XEN_BLOCK_BLOCKDEV_ADD_DSTATE;
extern uint16_t _TRACE_XEN_BLOCK_BLOCKDEV_DEL_DSTATE;
extern uint16_t _TRACE_XEN_BLOCK_DEVICE_CREATE_DSTATE;
extern uint16_t _TRACE_XEN_BLOCK_DEVICE_DESTROY_DSTATE;
extern uint16_t _TRACE_M25P80_FLASH_ERASE_DSTATE;
extern uint16_t _TRACE_M25P80_PROGRAMMING_ZERO_TO_ONE_DSTATE;
extern uint16_t _TRACE_M25P80_RESET_DONE_DSTATE;
extern uint16_t _TRACE_M25P80_COMMAND_DECODED_DSTATE;
extern uint16_t _TRACE_M25P80_COMPLETE_COLLECTING_DSTATE;
extern uint16_t _TRACE_M25P80_POPULATED_JEDEC_DSTATE;
extern uint16_t _TRACE_M25P80_CHIP_ERASE_DSTATE;
extern uint16_t _TRACE_M25P80_SELECT_DSTATE;
extern uint16_t _TRACE_M25P80_PAGE_PROGRAM_DSTATE;
extern uint16_t _TRACE_M25P80_TRANSFER_DSTATE;
extern uint16_t _TRACE_M25P80_READ_BYTE_DSTATE;
extern uint16_t _TRACE_M25P80_READ_DATA_DSTATE;
extern uint16_t _TRACE_M25P80_READ_SFDP_DSTATE;
extern uint16_t _TRACE_M25P80_BINDING_DSTATE;
extern uint16_t _TRACE_M25P80_BINDING_NO_BDRV_DSTATE;
extern uint16_t _TRACE_SWIM_ISMCTRL_READ_DSTATE;
extern uint16_t _TRACE_SWIM_ISMCTRL_WRITE_DSTATE;
extern uint16_t _TRACE_SWIM_IWMCTRL_READ_DSTATE;
extern uint16_t _TRACE_SWIM_IWMCTRL_WRITE_DSTATE;
extern uint16_t _TRACE_SWIM_SWITCH_TO_ISM_DSTATE;
extern uint16_t _TRACE_SWIM_SWITCH_TO_IWM_DSTATE;
#define TRACE_FDC_IOPORT_READ_ENABLED 1
#define TRACE_FDC_IOPORT_WRITE_ENABLED 1
#define TRACE_FDCTRL_TC_PULSE_ENABLED 1
#define TRACE_PFLASH_CHIP_ERASE_INVALID_ENABLED 1
#define TRACE_PFLASH_CHIP_ERASE_START_ENABLED 1
#define TRACE_PFLASH_DATA_READ_ENABLED 1
#define TRACE_PFLASH_DATA_WRITE_ENABLED 1
#define TRACE_PFLASH_DATA_WRITE_BLOCK_ENABLED 1
#define TRACE_PFLASH_DEVICE_ID_ENABLED 1
#define TRACE_PFLASH_DEVICE_INFO_ENABLED 1
#define TRACE_PFLASH_ERASE_COMPLETE_ENABLED 1
#define TRACE_PFLASH_ERASE_TIMEOUT_ENABLED 1
#define TRACE_PFLASH_IO_READ_ENABLED 1
#define TRACE_PFLASH_IO_WRITE_ENABLED 1
#define TRACE_PFLASH_MANUFACTURER_ID_ENABLED 1
#define TRACE_PFLASH_MODE_READ_ARRAY_ENABLED 1
#define TRACE_PFLASH_POSTLOAD_CB_ENABLED 1
#define TRACE_PFLASH_READ_DONE_ENABLED 1
#define TRACE_PFLASH_READ_STATUS_ENABLED 1
#define TRACE_PFLASH_READ_UNKNOWN_STATE_ENABLED 1
#define TRACE_PFLASH_RESET_ENABLED 1
#define TRACE_PFLASH_SECTOR_ERASE_START_ENABLED 1
#define TRACE_PFLASH_TIMER_EXPIRED_ENABLED 1
#define TRACE_PFLASH_UNLOCK0_FAILED_ENABLED 1
#define TRACE_PFLASH_UNLOCK1_FAILED_ENABLED 1
#define TRACE_PFLASH_UNSUPPORTED_DEVICE_CONFIGURATION_ENABLED 1
#define TRACE_PFLASH_WRITE_ENABLED 1
#define TRACE_PFLASH_WRITE_BLOCK_START_ENABLED 1
#define TRACE_PFLASH_WRITE_BLOCK_FLUSH_ENABLED 1
#define TRACE_PFLASH_WRITE_BLOCK_ABORT_ENABLED 1
#define TRACE_PFLASH_WRITE_BLOCK_ERASE_ENABLED 1
#define TRACE_PFLASH_WRITE_FAILED_ENABLED 1
#define TRACE_PFLASH_WRITE_INVALID_ENABLED 1
#define TRACE_PFLASH_WRITE_INVALID_COMMAND_ENABLED 1
#define TRACE_PFLASH_WRITE_INVALID_STATE_ENABLED 1
#define TRACE_PFLASH_WRITE_START_ENABLED 1
#define TRACE_PFLASH_WRITE_UNKNOWN_ENABLED 1
#define TRACE_VIRTIO_BLK_REQ_COMPLETE_ENABLED 1
#define TRACE_VIRTIO_BLK_RW_COMPLETE_ENABLED 1
#define TRACE_VIRTIO_BLK_ZONE_REPORT_COMPLETE_ENABLED 1
#define TRACE_VIRTIO_BLK_ZONE_MGMT_COMPLETE_ENABLED 1
#define TRACE_VIRTIO_BLK_ZONE_APPEND_COMPLETE_ENABLED 1
#define TRACE_VIRTIO_BLK_HANDLE_WRITE_ENABLED 1
#define TRACE_VIRTIO_BLK_HANDLE_READ_ENABLED 1
#define TRACE_VIRTIO_BLK_SUBMIT_MULTIREQ_ENABLED 1
#define TRACE_VIRTIO_BLK_HANDLE_ZONE_REPORT_ENABLED 1
#define TRACE_VIRTIO_BLK_HANDLE_ZONE_MGMT_ENABLED 1
#define TRACE_VIRTIO_BLK_HANDLE_ZONE_RESET_ALL_ENABLED 1
#define TRACE_VIRTIO_BLK_HANDLE_ZONE_APPEND_ENABLED 1
#define TRACE_HD_GEOMETRY_LCHS_GUESS_ENABLED 1
#define TRACE_HD_GEOMETRY_GUESS_ENABLED 1
#define TRACE_XEN_BLOCK_REALIZE_ENABLED 1
#define TRACE_XEN_BLOCK_CONNECT_ENABLED 1
#define TRACE_XEN_BLOCK_DISCONNECT_ENABLED 1
#define TRACE_XEN_BLOCK_UNREALIZE_ENABLED 1
#define TRACE_XEN_BLOCK_SIZE_ENABLED 1
#define TRACE_XEN_DISK_REALIZE_ENABLED 1
#define TRACE_XEN_DISK_UNREALIZE_ENABLED 1
#define TRACE_XEN_CDROM_REALIZE_ENABLED 1
#define TRACE_XEN_CDROM_UNREALIZE_ENABLED 1
#define TRACE_XEN_BLOCK_BLOCKDEV_ADD_ENABLED 1
#define TRACE_XEN_BLOCK_BLOCKDEV_DEL_ENABLED 1
#define TRACE_XEN_BLOCK_DEVICE_CREATE_ENABLED 1
#define TRACE_XEN_BLOCK_DEVICE_DESTROY_ENABLED 1
#define TRACE_M25P80_FLASH_ERASE_ENABLED 1
#define TRACE_M25P80_PROGRAMMING_ZERO_TO_ONE_ENABLED 1
#define TRACE_M25P80_RESET_DONE_ENABLED 1
#define TRACE_M25P80_COMMAND_DECODED_ENABLED 1
#define TRACE_M25P80_COMPLETE_COLLECTING_ENABLED 1
#define TRACE_M25P80_POPULATED_JEDEC_ENABLED 1
#define TRACE_M25P80_CHIP_ERASE_ENABLED 1
#define TRACE_M25P80_SELECT_ENABLED 1
#define TRACE_M25P80_PAGE_PROGRAM_ENABLED 1
#define TRACE_M25P80_TRANSFER_ENABLED 1
#define TRACE_M25P80_READ_BYTE_ENABLED 1
#define TRACE_M25P80_READ_DATA_ENABLED 1
#define TRACE_M25P80_READ_SFDP_ENABLED 1
#define TRACE_M25P80_BINDING_ENABLED 1
#define TRACE_M25P80_BINDING_NO_BDRV_ENABLED 1
#define TRACE_SWIM_ISMCTRL_READ_ENABLED 1
#define TRACE_SWIM_ISMCTRL_WRITE_ENABLED 1
#define TRACE_SWIM_IWMCTRL_READ_ENABLED 1
#define TRACE_SWIM_IWMCTRL_WRITE_ENABLED 1
#define TRACE_SWIM_SWITCH_TO_ISM_ENABLED 1
#define TRACE_SWIM_SWITCH_TO_IWM_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_FDC_IOPORT_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_FDC_IOPORT_READ) || \
    false)

static inline void _nocheck__trace_fdc_ioport_read(uint8_t reg, uint8_t value)
{
    if (trace_event_get_state(TRACE_FDC_IOPORT_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 4 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:fdc_ioport_read " "read reg 0x%02x val 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reg, value);
#line 283 "trace/trace-hw_block.h"
        } else {
#line 4 "../hw/block/trace-events"
            qemu_log("fdc_ioport_read " "read reg 0x%02x val 0x%02x" "\n", reg, value);
#line 287 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_fdc_ioport_read(uint8_t reg, uint8_t value)
{
    if (true) {
        _nocheck__trace_fdc_ioport_read(reg, value);
    }
}

#define TRACE_FDC_IOPORT_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_FDC_IOPORT_WRITE) || \
    false)

static inline void _nocheck__trace_fdc_ioport_write(uint8_t reg, uint8_t value)
{
    if (trace_event_get_state(TRACE_FDC_IOPORT_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 5 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:fdc_ioport_write " "write reg 0x%02x val 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reg, value);
#line 314 "trace/trace-hw_block.h"
        } else {
#line 5 "../hw/block/trace-events"
            qemu_log("fdc_ioport_write " "write reg 0x%02x val 0x%02x" "\n", reg, value);
#line 318 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_fdc_ioport_write(uint8_t reg, uint8_t value)
{
    if (true) {
        _nocheck__trace_fdc_ioport_write(reg, value);
    }
}

#define TRACE_FDCTRL_TC_PULSE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_FDCTRL_TC_PULSE) || \
    false)

static inline void _nocheck__trace_fdctrl_tc_pulse(int level)
{
    if (trace_event_get_state(TRACE_FDCTRL_TC_PULSE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 8 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:fdctrl_tc_pulse " "TC pulse: %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , level);
#line 345 "trace/trace-hw_block.h"
        } else {
#line 8 "../hw/block/trace-events"
            qemu_log("fdctrl_tc_pulse " "TC pulse: %u" "\n", level);
#line 349 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_fdctrl_tc_pulse(int level)
{
    if (true) {
        _nocheck__trace_fdctrl_tc_pulse(level);
    }
}

#define TRACE_PFLASH_CHIP_ERASE_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_CHIP_ERASE_INVALID) || \
    false)

static inline void _nocheck__trace_pflash_chip_erase_invalid(const char * name, uint64_t offset)
{
    if (trace_event_get_state(TRACE_PFLASH_CHIP_ERASE_INVALID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 12 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_chip_erase_invalid " "%s: chip erase: invalid address 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset);
#line 376 "trace/trace-hw_block.h"
        } else {
#line 12 "../hw/block/trace-events"
            qemu_log("pflash_chip_erase_invalid " "%s: chip erase: invalid address 0x%" PRIx64 "\n", name, offset);
#line 380 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_chip_erase_invalid(const char * name, uint64_t offset)
{
    if (true) {
        _nocheck__trace_pflash_chip_erase_invalid(name, offset);
    }
}

#define TRACE_PFLASH_CHIP_ERASE_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_CHIP_ERASE_START) || \
    false)

static inline void _nocheck__trace_pflash_chip_erase_start(const char * name)
{
    if (trace_event_get_state(TRACE_PFLASH_CHIP_ERASE_START) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 13 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_chip_erase_start " "%s: start chip erase" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 407 "trace/trace-hw_block.h"
        } else {
#line 13 "../hw/block/trace-events"
            qemu_log("pflash_chip_erase_start " "%s: start chip erase" "\n", name);
#line 411 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_chip_erase_start(const char * name)
{
    if (true) {
        _nocheck__trace_pflash_chip_erase_start(name);
    }
}

#define TRACE_PFLASH_DATA_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_DATA_READ) || \
    false)

static inline void _nocheck__trace_pflash_data_read(const char * name, uint64_t offset, unsigned size, uint32_t value)
{
    if (trace_event_get_state(TRACE_PFLASH_DATA_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 14 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_data_read " "%s: data offset:0x%04"PRIx64" size:%u value:0x%04x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset, size, value);
#line 438 "trace/trace-hw_block.h"
        } else {
#line 14 "../hw/block/trace-events"
            qemu_log("pflash_data_read " "%s: data offset:0x%04"PRIx64" size:%u value:0x%04x" "\n", name, offset, size, value);
#line 442 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_data_read(const char * name, uint64_t offset, unsigned size, uint32_t value)
{
    if (true) {
        _nocheck__trace_pflash_data_read(name, offset, size, value);
    }
}

#define TRACE_PFLASH_DATA_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_DATA_WRITE) || \
    false)

static inline void _nocheck__trace_pflash_data_write(const char * name, uint64_t offset, unsigned size, uint32_t value)
{
    if (trace_event_get_state(TRACE_PFLASH_DATA_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 15 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_data_write " "%s: data offset:0x%04"PRIx64" size:%u value:0x%04x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset, size, value);
#line 469 "trace/trace-hw_block.h"
        } else {
#line 15 "../hw/block/trace-events"
            qemu_log("pflash_data_write " "%s: data offset:0x%04"PRIx64" size:%u value:0x%04x" "\n", name, offset, size, value);
#line 473 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_data_write(const char * name, uint64_t offset, unsigned size, uint32_t value)
{
    if (true) {
        _nocheck__trace_pflash_data_write(name, offset, size, value);
    }
}

#define TRACE_PFLASH_DATA_WRITE_BLOCK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_DATA_WRITE_BLOCK) || \
    false)

static inline void _nocheck__trace_pflash_data_write_block(const char * name, uint64_t offset, unsigned size, uint32_t value, uint64_t counter)
{
    if (trace_event_get_state(TRACE_PFLASH_DATA_WRITE_BLOCK) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 16 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_data_write_block " "%s: data offset:0x%04"PRIx64" size:%u value:0x%04x counter:0x%016"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset, size, value, counter);
#line 500 "trace/trace-hw_block.h"
        } else {
#line 16 "../hw/block/trace-events"
            qemu_log("pflash_data_write_block " "%s: data offset:0x%04"PRIx64" size:%u value:0x%04x counter:0x%016"PRIx64 "\n", name, offset, size, value, counter);
#line 504 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_data_write_block(const char * name, uint64_t offset, unsigned size, uint32_t value, uint64_t counter)
{
    if (true) {
        _nocheck__trace_pflash_data_write_block(name, offset, size, value, counter);
    }
}

#define TRACE_PFLASH_DEVICE_ID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_DEVICE_ID) || \
    false)

static inline void _nocheck__trace_pflash_device_id(const char * name, uint16_t id)
{
    if (trace_event_get_state(TRACE_PFLASH_DEVICE_ID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 17 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_device_id " "%s: read device ID: 0x%04x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, id);
#line 531 "trace/trace-hw_block.h"
        } else {
#line 17 "../hw/block/trace-events"
            qemu_log("pflash_device_id " "%s: read device ID: 0x%04x" "\n", name, id);
#line 535 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_device_id(const char * name, uint16_t id)
{
    if (true) {
        _nocheck__trace_pflash_device_id(name, id);
    }
}

#define TRACE_PFLASH_DEVICE_INFO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_DEVICE_INFO) || \
    false)

static inline void _nocheck__trace_pflash_device_info(const char * name, uint64_t offset)
{
    if (trace_event_get_state(TRACE_PFLASH_DEVICE_INFO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 18 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_device_info " "%s: read device information offset:0x%04" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset);
#line 562 "trace/trace-hw_block.h"
        } else {
#line 18 "../hw/block/trace-events"
            qemu_log("pflash_device_info " "%s: read device information offset:0x%04" PRIx64 "\n", name, offset);
#line 566 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_device_info(const char * name, uint64_t offset)
{
    if (true) {
        _nocheck__trace_pflash_device_info(name, offset);
    }
}

#define TRACE_PFLASH_ERASE_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_ERASE_COMPLETE) || \
    false)

static inline void _nocheck__trace_pflash_erase_complete(const char * name)
{
    if (trace_event_get_state(TRACE_PFLASH_ERASE_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 19 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_erase_complete " "%s: sector erase complete" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 593 "trace/trace-hw_block.h"
        } else {
#line 19 "../hw/block/trace-events"
            qemu_log("pflash_erase_complete " "%s: sector erase complete" "\n", name);
#line 597 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_erase_complete(const char * name)
{
    if (true) {
        _nocheck__trace_pflash_erase_complete(name);
    }
}

#define TRACE_PFLASH_ERASE_TIMEOUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_ERASE_TIMEOUT) || \
    false)

static inline void _nocheck__trace_pflash_erase_timeout(const char * name, int count)
{
    if (trace_event_get_state(TRACE_PFLASH_ERASE_TIMEOUT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 20 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_erase_timeout " "%s: erase timeout fired; erasing %d sectors" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, count);
#line 624 "trace/trace-hw_block.h"
        } else {
#line 20 "../hw/block/trace-events"
            qemu_log("pflash_erase_timeout " "%s: erase timeout fired; erasing %d sectors" "\n", name, count);
#line 628 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_erase_timeout(const char * name, int count)
{
    if (true) {
        _nocheck__trace_pflash_erase_timeout(name, count);
    }
}

#define TRACE_PFLASH_IO_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_IO_READ) || \
    false)

static inline void _nocheck__trace_pflash_io_read(const char * name, uint64_t offset, unsigned int size, uint32_t value, uint8_t cmd, uint8_t wcycle)
{
    if (trace_event_get_state(TRACE_PFLASH_IO_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 21 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_io_read " "%s: offset:0x%04" PRIx64 " size:%u value:0x%04x cmd:0x%02x wcycle:%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset, size, value, cmd, wcycle);
#line 655 "trace/trace-hw_block.h"
        } else {
#line 21 "../hw/block/trace-events"
            qemu_log("pflash_io_read " "%s: offset:0x%04" PRIx64 " size:%u value:0x%04x cmd:0x%02x wcycle:%u" "\n", name, offset, size, value, cmd, wcycle);
#line 659 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_io_read(const char * name, uint64_t offset, unsigned int size, uint32_t value, uint8_t cmd, uint8_t wcycle)
{
    if (true) {
        _nocheck__trace_pflash_io_read(name, offset, size, value, cmd, wcycle);
    }
}

#define TRACE_PFLASH_IO_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_IO_WRITE) || \
    false)

static inline void _nocheck__trace_pflash_io_write(const char * name, uint64_t offset, unsigned int size, uint32_t value, uint8_t wcycle)
{
    if (trace_event_get_state(TRACE_PFLASH_IO_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 22 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_io_write " "%s: offset:0x%04"PRIx64" size:%u value:0x%04x wcycle:%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset, size, value, wcycle);
#line 686 "trace/trace-hw_block.h"
        } else {
#line 22 "../hw/block/trace-events"
            qemu_log("pflash_io_write " "%s: offset:0x%04"PRIx64" size:%u value:0x%04x wcycle:%u" "\n", name, offset, size, value, wcycle);
#line 690 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_io_write(const char * name, uint64_t offset, unsigned int size, uint32_t value, uint8_t wcycle)
{
    if (true) {
        _nocheck__trace_pflash_io_write(name, offset, size, value, wcycle);
    }
}

#define TRACE_PFLASH_MANUFACTURER_ID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_MANUFACTURER_ID) || \
    false)

static inline void _nocheck__trace_pflash_manufacturer_id(const char * name, uint16_t id)
{
    if (trace_event_get_state(TRACE_PFLASH_MANUFACTURER_ID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 23 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_manufacturer_id " "%s: read manufacturer ID: 0x%04x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, id);
#line 717 "trace/trace-hw_block.h"
        } else {
#line 23 "../hw/block/trace-events"
            qemu_log("pflash_manufacturer_id " "%s: read manufacturer ID: 0x%04x" "\n", name, id);
#line 721 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_manufacturer_id(const char * name, uint16_t id)
{
    if (true) {
        _nocheck__trace_pflash_manufacturer_id(name, id);
    }
}

#define TRACE_PFLASH_MODE_READ_ARRAY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_MODE_READ_ARRAY) || \
    false)

static inline void _nocheck__trace_pflash_mode_read_array(const char * name)
{
    if (trace_event_get_state(TRACE_PFLASH_MODE_READ_ARRAY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 24 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_mode_read_array " "%s: read array mode" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 748 "trace/trace-hw_block.h"
        } else {
#line 24 "../hw/block/trace-events"
            qemu_log("pflash_mode_read_array " "%s: read array mode" "\n", name);
#line 752 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_mode_read_array(const char * name)
{
    if (true) {
        _nocheck__trace_pflash_mode_read_array(name);
    }
}

#define TRACE_PFLASH_POSTLOAD_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_POSTLOAD_CB) || \
    false)

static inline void _nocheck__trace_pflash_postload_cb(const char * name)
{
    if (trace_event_get_state(TRACE_PFLASH_POSTLOAD_CB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 25 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_postload_cb " "%s: updating bdrv" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 779 "trace/trace-hw_block.h"
        } else {
#line 25 "../hw/block/trace-events"
            qemu_log("pflash_postload_cb " "%s: updating bdrv" "\n", name);
#line 783 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_postload_cb(const char * name)
{
    if (true) {
        _nocheck__trace_pflash_postload_cb(name);
    }
}

#define TRACE_PFLASH_READ_DONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_READ_DONE) || \
    false)

static inline void _nocheck__trace_pflash_read_done(const char * name, uint64_t offset, uint64_t ret)
{
    if (trace_event_get_state(TRACE_PFLASH_READ_DONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 26 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_read_done " "%s: ID:0x%" PRIx64 " ret:0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset, ret);
#line 810 "trace/trace-hw_block.h"
        } else {
#line 26 "../hw/block/trace-events"
            qemu_log("pflash_read_done " "%s: ID:0x%" PRIx64 " ret:0x%" PRIx64 "\n", name, offset, ret);
#line 814 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_read_done(const char * name, uint64_t offset, uint64_t ret)
{
    if (true) {
        _nocheck__trace_pflash_read_done(name, offset, ret);
    }
}

#define TRACE_PFLASH_READ_STATUS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_READ_STATUS) || \
    false)

static inline void _nocheck__trace_pflash_read_status(const char * name, uint32_t ret)
{
    if (trace_event_get_state(TRACE_PFLASH_READ_STATUS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 27 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_read_status " "%s: status:0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, ret);
#line 841 "trace/trace-hw_block.h"
        } else {
#line 27 "../hw/block/trace-events"
            qemu_log("pflash_read_status " "%s: status:0x%x" "\n", name, ret);
#line 845 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_read_status(const char * name, uint32_t ret)
{
    if (true) {
        _nocheck__trace_pflash_read_status(name, ret);
    }
}

#define TRACE_PFLASH_READ_UNKNOWN_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_READ_UNKNOWN_STATE) || \
    false)

static inline void _nocheck__trace_pflash_read_unknown_state(const char * name, uint8_t cmd)
{
    if (trace_event_get_state(TRACE_PFLASH_READ_UNKNOWN_STATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 28 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_read_unknown_state " "%s: unknown command state:0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, cmd);
#line 872 "trace/trace-hw_block.h"
        } else {
#line 28 "../hw/block/trace-events"
            qemu_log("pflash_read_unknown_state " "%s: unknown command state:0x%x" "\n", name, cmd);
#line 876 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_read_unknown_state(const char * name, uint8_t cmd)
{
    if (true) {
        _nocheck__trace_pflash_read_unknown_state(name, cmd);
    }
}

#define TRACE_PFLASH_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_RESET) || \
    false)

static inline void _nocheck__trace_pflash_reset(const char * name)
{
    if (trace_event_get_state(TRACE_PFLASH_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 29 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_reset " "%s: reset" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 903 "trace/trace-hw_block.h"
        } else {
#line 29 "../hw/block/trace-events"
            qemu_log("pflash_reset " "%s: reset" "\n", name);
#line 907 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_reset(const char * name)
{
    if (true) {
        _nocheck__trace_pflash_reset(name);
    }
}

#define TRACE_PFLASH_SECTOR_ERASE_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_SECTOR_ERASE_START) || \
    false)

static inline void _nocheck__trace_pflash_sector_erase_start(const char * name, int width1, uint64_t start, int width2, uint64_t end)
{
    if (trace_event_get_state(TRACE_PFLASH_SECTOR_ERASE_START) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 30 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_sector_erase_start " "%s: start sector erase at: 0x%0*" PRIx64 "-0x%0*" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, width1, start, width2, end);
#line 934 "trace/trace-hw_block.h"
        } else {
#line 30 "../hw/block/trace-events"
            qemu_log("pflash_sector_erase_start " "%s: start sector erase at: 0x%0*" PRIx64 "-0x%0*" PRIx64 "\n", name, width1, start, width2, end);
#line 938 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_sector_erase_start(const char * name, int width1, uint64_t start, int width2, uint64_t end)
{
    if (true) {
        _nocheck__trace_pflash_sector_erase_start(name, width1, start, width2, end);
    }
}

#define TRACE_PFLASH_TIMER_EXPIRED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_TIMER_EXPIRED) || \
    false)

static inline void _nocheck__trace_pflash_timer_expired(const char * name, uint8_t cmd)
{
    if (trace_event_get_state(TRACE_PFLASH_TIMER_EXPIRED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 31 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_timer_expired " "%s: command 0x%02x done" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, cmd);
#line 965 "trace/trace-hw_block.h"
        } else {
#line 31 "../hw/block/trace-events"
            qemu_log("pflash_timer_expired " "%s: command 0x%02x done" "\n", name, cmd);
#line 969 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_timer_expired(const char * name, uint8_t cmd)
{
    if (true) {
        _nocheck__trace_pflash_timer_expired(name, cmd);
    }
}

#define TRACE_PFLASH_UNLOCK0_FAILED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_UNLOCK0_FAILED) || \
    false)

static inline void _nocheck__trace_pflash_unlock0_failed(const char * name, uint64_t offset, uint8_t cmd, uint16_t addr0)
{
    if (trace_event_get_state(TRACE_PFLASH_UNLOCK0_FAILED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 32 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_unlock0_failed " "%s: unlock0 failed 0x%" PRIx64 " 0x%02x 0x%04x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset, cmd, addr0);
#line 996 "trace/trace-hw_block.h"
        } else {
#line 32 "../hw/block/trace-events"
            qemu_log("pflash_unlock0_failed " "%s: unlock0 failed 0x%" PRIx64 " 0x%02x 0x%04x" "\n", name, offset, cmd, addr0);
#line 1000 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_unlock0_failed(const char * name, uint64_t offset, uint8_t cmd, uint16_t addr0)
{
    if (true) {
        _nocheck__trace_pflash_unlock0_failed(name, offset, cmd, addr0);
    }
}

#define TRACE_PFLASH_UNLOCK1_FAILED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_UNLOCK1_FAILED) || \
    false)

static inline void _nocheck__trace_pflash_unlock1_failed(const char * name, uint64_t offset, uint8_t cmd)
{
    if (trace_event_get_state(TRACE_PFLASH_UNLOCK1_FAILED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 33 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_unlock1_failed " "%s: unlock0 failed 0x%" PRIx64 " 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset, cmd);
#line 1027 "trace/trace-hw_block.h"
        } else {
#line 33 "../hw/block/trace-events"
            qemu_log("pflash_unlock1_failed " "%s: unlock0 failed 0x%" PRIx64 " 0x%02x" "\n", name, offset, cmd);
#line 1031 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_unlock1_failed(const char * name, uint64_t offset, uint8_t cmd)
{
    if (true) {
        _nocheck__trace_pflash_unlock1_failed(name, offset, cmd);
    }
}

#define TRACE_PFLASH_UNSUPPORTED_DEVICE_CONFIGURATION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_UNSUPPORTED_DEVICE_CONFIGURATION) || \
    false)

static inline void _nocheck__trace_pflash_unsupported_device_configuration(const char * name, uint8_t width, uint8_t max)
{
    if (trace_event_get_state(TRACE_PFLASH_UNSUPPORTED_DEVICE_CONFIGURATION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 34 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_unsupported_device_configuration " "%s: unsupported device configuration: device_width:%d max_device_width:%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, width, max);
#line 1058 "trace/trace-hw_block.h"
        } else {
#line 34 "../hw/block/trace-events"
            qemu_log("pflash_unsupported_device_configuration " "%s: unsupported device configuration: device_width:%d max_device_width:%d" "\n", name, width, max);
#line 1062 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_unsupported_device_configuration(const char * name, uint8_t width, uint8_t max)
{
    if (true) {
        _nocheck__trace_pflash_unsupported_device_configuration(name, width, max);
    }
}

#define TRACE_PFLASH_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_WRITE) || \
    false)

static inline void _nocheck__trace_pflash_write(const char * name, const char * str)
{
    if (trace_event_get_state(TRACE_PFLASH_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 35 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_write " "%s: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, str);
#line 1089 "trace/trace-hw_block.h"
        } else {
#line 35 "../hw/block/trace-events"
            qemu_log("pflash_write " "%s: %s" "\n", name, str);
#line 1093 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_write(const char * name, const char * str)
{
    if (true) {
        _nocheck__trace_pflash_write(name, str);
    }
}

#define TRACE_PFLASH_WRITE_BLOCK_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_WRITE_BLOCK_START) || \
    false)

static inline void _nocheck__trace_pflash_write_block_start(const char * name, uint32_t value)
{
    if (trace_event_get_state(TRACE_PFLASH_WRITE_BLOCK_START) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 36 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_write_block_start " "%s: block write start: bytes:0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, value);
#line 1120 "trace/trace-hw_block.h"
        } else {
#line 36 "../hw/block/trace-events"
            qemu_log("pflash_write_block_start " "%s: block write start: bytes:0x%x" "\n", name, value);
#line 1124 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_write_block_start(const char * name, uint32_t value)
{
    if (true) {
        _nocheck__trace_pflash_write_block_start(name, value);
    }
}

#define TRACE_PFLASH_WRITE_BLOCK_FLUSH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_WRITE_BLOCK_FLUSH) || \
    false)

static inline void _nocheck__trace_pflash_write_block_flush(const char * name)
{
    if (trace_event_get_state(TRACE_PFLASH_WRITE_BLOCK_FLUSH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 37 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_write_block_flush " "%s: block write flush" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 1151 "trace/trace-hw_block.h"
        } else {
#line 37 "../hw/block/trace-events"
            qemu_log("pflash_write_block_flush " "%s: block write flush" "\n", name);
#line 1155 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_write_block_flush(const char * name)
{
    if (true) {
        _nocheck__trace_pflash_write_block_flush(name);
    }
}

#define TRACE_PFLASH_WRITE_BLOCK_ABORT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_WRITE_BLOCK_ABORT) || \
    false)

static inline void _nocheck__trace_pflash_write_block_abort(const char * name)
{
    if (trace_event_get_state(TRACE_PFLASH_WRITE_BLOCK_ABORT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 38 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_write_block_abort " "%s: block write abort" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 1182 "trace/trace-hw_block.h"
        } else {
#line 38 "../hw/block/trace-events"
            qemu_log("pflash_write_block_abort " "%s: block write abort" "\n", name);
#line 1186 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_write_block_abort(const char * name)
{
    if (true) {
        _nocheck__trace_pflash_write_block_abort(name);
    }
}

#define TRACE_PFLASH_WRITE_BLOCK_ERASE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_WRITE_BLOCK_ERASE) || \
    false)

static inline void _nocheck__trace_pflash_write_block_erase(const char * name, uint64_t offset, uint64_t len)
{
    if (trace_event_get_state(TRACE_PFLASH_WRITE_BLOCK_ERASE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 39 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_write_block_erase " "%s: block erase offset:0x%" PRIx64 " bytes:0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset, len);
#line 1213 "trace/trace-hw_block.h"
        } else {
#line 39 "../hw/block/trace-events"
            qemu_log("pflash_write_block_erase " "%s: block erase offset:0x%" PRIx64 " bytes:0x%" PRIx64 "\n", name, offset, len);
#line 1217 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_write_block_erase(const char * name, uint64_t offset, uint64_t len)
{
    if (true) {
        _nocheck__trace_pflash_write_block_erase(name, offset, len);
    }
}

#define TRACE_PFLASH_WRITE_FAILED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_WRITE_FAILED) || \
    false)

static inline void _nocheck__trace_pflash_write_failed(const char * name, uint64_t offset, uint8_t cmd)
{
    if (trace_event_get_state(TRACE_PFLASH_WRITE_FAILED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 40 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_write_failed " "%s: command failed 0x%" PRIx64 " 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset, cmd);
#line 1244 "trace/trace-hw_block.h"
        } else {
#line 40 "../hw/block/trace-events"
            qemu_log("pflash_write_failed " "%s: command failed 0x%" PRIx64 " 0x%02x" "\n", name, offset, cmd);
#line 1248 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_write_failed(const char * name, uint64_t offset, uint8_t cmd)
{
    if (true) {
        _nocheck__trace_pflash_write_failed(name, offset, cmd);
    }
}

#define TRACE_PFLASH_WRITE_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_WRITE_INVALID) || \
    false)

static inline void _nocheck__trace_pflash_write_invalid(const char * name, uint8_t cmd)
{
    if (trace_event_get_state(TRACE_PFLASH_WRITE_INVALID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 41 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_write_invalid " "%s: invalid write for command 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, cmd);
#line 1275 "trace/trace-hw_block.h"
        } else {
#line 41 "../hw/block/trace-events"
            qemu_log("pflash_write_invalid " "%s: invalid write for command 0x%02x" "\n", name, cmd);
#line 1279 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_write_invalid(const char * name, uint8_t cmd)
{
    if (true) {
        _nocheck__trace_pflash_write_invalid(name, cmd);
    }
}

#define TRACE_PFLASH_WRITE_INVALID_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_WRITE_INVALID_COMMAND) || \
    false)

static inline void _nocheck__trace_pflash_write_invalid_command(const char * name, uint8_t cmd)
{
    if (trace_event_get_state(TRACE_PFLASH_WRITE_INVALID_COMMAND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 42 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_write_invalid_command " "%s: invalid command 0x%02x (wc 5)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, cmd);
#line 1306 "trace/trace-hw_block.h"
        } else {
#line 42 "../hw/block/trace-events"
            qemu_log("pflash_write_invalid_command " "%s: invalid command 0x%02x (wc 5)" "\n", name, cmd);
#line 1310 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_write_invalid_command(const char * name, uint8_t cmd)
{
    if (true) {
        _nocheck__trace_pflash_write_invalid_command(name, cmd);
    }
}

#define TRACE_PFLASH_WRITE_INVALID_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_WRITE_INVALID_STATE) || \
    false)

static inline void _nocheck__trace_pflash_write_invalid_state(const char * name, uint8_t cmd, int wc)
{
    if (trace_event_get_state(TRACE_PFLASH_WRITE_INVALID_STATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 43 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_write_invalid_state " "%s: invalid command state 0x%02x (wc %d)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, cmd, wc);
#line 1337 "trace/trace-hw_block.h"
        } else {
#line 43 "../hw/block/trace-events"
            qemu_log("pflash_write_invalid_state " "%s: invalid command state 0x%02x (wc %d)" "\n", name, cmd, wc);
#line 1341 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_write_invalid_state(const char * name, uint8_t cmd, int wc)
{
    if (true) {
        _nocheck__trace_pflash_write_invalid_state(name, cmd, wc);
    }
}

#define TRACE_PFLASH_WRITE_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_WRITE_START) || \
    false)

static inline void _nocheck__trace_pflash_write_start(const char * name, uint8_t cmd)
{
    if (trace_event_get_state(TRACE_PFLASH_WRITE_START) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 44 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_write_start " "%s: starting command 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, cmd);
#line 1368 "trace/trace-hw_block.h"
        } else {
#line 44 "../hw/block/trace-events"
            qemu_log("pflash_write_start " "%s: starting command 0x%02x" "\n", name, cmd);
#line 1372 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_write_start(const char * name, uint8_t cmd)
{
    if (true) {
        _nocheck__trace_pflash_write_start(name, cmd);
    }
}

#define TRACE_PFLASH_WRITE_UNKNOWN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_WRITE_UNKNOWN) || \
    false)

static inline void _nocheck__trace_pflash_write_unknown(const char * name, uint8_t cmd)
{
    if (trace_event_get_state(TRACE_PFLASH_WRITE_UNKNOWN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 45 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_write_unknown " "%s: unknown command 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, cmd);
#line 1399 "trace/trace-hw_block.h"
        } else {
#line 45 "../hw/block/trace-events"
            qemu_log("pflash_write_unknown " "%s: unknown command 0x%02x" "\n", name, cmd);
#line 1403 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_write_unknown(const char * name, uint8_t cmd)
{
    if (true) {
        _nocheck__trace_pflash_write_unknown(name, cmd);
    }
}

#define TRACE_VIRTIO_BLK_REQ_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BLK_REQ_COMPLETE) || \
    false)

static inline void _nocheck__trace_virtio_blk_req_complete(void * vdev, void * req, int status)
{
    if (trace_event_get_state(TRACE_VIRTIO_BLK_REQ_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 48 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_blk_req_complete " "vdev %p req %p status %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vdev, req, status);
#line 1430 "trace/trace-hw_block.h"
        } else {
#line 48 "../hw/block/trace-events"
            qemu_log("virtio_blk_req_complete " "vdev %p req %p status %d" "\n", vdev, req, status);
#line 1434 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_virtio_blk_req_complete(void * vdev, void * req, int status)
{
    if (true) {
        _nocheck__trace_virtio_blk_req_complete(vdev, req, status);
    }
}

#define TRACE_VIRTIO_BLK_RW_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BLK_RW_COMPLETE) || \
    false)

static inline void _nocheck__trace_virtio_blk_rw_complete(void * vdev, void * req, int ret)
{
    if (trace_event_get_state(TRACE_VIRTIO_BLK_RW_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 49 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_blk_rw_complete " "vdev %p req %p ret %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vdev, req, ret);
#line 1461 "trace/trace-hw_block.h"
        } else {
#line 49 "../hw/block/trace-events"
            qemu_log("virtio_blk_rw_complete " "vdev %p req %p ret %d" "\n", vdev, req, ret);
#line 1465 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_virtio_blk_rw_complete(void * vdev, void * req, int ret)
{
    if (true) {
        _nocheck__trace_virtio_blk_rw_complete(vdev, req, ret);
    }
}

#define TRACE_VIRTIO_BLK_ZONE_REPORT_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BLK_ZONE_REPORT_COMPLETE) || \
    false)

static inline void _nocheck__trace_virtio_blk_zone_report_complete(void * vdev, void * req, unsigned int nr_zones, int ret)
{
    if (trace_event_get_state(TRACE_VIRTIO_BLK_ZONE_REPORT_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 50 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_blk_zone_report_complete " "vdev %p req %p nr_zones %u ret %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vdev, req, nr_zones, ret);
#line 1492 "trace/trace-hw_block.h"
        } else {
#line 50 "../hw/block/trace-events"
            qemu_log("virtio_blk_zone_report_complete " "vdev %p req %p nr_zones %u ret %d" "\n", vdev, req, nr_zones, ret);
#line 1496 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_virtio_blk_zone_report_complete(void * vdev, void * req, unsigned int nr_zones, int ret)
{
    if (true) {
        _nocheck__trace_virtio_blk_zone_report_complete(vdev, req, nr_zones, ret);
    }
}

#define TRACE_VIRTIO_BLK_ZONE_MGMT_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BLK_ZONE_MGMT_COMPLETE) || \
    false)

static inline void _nocheck__trace_virtio_blk_zone_mgmt_complete(void * vdev, void * req, int ret)
{
    if (trace_event_get_state(TRACE_VIRTIO_BLK_ZONE_MGMT_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 51 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_blk_zone_mgmt_complete " "vdev %p req %p ret %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vdev, req, ret);
#line 1523 "trace/trace-hw_block.h"
        } else {
#line 51 "../hw/block/trace-events"
            qemu_log("virtio_blk_zone_mgmt_complete " "vdev %p req %p ret %d" "\n", vdev, req, ret);
#line 1527 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_virtio_blk_zone_mgmt_complete(void * vdev, void * req, int ret)
{
    if (true) {
        _nocheck__trace_virtio_blk_zone_mgmt_complete(vdev, req, ret);
    }
}

#define TRACE_VIRTIO_BLK_ZONE_APPEND_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BLK_ZONE_APPEND_COMPLETE) || \
    false)

static inline void _nocheck__trace_virtio_blk_zone_append_complete(void * vdev, void * req, int64_t sector, int ret)
{
    if (trace_event_get_state(TRACE_VIRTIO_BLK_ZONE_APPEND_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 52 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_blk_zone_append_complete " "vdev %p req %p, append sector 0x%" PRIx64 " ret %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vdev, req, sector, ret);
#line 1554 "trace/trace-hw_block.h"
        } else {
#line 52 "../hw/block/trace-events"
            qemu_log("virtio_blk_zone_append_complete " "vdev %p req %p, append sector 0x%" PRIx64 " ret %d" "\n", vdev, req, sector, ret);
#line 1558 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_virtio_blk_zone_append_complete(void * vdev, void * req, int64_t sector, int ret)
{
    if (true) {
        _nocheck__trace_virtio_blk_zone_append_complete(vdev, req, sector, ret);
    }
}

#define TRACE_VIRTIO_BLK_HANDLE_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BLK_HANDLE_WRITE) || \
    false)

static inline void _nocheck__trace_virtio_blk_handle_write(void * vdev, void * req, uint64_t sector, size_t nsectors)
{
    if (trace_event_get_state(TRACE_VIRTIO_BLK_HANDLE_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 53 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_blk_handle_write " "vdev %p req %p sector %"PRIu64" nsectors %zu" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vdev, req, sector, nsectors);
#line 1585 "trace/trace-hw_block.h"
        } else {
#line 53 "../hw/block/trace-events"
            qemu_log("virtio_blk_handle_write " "vdev %p req %p sector %"PRIu64" nsectors %zu" "\n", vdev, req, sector, nsectors);
#line 1589 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_virtio_blk_handle_write(void * vdev, void * req, uint64_t sector, size_t nsectors)
{
    if (true) {
        _nocheck__trace_virtio_blk_handle_write(vdev, req, sector, nsectors);
    }
}

#define TRACE_VIRTIO_BLK_HANDLE_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BLK_HANDLE_READ) || \
    false)

static inline void _nocheck__trace_virtio_blk_handle_read(void * vdev, void * req, uint64_t sector, size_t nsectors)
{
    if (trace_event_get_state(TRACE_VIRTIO_BLK_HANDLE_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 54 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_blk_handle_read " "vdev %p req %p sector %"PRIu64" nsectors %zu" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vdev, req, sector, nsectors);
#line 1616 "trace/trace-hw_block.h"
        } else {
#line 54 "../hw/block/trace-events"
            qemu_log("virtio_blk_handle_read " "vdev %p req %p sector %"PRIu64" nsectors %zu" "\n", vdev, req, sector, nsectors);
#line 1620 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_virtio_blk_handle_read(void * vdev, void * req, uint64_t sector, size_t nsectors)
{
    if (true) {
        _nocheck__trace_virtio_blk_handle_read(vdev, req, sector, nsectors);
    }
}

#define TRACE_VIRTIO_BLK_SUBMIT_MULTIREQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BLK_SUBMIT_MULTIREQ) || \
    false)

static inline void _nocheck__trace_virtio_blk_submit_multireq(void * vdev, void * mrb, int start, int num_reqs, uint64_t offset, size_t size, bool is_write)
{
    if (trace_event_get_state(TRACE_VIRTIO_BLK_SUBMIT_MULTIREQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 55 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_blk_submit_multireq " "vdev %p mrb %p start %d num_reqs %d offset %"PRIu64" size %zu is_write %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vdev, mrb, start, num_reqs, offset, size, is_write);
#line 1647 "trace/trace-hw_block.h"
        } else {
#line 55 "../hw/block/trace-events"
            qemu_log("virtio_blk_submit_multireq " "vdev %p mrb %p start %d num_reqs %d offset %"PRIu64" size %zu is_write %d" "\n", vdev, mrb, start, num_reqs, offset, size, is_write);
#line 1651 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_virtio_blk_submit_multireq(void * vdev, void * mrb, int start, int num_reqs, uint64_t offset, size_t size, bool is_write)
{
    if (true) {
        _nocheck__trace_virtio_blk_submit_multireq(vdev, mrb, start, num_reqs, offset, size, is_write);
    }
}

#define TRACE_VIRTIO_BLK_HANDLE_ZONE_REPORT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BLK_HANDLE_ZONE_REPORT) || \
    false)

static inline void _nocheck__trace_virtio_blk_handle_zone_report(void * vdev, void * req, int64_t sector, unsigned int nr_zones)
{
    if (trace_event_get_state(TRACE_VIRTIO_BLK_HANDLE_ZONE_REPORT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 56 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_blk_handle_zone_report " "vdev %p req %p sector 0x%" PRIx64 " nr_zones %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vdev, req, sector, nr_zones);
#line 1678 "trace/trace-hw_block.h"
        } else {
#line 56 "../hw/block/trace-events"
            qemu_log("virtio_blk_handle_zone_report " "vdev %p req %p sector 0x%" PRIx64 " nr_zones %u" "\n", vdev, req, sector, nr_zones);
#line 1682 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_virtio_blk_handle_zone_report(void * vdev, void * req, int64_t sector, unsigned int nr_zones)
{
    if (true) {
        _nocheck__trace_virtio_blk_handle_zone_report(vdev, req, sector, nr_zones);
    }
}

#define TRACE_VIRTIO_BLK_HANDLE_ZONE_MGMT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BLK_HANDLE_ZONE_MGMT) || \
    false)

static inline void _nocheck__trace_virtio_blk_handle_zone_mgmt(void * vdev, void * req, uint8_t op, int64_t sector, int64_t len)
{
    if (trace_event_get_state(TRACE_VIRTIO_BLK_HANDLE_ZONE_MGMT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 57 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_blk_handle_zone_mgmt " "vdev %p req %p op 0x%x sector 0x%" PRIx64 " len 0x%" PRIx64 "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vdev, req, op, sector, len);
#line 1709 "trace/trace-hw_block.h"
        } else {
#line 57 "../hw/block/trace-events"
            qemu_log("virtio_blk_handle_zone_mgmt " "vdev %p req %p op 0x%x sector 0x%" PRIx64 " len 0x%" PRIx64 "" "\n", vdev, req, op, sector, len);
#line 1713 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_virtio_blk_handle_zone_mgmt(void * vdev, void * req, uint8_t op, int64_t sector, int64_t len)
{
    if (true) {
        _nocheck__trace_virtio_blk_handle_zone_mgmt(vdev, req, op, sector, len);
    }
}

#define TRACE_VIRTIO_BLK_HANDLE_ZONE_RESET_ALL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BLK_HANDLE_ZONE_RESET_ALL) || \
    false)

static inline void _nocheck__trace_virtio_blk_handle_zone_reset_all(void * vdev, void * req, int64_t sector, int64_t len)
{
    if (trace_event_get_state(TRACE_VIRTIO_BLK_HANDLE_ZONE_RESET_ALL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 58 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_blk_handle_zone_reset_all " "vdev %p req %p sector 0x%" PRIx64 " cap 0x%" PRIx64 "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vdev, req, sector, len);
#line 1740 "trace/trace-hw_block.h"
        } else {
#line 58 "../hw/block/trace-events"
            qemu_log("virtio_blk_handle_zone_reset_all " "vdev %p req %p sector 0x%" PRIx64 " cap 0x%" PRIx64 "" "\n", vdev, req, sector, len);
#line 1744 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_virtio_blk_handle_zone_reset_all(void * vdev, void * req, int64_t sector, int64_t len)
{
    if (true) {
        _nocheck__trace_virtio_blk_handle_zone_reset_all(vdev, req, sector, len);
    }
}

#define TRACE_VIRTIO_BLK_HANDLE_ZONE_APPEND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BLK_HANDLE_ZONE_APPEND) || \
    false)

static inline void _nocheck__trace_virtio_blk_handle_zone_append(void * vdev, void * req, int64_t sector)
{
    if (trace_event_get_state(TRACE_VIRTIO_BLK_HANDLE_ZONE_APPEND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 59 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_blk_handle_zone_append " "vdev %p req %p, append sector 0x%" PRIx64 "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vdev, req, sector);
#line 1771 "trace/trace-hw_block.h"
        } else {
#line 59 "../hw/block/trace-events"
            qemu_log("virtio_blk_handle_zone_append " "vdev %p req %p, append sector 0x%" PRIx64 "" "\n", vdev, req, sector);
#line 1775 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_virtio_blk_handle_zone_append(void * vdev, void * req, int64_t sector)
{
    if (true) {
        _nocheck__trace_virtio_blk_handle_zone_append(vdev, req, sector);
    }
}

#define TRACE_HD_GEOMETRY_LCHS_GUESS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HD_GEOMETRY_LCHS_GUESS) || \
    false)

static inline void _nocheck__trace_hd_geometry_lchs_guess(void * blk, int cyls, int heads, int secs)
{
    if (trace_event_get_state(TRACE_HD_GEOMETRY_LCHS_GUESS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 62 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:hd_geometry_lchs_guess " "blk %p LCHS %d %d %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , blk, cyls, heads, secs);
#line 1802 "trace/trace-hw_block.h"
        } else {
#line 62 "../hw/block/trace-events"
            qemu_log("hd_geometry_lchs_guess " "blk %p LCHS %d %d %d" "\n", blk, cyls, heads, secs);
#line 1806 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_hd_geometry_lchs_guess(void * blk, int cyls, int heads, int secs)
{
    if (true) {
        _nocheck__trace_hd_geometry_lchs_guess(blk, cyls, heads, secs);
    }
}

#define TRACE_HD_GEOMETRY_GUESS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HD_GEOMETRY_GUESS) || \
    false)

static inline void _nocheck__trace_hd_geometry_guess(void * blk, uint32_t cyls, uint32_t heads, uint32_t secs, int trans)
{
    if (trace_event_get_state(TRACE_HD_GEOMETRY_GUESS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 63 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:hd_geometry_guess " "blk %p CHS %u %u %u trans %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , blk, cyls, heads, secs, trans);
#line 1833 "trace/trace-hw_block.h"
        } else {
#line 63 "../hw/block/trace-events"
            qemu_log("hd_geometry_guess " "blk %p CHS %u %u %u trans %d" "\n", blk, cyls, heads, secs, trans);
#line 1837 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_hd_geometry_guess(void * blk, uint32_t cyls, uint32_t heads, uint32_t secs, int trans)
{
    if (true) {
        _nocheck__trace_hd_geometry_guess(blk, cyls, heads, secs, trans);
    }
}

#define TRACE_XEN_BLOCK_REALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BLOCK_REALIZE) || \
    false)

static inline void _nocheck__trace_xen_block_realize(const char * type, uint32_t disk, uint32_t partition)
{
    if (trace_event_get_state(TRACE_XEN_BLOCK_REALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 66 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_block_realize " "%s d%up%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, disk, partition);
#line 1864 "trace/trace-hw_block.h"
        } else {
#line 66 "../hw/block/trace-events"
            qemu_log("xen_block_realize " "%s d%up%u" "\n", type, disk, partition);
#line 1868 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_block_realize(const char * type, uint32_t disk, uint32_t partition)
{
    if (true) {
        _nocheck__trace_xen_block_realize(type, disk, partition);
    }
}

#define TRACE_XEN_BLOCK_CONNECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BLOCK_CONNECT) || \
    false)

static inline void _nocheck__trace_xen_block_connect(const char * type, uint32_t disk, uint32_t partition)
{
    if (trace_event_get_state(TRACE_XEN_BLOCK_CONNECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 67 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_block_connect " "%s d%up%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, disk, partition);
#line 1895 "trace/trace-hw_block.h"
        } else {
#line 67 "../hw/block/trace-events"
            qemu_log("xen_block_connect " "%s d%up%u" "\n", type, disk, partition);
#line 1899 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_block_connect(const char * type, uint32_t disk, uint32_t partition)
{
    if (true) {
        _nocheck__trace_xen_block_connect(type, disk, partition);
    }
}

#define TRACE_XEN_BLOCK_DISCONNECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BLOCK_DISCONNECT) || \
    false)

static inline void _nocheck__trace_xen_block_disconnect(const char * type, uint32_t disk, uint32_t partition)
{
    if (trace_event_get_state(TRACE_XEN_BLOCK_DISCONNECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 68 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_block_disconnect " "%s d%up%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, disk, partition);
#line 1926 "trace/trace-hw_block.h"
        } else {
#line 68 "../hw/block/trace-events"
            qemu_log("xen_block_disconnect " "%s d%up%u" "\n", type, disk, partition);
#line 1930 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_block_disconnect(const char * type, uint32_t disk, uint32_t partition)
{
    if (true) {
        _nocheck__trace_xen_block_disconnect(type, disk, partition);
    }
}

#define TRACE_XEN_BLOCK_UNREALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BLOCK_UNREALIZE) || \
    false)

static inline void _nocheck__trace_xen_block_unrealize(const char * type, uint32_t disk, uint32_t partition)
{
    if (trace_event_get_state(TRACE_XEN_BLOCK_UNREALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 69 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_block_unrealize " "%s d%up%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, disk, partition);
#line 1957 "trace/trace-hw_block.h"
        } else {
#line 69 "../hw/block/trace-events"
            qemu_log("xen_block_unrealize " "%s d%up%u" "\n", type, disk, partition);
#line 1961 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_block_unrealize(const char * type, uint32_t disk, uint32_t partition)
{
    if (true) {
        _nocheck__trace_xen_block_unrealize(type, disk, partition);
    }
}

#define TRACE_XEN_BLOCK_SIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BLOCK_SIZE) || \
    false)

static inline void _nocheck__trace_xen_block_size(const char * type, uint32_t disk, uint32_t partition, int64_t sectors)
{
    if (trace_event_get_state(TRACE_XEN_BLOCK_SIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 70 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_block_size " "%s d%up%u %"PRIi64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, disk, partition, sectors);
#line 1988 "trace/trace-hw_block.h"
        } else {
#line 70 "../hw/block/trace-events"
            qemu_log("xen_block_size " "%s d%up%u %"PRIi64 "\n", type, disk, partition, sectors);
#line 1992 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_block_size(const char * type, uint32_t disk, uint32_t partition, int64_t sectors)
{
    if (true) {
        _nocheck__trace_xen_block_size(type, disk, partition, sectors);
    }
}

#define TRACE_XEN_DISK_REALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DISK_REALIZE) || \
    false)

static inline void _nocheck__trace_xen_disk_realize(void)
{
    if (trace_event_get_state(TRACE_XEN_DISK_REALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 71 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_disk_realize " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2019 "trace/trace-hw_block.h"
        } else {
#line 71 "../hw/block/trace-events"
            qemu_log("xen_disk_realize " "" "\n");
#line 2023 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_disk_realize(void)
{
    if (true) {
        _nocheck__trace_xen_disk_realize();
    }
}

#define TRACE_XEN_DISK_UNREALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DISK_UNREALIZE) || \
    false)

static inline void _nocheck__trace_xen_disk_unrealize(void)
{
    if (trace_event_get_state(TRACE_XEN_DISK_UNREALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 72 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_disk_unrealize " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2050 "trace/trace-hw_block.h"
        } else {
#line 72 "../hw/block/trace-events"
            qemu_log("xen_disk_unrealize " "" "\n");
#line 2054 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_disk_unrealize(void)
{
    if (true) {
        _nocheck__trace_xen_disk_unrealize();
    }
}

#define TRACE_XEN_CDROM_REALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_CDROM_REALIZE) || \
    false)

static inline void _nocheck__trace_xen_cdrom_realize(void)
{
    if (trace_event_get_state(TRACE_XEN_CDROM_REALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 73 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_cdrom_realize " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2081 "trace/trace-hw_block.h"
        } else {
#line 73 "../hw/block/trace-events"
            qemu_log("xen_cdrom_realize " "" "\n");
#line 2085 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_cdrom_realize(void)
{
    if (true) {
        _nocheck__trace_xen_cdrom_realize();
    }
}

#define TRACE_XEN_CDROM_UNREALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_CDROM_UNREALIZE) || \
    false)

static inline void _nocheck__trace_xen_cdrom_unrealize(void)
{
    if (trace_event_get_state(TRACE_XEN_CDROM_UNREALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 74 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_cdrom_unrealize " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2112 "trace/trace-hw_block.h"
        } else {
#line 74 "../hw/block/trace-events"
            qemu_log("xen_cdrom_unrealize " "" "\n");
#line 2116 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_cdrom_unrealize(void)
{
    if (true) {
        _nocheck__trace_xen_cdrom_unrealize();
    }
}

#define TRACE_XEN_BLOCK_BLOCKDEV_ADD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BLOCK_BLOCKDEV_ADD) || \
    false)

static inline void _nocheck__trace_xen_block_blockdev_add(char * str)
{
    if (trace_event_get_state(TRACE_XEN_BLOCK_BLOCKDEV_ADD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 75 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_block_blockdev_add " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , str);
#line 2143 "trace/trace-hw_block.h"
        } else {
#line 75 "../hw/block/trace-events"
            qemu_log("xen_block_blockdev_add " "%s" "\n", str);
#line 2147 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_block_blockdev_add(char * str)
{
    if (true) {
        _nocheck__trace_xen_block_blockdev_add(str);
    }
}

#define TRACE_XEN_BLOCK_BLOCKDEV_DEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BLOCK_BLOCKDEV_DEL) || \
    false)

static inline void _nocheck__trace_xen_block_blockdev_del(const char * node_name)
{
    if (trace_event_get_state(TRACE_XEN_BLOCK_BLOCKDEV_DEL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 76 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_block_blockdev_del " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , node_name);
#line 2174 "trace/trace-hw_block.h"
        } else {
#line 76 "../hw/block/trace-events"
            qemu_log("xen_block_blockdev_del " "%s" "\n", node_name);
#line 2178 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_block_blockdev_del(const char * node_name)
{
    if (true) {
        _nocheck__trace_xen_block_blockdev_del(node_name);
    }
}

#define TRACE_XEN_BLOCK_DEVICE_CREATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BLOCK_DEVICE_CREATE) || \
    false)

static inline void _nocheck__trace_xen_block_device_create(unsigned int number)
{
    if (trace_event_get_state(TRACE_XEN_BLOCK_DEVICE_CREATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 77 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_block_device_create " "%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , number);
#line 2205 "trace/trace-hw_block.h"
        } else {
#line 77 "../hw/block/trace-events"
            qemu_log("xen_block_device_create " "%u" "\n", number);
#line 2209 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_block_device_create(unsigned int number)
{
    if (true) {
        _nocheck__trace_xen_block_device_create(number);
    }
}

#define TRACE_XEN_BLOCK_DEVICE_DESTROY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BLOCK_DEVICE_DESTROY) || \
    false)

static inline void _nocheck__trace_xen_block_device_destroy(unsigned int number)
{
    if (trace_event_get_state(TRACE_XEN_BLOCK_DEVICE_DESTROY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 78 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_block_device_destroy " "%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , number);
#line 2236 "trace/trace-hw_block.h"
        } else {
#line 78 "../hw/block/trace-events"
            qemu_log("xen_block_device_destroy " "%u" "\n", number);
#line 2240 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_block_device_destroy(unsigned int number)
{
    if (true) {
        _nocheck__trace_xen_block_device_destroy(number);
    }
}

#define TRACE_M25P80_FLASH_ERASE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_FLASH_ERASE) || \
    false)

static inline void _nocheck__trace_m25p80_flash_erase(void * s, int offset, uint32_t len)
{
    if (trace_event_get_state(TRACE_M25P80_FLASH_ERASE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 81 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_flash_erase " "[%p] offset = 0x%"PRIx32", len = %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, offset, len);
#line 2267 "trace/trace-hw_block.h"
        } else {
#line 81 "../hw/block/trace-events"
            qemu_log("m25p80_flash_erase " "[%p] offset = 0x%"PRIx32", len = %u" "\n", s, offset, len);
#line 2271 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_flash_erase(void * s, int offset, uint32_t len)
{
    if (true) {
        _nocheck__trace_m25p80_flash_erase(s, offset, len);
    }
}

#define TRACE_M25P80_PROGRAMMING_ZERO_TO_ONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_PROGRAMMING_ZERO_TO_ONE) || \
    false)

static inline void _nocheck__trace_m25p80_programming_zero_to_one(void * s, uint32_t addr, uint8_t prev, uint8_t data)
{
    if (trace_event_get_state(TRACE_M25P80_PROGRAMMING_ZERO_TO_ONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 82 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_programming_zero_to_one " "[%p] programming zero to one! addr=0x%"PRIx32"  0x%"PRIx8" -> 0x%"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, addr, prev, data);
#line 2298 "trace/trace-hw_block.h"
        } else {
#line 82 "../hw/block/trace-events"
            qemu_log("m25p80_programming_zero_to_one " "[%p] programming zero to one! addr=0x%"PRIx32"  0x%"PRIx8" -> 0x%"PRIx8 "\n", s, addr, prev, data);
#line 2302 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_programming_zero_to_one(void * s, uint32_t addr, uint8_t prev, uint8_t data)
{
    if (true) {
        _nocheck__trace_m25p80_programming_zero_to_one(s, addr, prev, data);
    }
}

#define TRACE_M25P80_RESET_DONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_RESET_DONE) || \
    false)

static inline void _nocheck__trace_m25p80_reset_done(void * s)
{
    if (trace_event_get_state(TRACE_M25P80_RESET_DONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 83 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_reset_done " "[%p] Reset done." "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s);
#line 2329 "trace/trace-hw_block.h"
        } else {
#line 83 "../hw/block/trace-events"
            qemu_log("m25p80_reset_done " "[%p] Reset done." "\n", s);
#line 2333 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_reset_done(void * s)
{
    if (true) {
        _nocheck__trace_m25p80_reset_done(s);
    }
}

#define TRACE_M25P80_COMMAND_DECODED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_COMMAND_DECODED) || \
    false)

static inline void _nocheck__trace_m25p80_command_decoded(void * s, uint32_t cmd)
{
    if (trace_event_get_state(TRACE_M25P80_COMMAND_DECODED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 84 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_command_decoded " "[%p] new command:0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, cmd);
#line 2360 "trace/trace-hw_block.h"
        } else {
#line 84 "../hw/block/trace-events"
            qemu_log("m25p80_command_decoded " "[%p] new command:0x%"PRIx32 "\n", s, cmd);
#line 2364 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_command_decoded(void * s, uint32_t cmd)
{
    if (true) {
        _nocheck__trace_m25p80_command_decoded(s, cmd);
    }
}

#define TRACE_M25P80_COMPLETE_COLLECTING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_COMPLETE_COLLECTING) || \
    false)

static inline void _nocheck__trace_m25p80_complete_collecting(void * s, uint32_t cmd, int n, uint8_t ear, uint32_t cur_addr)
{
    if (trace_event_get_state(TRACE_M25P80_COMPLETE_COLLECTING) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 85 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_complete_collecting " "[%p] decode cmd: 0x%"PRIx32" len %d ear 0x%"PRIx8" addr 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, cmd, n, ear, cur_addr);
#line 2391 "trace/trace-hw_block.h"
        } else {
#line 85 "../hw/block/trace-events"
            qemu_log("m25p80_complete_collecting " "[%p] decode cmd: 0x%"PRIx32" len %d ear 0x%"PRIx8" addr 0x%"PRIx32 "\n", s, cmd, n, ear, cur_addr);
#line 2395 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_complete_collecting(void * s, uint32_t cmd, int n, uint8_t ear, uint32_t cur_addr)
{
    if (true) {
        _nocheck__trace_m25p80_complete_collecting(s, cmd, n, ear, cur_addr);
    }
}

#define TRACE_M25P80_POPULATED_JEDEC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_POPULATED_JEDEC) || \
    false)

static inline void _nocheck__trace_m25p80_populated_jedec(void * s)
{
    if (trace_event_get_state(TRACE_M25P80_POPULATED_JEDEC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 86 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_populated_jedec " "[%p] populated jedec code" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s);
#line 2422 "trace/trace-hw_block.h"
        } else {
#line 86 "../hw/block/trace-events"
            qemu_log("m25p80_populated_jedec " "[%p] populated jedec code" "\n", s);
#line 2426 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_populated_jedec(void * s)
{
    if (true) {
        _nocheck__trace_m25p80_populated_jedec(s);
    }
}

#define TRACE_M25P80_CHIP_ERASE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_CHIP_ERASE) || \
    false)

static inline void _nocheck__trace_m25p80_chip_erase(void * s)
{
    if (trace_event_get_state(TRACE_M25P80_CHIP_ERASE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 87 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_chip_erase " "[%p] chip erase" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s);
#line 2453 "trace/trace-hw_block.h"
        } else {
#line 87 "../hw/block/trace-events"
            qemu_log("m25p80_chip_erase " "[%p] chip erase" "\n", s);
#line 2457 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_chip_erase(void * s)
{
    if (true) {
        _nocheck__trace_m25p80_chip_erase(s);
    }
}

#define TRACE_M25P80_SELECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_SELECT) || \
    false)

static inline void _nocheck__trace_m25p80_select(void * s, const char * what)
{
    if (trace_event_get_state(TRACE_M25P80_SELECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 88 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_select " "[%p] %sselect" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, what);
#line 2484 "trace/trace-hw_block.h"
        } else {
#line 88 "../hw/block/trace-events"
            qemu_log("m25p80_select " "[%p] %sselect" "\n", s, what);
#line 2488 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_select(void * s, const char * what)
{
    if (true) {
        _nocheck__trace_m25p80_select(s, what);
    }
}

#define TRACE_M25P80_PAGE_PROGRAM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_PAGE_PROGRAM) || \
    false)

static inline void _nocheck__trace_m25p80_page_program(void * s, uint32_t addr, uint8_t tx)
{
    if (trace_event_get_state(TRACE_M25P80_PAGE_PROGRAM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 89 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_page_program " "[%p] page program cur_addr=0x%"PRIx32" data=0x%"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, addr, tx);
#line 2515 "trace/trace-hw_block.h"
        } else {
#line 89 "../hw/block/trace-events"
            qemu_log("m25p80_page_program " "[%p] page program cur_addr=0x%"PRIx32" data=0x%"PRIx8 "\n", s, addr, tx);
#line 2519 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_page_program(void * s, uint32_t addr, uint8_t tx)
{
    if (true) {
        _nocheck__trace_m25p80_page_program(s, addr, tx);
    }
}

#define TRACE_M25P80_TRANSFER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_TRANSFER) || \
    false)

static inline void _nocheck__trace_m25p80_transfer(void * s, uint8_t state, uint32_t len, uint8_t needed, uint32_t pos, uint32_t cur_addr, uint8_t t)
{
    if (trace_event_get_state(TRACE_M25P80_TRANSFER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 90 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_transfer " "[%p] Transfer state 0x%"PRIx8" len 0x%"PRIx32" needed 0x%"PRIx8" pos 0x%"PRIx32" addr 0x%"PRIx32" tx 0x%"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, state, len, needed, pos, cur_addr, t);
#line 2546 "trace/trace-hw_block.h"
        } else {
#line 90 "../hw/block/trace-events"
            qemu_log("m25p80_transfer " "[%p] Transfer state 0x%"PRIx8" len 0x%"PRIx32" needed 0x%"PRIx8" pos 0x%"PRIx32" addr 0x%"PRIx32" tx 0x%"PRIx8 "\n", s, state, len, needed, pos, cur_addr, t);
#line 2550 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_transfer(void * s, uint8_t state, uint32_t len, uint8_t needed, uint32_t pos, uint32_t cur_addr, uint8_t t)
{
    if (true) {
        _nocheck__trace_m25p80_transfer(s, state, len, needed, pos, cur_addr, t);
    }
}

#define TRACE_M25P80_READ_BYTE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_READ_BYTE) || \
    false)

static inline void _nocheck__trace_m25p80_read_byte(void * s, uint32_t addr, uint8_t v)
{
    if (trace_event_get_state(TRACE_M25P80_READ_BYTE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 91 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_read_byte " "[%p] Read byte 0x%"PRIx32"=0x%"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, addr, v);
#line 2577 "trace/trace-hw_block.h"
        } else {
#line 91 "../hw/block/trace-events"
            qemu_log("m25p80_read_byte " "[%p] Read byte 0x%"PRIx32"=0x%"PRIx8 "\n", s, addr, v);
#line 2581 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_read_byte(void * s, uint32_t addr, uint8_t v)
{
    if (true) {
        _nocheck__trace_m25p80_read_byte(s, addr, v);
    }
}

#define TRACE_M25P80_READ_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_READ_DATA) || \
    false)

static inline void _nocheck__trace_m25p80_read_data(void * s, uint32_t pos, uint8_t v)
{
    if (trace_event_get_state(TRACE_M25P80_READ_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 92 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_read_data " "[%p] Read data 0x%"PRIx32"=0x%"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, pos, v);
#line 2608 "trace/trace-hw_block.h"
        } else {
#line 92 "../hw/block/trace-events"
            qemu_log("m25p80_read_data " "[%p] Read data 0x%"PRIx32"=0x%"PRIx8 "\n", s, pos, v);
#line 2612 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_read_data(void * s, uint32_t pos, uint8_t v)
{
    if (true) {
        _nocheck__trace_m25p80_read_data(s, pos, v);
    }
}

#define TRACE_M25P80_READ_SFDP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_READ_SFDP) || \
    false)

static inline void _nocheck__trace_m25p80_read_sfdp(void * s, uint32_t addr, uint8_t v)
{
    if (trace_event_get_state(TRACE_M25P80_READ_SFDP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 93 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_read_sfdp " "[%p] Read SFDP 0x%"PRIx32"=0x%"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, addr, v);
#line 2639 "trace/trace-hw_block.h"
        } else {
#line 93 "../hw/block/trace-events"
            qemu_log("m25p80_read_sfdp " "[%p] Read SFDP 0x%"PRIx32"=0x%"PRIx8 "\n", s, addr, v);
#line 2643 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_read_sfdp(void * s, uint32_t addr, uint8_t v)
{
    if (true) {
        _nocheck__trace_m25p80_read_sfdp(s, addr, v);
    }
}

#define TRACE_M25P80_BINDING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_BINDING) || \
    false)

static inline void _nocheck__trace_m25p80_binding(void * s)
{
    if (trace_event_get_state(TRACE_M25P80_BINDING) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 94 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_binding " "[%p] Binding to IF_MTD drive" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s);
#line 2670 "trace/trace-hw_block.h"
        } else {
#line 94 "../hw/block/trace-events"
            qemu_log("m25p80_binding " "[%p] Binding to IF_MTD drive" "\n", s);
#line 2674 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_binding(void * s)
{
    if (true) {
        _nocheck__trace_m25p80_binding(s);
    }
}

#define TRACE_M25P80_BINDING_NO_BDRV_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_BINDING_NO_BDRV) || \
    false)

static inline void _nocheck__trace_m25p80_binding_no_bdrv(void * s)
{
    if (trace_event_get_state(TRACE_M25P80_BINDING_NO_BDRV) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 95 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_binding_no_bdrv " "[%p] No BDRV - binding to RAM" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s);
#line 2701 "trace/trace-hw_block.h"
        } else {
#line 95 "../hw/block/trace-events"
            qemu_log("m25p80_binding_no_bdrv " "[%p] No BDRV - binding to RAM" "\n", s);
#line 2705 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_binding_no_bdrv(void * s)
{
    if (true) {
        _nocheck__trace_m25p80_binding_no_bdrv(s);
    }
}

#define TRACE_SWIM_ISMCTRL_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SWIM_ISMCTRL_READ) || \
    false)

static inline void _nocheck__trace_swim_ismctrl_read(int reg, const char * name, unsigned size, uint64_t value)
{
    if (trace_event_get_state(TRACE_SWIM_ISMCTRL_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 98 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:swim_ismctrl_read " "reg=%d [%s] size=%u value=0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reg, name, size, value);
#line 2732 "trace/trace-hw_block.h"
        } else {
#line 98 "../hw/block/trace-events"
            qemu_log("swim_ismctrl_read " "reg=%d [%s] size=%u value=0x%"PRIx64 "\n", reg, name, size, value);
#line 2736 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_swim_ismctrl_read(int reg, const char * name, unsigned size, uint64_t value)
{
    if (true) {
        _nocheck__trace_swim_ismctrl_read(reg, name, size, value);
    }
}

#define TRACE_SWIM_ISMCTRL_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SWIM_ISMCTRL_WRITE) || \
    false)

static inline void _nocheck__trace_swim_ismctrl_write(int reg, const char * name, unsigned size, uint64_t value)
{
    if (trace_event_get_state(TRACE_SWIM_ISMCTRL_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 99 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:swim_ismctrl_write " "reg=%d [%s] size=%u value=0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reg, name, size, value);
#line 2763 "trace/trace-hw_block.h"
        } else {
#line 99 "../hw/block/trace-events"
            qemu_log("swim_ismctrl_write " "reg=%d [%s] size=%u value=0x%"PRIx64 "\n", reg, name, size, value);
#line 2767 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_swim_ismctrl_write(int reg, const char * name, unsigned size, uint64_t value)
{
    if (true) {
        _nocheck__trace_swim_ismctrl_write(reg, name, size, value);
    }
}

#define TRACE_SWIM_IWMCTRL_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SWIM_IWMCTRL_READ) || \
    false)

static inline void _nocheck__trace_swim_iwmctrl_read(int reg, const char * name, unsigned size, uint64_t value)
{
    if (trace_event_get_state(TRACE_SWIM_IWMCTRL_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 100 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:swim_iwmctrl_read " "reg=%d [%s] size=%u value=0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reg, name, size, value);
#line 2794 "trace/trace-hw_block.h"
        } else {
#line 100 "../hw/block/trace-events"
            qemu_log("swim_iwmctrl_read " "reg=%d [%s] size=%u value=0x%"PRIx64 "\n", reg, name, size, value);
#line 2798 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_swim_iwmctrl_read(int reg, const char * name, unsigned size, uint64_t value)
{
    if (true) {
        _nocheck__trace_swim_iwmctrl_read(reg, name, size, value);
    }
}

#define TRACE_SWIM_IWMCTRL_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SWIM_IWMCTRL_WRITE) || \
    false)

static inline void _nocheck__trace_swim_iwmctrl_write(int reg, const char * name, unsigned size, uint64_t value)
{
    if (trace_event_get_state(TRACE_SWIM_IWMCTRL_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 101 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:swim_iwmctrl_write " "reg=%d [%s] size=%u value=0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reg, name, size, value);
#line 2825 "trace/trace-hw_block.h"
        } else {
#line 101 "../hw/block/trace-events"
            qemu_log("swim_iwmctrl_write " "reg=%d [%s] size=%u value=0x%"PRIx64 "\n", reg, name, size, value);
#line 2829 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_swim_iwmctrl_write(int reg, const char * name, unsigned size, uint64_t value)
{
    if (true) {
        _nocheck__trace_swim_iwmctrl_write(reg, name, size, value);
    }
}

#define TRACE_SWIM_SWITCH_TO_ISM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SWIM_SWITCH_TO_ISM) || \
    false)

static inline void _nocheck__trace_swim_switch_to_ism(void)
{
    if (trace_event_get_state(TRACE_SWIM_SWITCH_TO_ISM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 102 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:swim_switch_to_ism " "switch from IWM to ISM mode" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2856 "trace/trace-hw_block.h"
        } else {
#line 102 "../hw/block/trace-events"
            qemu_log("swim_switch_to_ism " "switch from IWM to ISM mode" "\n");
#line 2860 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_swim_switch_to_ism(void)
{
    if (true) {
        _nocheck__trace_swim_switch_to_ism();
    }
}

#define TRACE_SWIM_SWITCH_TO_IWM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SWIM_SWITCH_TO_IWM) || \
    false)

static inline void _nocheck__trace_swim_switch_to_iwm(void)
{
    if (trace_event_get_state(TRACE_SWIM_SWITCH_TO_IWM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 103 "../hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:swim_switch_to_iwm " "switch from ISM to IWM mode" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2887 "trace/trace-hw_block.h"
        } else {
#line 103 "../hw/block/trace-events"
            qemu_log("swim_switch_to_iwm " "switch from ISM to IWM mode" "\n");
#line 2891 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_swim_switch_to_iwm(void)
{
    if (true) {
        _nocheck__trace_swim_switch_to_iwm();
    }
}
#endif /* TRACE_HW_BLOCK_GENERATED_TRACERS_H */
