/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_ARM_GENERATED_TRACERS_H
#define TRACE_HW_ARM_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_VIRT_ACPI_SETUP_EVENT;
extern TraceEvent _TRACE_SMMU_ADD_MR_EVENT;
extern TraceEvent _TRACE_SMMU_PTW_LEVEL_EVENT;
extern TraceEvent _TRACE_SMMU_PTW_INVALID_PTE_EVENT;
extern TraceEvent _TRACE_SMMU_PTW_PAGE_PTE_EVENT;
extern TraceEvent _TRACE_SMMU_PTW_BLOCK_PTE_EVENT;
extern TraceEvent _TRACE_SMMU_GET_PTE_EVENT;
extern TraceEvent _TRACE_SMMU_IOTLB_INV_ALL_EVENT;
extern TraceEvent _TRACE_SMMU_IOTLB_INV_ASID_VMID_EVENT;
extern TraceEvent _TRACE_SMMU_IOTLB_INV_VMID_EVENT;
extern TraceEvent _TRACE_SMMU_IOTLB_INV_VMID_S1_EVENT;
extern TraceEvent _TRACE_SMMU_IOTLB_INV_IOVA_EVENT;
extern TraceEvent _TRACE_SMMU_INV_NOTIFIERS_MR_EVENT;
extern TraceEvent _TRACE_SMMU_IOTLB_LOOKUP_HIT_EVENT;
extern TraceEvent _TRACE_SMMU_IOTLB_LOOKUP_MISS_EVENT;
extern TraceEvent _TRACE_SMMU_IOTLB_INSERT_EVENT;
extern TraceEvent _TRACE_SMMUV3_READ_MMIO_EVENT;
extern TraceEvent _TRACE_SMMUV3_TRIGGER_IRQ_EVENT;
extern TraceEvent _TRACE_SMMUV3_WRITE_GERROR_EVENT;
extern TraceEvent _TRACE_SMMUV3_WRITE_GERRORN_EVENT;
extern TraceEvent _TRACE_SMMUV3_UNHANDLED_CMD_EVENT;
extern TraceEvent _TRACE_SMMUV3_CMDQ_CONSUME_EVENT;
extern TraceEvent _TRACE_SMMUV3_CMDQ_OPCODE_EVENT;
extern TraceEvent _TRACE_SMMUV3_CMDQ_CONSUME_OUT_EVENT;
extern TraceEvent _TRACE_SMMUV3_CMDQ_CONSUME_ERROR_EVENT;
extern TraceEvent _TRACE_SMMUV3_WRITE_MMIO_EVENT;
extern TraceEvent _TRACE_SMMUV3_RECORD_EVENT_EVENT;
extern TraceEvent _TRACE_SMMUV3_FIND_STE_EVENT;
extern TraceEvent _TRACE_SMMUV3_FIND_STE_2LVL_EVENT;
extern TraceEvent _TRACE_SMMUV3_GET_STE_EVENT;
extern TraceEvent _TRACE_SMMUV3_TRANSLATE_DISABLE_EVENT;
extern TraceEvent _TRACE_SMMUV3_TRANSLATE_BYPASS_EVENT;
extern TraceEvent _TRACE_SMMUV3_TRANSLATE_ABORT_EVENT;
extern TraceEvent _TRACE_SMMUV3_TRANSLATE_SUCCESS_EVENT;
extern TraceEvent _TRACE_SMMUV3_GET_CD_EVENT;
extern TraceEvent _TRACE_SMMUV3_DECODE_CD_EVENT;
extern TraceEvent _TRACE_SMMUV3_DECODE_CD_TT_EVENT;
extern TraceEvent _TRACE_SMMUV3_CMDQ_CFGI_STE_EVENT;
extern TraceEvent _TRACE_SMMUV3_CMDQ_CFGI_STE_RANGE_EVENT;
extern TraceEvent _TRACE_SMMUV3_CMDQ_CFGI_CD_EVENT;
extern TraceEvent _TRACE_SMMUV3_CONFIG_CACHE_HIT_EVENT;
extern TraceEvent _TRACE_SMMUV3_CONFIG_CACHE_MISS_EVENT;
extern TraceEvent _TRACE_SMMUV3_RANGE_INVAL_EVENT;
extern TraceEvent _TRACE_SMMUV3_CMDQ_TLBI_NH_EVENT;
extern TraceEvent _TRACE_SMMUV3_CMDQ_TLBI_NSNH_EVENT;
extern TraceEvent _TRACE_SMMUV3_CMDQ_TLBI_NH_ASID_EVENT;
extern TraceEvent _TRACE_SMMUV3_CMDQ_TLBI_S12_VMID_EVENT;
extern TraceEvent _TRACE_SMMUV3_CONFIG_CACHE_INV_EVENT;
extern TraceEvent _TRACE_SMMUV3_NOTIFY_FLAG_ADD_EVENT;
extern TraceEvent _TRACE_SMMUV3_NOTIFY_FLAG_DEL_EVENT;
extern TraceEvent _TRACE_SMMUV3_INV_NOTIFIERS_IOVA_EVENT;
extern TraceEvent _TRACE_STRONGARM_UART_UPDATE_PARAMETERS_EVENT;
extern TraceEvent _TRACE_STRONGARM_SSP_READ_UNDERRUN_EVENT;
extern TraceEvent _TRACE_Z2_LCD_REG_UPDATE_EVENT;
extern TraceEvent _TRACE_Z2_LCD_ENABLE_DISABLE_RESULT_EVENT;
extern TraceEvent _TRACE_Z2_AER915_SEND_TOO_LONG_EVENT;
extern TraceEvent _TRACE_Z2_AER915_SEND_EVENT;
extern TraceEvent _TRACE_Z2_AER915_EVENT_EVENT;
extern TraceEvent _TRACE_XEN_CREATE_VIRTIO_MMIO_DEVICES_EVENT;
extern TraceEvent _TRACE_XEN_INIT_RAM_EVENT;
extern TraceEvent _TRACE_XEN_ENABLE_TPM_EVENT;
extern TraceEvent _TRACE_BCM2838_GIC_SET_IRQ_EVENT;
extern uint16_t _TRACE_VIRT_ACPI_SETUP_DSTATE;
extern uint16_t _TRACE_SMMU_ADD_MR_DSTATE;
extern uint16_t _TRACE_SMMU_PTW_LEVEL_DSTATE;
extern uint16_t _TRACE_SMMU_PTW_INVALID_PTE_DSTATE;
extern uint16_t _TRACE_SMMU_PTW_PAGE_PTE_DSTATE;
extern uint16_t _TRACE_SMMU_PTW_BLOCK_PTE_DSTATE;
extern uint16_t _TRACE_SMMU_GET_PTE_DSTATE;
extern uint16_t _TRACE_SMMU_IOTLB_INV_ALL_DSTATE;
extern uint16_t _TRACE_SMMU_IOTLB_INV_ASID_VMID_DSTATE;
extern uint16_t _TRACE_SMMU_IOTLB_INV_VMID_DSTATE;
extern uint16_t _TRACE_SMMU_IOTLB_INV_VMID_S1_DSTATE;
extern uint16_t _TRACE_SMMU_IOTLB_INV_IOVA_DSTATE;
extern uint16_t _TRACE_SMMU_INV_NOTIFIERS_MR_DSTATE;
extern uint16_t _TRACE_SMMU_IOTLB_LOOKUP_HIT_DSTATE;
extern uint16_t _TRACE_SMMU_IOTLB_LOOKUP_MISS_DSTATE;
extern uint16_t _TRACE_SMMU_IOTLB_INSERT_DSTATE;
extern uint16_t _TRACE_SMMUV3_READ_MMIO_DSTATE;
extern uint16_t _TRACE_SMMUV3_TRIGGER_IRQ_DSTATE;
extern uint16_t _TRACE_SMMUV3_WRITE_GERROR_DSTATE;
extern uint16_t _TRACE_SMMUV3_WRITE_GERRORN_DSTATE;
extern uint16_t _TRACE_SMMUV3_UNHANDLED_CMD_DSTATE;
extern uint16_t _TRACE_SMMUV3_CMDQ_CONSUME_DSTATE;
extern uint16_t _TRACE_SMMUV3_CMDQ_OPCODE_DSTATE;
extern uint16_t _TRACE_SMMUV3_CMDQ_CONSUME_OUT_DSTATE;
extern uint16_t _TRACE_SMMUV3_CMDQ_CONSUME_ERROR_DSTATE;
extern uint16_t _TRACE_SMMUV3_WRITE_MMIO_DSTATE;
extern uint16_t _TRACE_SMMUV3_RECORD_EVENT_DSTATE;
extern uint16_t _TRACE_SMMUV3_FIND_STE_DSTATE;
extern uint16_t _TRACE_SMMUV3_FIND_STE_2LVL_DSTATE;
extern uint16_t _TRACE_SMMUV3_GET_STE_DSTATE;
extern uint16_t _TRACE_SMMUV3_TRANSLATE_DISABLE_DSTATE;
extern uint16_t _TRACE_SMMUV3_TRANSLATE_BYPASS_DSTATE;
extern uint16_t _TRACE_SMMUV3_TRANSLATE_ABORT_DSTATE;
extern uint16_t _TRACE_SMMUV3_TRANSLATE_SUCCESS_DSTATE;
extern uint16_t _TRACE_SMMUV3_GET_CD_DSTATE;
extern uint16_t _TRACE_SMMUV3_DECODE_CD_DSTATE;
extern uint16_t _TRACE_SMMUV3_DECODE_CD_TT_DSTATE;
extern uint16_t _TRACE_SMMUV3_CMDQ_CFGI_STE_DSTATE;
extern uint16_t _TRACE_SMMUV3_CMDQ_CFGI_STE_RANGE_DSTATE;
extern uint16_t _TRACE_SMMUV3_CMDQ_CFGI_CD_DSTATE;
extern uint16_t _TRACE_SMMUV3_CONFIG_CACHE_HIT_DSTATE;
extern uint16_t _TRACE_SMMUV3_CONFIG_CACHE_MISS_DSTATE;
extern uint16_t _TRACE_SMMUV3_RANGE_INVAL_DSTATE;
extern uint16_t _TRACE_SMMUV3_CMDQ_TLBI_NH_DSTATE;
extern uint16_t _TRACE_SMMUV3_CMDQ_TLBI_NSNH_DSTATE;
extern uint16_t _TRACE_SMMUV3_CMDQ_TLBI_NH_ASID_DSTATE;
extern uint16_t _TRACE_SMMUV3_CMDQ_TLBI_S12_VMID_DSTATE;
extern uint16_t _TRACE_SMMUV3_CONFIG_CACHE_INV_DSTATE;
extern uint16_t _TRACE_SMMUV3_NOTIFY_FLAG_ADD_DSTATE;
extern uint16_t _TRACE_SMMUV3_NOTIFY_FLAG_DEL_DSTATE;
extern uint16_t _TRACE_SMMUV3_INV_NOTIFIERS_IOVA_DSTATE;
extern uint16_t _TRACE_STRONGARM_UART_UPDATE_PARAMETERS_DSTATE;
extern uint16_t _TRACE_STRONGARM_SSP_READ_UNDERRUN_DSTATE;
extern uint16_t _TRACE_Z2_LCD_REG_UPDATE_DSTATE;
extern uint16_t _TRACE_Z2_LCD_ENABLE_DISABLE_RESULT_DSTATE;
extern uint16_t _TRACE_Z2_AER915_SEND_TOO_LONG_DSTATE;
extern uint16_t _TRACE_Z2_AER915_SEND_DSTATE;
extern uint16_t _TRACE_Z2_AER915_EVENT_DSTATE;
extern uint16_t _TRACE_XEN_CREATE_VIRTIO_MMIO_DEVICES_DSTATE;
extern uint16_t _TRACE_XEN_INIT_RAM_DSTATE;
extern uint16_t _TRACE_XEN_ENABLE_TPM_DSTATE;
extern uint16_t _TRACE_BCM2838_GIC_SET_IRQ_DSTATE;
#define TRACE_VIRT_ACPI_SETUP_ENABLED 1
#define TRACE_SMMU_ADD_MR_ENABLED 1
#define TRACE_SMMU_PTW_LEVEL_ENABLED 1
#define TRACE_SMMU_PTW_INVALID_PTE_ENABLED 1
#define TRACE_SMMU_PTW_PAGE_PTE_ENABLED 1
#define TRACE_SMMU_PTW_BLOCK_PTE_ENABLED 1
#define TRACE_SMMU_GET_PTE_ENABLED 1
#define TRACE_SMMU_IOTLB_INV_ALL_ENABLED 1
#define TRACE_SMMU_IOTLB_INV_ASID_VMID_ENABLED 1
#define TRACE_SMMU_IOTLB_INV_VMID_ENABLED 1
#define TRACE_SMMU_IOTLB_INV_VMID_S1_ENABLED 1
#define TRACE_SMMU_IOTLB_INV_IOVA_ENABLED 1
#define TRACE_SMMU_INV_NOTIFIERS_MR_ENABLED 1
#define TRACE_SMMU_IOTLB_LOOKUP_HIT_ENABLED 1
#define TRACE_SMMU_IOTLB_LOOKUP_MISS_ENABLED 1
#define TRACE_SMMU_IOTLB_INSERT_ENABLED 1
#define TRACE_SMMUV3_READ_MMIO_ENABLED 1
#define TRACE_SMMUV3_TRIGGER_IRQ_ENABLED 1
#define TRACE_SMMUV3_WRITE_GERROR_ENABLED 1
#define TRACE_SMMUV3_WRITE_GERRORN_ENABLED 1
#define TRACE_SMMUV3_UNHANDLED_CMD_ENABLED 1
#define TRACE_SMMUV3_CMDQ_CONSUME_ENABLED 1
#define TRACE_SMMUV3_CMDQ_OPCODE_ENABLED 1
#define TRACE_SMMUV3_CMDQ_CONSUME_OUT_ENABLED 1
#define TRACE_SMMUV3_CMDQ_CONSUME_ERROR_ENABLED 1
#define TRACE_SMMUV3_WRITE_MMIO_ENABLED 1
#define TRACE_SMMUV3_RECORD_EVENT_ENABLED 1
#define TRACE_SMMUV3_FIND_STE_ENABLED 1
#define TRACE_SMMUV3_FIND_STE_2LVL_ENABLED 1
#define TRACE_SMMUV3_GET_STE_ENABLED 1
#define TRACE_SMMUV3_TRANSLATE_DISABLE_ENABLED 1
#define TRACE_SMMUV3_TRANSLATE_BYPASS_ENABLED 1
#define TRACE_SMMUV3_TRANSLATE_ABORT_ENABLED 1
#define TRACE_SMMUV3_TRANSLATE_SUCCESS_ENABLED 1
#define TRACE_SMMUV3_GET_CD_ENABLED 1
#define TRACE_SMMUV3_DECODE_CD_ENABLED 1
#define TRACE_SMMUV3_DECODE_CD_TT_ENABLED 1
#define TRACE_SMMUV3_CMDQ_CFGI_STE_ENABLED 1
#define TRACE_SMMUV3_CMDQ_CFGI_STE_RANGE_ENABLED 1
#define TRACE_SMMUV3_CMDQ_CFGI_CD_ENABLED 1
#define TRACE_SMMUV3_CONFIG_CACHE_HIT_ENABLED 1
#define TRACE_SMMUV3_CONFIG_CACHE_MISS_ENABLED 1
#define TRACE_SMMUV3_RANGE_INVAL_ENABLED 1
#define TRACE_SMMUV3_CMDQ_TLBI_NH_ENABLED 1
#define TRACE_SMMUV3_CMDQ_TLBI_NSNH_ENABLED 1
#define TRACE_SMMUV3_CMDQ_TLBI_NH_ASID_ENABLED 1
#define TRACE_SMMUV3_CMDQ_TLBI_S12_VMID_ENABLED 1
#define TRACE_SMMUV3_CONFIG_CACHE_INV_ENABLED 1
#define TRACE_SMMUV3_NOTIFY_FLAG_ADD_ENABLED 1
#define TRACE_SMMUV3_NOTIFY_FLAG_DEL_ENABLED 1
#define TRACE_SMMUV3_INV_NOTIFIERS_IOVA_ENABLED 1
#define TRACE_STRONGARM_UART_UPDATE_PARAMETERS_ENABLED 1
#define TRACE_STRONGARM_SSP_READ_UNDERRUN_ENABLED 1
#define TRACE_Z2_LCD_REG_UPDATE_ENABLED 1
#define TRACE_Z2_LCD_ENABLE_DISABLE_RESULT_ENABLED 1
#define TRACE_Z2_AER915_SEND_TOO_LONG_ENABLED 1
#define TRACE_Z2_AER915_SEND_ENABLED 1
#define TRACE_Z2_AER915_EVENT_ENABLED 1
#define TRACE_XEN_CREATE_VIRTIO_MMIO_DEVICES_ENABLED 1
#define TRACE_XEN_INIT_RAM_ENABLED 1
#define TRACE_XEN_ENABLE_TPM_ENABLED 1
#define TRACE_BCM2838_GIC_SET_IRQ_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_VIRT_ACPI_SETUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRT_ACPI_SETUP) || \
    false)

static inline void _nocheck__trace_virt_acpi_setup(void)
{
    if (trace_event_get_state(TRACE_VIRT_ACPI_SETUP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 4 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:virt_acpi_setup " "No fw cfg or ACPI disabled. Bailing out." "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 214 "trace/trace-hw_arm.h"
        } else {
#line 4 "../hw/arm/trace-events"
            qemu_log("virt_acpi_setup " "No fw cfg or ACPI disabled. Bailing out." "\n");
#line 218 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_virt_acpi_setup(void)
{
    if (true) {
        _nocheck__trace_virt_acpi_setup();
    }
}

#define TRACE_SMMU_ADD_MR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMU_ADD_MR) || \
    false)

static inline void _nocheck__trace_smmu_add_mr(const char * name)
{
    if (trace_event_get_state(TRACE_SMMU_ADD_MR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 7 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmu_add_mr " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 245 "trace/trace-hw_arm.h"
        } else {
#line 7 "../hw/arm/trace-events"
            qemu_log("smmu_add_mr " "%s" "\n", name);
#line 249 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmu_add_mr(const char * name)
{
    if (true) {
        _nocheck__trace_smmu_add_mr(name);
    }
}

#define TRACE_SMMU_PTW_LEVEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMU_PTW_LEVEL) || \
    false)

static inline void _nocheck__trace_smmu_ptw_level(int stage, int level, uint64_t iova, size_t subpage_size, uint64_t baseaddr, uint32_t offset, uint64_t pte)
{
    if (trace_event_get_state(TRACE_SMMU_PTW_LEVEL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 8 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmu_ptw_level " "stage=%d level=%d iova=0x%"PRIx64" subpage_sz=0x%zx baseaddr=0x%"PRIx64" offset=%d => pte=0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , stage, level, iova, subpage_size, baseaddr, offset, pte);
#line 276 "trace/trace-hw_arm.h"
        } else {
#line 8 "../hw/arm/trace-events"
            qemu_log("smmu_ptw_level " "stage=%d level=%d iova=0x%"PRIx64" subpage_sz=0x%zx baseaddr=0x%"PRIx64" offset=%d => pte=0x%"PRIx64 "\n", stage, level, iova, subpage_size, baseaddr, offset, pte);
#line 280 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmu_ptw_level(int stage, int level, uint64_t iova, size_t subpage_size, uint64_t baseaddr, uint32_t offset, uint64_t pte)
{
    if (true) {
        _nocheck__trace_smmu_ptw_level(stage, level, iova, subpage_size, baseaddr, offset, pte);
    }
}

#define TRACE_SMMU_PTW_INVALID_PTE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMU_PTW_INVALID_PTE) || \
    false)

static inline void _nocheck__trace_smmu_ptw_invalid_pte(int stage, int level, uint64_t baseaddr, uint64_t pteaddr, uint32_t offset, uint64_t pte)
{
    if (trace_event_get_state(TRACE_SMMU_PTW_INVALID_PTE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 9 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmu_ptw_invalid_pte " "stage=%d level=%d base@=0x%"PRIx64" pte@=0x%"PRIx64" offset=%d pte=0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , stage, level, baseaddr, pteaddr, offset, pte);
#line 307 "trace/trace-hw_arm.h"
        } else {
#line 9 "../hw/arm/trace-events"
            qemu_log("smmu_ptw_invalid_pte " "stage=%d level=%d base@=0x%"PRIx64" pte@=0x%"PRIx64" offset=%d pte=0x%"PRIx64 "\n", stage, level, baseaddr, pteaddr, offset, pte);
#line 311 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmu_ptw_invalid_pte(int stage, int level, uint64_t baseaddr, uint64_t pteaddr, uint32_t offset, uint64_t pte)
{
    if (true) {
        _nocheck__trace_smmu_ptw_invalid_pte(stage, level, baseaddr, pteaddr, offset, pte);
    }
}

#define TRACE_SMMU_PTW_PAGE_PTE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMU_PTW_PAGE_PTE) || \
    false)

static inline void _nocheck__trace_smmu_ptw_page_pte(int stage, int level, uint64_t iova, uint64_t baseaddr, uint64_t pteaddr, uint64_t pte, uint64_t address)
{
    if (trace_event_get_state(TRACE_SMMU_PTW_PAGE_PTE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 10 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmu_ptw_page_pte " "stage=%d level=%d iova=0x%"PRIx64" base@=0x%"PRIx64" pte@=0x%"PRIx64" pte=0x%"PRIx64" page address = 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , stage, level, iova, baseaddr, pteaddr, pte, address);
#line 338 "trace/trace-hw_arm.h"
        } else {
#line 10 "../hw/arm/trace-events"
            qemu_log("smmu_ptw_page_pte " "stage=%d level=%d iova=0x%"PRIx64" base@=0x%"PRIx64" pte@=0x%"PRIx64" pte=0x%"PRIx64" page address = 0x%"PRIx64 "\n", stage, level, iova, baseaddr, pteaddr, pte, address);
#line 342 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmu_ptw_page_pte(int stage, int level, uint64_t iova, uint64_t baseaddr, uint64_t pteaddr, uint64_t pte, uint64_t address)
{
    if (true) {
        _nocheck__trace_smmu_ptw_page_pte(stage, level, iova, baseaddr, pteaddr, pte, address);
    }
}

#define TRACE_SMMU_PTW_BLOCK_PTE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMU_PTW_BLOCK_PTE) || \
    false)

static inline void _nocheck__trace_smmu_ptw_block_pte(int stage, int level, uint64_t baseaddr, uint64_t pteaddr, uint64_t pte, uint64_t iova, uint64_t gpa, int bsize_mb)
{
    if (trace_event_get_state(TRACE_SMMU_PTW_BLOCK_PTE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 11 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmu_ptw_block_pte " "stage=%d level=%d base@=0x%"PRIx64" pte@=0x%"PRIx64" pte=0x%"PRIx64" iova=0x%"PRIx64" block address = 0x%"PRIx64" block size = %d MiB" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , stage, level, baseaddr, pteaddr, pte, iova, gpa, bsize_mb);
#line 369 "trace/trace-hw_arm.h"
        } else {
#line 11 "../hw/arm/trace-events"
            qemu_log("smmu_ptw_block_pte " "stage=%d level=%d base@=0x%"PRIx64" pte@=0x%"PRIx64" pte=0x%"PRIx64" iova=0x%"PRIx64" block address = 0x%"PRIx64" block size = %d MiB" "\n", stage, level, baseaddr, pteaddr, pte, iova, gpa, bsize_mb);
#line 373 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmu_ptw_block_pte(int stage, int level, uint64_t baseaddr, uint64_t pteaddr, uint64_t pte, uint64_t iova, uint64_t gpa, int bsize_mb)
{
    if (true) {
        _nocheck__trace_smmu_ptw_block_pte(stage, level, baseaddr, pteaddr, pte, iova, gpa, bsize_mb);
    }
}

#define TRACE_SMMU_GET_PTE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMU_GET_PTE) || \
    false)

static inline void _nocheck__trace_smmu_get_pte(uint64_t baseaddr, int index, uint64_t pteaddr, uint64_t pte)
{
    if (trace_event_get_state(TRACE_SMMU_GET_PTE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 12 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmu_get_pte " "baseaddr=0x%"PRIx64" index=0x%x, pteaddr=0x%"PRIx64", pte=0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , baseaddr, index, pteaddr, pte);
#line 400 "trace/trace-hw_arm.h"
        } else {
#line 12 "../hw/arm/trace-events"
            qemu_log("smmu_get_pte " "baseaddr=0x%"PRIx64" index=0x%x, pteaddr=0x%"PRIx64", pte=0x%"PRIx64 "\n", baseaddr, index, pteaddr, pte);
#line 404 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmu_get_pte(uint64_t baseaddr, int index, uint64_t pteaddr, uint64_t pte)
{
    if (true) {
        _nocheck__trace_smmu_get_pte(baseaddr, index, pteaddr, pte);
    }
}

#define TRACE_SMMU_IOTLB_INV_ALL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMU_IOTLB_INV_ALL) || \
    false)

static inline void _nocheck__trace_smmu_iotlb_inv_all(void)
{
    if (trace_event_get_state(TRACE_SMMU_IOTLB_INV_ALL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 13 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmu_iotlb_inv_all " "IOTLB invalidate all" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 431 "trace/trace-hw_arm.h"
        } else {
#line 13 "../hw/arm/trace-events"
            qemu_log("smmu_iotlb_inv_all " "IOTLB invalidate all" "\n");
#line 435 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmu_iotlb_inv_all(void)
{
    if (true) {
        _nocheck__trace_smmu_iotlb_inv_all();
    }
}

#define TRACE_SMMU_IOTLB_INV_ASID_VMID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMU_IOTLB_INV_ASID_VMID) || \
    false)

static inline void _nocheck__trace_smmu_iotlb_inv_asid_vmid(int asid, int vmid)
{
    if (trace_event_get_state(TRACE_SMMU_IOTLB_INV_ASID_VMID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 14 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmu_iotlb_inv_asid_vmid " "IOTLB invalidate asid=%d vmid=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , asid, vmid);
#line 462 "trace/trace-hw_arm.h"
        } else {
#line 14 "../hw/arm/trace-events"
            qemu_log("smmu_iotlb_inv_asid_vmid " "IOTLB invalidate asid=%d vmid=%d" "\n", asid, vmid);
#line 466 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmu_iotlb_inv_asid_vmid(int asid, int vmid)
{
    if (true) {
        _nocheck__trace_smmu_iotlb_inv_asid_vmid(asid, vmid);
    }
}

#define TRACE_SMMU_IOTLB_INV_VMID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMU_IOTLB_INV_VMID) || \
    false)

static inline void _nocheck__trace_smmu_iotlb_inv_vmid(int vmid)
{
    if (trace_event_get_state(TRACE_SMMU_IOTLB_INV_VMID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 15 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmu_iotlb_inv_vmid " "IOTLB invalidate vmid=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vmid);
#line 493 "trace/trace-hw_arm.h"
        } else {
#line 15 "../hw/arm/trace-events"
            qemu_log("smmu_iotlb_inv_vmid " "IOTLB invalidate vmid=%d" "\n", vmid);
#line 497 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmu_iotlb_inv_vmid(int vmid)
{
    if (true) {
        _nocheck__trace_smmu_iotlb_inv_vmid(vmid);
    }
}

#define TRACE_SMMU_IOTLB_INV_VMID_S1_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMU_IOTLB_INV_VMID_S1) || \
    false)

static inline void _nocheck__trace_smmu_iotlb_inv_vmid_s1(int vmid)
{
    if (trace_event_get_state(TRACE_SMMU_IOTLB_INV_VMID_S1) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 16 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmu_iotlb_inv_vmid_s1 " "IOTLB invalidate vmid=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vmid);
#line 524 "trace/trace-hw_arm.h"
        } else {
#line 16 "../hw/arm/trace-events"
            qemu_log("smmu_iotlb_inv_vmid_s1 " "IOTLB invalidate vmid=%d" "\n", vmid);
#line 528 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmu_iotlb_inv_vmid_s1(int vmid)
{
    if (true) {
        _nocheck__trace_smmu_iotlb_inv_vmid_s1(vmid);
    }
}

#define TRACE_SMMU_IOTLB_INV_IOVA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMU_IOTLB_INV_IOVA) || \
    false)

static inline void _nocheck__trace_smmu_iotlb_inv_iova(int asid, uint64_t addr)
{
    if (trace_event_get_state(TRACE_SMMU_IOTLB_INV_IOVA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 17 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmu_iotlb_inv_iova " "IOTLB invalidate asid=%d addr=0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , asid, addr);
#line 555 "trace/trace-hw_arm.h"
        } else {
#line 17 "../hw/arm/trace-events"
            qemu_log("smmu_iotlb_inv_iova " "IOTLB invalidate asid=%d addr=0x%"PRIx64 "\n", asid, addr);
#line 559 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmu_iotlb_inv_iova(int asid, uint64_t addr)
{
    if (true) {
        _nocheck__trace_smmu_iotlb_inv_iova(asid, addr);
    }
}

#define TRACE_SMMU_INV_NOTIFIERS_MR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMU_INV_NOTIFIERS_MR) || \
    false)

static inline void _nocheck__trace_smmu_inv_notifiers_mr(const char * name)
{
    if (trace_event_get_state(TRACE_SMMU_INV_NOTIFIERS_MR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 18 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmu_inv_notifiers_mr " "iommu mr=%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 586 "trace/trace-hw_arm.h"
        } else {
#line 18 "../hw/arm/trace-events"
            qemu_log("smmu_inv_notifiers_mr " "iommu mr=%s" "\n", name);
#line 590 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmu_inv_notifiers_mr(const char * name)
{
    if (true) {
        _nocheck__trace_smmu_inv_notifiers_mr(name);
    }
}

#define TRACE_SMMU_IOTLB_LOOKUP_HIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMU_IOTLB_LOOKUP_HIT) || \
    false)

static inline void _nocheck__trace_smmu_iotlb_lookup_hit(int asid, int vmid, uint64_t addr, uint32_t hit, uint32_t miss, uint32_t p)
{
    if (trace_event_get_state(TRACE_SMMU_IOTLB_LOOKUP_HIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 19 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmu_iotlb_lookup_hit " "IOTLB cache HIT asid=%d vmid=%d addr=0x%"PRIx64" hit=%d miss=%d hit rate=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , asid, vmid, addr, hit, miss, p);
#line 617 "trace/trace-hw_arm.h"
        } else {
#line 19 "../hw/arm/trace-events"
            qemu_log("smmu_iotlb_lookup_hit " "IOTLB cache HIT asid=%d vmid=%d addr=0x%"PRIx64" hit=%d miss=%d hit rate=%d" "\n", asid, vmid, addr, hit, miss, p);
#line 621 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmu_iotlb_lookup_hit(int asid, int vmid, uint64_t addr, uint32_t hit, uint32_t miss, uint32_t p)
{
    if (true) {
        _nocheck__trace_smmu_iotlb_lookup_hit(asid, vmid, addr, hit, miss, p);
    }
}

#define TRACE_SMMU_IOTLB_LOOKUP_MISS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMU_IOTLB_LOOKUP_MISS) || \
    false)

static inline void _nocheck__trace_smmu_iotlb_lookup_miss(int asid, int vmid, uint64_t addr, uint32_t hit, uint32_t miss, uint32_t p)
{
    if (trace_event_get_state(TRACE_SMMU_IOTLB_LOOKUP_MISS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 20 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmu_iotlb_lookup_miss " "IOTLB cache MISS asid=%d vmid=%d addr=0x%"PRIx64" hit=%d miss=%d hit rate=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , asid, vmid, addr, hit, miss, p);
#line 648 "trace/trace-hw_arm.h"
        } else {
#line 20 "../hw/arm/trace-events"
            qemu_log("smmu_iotlb_lookup_miss " "IOTLB cache MISS asid=%d vmid=%d addr=0x%"PRIx64" hit=%d miss=%d hit rate=%d" "\n", asid, vmid, addr, hit, miss, p);
#line 652 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmu_iotlb_lookup_miss(int asid, int vmid, uint64_t addr, uint32_t hit, uint32_t miss, uint32_t p)
{
    if (true) {
        _nocheck__trace_smmu_iotlb_lookup_miss(asid, vmid, addr, hit, miss, p);
    }
}

#define TRACE_SMMU_IOTLB_INSERT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMU_IOTLB_INSERT) || \
    false)

static inline void _nocheck__trace_smmu_iotlb_insert(int asid, int vmid, uint64_t addr, uint8_t tg, uint8_t level)
{
    if (trace_event_get_state(TRACE_SMMU_IOTLB_INSERT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 21 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmu_iotlb_insert " "IOTLB ++ asid=%d vmid=%d addr=0x%"PRIx64" tg=%d level=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , asid, vmid, addr, tg, level);
#line 679 "trace/trace-hw_arm.h"
        } else {
#line 21 "../hw/arm/trace-events"
            qemu_log("smmu_iotlb_insert " "IOTLB ++ asid=%d vmid=%d addr=0x%"PRIx64" tg=%d level=%d" "\n", asid, vmid, addr, tg, level);
#line 683 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmu_iotlb_insert(int asid, int vmid, uint64_t addr, uint8_t tg, uint8_t level)
{
    if (true) {
        _nocheck__trace_smmu_iotlb_insert(asid, vmid, addr, tg, level);
    }
}

#define TRACE_SMMUV3_READ_MMIO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_READ_MMIO) || \
    false)

static inline void _nocheck__trace_smmuv3_read_mmio(uint64_t addr, uint64_t val, unsigned size, uint32_t r)
{
    if (trace_event_get_state(TRACE_SMMUV3_READ_MMIO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 24 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmuv3_read_mmio " "addr: 0x%"PRIx64" val:0x%"PRIx64" size: 0x%x(%d)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val, size, r);
#line 710 "trace/trace-hw_arm.h"
        } else {
#line 24 "../hw/arm/trace-events"
            qemu_log("smmuv3_read_mmio " "addr: 0x%"PRIx64" val:0x%"PRIx64" size: 0x%x(%d)" "\n", addr, val, size, r);
#line 714 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmuv3_read_mmio(uint64_t addr, uint64_t val, unsigned size, uint32_t r)
{
    if (true) {
        _nocheck__trace_smmuv3_read_mmio(addr, val, size, r);
    }
}

#define TRACE_SMMUV3_TRIGGER_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_TRIGGER_IRQ) || \
    false)

static inline void _nocheck__trace_smmuv3_trigger_irq(int irq)
{
    if (trace_event_get_state(TRACE_SMMUV3_TRIGGER_IRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 25 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmuv3_trigger_irq " "irq=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , irq);
#line 741 "trace/trace-hw_arm.h"
        } else {
#line 25 "../hw/arm/trace-events"
            qemu_log("smmuv3_trigger_irq " "irq=%d" "\n", irq);
#line 745 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmuv3_trigger_irq(int irq)
{
    if (true) {
        _nocheck__trace_smmuv3_trigger_irq(irq);
    }
}

#define TRACE_SMMUV3_WRITE_GERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_WRITE_GERROR) || \
    false)

static inline void _nocheck__trace_smmuv3_write_gerror(uint32_t toggled, uint32_t gerror)
{
    if (trace_event_get_state(TRACE_SMMUV3_WRITE_GERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 26 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmuv3_write_gerror " "toggled=0x%x, new GERROR=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , toggled, gerror);
#line 772 "trace/trace-hw_arm.h"
        } else {
#line 26 "../hw/arm/trace-events"
            qemu_log("smmuv3_write_gerror " "toggled=0x%x, new GERROR=0x%x" "\n", toggled, gerror);
#line 776 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmuv3_write_gerror(uint32_t toggled, uint32_t gerror)
{
    if (true) {
        _nocheck__trace_smmuv3_write_gerror(toggled, gerror);
    }
}

#define TRACE_SMMUV3_WRITE_GERRORN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_WRITE_GERRORN) || \
    false)

static inline void _nocheck__trace_smmuv3_write_gerrorn(uint32_t acked, uint32_t gerrorn)
{
    if (trace_event_get_state(TRACE_SMMUV3_WRITE_GERRORN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 27 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmuv3_write_gerrorn " "acked=0x%x, new GERRORN=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , acked, gerrorn);
#line 803 "trace/trace-hw_arm.h"
        } else {
#line 27 "../hw/arm/trace-events"
            qemu_log("smmuv3_write_gerrorn " "acked=0x%x, new GERRORN=0x%x" "\n", acked, gerrorn);
#line 807 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmuv3_write_gerrorn(uint32_t acked, uint32_t gerrorn)
{
    if (true) {
        _nocheck__trace_smmuv3_write_gerrorn(acked, gerrorn);
    }
}

#define TRACE_SMMUV3_UNHANDLED_CMD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_UNHANDLED_CMD) || \
    false)

static inline void _nocheck__trace_smmuv3_unhandled_cmd(uint32_t type)
{
    if (trace_event_get_state(TRACE_SMMUV3_UNHANDLED_CMD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 28 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmuv3_unhandled_cmd " "Unhandled command type=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type);
#line 834 "trace/trace-hw_arm.h"
        } else {
#line 28 "../hw/arm/trace-events"
            qemu_log("smmuv3_unhandled_cmd " "Unhandled command type=%d" "\n", type);
#line 838 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmuv3_unhandled_cmd(uint32_t type)
{
    if (true) {
        _nocheck__trace_smmuv3_unhandled_cmd(type);
    }
}

#define TRACE_SMMUV3_CMDQ_CONSUME_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_CMDQ_CONSUME) || \
    false)

static inline void _nocheck__trace_smmuv3_cmdq_consume(uint32_t prod, uint32_t cons, uint8_t prod_wrap, uint8_t cons_wrap)
{
    if (trace_event_get_state(TRACE_SMMUV3_CMDQ_CONSUME) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 29 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmuv3_cmdq_consume " "prod=%d cons=%d prod.wrap=%d cons.wrap=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , prod, cons, prod_wrap, cons_wrap);
#line 865 "trace/trace-hw_arm.h"
        } else {
#line 29 "../hw/arm/trace-events"
            qemu_log("smmuv3_cmdq_consume " "prod=%d cons=%d prod.wrap=%d cons.wrap=%d" "\n", prod, cons, prod_wrap, cons_wrap);
#line 869 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmuv3_cmdq_consume(uint32_t prod, uint32_t cons, uint8_t prod_wrap, uint8_t cons_wrap)
{
    if (true) {
        _nocheck__trace_smmuv3_cmdq_consume(prod, cons, prod_wrap, cons_wrap);
    }
}

#define TRACE_SMMUV3_CMDQ_OPCODE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_CMDQ_OPCODE) || \
    false)

static inline void _nocheck__trace_smmuv3_cmdq_opcode(const char * opcode)
{
    if (trace_event_get_state(TRACE_SMMUV3_CMDQ_OPCODE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 30 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmuv3_cmdq_opcode " "<--- %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , opcode);
#line 896 "trace/trace-hw_arm.h"
        } else {
#line 30 "../hw/arm/trace-events"
            qemu_log("smmuv3_cmdq_opcode " "<--- %s" "\n", opcode);
#line 900 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmuv3_cmdq_opcode(const char * opcode)
{
    if (true) {
        _nocheck__trace_smmuv3_cmdq_opcode(opcode);
    }
}

#define TRACE_SMMUV3_CMDQ_CONSUME_OUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_CMDQ_CONSUME_OUT) || \
    false)

static inline void _nocheck__trace_smmuv3_cmdq_consume_out(uint32_t prod, uint32_t cons, uint8_t prod_wrap, uint8_t cons_wrap)
{
    if (trace_event_get_state(TRACE_SMMUV3_CMDQ_CONSUME_OUT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 31 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmuv3_cmdq_consume_out " "prod:%d, cons:%d, prod_wrap:%d, cons_wrap:%d " "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , prod, cons, prod_wrap, cons_wrap);
#line 927 "trace/trace-hw_arm.h"
        } else {
#line 31 "../hw/arm/trace-events"
            qemu_log("smmuv3_cmdq_consume_out " "prod:%d, cons:%d, prod_wrap:%d, cons_wrap:%d " "\n", prod, cons, prod_wrap, cons_wrap);
#line 931 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmuv3_cmdq_consume_out(uint32_t prod, uint32_t cons, uint8_t prod_wrap, uint8_t cons_wrap)
{
    if (true) {
        _nocheck__trace_smmuv3_cmdq_consume_out(prod, cons, prod_wrap, cons_wrap);
    }
}

#define TRACE_SMMUV3_CMDQ_CONSUME_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_CMDQ_CONSUME_ERROR) || \
    false)

static inline void _nocheck__trace_smmuv3_cmdq_consume_error(const char * cmd_name, uint8_t cmd_error)
{
    if (trace_event_get_state(TRACE_SMMUV3_CMDQ_CONSUME_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 32 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmuv3_cmdq_consume_error " "Error on %s command execution: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd_name, cmd_error);
#line 958 "trace/trace-hw_arm.h"
        } else {
#line 32 "../hw/arm/trace-events"
            qemu_log("smmuv3_cmdq_consume_error " "Error on %s command execution: %d" "\n", cmd_name, cmd_error);
#line 962 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmuv3_cmdq_consume_error(const char * cmd_name, uint8_t cmd_error)
{
    if (true) {
        _nocheck__trace_smmuv3_cmdq_consume_error(cmd_name, cmd_error);
    }
}

#define TRACE_SMMUV3_WRITE_MMIO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_WRITE_MMIO) || \
    false)

static inline void _nocheck__trace_smmuv3_write_mmio(uint64_t addr, uint64_t val, unsigned size, uint32_t r)
{
    if (trace_event_get_state(TRACE_SMMUV3_WRITE_MMIO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 33 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmuv3_write_mmio " "addr: 0x%"PRIx64" val:0x%"PRIx64" size: 0x%x(%d)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val, size, r);
#line 989 "trace/trace-hw_arm.h"
        } else {
#line 33 "../hw/arm/trace-events"
            qemu_log("smmuv3_write_mmio " "addr: 0x%"PRIx64" val:0x%"PRIx64" size: 0x%x(%d)" "\n", addr, val, size, r);
#line 993 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmuv3_write_mmio(uint64_t addr, uint64_t val, unsigned size, uint32_t r)
{
    if (true) {
        _nocheck__trace_smmuv3_write_mmio(addr, val, size, r);
    }
}

#define TRACE_SMMUV3_RECORD_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_RECORD_EVENT) || \
    false)

static inline void _nocheck__trace_smmuv3_record_event(const char * type, uint32_t sid)
{
    if (trace_event_get_state(TRACE_SMMUV3_RECORD_EVENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 34 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmuv3_record_event " "%s sid=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, sid);
#line 1020 "trace/trace-hw_arm.h"
        } else {
#line 34 "../hw/arm/trace-events"
            qemu_log("smmuv3_record_event " "%s sid=0x%x" "\n", type, sid);
#line 1024 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmuv3_record_event(const char * type, uint32_t sid)
{
    if (true) {
        _nocheck__trace_smmuv3_record_event(type, sid);
    }
}

#define TRACE_SMMUV3_FIND_STE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_FIND_STE) || \
    false)

static inline void _nocheck__trace_smmuv3_find_ste(uint16_t sid, uint32_t features, uint16_t sid_split)
{
    if (trace_event_get_state(TRACE_SMMUV3_FIND_STE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 35 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmuv3_find_ste " "sid=0x%x features:0x%x, sid_split:0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , sid, features, sid_split);
#line 1051 "trace/trace-hw_arm.h"
        } else {
#line 35 "../hw/arm/trace-events"
            qemu_log("smmuv3_find_ste " "sid=0x%x features:0x%x, sid_split:0x%x" "\n", sid, features, sid_split);
#line 1055 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmuv3_find_ste(uint16_t sid, uint32_t features, uint16_t sid_split)
{
    if (true) {
        _nocheck__trace_smmuv3_find_ste(sid, features, sid_split);
    }
}

#define TRACE_SMMUV3_FIND_STE_2LVL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_FIND_STE_2LVL) || \
    false)

static inline void _nocheck__trace_smmuv3_find_ste_2lvl(uint64_t strtab_base, uint64_t l1ptr, int l1_ste_offset, uint64_t l2ptr, int l2_ste_offset, int max_l2_ste)
{
    if (trace_event_get_state(TRACE_SMMUV3_FIND_STE_2LVL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 36 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmuv3_find_ste_2lvl " "strtab_base:0x%"PRIx64" l1ptr:0x%"PRIx64" l1_off:0x%x, l2ptr:0x%"PRIx64" l2_off:0x%x max_l2_ste:%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , strtab_base, l1ptr, l1_ste_offset, l2ptr, l2_ste_offset, max_l2_ste);
#line 1082 "trace/trace-hw_arm.h"
        } else {
#line 36 "../hw/arm/trace-events"
            qemu_log("smmuv3_find_ste_2lvl " "strtab_base:0x%"PRIx64" l1ptr:0x%"PRIx64" l1_off:0x%x, l2ptr:0x%"PRIx64" l2_off:0x%x max_l2_ste:%d" "\n", strtab_base, l1ptr, l1_ste_offset, l2ptr, l2_ste_offset, max_l2_ste);
#line 1086 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmuv3_find_ste_2lvl(uint64_t strtab_base, uint64_t l1ptr, int l1_ste_offset, uint64_t l2ptr, int l2_ste_offset, int max_l2_ste)
{
    if (true) {
        _nocheck__trace_smmuv3_find_ste_2lvl(strtab_base, l1ptr, l1_ste_offset, l2ptr, l2_ste_offset, max_l2_ste);
    }
}

#define TRACE_SMMUV3_GET_STE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_GET_STE) || \
    false)

static inline void _nocheck__trace_smmuv3_get_ste(uint64_t addr)
{
    if (trace_event_get_state(TRACE_SMMUV3_GET_STE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 37 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmuv3_get_ste " "STE addr: 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 1113 "trace/trace-hw_arm.h"
        } else {
#line 37 "../hw/arm/trace-events"
            qemu_log("smmuv3_get_ste " "STE addr: 0x%"PRIx64 "\n", addr);
#line 1117 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmuv3_get_ste(uint64_t addr)
{
    if (true) {
        _nocheck__trace_smmuv3_get_ste(addr);
    }
}

#define TRACE_SMMUV3_TRANSLATE_DISABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_TRANSLATE_DISABLE) || \
    false)

static inline void _nocheck__trace_smmuv3_translate_disable(const char * n, uint16_t sid, uint64_t addr, bool is_write)
{
    if (trace_event_get_state(TRACE_SMMUV3_TRANSLATE_DISABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 38 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmuv3_translate_disable " "%s sid=0x%x bypass (smmu disabled) iova:0x%"PRIx64" is_write=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , n, sid, addr, is_write);
#line 1144 "trace/trace-hw_arm.h"
        } else {
#line 38 "../hw/arm/trace-events"
            qemu_log("smmuv3_translate_disable " "%s sid=0x%x bypass (smmu disabled) iova:0x%"PRIx64" is_write=%d" "\n", n, sid, addr, is_write);
#line 1148 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmuv3_translate_disable(const char * n, uint16_t sid, uint64_t addr, bool is_write)
{
    if (true) {
        _nocheck__trace_smmuv3_translate_disable(n, sid, addr, is_write);
    }
}

#define TRACE_SMMUV3_TRANSLATE_BYPASS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_TRANSLATE_BYPASS) || \
    false)

static inline void _nocheck__trace_smmuv3_translate_bypass(const char * n, uint16_t sid, uint64_t addr, bool is_write)
{
    if (trace_event_get_state(TRACE_SMMUV3_TRANSLATE_BYPASS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 39 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmuv3_translate_bypass " "%s sid=0x%x STE bypass iova:0x%"PRIx64" is_write=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , n, sid, addr, is_write);
#line 1175 "trace/trace-hw_arm.h"
        } else {
#line 39 "../hw/arm/trace-events"
            qemu_log("smmuv3_translate_bypass " "%s sid=0x%x STE bypass iova:0x%"PRIx64" is_write=%d" "\n", n, sid, addr, is_write);
#line 1179 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmuv3_translate_bypass(const char * n, uint16_t sid, uint64_t addr, bool is_write)
{
    if (true) {
        _nocheck__trace_smmuv3_translate_bypass(n, sid, addr, is_write);
    }
}

#define TRACE_SMMUV3_TRANSLATE_ABORT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_TRANSLATE_ABORT) || \
    false)

static inline void _nocheck__trace_smmuv3_translate_abort(const char * n, uint16_t sid, uint64_t addr, bool is_write)
{
    if (trace_event_get_state(TRACE_SMMUV3_TRANSLATE_ABORT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 40 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmuv3_translate_abort " "%s sid=0x%x abort on iova:0x%"PRIx64" is_write=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , n, sid, addr, is_write);
#line 1206 "trace/trace-hw_arm.h"
        } else {
#line 40 "../hw/arm/trace-events"
            qemu_log("smmuv3_translate_abort " "%s sid=0x%x abort on iova:0x%"PRIx64" is_write=%d" "\n", n, sid, addr, is_write);
#line 1210 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmuv3_translate_abort(const char * n, uint16_t sid, uint64_t addr, bool is_write)
{
    if (true) {
        _nocheck__trace_smmuv3_translate_abort(n, sid, addr, is_write);
    }
}

#define TRACE_SMMUV3_TRANSLATE_SUCCESS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_TRANSLATE_SUCCESS) || \
    false)

static inline void _nocheck__trace_smmuv3_translate_success(const char * n, uint16_t sid, uint64_t iova, uint64_t translated, int perm, int stage)
{
    if (trace_event_get_state(TRACE_SMMUV3_TRANSLATE_SUCCESS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 41 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmuv3_translate_success " "%s sid=0x%x iova=0x%"PRIx64" translated=0x%"PRIx64" perm=0x%x stage=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , n, sid, iova, translated, perm, stage);
#line 1237 "trace/trace-hw_arm.h"
        } else {
#line 41 "../hw/arm/trace-events"
            qemu_log("smmuv3_translate_success " "%s sid=0x%x iova=0x%"PRIx64" translated=0x%"PRIx64" perm=0x%x stage=%d" "\n", n, sid, iova, translated, perm, stage);
#line 1241 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmuv3_translate_success(const char * n, uint16_t sid, uint64_t iova, uint64_t translated, int perm, int stage)
{
    if (true) {
        _nocheck__trace_smmuv3_translate_success(n, sid, iova, translated, perm, stage);
    }
}

#define TRACE_SMMUV3_GET_CD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_GET_CD) || \
    false)

static inline void _nocheck__trace_smmuv3_get_cd(uint64_t addr)
{
    if (trace_event_get_state(TRACE_SMMUV3_GET_CD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 42 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmuv3_get_cd " "CD addr: 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 1268 "trace/trace-hw_arm.h"
        } else {
#line 42 "../hw/arm/trace-events"
            qemu_log("smmuv3_get_cd " "CD addr: 0x%"PRIx64 "\n", addr);
#line 1272 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmuv3_get_cd(uint64_t addr)
{
    if (true) {
        _nocheck__trace_smmuv3_get_cd(addr);
    }
}

#define TRACE_SMMUV3_DECODE_CD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_DECODE_CD) || \
    false)

static inline void _nocheck__trace_smmuv3_decode_cd(uint32_t oas)
{
    if (trace_event_get_state(TRACE_SMMUV3_DECODE_CD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 43 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmuv3_decode_cd " "oas=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , oas);
#line 1299 "trace/trace-hw_arm.h"
        } else {
#line 43 "../hw/arm/trace-events"
            qemu_log("smmuv3_decode_cd " "oas=%d" "\n", oas);
#line 1303 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmuv3_decode_cd(uint32_t oas)
{
    if (true) {
        _nocheck__trace_smmuv3_decode_cd(oas);
    }
}

#define TRACE_SMMUV3_DECODE_CD_TT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_DECODE_CD_TT) || \
    false)

static inline void _nocheck__trace_smmuv3_decode_cd_tt(int i, uint32_t tsz, uint64_t ttb, uint32_t granule_sz, bool had)
{
    if (trace_event_get_state(TRACE_SMMUV3_DECODE_CD_TT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 44 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmuv3_decode_cd_tt " "TT[%d]:tsz:%d ttb:0x%"PRIx64" granule_sz:%d had:%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , i, tsz, ttb, granule_sz, had);
#line 1330 "trace/trace-hw_arm.h"
        } else {
#line 44 "../hw/arm/trace-events"
            qemu_log("smmuv3_decode_cd_tt " "TT[%d]:tsz:%d ttb:0x%"PRIx64" granule_sz:%d had:%d" "\n", i, tsz, ttb, granule_sz, had);
#line 1334 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmuv3_decode_cd_tt(int i, uint32_t tsz, uint64_t ttb, uint32_t granule_sz, bool had)
{
    if (true) {
        _nocheck__trace_smmuv3_decode_cd_tt(i, tsz, ttb, granule_sz, had);
    }
}

#define TRACE_SMMUV3_CMDQ_CFGI_STE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_CMDQ_CFGI_STE) || \
    false)

static inline void _nocheck__trace_smmuv3_cmdq_cfgi_ste(int streamid)
{
    if (trace_event_get_state(TRACE_SMMUV3_CMDQ_CFGI_STE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 45 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmuv3_cmdq_cfgi_ste " "streamid= 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , streamid);
#line 1361 "trace/trace-hw_arm.h"
        } else {
#line 45 "../hw/arm/trace-events"
            qemu_log("smmuv3_cmdq_cfgi_ste " "streamid= 0x%x" "\n", streamid);
#line 1365 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmuv3_cmdq_cfgi_ste(int streamid)
{
    if (true) {
        _nocheck__trace_smmuv3_cmdq_cfgi_ste(streamid);
    }
}

#define TRACE_SMMUV3_CMDQ_CFGI_STE_RANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_CMDQ_CFGI_STE_RANGE) || \
    false)

static inline void _nocheck__trace_smmuv3_cmdq_cfgi_ste_range(int start, int end)
{
    if (trace_event_get_state(TRACE_SMMUV3_CMDQ_CFGI_STE_RANGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 46 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmuv3_cmdq_cfgi_ste_range " "start=0x%x - end=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , start, end);
#line 1392 "trace/trace-hw_arm.h"
        } else {
#line 46 "../hw/arm/trace-events"
            qemu_log("smmuv3_cmdq_cfgi_ste_range " "start=0x%x - end=0x%x" "\n", start, end);
#line 1396 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmuv3_cmdq_cfgi_ste_range(int start, int end)
{
    if (true) {
        _nocheck__trace_smmuv3_cmdq_cfgi_ste_range(start, end);
    }
}

#define TRACE_SMMUV3_CMDQ_CFGI_CD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_CMDQ_CFGI_CD) || \
    false)

static inline void _nocheck__trace_smmuv3_cmdq_cfgi_cd(uint32_t sid)
{
    if (trace_event_get_state(TRACE_SMMUV3_CMDQ_CFGI_CD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 47 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmuv3_cmdq_cfgi_cd " "sid=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , sid);
#line 1423 "trace/trace-hw_arm.h"
        } else {
#line 47 "../hw/arm/trace-events"
            qemu_log("smmuv3_cmdq_cfgi_cd " "sid=0x%x" "\n", sid);
#line 1427 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmuv3_cmdq_cfgi_cd(uint32_t sid)
{
    if (true) {
        _nocheck__trace_smmuv3_cmdq_cfgi_cd(sid);
    }
}

#define TRACE_SMMUV3_CONFIG_CACHE_HIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_CONFIG_CACHE_HIT) || \
    false)

static inline void _nocheck__trace_smmuv3_config_cache_hit(uint32_t sid, uint32_t hits, uint32_t misses, uint32_t perc)
{
    if (trace_event_get_state(TRACE_SMMUV3_CONFIG_CACHE_HIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 48 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmuv3_config_cache_hit " "Config cache HIT for sid=0x%x (hits=%d, misses=%d, hit rate=%d)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , sid, hits, misses, perc);
#line 1454 "trace/trace-hw_arm.h"
        } else {
#line 48 "../hw/arm/trace-events"
            qemu_log("smmuv3_config_cache_hit " "Config cache HIT for sid=0x%x (hits=%d, misses=%d, hit rate=%d)" "\n", sid, hits, misses, perc);
#line 1458 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmuv3_config_cache_hit(uint32_t sid, uint32_t hits, uint32_t misses, uint32_t perc)
{
    if (true) {
        _nocheck__trace_smmuv3_config_cache_hit(sid, hits, misses, perc);
    }
}

#define TRACE_SMMUV3_CONFIG_CACHE_MISS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_CONFIG_CACHE_MISS) || \
    false)

static inline void _nocheck__trace_smmuv3_config_cache_miss(uint32_t sid, uint32_t hits, uint32_t misses, uint32_t perc)
{
    if (trace_event_get_state(TRACE_SMMUV3_CONFIG_CACHE_MISS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 49 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmuv3_config_cache_miss " "Config cache MISS for sid=0x%x (hits=%d, misses=%d, hit rate=%d)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , sid, hits, misses, perc);
#line 1485 "trace/trace-hw_arm.h"
        } else {
#line 49 "../hw/arm/trace-events"
            qemu_log("smmuv3_config_cache_miss " "Config cache MISS for sid=0x%x (hits=%d, misses=%d, hit rate=%d)" "\n", sid, hits, misses, perc);
#line 1489 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmuv3_config_cache_miss(uint32_t sid, uint32_t hits, uint32_t misses, uint32_t perc)
{
    if (true) {
        _nocheck__trace_smmuv3_config_cache_miss(sid, hits, misses, perc);
    }
}

#define TRACE_SMMUV3_RANGE_INVAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_RANGE_INVAL) || \
    false)

static inline void _nocheck__trace_smmuv3_range_inval(int vmid, int asid, uint64_t addr, uint8_t tg, uint64_t num_pages, uint8_t ttl, bool leaf, int stage)
{
    if (trace_event_get_state(TRACE_SMMUV3_RANGE_INVAL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 50 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmuv3_range_inval " "vmid=%d asid=%d addr=0x%"PRIx64" tg=%d num_pages=0x%"PRIx64" ttl=%d leaf=%d stage=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vmid, asid, addr, tg, num_pages, ttl, leaf, stage);
#line 1516 "trace/trace-hw_arm.h"
        } else {
#line 50 "../hw/arm/trace-events"
            qemu_log("smmuv3_range_inval " "vmid=%d asid=%d addr=0x%"PRIx64" tg=%d num_pages=0x%"PRIx64" ttl=%d leaf=%d stage=%d" "\n", vmid, asid, addr, tg, num_pages, ttl, leaf, stage);
#line 1520 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmuv3_range_inval(int vmid, int asid, uint64_t addr, uint8_t tg, uint64_t num_pages, uint8_t ttl, bool leaf, int stage)
{
    if (true) {
        _nocheck__trace_smmuv3_range_inval(vmid, asid, addr, tg, num_pages, ttl, leaf, stage);
    }
}

#define TRACE_SMMUV3_CMDQ_TLBI_NH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_CMDQ_TLBI_NH) || \
    false)

static inline void _nocheck__trace_smmuv3_cmdq_tlbi_nh(int vmid)
{
    if (trace_event_get_state(TRACE_SMMUV3_CMDQ_TLBI_NH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 51 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmuv3_cmdq_tlbi_nh " "vmid=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vmid);
#line 1547 "trace/trace-hw_arm.h"
        } else {
#line 51 "../hw/arm/trace-events"
            qemu_log("smmuv3_cmdq_tlbi_nh " "vmid=%d" "\n", vmid);
#line 1551 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmuv3_cmdq_tlbi_nh(int vmid)
{
    if (true) {
        _nocheck__trace_smmuv3_cmdq_tlbi_nh(vmid);
    }
}

#define TRACE_SMMUV3_CMDQ_TLBI_NSNH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_CMDQ_TLBI_NSNH) || \
    false)

static inline void _nocheck__trace_smmuv3_cmdq_tlbi_nsnh(void)
{
    if (trace_event_get_state(TRACE_SMMUV3_CMDQ_TLBI_NSNH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 52 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmuv3_cmdq_tlbi_nsnh " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1578 "trace/trace-hw_arm.h"
        } else {
#line 52 "../hw/arm/trace-events"
            qemu_log("smmuv3_cmdq_tlbi_nsnh " "" "\n");
#line 1582 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmuv3_cmdq_tlbi_nsnh(void)
{
    if (true) {
        _nocheck__trace_smmuv3_cmdq_tlbi_nsnh();
    }
}

#define TRACE_SMMUV3_CMDQ_TLBI_NH_ASID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_CMDQ_TLBI_NH_ASID) || \
    false)

static inline void _nocheck__trace_smmuv3_cmdq_tlbi_nh_asid(int asid)
{
    if (trace_event_get_state(TRACE_SMMUV3_CMDQ_TLBI_NH_ASID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 53 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmuv3_cmdq_tlbi_nh_asid " "asid=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , asid);
#line 1609 "trace/trace-hw_arm.h"
        } else {
#line 53 "../hw/arm/trace-events"
            qemu_log("smmuv3_cmdq_tlbi_nh_asid " "asid=%d" "\n", asid);
#line 1613 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmuv3_cmdq_tlbi_nh_asid(int asid)
{
    if (true) {
        _nocheck__trace_smmuv3_cmdq_tlbi_nh_asid(asid);
    }
}

#define TRACE_SMMUV3_CMDQ_TLBI_S12_VMID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_CMDQ_TLBI_S12_VMID) || \
    false)

static inline void _nocheck__trace_smmuv3_cmdq_tlbi_s12_vmid(int vmid)
{
    if (trace_event_get_state(TRACE_SMMUV3_CMDQ_TLBI_S12_VMID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 54 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmuv3_cmdq_tlbi_s12_vmid " "vmid=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vmid);
#line 1640 "trace/trace-hw_arm.h"
        } else {
#line 54 "../hw/arm/trace-events"
            qemu_log("smmuv3_cmdq_tlbi_s12_vmid " "vmid=%d" "\n", vmid);
#line 1644 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmuv3_cmdq_tlbi_s12_vmid(int vmid)
{
    if (true) {
        _nocheck__trace_smmuv3_cmdq_tlbi_s12_vmid(vmid);
    }
}

#define TRACE_SMMUV3_CONFIG_CACHE_INV_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_CONFIG_CACHE_INV) || \
    false)

static inline void _nocheck__trace_smmuv3_config_cache_inv(uint32_t sid)
{
    if (trace_event_get_state(TRACE_SMMUV3_CONFIG_CACHE_INV) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 55 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmuv3_config_cache_inv " "Config cache INV for sid=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , sid);
#line 1671 "trace/trace-hw_arm.h"
        } else {
#line 55 "../hw/arm/trace-events"
            qemu_log("smmuv3_config_cache_inv " "Config cache INV for sid=0x%x" "\n", sid);
#line 1675 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmuv3_config_cache_inv(uint32_t sid)
{
    if (true) {
        _nocheck__trace_smmuv3_config_cache_inv(sid);
    }
}

#define TRACE_SMMUV3_NOTIFY_FLAG_ADD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_NOTIFY_FLAG_ADD) || \
    false)

static inline void _nocheck__trace_smmuv3_notify_flag_add(const char * iommu)
{
    if (trace_event_get_state(TRACE_SMMUV3_NOTIFY_FLAG_ADD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 56 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmuv3_notify_flag_add " "ADD SMMUNotifier node for iommu mr=%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , iommu);
#line 1702 "trace/trace-hw_arm.h"
        } else {
#line 56 "../hw/arm/trace-events"
            qemu_log("smmuv3_notify_flag_add " "ADD SMMUNotifier node for iommu mr=%s" "\n", iommu);
#line 1706 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmuv3_notify_flag_add(const char * iommu)
{
    if (true) {
        _nocheck__trace_smmuv3_notify_flag_add(iommu);
    }
}

#define TRACE_SMMUV3_NOTIFY_FLAG_DEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_NOTIFY_FLAG_DEL) || \
    false)

static inline void _nocheck__trace_smmuv3_notify_flag_del(const char * iommu)
{
    if (trace_event_get_state(TRACE_SMMUV3_NOTIFY_FLAG_DEL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 57 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmuv3_notify_flag_del " "DEL SMMUNotifier node for iommu mr=%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , iommu);
#line 1733 "trace/trace-hw_arm.h"
        } else {
#line 57 "../hw/arm/trace-events"
            qemu_log("smmuv3_notify_flag_del " "DEL SMMUNotifier node for iommu mr=%s" "\n", iommu);
#line 1737 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmuv3_notify_flag_del(const char * iommu)
{
    if (true) {
        _nocheck__trace_smmuv3_notify_flag_del(iommu);
    }
}

#define TRACE_SMMUV3_INV_NOTIFIERS_IOVA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_INV_NOTIFIERS_IOVA) || \
    false)

static inline void _nocheck__trace_smmuv3_inv_notifiers_iova(const char * name, int asid, int vmid, uint64_t iova, uint8_t tg, uint64_t num_pages, int stage)
{
    if (trace_event_get_state(TRACE_SMMUV3_INV_NOTIFIERS_IOVA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 58 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:smmuv3_inv_notifiers_iova " "iommu mr=%s asid=%d vmid=%d iova=0x%"PRIx64" tg=%d num_pages=0x%"PRIx64" stage=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, asid, vmid, iova, tg, num_pages, stage);
#line 1764 "trace/trace-hw_arm.h"
        } else {
#line 58 "../hw/arm/trace-events"
            qemu_log("smmuv3_inv_notifiers_iova " "iommu mr=%s asid=%d vmid=%d iova=0x%"PRIx64" tg=%d num_pages=0x%"PRIx64" stage=%d" "\n", name, asid, vmid, iova, tg, num_pages, stage);
#line 1768 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_smmuv3_inv_notifiers_iova(const char * name, int asid, int vmid, uint64_t iova, uint8_t tg, uint64_t num_pages, int stage)
{
    if (true) {
        _nocheck__trace_smmuv3_inv_notifiers_iova(name, asid, vmid, iova, tg, num_pages, stage);
    }
}

#define TRACE_STRONGARM_UART_UPDATE_PARAMETERS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_STRONGARM_UART_UPDATE_PARAMETERS) || \
    false)

static inline void _nocheck__trace_strongarm_uart_update_parameters(const char * label, int speed, char parity, int data_bits, int stop_bits)
{
    if (trace_event_get_state(TRACE_STRONGARM_UART_UPDATE_PARAMETERS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 61 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:strongarm_uart_update_parameters " "%s speed=%d parity=%c data=%d stop=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , label, speed, parity, data_bits, stop_bits);
#line 1795 "trace/trace-hw_arm.h"
        } else {
#line 61 "../hw/arm/trace-events"
            qemu_log("strongarm_uart_update_parameters " "%s speed=%d parity=%c data=%d stop=%d" "\n", label, speed, parity, data_bits, stop_bits);
#line 1799 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_strongarm_uart_update_parameters(const char * label, int speed, char parity, int data_bits, int stop_bits)
{
    if (true) {
        _nocheck__trace_strongarm_uart_update_parameters(label, speed, parity, data_bits, stop_bits);
    }
}

#define TRACE_STRONGARM_SSP_READ_UNDERRUN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_STRONGARM_SSP_READ_UNDERRUN) || \
    false)

static inline void _nocheck__trace_strongarm_ssp_read_underrun(void)
{
    if (trace_event_get_state(TRACE_STRONGARM_SSP_READ_UNDERRUN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 62 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:strongarm_ssp_read_underrun " "SSP rx underrun" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1826 "trace/trace-hw_arm.h"
        } else {
#line 62 "../hw/arm/trace-events"
            qemu_log("strongarm_ssp_read_underrun " "SSP rx underrun" "\n");
#line 1830 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_strongarm_ssp_read_underrun(void)
{
    if (true) {
        _nocheck__trace_strongarm_ssp_read_underrun();
    }
}

#define TRACE_Z2_LCD_REG_UPDATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_Z2_LCD_REG_UPDATE) || \
    false)

static inline void _nocheck__trace_z2_lcd_reg_update(uint8_t cur, uint8_t i_0, uint8_t i_1, uint8_t i_2, uint32_t value)
{
    if (trace_event_get_state(TRACE_Z2_LCD_REG_UPDATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 65 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:z2_lcd_reg_update " "cur_reg = 0x%x, buf = [0x%x, 0x%x, 0x%x], value = 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cur, i_0, i_1, i_2, value);
#line 1857 "trace/trace-hw_arm.h"
        } else {
#line 65 "../hw/arm/trace-events"
            qemu_log("z2_lcd_reg_update " "cur_reg = 0x%x, buf = [0x%x, 0x%x, 0x%x], value = 0x%x" "\n", cur, i_0, i_1, i_2, value);
#line 1861 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_z2_lcd_reg_update(uint8_t cur, uint8_t i_0, uint8_t i_1, uint8_t i_2, uint32_t value)
{
    if (true) {
        _nocheck__trace_z2_lcd_reg_update(cur, i_0, i_1, i_2, value);
    }
}

#define TRACE_Z2_LCD_ENABLE_DISABLE_RESULT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_Z2_LCD_ENABLE_DISABLE_RESULT) || \
    false)

static inline void _nocheck__trace_z2_lcd_enable_disable_result(const char * result)
{
    if (trace_event_get_state(TRACE_Z2_LCD_ENABLE_DISABLE_RESULT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 66 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:z2_lcd_enable_disable_result " "LCD %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , result);
#line 1888 "trace/trace-hw_arm.h"
        } else {
#line 66 "../hw/arm/trace-events"
            qemu_log("z2_lcd_enable_disable_result " "LCD %s" "\n", result);
#line 1892 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_z2_lcd_enable_disable_result(const char * result)
{
    if (true) {
        _nocheck__trace_z2_lcd_enable_disable_result(result);
    }
}

#define TRACE_Z2_AER915_SEND_TOO_LONG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_Z2_AER915_SEND_TOO_LONG) || \
    false)

static inline void _nocheck__trace_z2_aer915_send_too_long(int8_t msg)
{
    if (trace_event_get_state(TRACE_Z2_AER915_SEND_TOO_LONG) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 67 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:z2_aer915_send_too_long " "message too long (%i bytes)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , msg);
#line 1919 "trace/trace-hw_arm.h"
        } else {
#line 67 "../hw/arm/trace-events"
            qemu_log("z2_aer915_send_too_long " "message too long (%i bytes)" "\n", msg);
#line 1923 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_z2_aer915_send_too_long(int8_t msg)
{
    if (true) {
        _nocheck__trace_z2_aer915_send_too_long(msg);
    }
}

#define TRACE_Z2_AER915_SEND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_Z2_AER915_SEND) || \
    false)

static inline void _nocheck__trace_z2_aer915_send(uint8_t reg, uint8_t value)
{
    if (trace_event_get_state(TRACE_Z2_AER915_SEND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 68 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:z2_aer915_send " "reg %d value 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reg, value);
#line 1950 "trace/trace-hw_arm.h"
        } else {
#line 68 "../hw/arm/trace-events"
            qemu_log("z2_aer915_send " "reg %d value 0x%02x" "\n", reg, value);
#line 1954 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_z2_aer915_send(uint8_t reg, uint8_t value)
{
    if (true) {
        _nocheck__trace_z2_aer915_send(reg, value);
    }
}

#define TRACE_Z2_AER915_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_Z2_AER915_EVENT) || \
    false)

static inline void _nocheck__trace_z2_aer915_event(int8_t event, int8_t len)
{
    if (trace_event_get_state(TRACE_Z2_AER915_EVENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 69 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:z2_aer915_event " "i2c event =0x%x len=%d bytes" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , event, len);
#line 1981 "trace/trace-hw_arm.h"
        } else {
#line 69 "../hw/arm/trace-events"
            qemu_log("z2_aer915_event " "i2c event =0x%x len=%d bytes" "\n", event, len);
#line 1985 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_z2_aer915_event(int8_t event, int8_t len)
{
    if (true) {
        _nocheck__trace_z2_aer915_event(event, len);
    }
}

#define TRACE_XEN_CREATE_VIRTIO_MMIO_DEVICES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_CREATE_VIRTIO_MMIO_DEVICES) || \
    false)

static inline void _nocheck__trace_xen_create_virtio_mmio_devices(int i, int irq, uint64_t base)
{
    if (trace_event_get_state(TRACE_XEN_CREATE_VIRTIO_MMIO_DEVICES) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 72 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:xen_create_virtio_mmio_devices " "Created virtio-mmio device %d: irq %d base 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , i, irq, base);
#line 2012 "trace/trace-hw_arm.h"
        } else {
#line 72 "../hw/arm/trace-events"
            qemu_log("xen_create_virtio_mmio_devices " "Created virtio-mmio device %d: irq %d base 0x%"PRIx64 "\n", i, irq, base);
#line 2016 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_xen_create_virtio_mmio_devices(int i, int irq, uint64_t base)
{
    if (true) {
        _nocheck__trace_xen_create_virtio_mmio_devices(i, irq, base);
    }
}

#define TRACE_XEN_INIT_RAM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_INIT_RAM) || \
    false)

static inline void _nocheck__trace_xen_init_ram(uint64_t machine_ram_size)
{
    if (trace_event_get_state(TRACE_XEN_INIT_RAM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 73 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:xen_init_ram " "Initialized xen ram with size 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , machine_ram_size);
#line 2043 "trace/trace-hw_arm.h"
        } else {
#line 73 "../hw/arm/trace-events"
            qemu_log("xen_init_ram " "Initialized xen ram with size 0x%"PRIx64 "\n", machine_ram_size);
#line 2047 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_xen_init_ram(uint64_t machine_ram_size)
{
    if (true) {
        _nocheck__trace_xen_init_ram(machine_ram_size);
    }
}

#define TRACE_XEN_ENABLE_TPM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_ENABLE_TPM) || \
    false)

static inline void _nocheck__trace_xen_enable_tpm(uint64_t addr)
{
    if (trace_event_get_state(TRACE_XEN_ENABLE_TPM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 74 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:xen_enable_tpm " "Connected tpmdev at address 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 2074 "trace/trace-hw_arm.h"
        } else {
#line 74 "../hw/arm/trace-events"
            qemu_log("xen_enable_tpm " "Connected tpmdev at address 0x%"PRIx64 "\n", addr);
#line 2078 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_xen_enable_tpm(uint64_t addr)
{
    if (true) {
        _nocheck__trace_xen_enable_tpm(addr);
    }
}

#define TRACE_BCM2838_GIC_SET_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BCM2838_GIC_SET_IRQ) || \
    false)

static inline void _nocheck__trace_bcm2838_gic_set_irq(int irq, int level)
{
    if (trace_event_get_state(TRACE_BCM2838_GIC_SET_IRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 77 "../hw/arm/trace-events"
            qemu_log("%d@%zu.%06zu:bcm2838_gic_set_irq " "gic irq:%d lvl:%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , irq, level);
#line 2105 "trace/trace-hw_arm.h"
        } else {
#line 77 "../hw/arm/trace-events"
            qemu_log("bcm2838_gic_set_irq " "gic irq:%d lvl:%d" "\n", irq, level);
#line 2109 "trace/trace-hw_arm.h"
        }
    }
}

static inline void trace_bcm2838_gic_set_irq(int irq, int level)
{
    if (true) {
        _nocheck__trace_bcm2838_gic_set_irq(irq, level);
    }
}
#endif /* TRACE_HW_ARM_GENERATED_TRACERS_H */
