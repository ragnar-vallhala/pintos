/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_IO_GENERATED_TRACERS_H
#define TRACE_IO_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_QIO_TASK_NEW_EVENT;
extern TraceEvent _TRACE_QIO_TASK_COMPLETE_EVENT;
extern TraceEvent _TRACE_QIO_TASK_THREAD_START_EVENT;
extern TraceEvent _TRACE_QIO_TASK_THREAD_RUN_EVENT;
extern TraceEvent _TRACE_QIO_TASK_THREAD_EXIT_EVENT;
extern TraceEvent _TRACE_QIO_TASK_THREAD_RESULT_EVENT;
extern TraceEvent _TRACE_QIO_TASK_THREAD_SOURCE_ATTACH_EVENT;
extern TraceEvent _TRACE_QIO_TASK_THREAD_SOURCE_CANCEL_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_NULL_NEW_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_SOCKET_NEW_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_SOCKET_NEW_FD_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_SOCKET_CONNECT_SYNC_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_SOCKET_CONNECT_ASYNC_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_SOCKET_CONNECT_FAIL_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_SOCKET_CONNECT_COMPLETE_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_SOCKET_LISTEN_SYNC_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_SOCKET_LISTEN_ASYNC_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_SOCKET_LISTEN_FAIL_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_SOCKET_LISTEN_COMPLETE_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_SOCKET_DGRAM_SYNC_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_SOCKET_DGRAM_ASYNC_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_SOCKET_DGRAM_FAIL_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_SOCKET_DGRAM_COMPLETE_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_SOCKET_ACCEPT_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_SOCKET_ACCEPT_FAIL_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_SOCKET_ACCEPT_COMPLETE_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_FILE_NEW_FD_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_FILE_NEW_PATH_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_TLS_NEW_CLIENT_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_TLS_NEW_SERVER_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_TLS_HANDSHAKE_START_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_TLS_HANDSHAKE_PENDING_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_TLS_HANDSHAKE_FAIL_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_TLS_HANDSHAKE_COMPLETE_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_TLS_HANDSHAKE_CANCEL_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_TLS_CREDENTIALS_ALLOW_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_TLS_CREDENTIALS_DENY_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_WEBSOCK_NEW_SERVER_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_START_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_PENDING_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_REPLY_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_FAIL_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_COMPLETE_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_WEBSOCK_HTTP_GREETING_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_WEBSOCK_HTTP_REQUEST_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_WEBSOCK_HEADER_PARTIAL_DECODE_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_WEBSOCK_HEADER_FULL_DECODE_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_WEBSOCK_PAYLOAD_DECODE_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_WEBSOCK_ENCODE_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_WEBSOCK_CLOSE_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_COMMAND_NEW_PID_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_COMMAND_NEW_SPAWN_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_COMMAND_ABORT_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_COMMAND_WAIT_EVENT;
extern uint16_t _TRACE_QIO_TASK_NEW_DSTATE;
extern uint16_t _TRACE_QIO_TASK_COMPLETE_DSTATE;
extern uint16_t _TRACE_QIO_TASK_THREAD_START_DSTATE;
extern uint16_t _TRACE_QIO_TASK_THREAD_RUN_DSTATE;
extern uint16_t _TRACE_QIO_TASK_THREAD_EXIT_DSTATE;
extern uint16_t _TRACE_QIO_TASK_THREAD_RESULT_DSTATE;
extern uint16_t _TRACE_QIO_TASK_THREAD_SOURCE_ATTACH_DSTATE;
extern uint16_t _TRACE_QIO_TASK_THREAD_SOURCE_CANCEL_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_NULL_NEW_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_SOCKET_NEW_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_SOCKET_NEW_FD_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_SOCKET_CONNECT_SYNC_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_SOCKET_CONNECT_ASYNC_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_SOCKET_CONNECT_FAIL_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_SOCKET_CONNECT_COMPLETE_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_SOCKET_LISTEN_SYNC_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_SOCKET_LISTEN_ASYNC_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_SOCKET_LISTEN_FAIL_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_SOCKET_LISTEN_COMPLETE_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_SOCKET_DGRAM_SYNC_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_SOCKET_DGRAM_ASYNC_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_SOCKET_DGRAM_FAIL_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_SOCKET_DGRAM_COMPLETE_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_SOCKET_ACCEPT_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_SOCKET_ACCEPT_FAIL_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_SOCKET_ACCEPT_COMPLETE_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_FILE_NEW_FD_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_FILE_NEW_PATH_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_TLS_NEW_CLIENT_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_TLS_NEW_SERVER_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_TLS_HANDSHAKE_START_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_TLS_HANDSHAKE_PENDING_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_TLS_HANDSHAKE_FAIL_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_TLS_HANDSHAKE_COMPLETE_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_TLS_HANDSHAKE_CANCEL_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_TLS_CREDENTIALS_ALLOW_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_TLS_CREDENTIALS_DENY_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_WEBSOCK_NEW_SERVER_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_START_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_PENDING_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_REPLY_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_FAIL_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_COMPLETE_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_WEBSOCK_HTTP_GREETING_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_WEBSOCK_HTTP_REQUEST_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_WEBSOCK_HEADER_PARTIAL_DECODE_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_WEBSOCK_HEADER_FULL_DECODE_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_WEBSOCK_PAYLOAD_DECODE_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_WEBSOCK_ENCODE_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_WEBSOCK_CLOSE_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_COMMAND_NEW_PID_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_COMMAND_NEW_SPAWN_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_COMMAND_ABORT_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_COMMAND_WAIT_DSTATE;
#define TRACE_QIO_TASK_NEW_ENABLED 1
#define TRACE_QIO_TASK_COMPLETE_ENABLED 1
#define TRACE_QIO_TASK_THREAD_START_ENABLED 1
#define TRACE_QIO_TASK_THREAD_RUN_ENABLED 1
#define TRACE_QIO_TASK_THREAD_EXIT_ENABLED 1
#define TRACE_QIO_TASK_THREAD_RESULT_ENABLED 1
#define TRACE_QIO_TASK_THREAD_SOURCE_ATTACH_ENABLED 1
#define TRACE_QIO_TASK_THREAD_SOURCE_CANCEL_ENABLED 1
#define TRACE_QIO_CHANNEL_NULL_NEW_ENABLED 1
#define TRACE_QIO_CHANNEL_SOCKET_NEW_ENABLED 1
#define TRACE_QIO_CHANNEL_SOCKET_NEW_FD_ENABLED 1
#define TRACE_QIO_CHANNEL_SOCKET_CONNECT_SYNC_ENABLED 1
#define TRACE_QIO_CHANNEL_SOCKET_CONNECT_ASYNC_ENABLED 1
#define TRACE_QIO_CHANNEL_SOCKET_CONNECT_FAIL_ENABLED 1
#define TRACE_QIO_CHANNEL_SOCKET_CONNECT_COMPLETE_ENABLED 1
#define TRACE_QIO_CHANNEL_SOCKET_LISTEN_SYNC_ENABLED 1
#define TRACE_QIO_CHANNEL_SOCKET_LISTEN_ASYNC_ENABLED 1
#define TRACE_QIO_CHANNEL_SOCKET_LISTEN_FAIL_ENABLED 1
#define TRACE_QIO_CHANNEL_SOCKET_LISTEN_COMPLETE_ENABLED 1
#define TRACE_QIO_CHANNEL_SOCKET_DGRAM_SYNC_ENABLED 1
#define TRACE_QIO_CHANNEL_SOCKET_DGRAM_ASYNC_ENABLED 1
#define TRACE_QIO_CHANNEL_SOCKET_DGRAM_FAIL_ENABLED 1
#define TRACE_QIO_CHANNEL_SOCKET_DGRAM_COMPLETE_ENABLED 1
#define TRACE_QIO_CHANNEL_SOCKET_ACCEPT_ENABLED 1
#define TRACE_QIO_CHANNEL_SOCKET_ACCEPT_FAIL_ENABLED 1
#define TRACE_QIO_CHANNEL_SOCKET_ACCEPT_COMPLETE_ENABLED 1
#define TRACE_QIO_CHANNEL_FILE_NEW_FD_ENABLED 1
#define TRACE_QIO_CHANNEL_FILE_NEW_PATH_ENABLED 1
#define TRACE_QIO_CHANNEL_TLS_NEW_CLIENT_ENABLED 1
#define TRACE_QIO_CHANNEL_TLS_NEW_SERVER_ENABLED 1
#define TRACE_QIO_CHANNEL_TLS_HANDSHAKE_START_ENABLED 1
#define TRACE_QIO_CHANNEL_TLS_HANDSHAKE_PENDING_ENABLED 1
#define TRACE_QIO_CHANNEL_TLS_HANDSHAKE_FAIL_ENABLED 1
#define TRACE_QIO_CHANNEL_TLS_HANDSHAKE_COMPLETE_ENABLED 1
#define TRACE_QIO_CHANNEL_TLS_HANDSHAKE_CANCEL_ENABLED 1
#define TRACE_QIO_CHANNEL_TLS_CREDENTIALS_ALLOW_ENABLED 1
#define TRACE_QIO_CHANNEL_TLS_CREDENTIALS_DENY_ENABLED 1
#define TRACE_QIO_CHANNEL_WEBSOCK_NEW_SERVER_ENABLED 1
#define TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_START_ENABLED 1
#define TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_PENDING_ENABLED 1
#define TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_REPLY_ENABLED 1
#define TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_FAIL_ENABLED 1
#define TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_COMPLETE_ENABLED 1
#define TRACE_QIO_CHANNEL_WEBSOCK_HTTP_GREETING_ENABLED 1
#define TRACE_QIO_CHANNEL_WEBSOCK_HTTP_REQUEST_ENABLED 1
#define TRACE_QIO_CHANNEL_WEBSOCK_HEADER_PARTIAL_DECODE_ENABLED 1
#define TRACE_QIO_CHANNEL_WEBSOCK_HEADER_FULL_DECODE_ENABLED 1
#define TRACE_QIO_CHANNEL_WEBSOCK_PAYLOAD_DECODE_ENABLED 1
#define TRACE_QIO_CHANNEL_WEBSOCK_ENCODE_ENABLED 1
#define TRACE_QIO_CHANNEL_WEBSOCK_CLOSE_ENABLED 1
#define TRACE_QIO_CHANNEL_COMMAND_NEW_PID_ENABLED 1
#define TRACE_QIO_CHANNEL_COMMAND_NEW_SPAWN_ENABLED 1
#define TRACE_QIO_CHANNEL_COMMAND_ABORT_ENABLED 1
#define TRACE_QIO_CHANNEL_COMMAND_WAIT_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_QIO_TASK_NEW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_TASK_NEW) || \
    false)

static inline void _nocheck__trace_qio_task_new(void * task, void * source, void * func, void * opaque)
{
    if (trace_event_get_state(TRACE_QIO_TASK_NEW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 4 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_task_new " "Task new task=%p source=%p func=%p opaque=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , task, source, func, opaque);
#line 190 "trace/trace-io.h"
        } else {
#line 4 "../io/trace-events"
            qemu_log("qio_task_new " "Task new task=%p source=%p func=%p opaque=%p" "\n", task, source, func, opaque);
#line 194 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_task_new(void * task, void * source, void * func, void * opaque)
{
    if (true) {
        _nocheck__trace_qio_task_new(task, source, func, opaque);
    }
}

#define TRACE_QIO_TASK_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_TASK_COMPLETE) || \
    false)

static inline void _nocheck__trace_qio_task_complete(void * task)
{
    if (trace_event_get_state(TRACE_QIO_TASK_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 5 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_task_complete " "Task complete task=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , task);
#line 221 "trace/trace-io.h"
        } else {
#line 5 "../io/trace-events"
            qemu_log("qio_task_complete " "Task complete task=%p" "\n", task);
#line 225 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_task_complete(void * task)
{
    if (true) {
        _nocheck__trace_qio_task_complete(task);
    }
}

#define TRACE_QIO_TASK_THREAD_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_TASK_THREAD_START) || \
    false)

static inline void _nocheck__trace_qio_task_thread_start(void * task, void * worker, void * opaque)
{
    if (trace_event_get_state(TRACE_QIO_TASK_THREAD_START) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 6 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_task_thread_start " "Task thread start task=%p worker=%p opaque=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , task, worker, opaque);
#line 252 "trace/trace-io.h"
        } else {
#line 6 "../io/trace-events"
            qemu_log("qio_task_thread_start " "Task thread start task=%p worker=%p opaque=%p" "\n", task, worker, opaque);
#line 256 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_task_thread_start(void * task, void * worker, void * opaque)
{
    if (true) {
        _nocheck__trace_qio_task_thread_start(task, worker, opaque);
    }
}

#define TRACE_QIO_TASK_THREAD_RUN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_TASK_THREAD_RUN) || \
    false)

static inline void _nocheck__trace_qio_task_thread_run(void * task)
{
    if (trace_event_get_state(TRACE_QIO_TASK_THREAD_RUN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 7 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_task_thread_run " "Task thread run task=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , task);
#line 283 "trace/trace-io.h"
        } else {
#line 7 "../io/trace-events"
            qemu_log("qio_task_thread_run " "Task thread run task=%p" "\n", task);
#line 287 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_task_thread_run(void * task)
{
    if (true) {
        _nocheck__trace_qio_task_thread_run(task);
    }
}

#define TRACE_QIO_TASK_THREAD_EXIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_TASK_THREAD_EXIT) || \
    false)

static inline void _nocheck__trace_qio_task_thread_exit(void * task)
{
    if (trace_event_get_state(TRACE_QIO_TASK_THREAD_EXIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 8 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_task_thread_exit " "Task thread exit task=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , task);
#line 314 "trace/trace-io.h"
        } else {
#line 8 "../io/trace-events"
            qemu_log("qio_task_thread_exit " "Task thread exit task=%p" "\n", task);
#line 318 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_task_thread_exit(void * task)
{
    if (true) {
        _nocheck__trace_qio_task_thread_exit(task);
    }
}

#define TRACE_QIO_TASK_THREAD_RESULT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_TASK_THREAD_RESULT) || \
    false)

static inline void _nocheck__trace_qio_task_thread_result(void * task)
{
    if (trace_event_get_state(TRACE_QIO_TASK_THREAD_RESULT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 9 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_task_thread_result " "Task thread result task=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , task);
#line 345 "trace/trace-io.h"
        } else {
#line 9 "../io/trace-events"
            qemu_log("qio_task_thread_result " "Task thread result task=%p" "\n", task);
#line 349 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_task_thread_result(void * task)
{
    if (true) {
        _nocheck__trace_qio_task_thread_result(task);
    }
}

#define TRACE_QIO_TASK_THREAD_SOURCE_ATTACH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_TASK_THREAD_SOURCE_ATTACH) || \
    false)

static inline void _nocheck__trace_qio_task_thread_source_attach(void * task, void * source)
{
    if (trace_event_get_state(TRACE_QIO_TASK_THREAD_SOURCE_ATTACH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 10 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_task_thread_source_attach " "Task thread source attach task=%p source=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , task, source);
#line 376 "trace/trace-io.h"
        } else {
#line 10 "../io/trace-events"
            qemu_log("qio_task_thread_source_attach " "Task thread source attach task=%p source=%p" "\n", task, source);
#line 380 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_task_thread_source_attach(void * task, void * source)
{
    if (true) {
        _nocheck__trace_qio_task_thread_source_attach(task, source);
    }
}

#define TRACE_QIO_TASK_THREAD_SOURCE_CANCEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_TASK_THREAD_SOURCE_CANCEL) || \
    false)

static inline void _nocheck__trace_qio_task_thread_source_cancel(void * task, void * source)
{
    if (trace_event_get_state(TRACE_QIO_TASK_THREAD_SOURCE_CANCEL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 11 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_task_thread_source_cancel " "Task thread source cancel task=%p source=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , task, source);
#line 407 "trace/trace-io.h"
        } else {
#line 11 "../io/trace-events"
            qemu_log("qio_task_thread_source_cancel " "Task thread source cancel task=%p source=%p" "\n", task, source);
#line 411 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_task_thread_source_cancel(void * task, void * source)
{
    if (true) {
        _nocheck__trace_qio_task_thread_source_cancel(task, source);
    }
}

#define TRACE_QIO_CHANNEL_NULL_NEW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_NULL_NEW) || \
    false)

static inline void _nocheck__trace_qio_channel_null_new(void * ioc)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_NULL_NEW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 14 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_null_new " "Null new ioc=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc);
#line 438 "trace/trace-io.h"
        } else {
#line 14 "../io/trace-events"
            qemu_log("qio_channel_null_new " "Null new ioc=%p" "\n", ioc);
#line 442 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_null_new(void * ioc)
{
    if (true) {
        _nocheck__trace_qio_channel_null_new(ioc);
    }
}

#define TRACE_QIO_CHANNEL_SOCKET_NEW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_SOCKET_NEW) || \
    false)

static inline void _nocheck__trace_qio_channel_socket_new(void * ioc)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_SOCKET_NEW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 17 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_socket_new " "Socket new ioc=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc);
#line 469 "trace/trace-io.h"
        } else {
#line 17 "../io/trace-events"
            qemu_log("qio_channel_socket_new " "Socket new ioc=%p" "\n", ioc);
#line 473 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_socket_new(void * ioc)
{
    if (true) {
        _nocheck__trace_qio_channel_socket_new(ioc);
    }
}

#define TRACE_QIO_CHANNEL_SOCKET_NEW_FD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_SOCKET_NEW_FD) || \
    false)

static inline void _nocheck__trace_qio_channel_socket_new_fd(void * ioc, int fd)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_SOCKET_NEW_FD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 18 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_socket_new_fd " "Socket new ioc=%p fd=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc, fd);
#line 500 "trace/trace-io.h"
        } else {
#line 18 "../io/trace-events"
            qemu_log("qio_channel_socket_new_fd " "Socket new ioc=%p fd=%d" "\n", ioc, fd);
#line 504 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_socket_new_fd(void * ioc, int fd)
{
    if (true) {
        _nocheck__trace_qio_channel_socket_new_fd(ioc, fd);
    }
}

#define TRACE_QIO_CHANNEL_SOCKET_CONNECT_SYNC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_SOCKET_CONNECT_SYNC) || \
    false)

static inline void _nocheck__trace_qio_channel_socket_connect_sync(void * ioc, void * addr)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_SOCKET_CONNECT_SYNC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 19 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_socket_connect_sync " "Socket connect sync ioc=%p addr=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc, addr);
#line 531 "trace/trace-io.h"
        } else {
#line 19 "../io/trace-events"
            qemu_log("qio_channel_socket_connect_sync " "Socket connect sync ioc=%p addr=%p" "\n", ioc, addr);
#line 535 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_socket_connect_sync(void * ioc, void * addr)
{
    if (true) {
        _nocheck__trace_qio_channel_socket_connect_sync(ioc, addr);
    }
}

#define TRACE_QIO_CHANNEL_SOCKET_CONNECT_ASYNC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_SOCKET_CONNECT_ASYNC) || \
    false)

static inline void _nocheck__trace_qio_channel_socket_connect_async(void * ioc, void * addr)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_SOCKET_CONNECT_ASYNC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 20 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_socket_connect_async " "Socket connect async ioc=%p addr=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc, addr);
#line 562 "trace/trace-io.h"
        } else {
#line 20 "../io/trace-events"
            qemu_log("qio_channel_socket_connect_async " "Socket connect async ioc=%p addr=%p" "\n", ioc, addr);
#line 566 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_socket_connect_async(void * ioc, void * addr)
{
    if (true) {
        _nocheck__trace_qio_channel_socket_connect_async(ioc, addr);
    }
}

#define TRACE_QIO_CHANNEL_SOCKET_CONNECT_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_SOCKET_CONNECT_FAIL) || \
    false)

static inline void _nocheck__trace_qio_channel_socket_connect_fail(void * ioc)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_SOCKET_CONNECT_FAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 21 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_socket_connect_fail " "Socket connect fail ioc=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc);
#line 593 "trace/trace-io.h"
        } else {
#line 21 "../io/trace-events"
            qemu_log("qio_channel_socket_connect_fail " "Socket connect fail ioc=%p" "\n", ioc);
#line 597 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_socket_connect_fail(void * ioc)
{
    if (true) {
        _nocheck__trace_qio_channel_socket_connect_fail(ioc);
    }
}

#define TRACE_QIO_CHANNEL_SOCKET_CONNECT_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_SOCKET_CONNECT_COMPLETE) || \
    false)

static inline void _nocheck__trace_qio_channel_socket_connect_complete(void * ioc, int fd)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_SOCKET_CONNECT_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 22 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_socket_connect_complete " "Socket connect complete ioc=%p fd=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc, fd);
#line 624 "trace/trace-io.h"
        } else {
#line 22 "../io/trace-events"
            qemu_log("qio_channel_socket_connect_complete " "Socket connect complete ioc=%p fd=%d" "\n", ioc, fd);
#line 628 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_socket_connect_complete(void * ioc, int fd)
{
    if (true) {
        _nocheck__trace_qio_channel_socket_connect_complete(ioc, fd);
    }
}

#define TRACE_QIO_CHANNEL_SOCKET_LISTEN_SYNC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_SOCKET_LISTEN_SYNC) || \
    false)

static inline void _nocheck__trace_qio_channel_socket_listen_sync(void * ioc, void * addr, int num)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_SOCKET_LISTEN_SYNC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 23 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_socket_listen_sync " "Socket listen sync ioc=%p addr=%p num=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc, addr, num);
#line 655 "trace/trace-io.h"
        } else {
#line 23 "../io/trace-events"
            qemu_log("qio_channel_socket_listen_sync " "Socket listen sync ioc=%p addr=%p num=%d" "\n", ioc, addr, num);
#line 659 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_socket_listen_sync(void * ioc, void * addr, int num)
{
    if (true) {
        _nocheck__trace_qio_channel_socket_listen_sync(ioc, addr, num);
    }
}

#define TRACE_QIO_CHANNEL_SOCKET_LISTEN_ASYNC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_SOCKET_LISTEN_ASYNC) || \
    false)

static inline void _nocheck__trace_qio_channel_socket_listen_async(void * ioc, void * addr, int num)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_SOCKET_LISTEN_ASYNC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 24 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_socket_listen_async " "Socket listen async ioc=%p addr=%p num=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc, addr, num);
#line 686 "trace/trace-io.h"
        } else {
#line 24 "../io/trace-events"
            qemu_log("qio_channel_socket_listen_async " "Socket listen async ioc=%p addr=%p num=%d" "\n", ioc, addr, num);
#line 690 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_socket_listen_async(void * ioc, void * addr, int num)
{
    if (true) {
        _nocheck__trace_qio_channel_socket_listen_async(ioc, addr, num);
    }
}

#define TRACE_QIO_CHANNEL_SOCKET_LISTEN_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_SOCKET_LISTEN_FAIL) || \
    false)

static inline void _nocheck__trace_qio_channel_socket_listen_fail(void * ioc)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_SOCKET_LISTEN_FAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 25 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_socket_listen_fail " "Socket listen fail ioc=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc);
#line 717 "trace/trace-io.h"
        } else {
#line 25 "../io/trace-events"
            qemu_log("qio_channel_socket_listen_fail " "Socket listen fail ioc=%p" "\n", ioc);
#line 721 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_socket_listen_fail(void * ioc)
{
    if (true) {
        _nocheck__trace_qio_channel_socket_listen_fail(ioc);
    }
}

#define TRACE_QIO_CHANNEL_SOCKET_LISTEN_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_SOCKET_LISTEN_COMPLETE) || \
    false)

static inline void _nocheck__trace_qio_channel_socket_listen_complete(void * ioc, int fd)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_SOCKET_LISTEN_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 26 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_socket_listen_complete " "Socket listen complete ioc=%p fd=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc, fd);
#line 748 "trace/trace-io.h"
        } else {
#line 26 "../io/trace-events"
            qemu_log("qio_channel_socket_listen_complete " "Socket listen complete ioc=%p fd=%d" "\n", ioc, fd);
#line 752 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_socket_listen_complete(void * ioc, int fd)
{
    if (true) {
        _nocheck__trace_qio_channel_socket_listen_complete(ioc, fd);
    }
}

#define TRACE_QIO_CHANNEL_SOCKET_DGRAM_SYNC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_SOCKET_DGRAM_SYNC) || \
    false)

static inline void _nocheck__trace_qio_channel_socket_dgram_sync(void * ioc, void * localAddr, void * remoteAddr)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_SOCKET_DGRAM_SYNC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 27 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_socket_dgram_sync " "Socket dgram sync ioc=%p localAddr=%p remoteAddr=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc, localAddr, remoteAddr);
#line 779 "trace/trace-io.h"
        } else {
#line 27 "../io/trace-events"
            qemu_log("qio_channel_socket_dgram_sync " "Socket dgram sync ioc=%p localAddr=%p remoteAddr=%p" "\n", ioc, localAddr, remoteAddr);
#line 783 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_socket_dgram_sync(void * ioc, void * localAddr, void * remoteAddr)
{
    if (true) {
        _nocheck__trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);
    }
}

#define TRACE_QIO_CHANNEL_SOCKET_DGRAM_ASYNC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_SOCKET_DGRAM_ASYNC) || \
    false)

static inline void _nocheck__trace_qio_channel_socket_dgram_async(void * ioc, void * localAddr, void * remoteAddr)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_SOCKET_DGRAM_ASYNC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 28 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_socket_dgram_async " "Socket dgram async ioc=%p localAddr=%p remoteAddr=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc, localAddr, remoteAddr);
#line 810 "trace/trace-io.h"
        } else {
#line 28 "../io/trace-events"
            qemu_log("qio_channel_socket_dgram_async " "Socket dgram async ioc=%p localAddr=%p remoteAddr=%p" "\n", ioc, localAddr, remoteAddr);
#line 814 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_socket_dgram_async(void * ioc, void * localAddr, void * remoteAddr)
{
    if (true) {
        _nocheck__trace_qio_channel_socket_dgram_async(ioc, localAddr, remoteAddr);
    }
}

#define TRACE_QIO_CHANNEL_SOCKET_DGRAM_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_SOCKET_DGRAM_FAIL) || \
    false)

static inline void _nocheck__trace_qio_channel_socket_dgram_fail(void * ioc)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_SOCKET_DGRAM_FAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 29 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_socket_dgram_fail " "Socket dgram fail ioc=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc);
#line 841 "trace/trace-io.h"
        } else {
#line 29 "../io/trace-events"
            qemu_log("qio_channel_socket_dgram_fail " "Socket dgram fail ioc=%p" "\n", ioc);
#line 845 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_socket_dgram_fail(void * ioc)
{
    if (true) {
        _nocheck__trace_qio_channel_socket_dgram_fail(ioc);
    }
}

#define TRACE_QIO_CHANNEL_SOCKET_DGRAM_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_SOCKET_DGRAM_COMPLETE) || \
    false)

static inline void _nocheck__trace_qio_channel_socket_dgram_complete(void * ioc, int fd)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_SOCKET_DGRAM_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 30 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_socket_dgram_complete " "Socket dgram complete ioc=%p fd=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc, fd);
#line 872 "trace/trace-io.h"
        } else {
#line 30 "../io/trace-events"
            qemu_log("qio_channel_socket_dgram_complete " "Socket dgram complete ioc=%p fd=%d" "\n", ioc, fd);
#line 876 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_socket_dgram_complete(void * ioc, int fd)
{
    if (true) {
        _nocheck__trace_qio_channel_socket_dgram_complete(ioc, fd);
    }
}

#define TRACE_QIO_CHANNEL_SOCKET_ACCEPT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_SOCKET_ACCEPT) || \
    false)

static inline void _nocheck__trace_qio_channel_socket_accept(void * ioc)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_SOCKET_ACCEPT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 31 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_socket_accept " "Socket accept start ioc=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc);
#line 903 "trace/trace-io.h"
        } else {
#line 31 "../io/trace-events"
            qemu_log("qio_channel_socket_accept " "Socket accept start ioc=%p" "\n", ioc);
#line 907 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_socket_accept(void * ioc)
{
    if (true) {
        _nocheck__trace_qio_channel_socket_accept(ioc);
    }
}

#define TRACE_QIO_CHANNEL_SOCKET_ACCEPT_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_SOCKET_ACCEPT_FAIL) || \
    false)

static inline void _nocheck__trace_qio_channel_socket_accept_fail(void * ioc)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_SOCKET_ACCEPT_FAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 32 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_socket_accept_fail " "Socket accept fail ioc=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc);
#line 934 "trace/trace-io.h"
        } else {
#line 32 "../io/trace-events"
            qemu_log("qio_channel_socket_accept_fail " "Socket accept fail ioc=%p" "\n", ioc);
#line 938 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_socket_accept_fail(void * ioc)
{
    if (true) {
        _nocheck__trace_qio_channel_socket_accept_fail(ioc);
    }
}

#define TRACE_QIO_CHANNEL_SOCKET_ACCEPT_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_SOCKET_ACCEPT_COMPLETE) || \
    false)

static inline void _nocheck__trace_qio_channel_socket_accept_complete(void * ioc, void * cioc, int fd)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_SOCKET_ACCEPT_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 33 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_socket_accept_complete " "Socket accept complete ioc=%p cioc=%p fd=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc, cioc, fd);
#line 965 "trace/trace-io.h"
        } else {
#line 33 "../io/trace-events"
            qemu_log("qio_channel_socket_accept_complete " "Socket accept complete ioc=%p cioc=%p fd=%d" "\n", ioc, cioc, fd);
#line 969 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_socket_accept_complete(void * ioc, void * cioc, int fd)
{
    if (true) {
        _nocheck__trace_qio_channel_socket_accept_complete(ioc, cioc, fd);
    }
}

#define TRACE_QIO_CHANNEL_FILE_NEW_FD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_FILE_NEW_FD) || \
    false)

static inline void _nocheck__trace_qio_channel_file_new_fd(void * ioc, int fd)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_FILE_NEW_FD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 36 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_file_new_fd " "File new fd ioc=%p fd=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc, fd);
#line 996 "trace/trace-io.h"
        } else {
#line 36 "../io/trace-events"
            qemu_log("qio_channel_file_new_fd " "File new fd ioc=%p fd=%d" "\n", ioc, fd);
#line 1000 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_file_new_fd(void * ioc, int fd)
{
    if (true) {
        _nocheck__trace_qio_channel_file_new_fd(ioc, fd);
    }
}

#define TRACE_QIO_CHANNEL_FILE_NEW_PATH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_FILE_NEW_PATH) || \
    false)

static inline void _nocheck__trace_qio_channel_file_new_path(void * ioc, const char * path, int flags, int mode, int fd)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_FILE_NEW_PATH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 37 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_file_new_path " "File new fd ioc=%p path=%s flags=%d mode=%d fd=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc, path, flags, mode, fd);
#line 1027 "trace/trace-io.h"
        } else {
#line 37 "../io/trace-events"
            qemu_log("qio_channel_file_new_path " "File new fd ioc=%p path=%s flags=%d mode=%d fd=%d" "\n", ioc, path, flags, mode, fd);
#line 1031 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_file_new_path(void * ioc, const char * path, int flags, int mode, int fd)
{
    if (true) {
        _nocheck__trace_qio_channel_file_new_path(ioc, path, flags, mode, fd);
    }
}

#define TRACE_QIO_CHANNEL_TLS_NEW_CLIENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_TLS_NEW_CLIENT) || \
    false)

static inline void _nocheck__trace_qio_channel_tls_new_client(void * ioc, void * master, void * creds, const char * hostname)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_TLS_NEW_CLIENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 40 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_tls_new_client " "TLS new client ioc=%p master=%p creds=%p hostname=%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc, master, creds, hostname);
#line 1058 "trace/trace-io.h"
        } else {
#line 40 "../io/trace-events"
            qemu_log("qio_channel_tls_new_client " "TLS new client ioc=%p master=%p creds=%p hostname=%s" "\n", ioc, master, creds, hostname);
#line 1062 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_tls_new_client(void * ioc, void * master, void * creds, const char * hostname)
{
    if (true) {
        _nocheck__trace_qio_channel_tls_new_client(ioc, master, creds, hostname);
    }
}

#define TRACE_QIO_CHANNEL_TLS_NEW_SERVER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_TLS_NEW_SERVER) || \
    false)

static inline void _nocheck__trace_qio_channel_tls_new_server(void * ioc, void * master, void * creds, const char * aclname)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_TLS_NEW_SERVER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 41 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_tls_new_server " "TLS new client ioc=%p master=%p creds=%p acltname=%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc, master, creds, aclname);
#line 1089 "trace/trace-io.h"
        } else {
#line 41 "../io/trace-events"
            qemu_log("qio_channel_tls_new_server " "TLS new client ioc=%p master=%p creds=%p acltname=%s" "\n", ioc, master, creds, aclname);
#line 1093 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_tls_new_server(void * ioc, void * master, void * creds, const char * aclname)
{
    if (true) {
        _nocheck__trace_qio_channel_tls_new_server(ioc, master, creds, aclname);
    }
}

#define TRACE_QIO_CHANNEL_TLS_HANDSHAKE_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_TLS_HANDSHAKE_START) || \
    false)

static inline void _nocheck__trace_qio_channel_tls_handshake_start(void * ioc)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_TLS_HANDSHAKE_START) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 42 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_tls_handshake_start " "TLS handshake start ioc=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc);
#line 1120 "trace/trace-io.h"
        } else {
#line 42 "../io/trace-events"
            qemu_log("qio_channel_tls_handshake_start " "TLS handshake start ioc=%p" "\n", ioc);
#line 1124 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_tls_handshake_start(void * ioc)
{
    if (true) {
        _nocheck__trace_qio_channel_tls_handshake_start(ioc);
    }
}

#define TRACE_QIO_CHANNEL_TLS_HANDSHAKE_PENDING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_TLS_HANDSHAKE_PENDING) || \
    false)

static inline void _nocheck__trace_qio_channel_tls_handshake_pending(void * ioc, int status)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_TLS_HANDSHAKE_PENDING) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 43 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_tls_handshake_pending " "TLS handshake pending ioc=%p status=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc, status);
#line 1151 "trace/trace-io.h"
        } else {
#line 43 "../io/trace-events"
            qemu_log("qio_channel_tls_handshake_pending " "TLS handshake pending ioc=%p status=%d" "\n", ioc, status);
#line 1155 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_tls_handshake_pending(void * ioc, int status)
{
    if (true) {
        _nocheck__trace_qio_channel_tls_handshake_pending(ioc, status);
    }
}

#define TRACE_QIO_CHANNEL_TLS_HANDSHAKE_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_TLS_HANDSHAKE_FAIL) || \
    false)

static inline void _nocheck__trace_qio_channel_tls_handshake_fail(void * ioc)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_TLS_HANDSHAKE_FAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 44 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_tls_handshake_fail " "TLS handshake fail ioc=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc);
#line 1182 "trace/trace-io.h"
        } else {
#line 44 "../io/trace-events"
            qemu_log("qio_channel_tls_handshake_fail " "TLS handshake fail ioc=%p" "\n", ioc);
#line 1186 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_tls_handshake_fail(void * ioc)
{
    if (true) {
        _nocheck__trace_qio_channel_tls_handshake_fail(ioc);
    }
}

#define TRACE_QIO_CHANNEL_TLS_HANDSHAKE_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_TLS_HANDSHAKE_COMPLETE) || \
    false)

static inline void _nocheck__trace_qio_channel_tls_handshake_complete(void * ioc)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_TLS_HANDSHAKE_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 45 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_tls_handshake_complete " "TLS handshake complete ioc=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc);
#line 1213 "trace/trace-io.h"
        } else {
#line 45 "../io/trace-events"
            qemu_log("qio_channel_tls_handshake_complete " "TLS handshake complete ioc=%p" "\n", ioc);
#line 1217 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_tls_handshake_complete(void * ioc)
{
    if (true) {
        _nocheck__trace_qio_channel_tls_handshake_complete(ioc);
    }
}

#define TRACE_QIO_CHANNEL_TLS_HANDSHAKE_CANCEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_TLS_HANDSHAKE_CANCEL) || \
    false)

static inline void _nocheck__trace_qio_channel_tls_handshake_cancel(void * ioc)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_TLS_HANDSHAKE_CANCEL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 46 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_tls_handshake_cancel " "TLS handshake cancel ioc=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc);
#line 1244 "trace/trace-io.h"
        } else {
#line 46 "../io/trace-events"
            qemu_log("qio_channel_tls_handshake_cancel " "TLS handshake cancel ioc=%p" "\n", ioc);
#line 1248 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_tls_handshake_cancel(void * ioc)
{
    if (true) {
        _nocheck__trace_qio_channel_tls_handshake_cancel(ioc);
    }
}

#define TRACE_QIO_CHANNEL_TLS_CREDENTIALS_ALLOW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_TLS_CREDENTIALS_ALLOW) || \
    false)

static inline void _nocheck__trace_qio_channel_tls_credentials_allow(void * ioc)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_TLS_CREDENTIALS_ALLOW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 47 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_tls_credentials_allow " "TLS credentials allow ioc=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc);
#line 1275 "trace/trace-io.h"
        } else {
#line 47 "../io/trace-events"
            qemu_log("qio_channel_tls_credentials_allow " "TLS credentials allow ioc=%p" "\n", ioc);
#line 1279 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_tls_credentials_allow(void * ioc)
{
    if (true) {
        _nocheck__trace_qio_channel_tls_credentials_allow(ioc);
    }
}

#define TRACE_QIO_CHANNEL_TLS_CREDENTIALS_DENY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_TLS_CREDENTIALS_DENY) || \
    false)

static inline void _nocheck__trace_qio_channel_tls_credentials_deny(void * ioc)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_TLS_CREDENTIALS_DENY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 48 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_tls_credentials_deny " "TLS credentials deny ioc=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc);
#line 1306 "trace/trace-io.h"
        } else {
#line 48 "../io/trace-events"
            qemu_log("qio_channel_tls_credentials_deny " "TLS credentials deny ioc=%p" "\n", ioc);
#line 1310 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_tls_credentials_deny(void * ioc)
{
    if (true) {
        _nocheck__trace_qio_channel_tls_credentials_deny(ioc);
    }
}

#define TRACE_QIO_CHANNEL_WEBSOCK_NEW_SERVER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_WEBSOCK_NEW_SERVER) || \
    false)

static inline void _nocheck__trace_qio_channel_websock_new_server(void * ioc, void * master)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_WEBSOCK_NEW_SERVER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 51 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_websock_new_server " "Websock new client ioc=%p master=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc, master);
#line 1337 "trace/trace-io.h"
        } else {
#line 51 "../io/trace-events"
            qemu_log("qio_channel_websock_new_server " "Websock new client ioc=%p master=%p" "\n", ioc, master);
#line 1341 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_websock_new_server(void * ioc, void * master)
{
    if (true) {
        _nocheck__trace_qio_channel_websock_new_server(ioc, master);
    }
}

#define TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_START) || \
    false)

static inline void _nocheck__trace_qio_channel_websock_handshake_start(void * ioc)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_START) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 52 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_websock_handshake_start " "Websock handshake start ioc=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc);
#line 1368 "trace/trace-io.h"
        } else {
#line 52 "../io/trace-events"
            qemu_log("qio_channel_websock_handshake_start " "Websock handshake start ioc=%p" "\n", ioc);
#line 1372 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_websock_handshake_start(void * ioc)
{
    if (true) {
        _nocheck__trace_qio_channel_websock_handshake_start(ioc);
    }
}

#define TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_PENDING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_PENDING) || \
    false)

static inline void _nocheck__trace_qio_channel_websock_handshake_pending(void * ioc, int status)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_PENDING) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 53 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_websock_handshake_pending " "Websock handshake pending ioc=%p status=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc, status);
#line 1399 "trace/trace-io.h"
        } else {
#line 53 "../io/trace-events"
            qemu_log("qio_channel_websock_handshake_pending " "Websock handshake pending ioc=%p status=%d" "\n", ioc, status);
#line 1403 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_websock_handshake_pending(void * ioc, int status)
{
    if (true) {
        _nocheck__trace_qio_channel_websock_handshake_pending(ioc, status);
    }
}

#define TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_REPLY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_REPLY) || \
    false)

static inline void _nocheck__trace_qio_channel_websock_handshake_reply(void * ioc)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_REPLY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 54 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_websock_handshake_reply " "Websock handshake reply ioc=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc);
#line 1430 "trace/trace-io.h"
        } else {
#line 54 "../io/trace-events"
            qemu_log("qio_channel_websock_handshake_reply " "Websock handshake reply ioc=%p" "\n", ioc);
#line 1434 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_websock_handshake_reply(void * ioc)
{
    if (true) {
        _nocheck__trace_qio_channel_websock_handshake_reply(ioc);
    }
}

#define TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_FAIL) || \
    false)

static inline void _nocheck__trace_qio_channel_websock_handshake_fail(void * ioc, const char * msg)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_FAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 55 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_websock_handshake_fail " "Websock handshake fail ioc=%p err=%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc, msg);
#line 1461 "trace/trace-io.h"
        } else {
#line 55 "../io/trace-events"
            qemu_log("qio_channel_websock_handshake_fail " "Websock handshake fail ioc=%p err=%s" "\n", ioc, msg);
#line 1465 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_websock_handshake_fail(void * ioc, const char * msg)
{
    if (true) {
        _nocheck__trace_qio_channel_websock_handshake_fail(ioc, msg);
    }
}

#define TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_COMPLETE) || \
    false)

static inline void _nocheck__trace_qio_channel_websock_handshake_complete(void * ioc)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 56 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_websock_handshake_complete " "Websock handshake complete ioc=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc);
#line 1492 "trace/trace-io.h"
        } else {
#line 56 "../io/trace-events"
            qemu_log("qio_channel_websock_handshake_complete " "Websock handshake complete ioc=%p" "\n", ioc);
#line 1496 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_websock_handshake_complete(void * ioc)
{
    if (true) {
        _nocheck__trace_qio_channel_websock_handshake_complete(ioc);
    }
}

#define TRACE_QIO_CHANNEL_WEBSOCK_HTTP_GREETING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_WEBSOCK_HTTP_GREETING) || \
    false)

static inline void _nocheck__trace_qio_channel_websock_http_greeting(void * ioc, const char * greeting)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_WEBSOCK_HTTP_GREETING) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 57 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_websock_http_greeting " "Websocket HTTP request ioc=%p greeting='%s'" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc, greeting);
#line 1523 "trace/trace-io.h"
        } else {
#line 57 "../io/trace-events"
            qemu_log("qio_channel_websock_http_greeting " "Websocket HTTP request ioc=%p greeting='%s'" "\n", ioc, greeting);
#line 1527 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_websock_http_greeting(void * ioc, const char * greeting)
{
    if (true) {
        _nocheck__trace_qio_channel_websock_http_greeting(ioc, greeting);
    }
}

#define TRACE_QIO_CHANNEL_WEBSOCK_HTTP_REQUEST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_WEBSOCK_HTTP_REQUEST) || \
    false)

static inline void _nocheck__trace_qio_channel_websock_http_request(void * ioc, const char * protocols, const char * version, const char * host, const char * connection, const char * upgrade, const char * key)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_WEBSOCK_HTTP_REQUEST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 58 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_websock_http_request " "Websocket HTTP request ioc=%p protocols='%s' version='%s' host='%s' connection='%s' upgrade='%s' key='%s'" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc, protocols, version, host, connection, upgrade, key);
#line 1554 "trace/trace-io.h"
        } else {
#line 58 "../io/trace-events"
            qemu_log("qio_channel_websock_http_request " "Websocket HTTP request ioc=%p protocols='%s' version='%s' host='%s' connection='%s' upgrade='%s' key='%s'" "\n", ioc, protocols, version, host, connection, upgrade, key);
#line 1558 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_websock_http_request(void * ioc, const char * protocols, const char * version, const char * host, const char * connection, const char * upgrade, const char * key)
{
    if (true) {
        _nocheck__trace_qio_channel_websock_http_request(ioc, protocols, version, host, connection, upgrade, key);
    }
}

#define TRACE_QIO_CHANNEL_WEBSOCK_HEADER_PARTIAL_DECODE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_WEBSOCK_HEADER_PARTIAL_DECODE) || \
    false)

static inline void _nocheck__trace_qio_channel_websock_header_partial_decode(void * ioc, size_t payloadlen, unsigned char fin, unsigned char opcode, unsigned char has_mask)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_WEBSOCK_HEADER_PARTIAL_DECODE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 59 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_websock_header_partial_decode " "Websocket header decoded ioc=%p payload-len=%zu fin=0x%x opcode=0x%x has_mask=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc, payloadlen, fin, opcode, has_mask);
#line 1585 "trace/trace-io.h"
        } else {
#line 59 "../io/trace-events"
            qemu_log("qio_channel_websock_header_partial_decode " "Websocket header decoded ioc=%p payload-len=%zu fin=0x%x opcode=0x%x has_mask=0x%x" "\n", ioc, payloadlen, fin, opcode, has_mask);
#line 1589 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_websock_header_partial_decode(void * ioc, size_t payloadlen, unsigned char fin, unsigned char opcode, unsigned char has_mask)
{
    if (true) {
        _nocheck__trace_qio_channel_websock_header_partial_decode(ioc, payloadlen, fin, opcode, has_mask);
    }
}

#define TRACE_QIO_CHANNEL_WEBSOCK_HEADER_FULL_DECODE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_WEBSOCK_HEADER_FULL_DECODE) || \
    false)

static inline void _nocheck__trace_qio_channel_websock_header_full_decode(void * ioc, size_t headerlen, size_t payloadlen, uint32_t mask)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_WEBSOCK_HEADER_FULL_DECODE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 60 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_websock_header_full_decode " "Websocket header decoded ioc=%p header-len=%zu payload-len=%zu mask=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc, headerlen, payloadlen, mask);
#line 1616 "trace/trace-io.h"
        } else {
#line 60 "../io/trace-events"
            qemu_log("qio_channel_websock_header_full_decode " "Websocket header decoded ioc=%p header-len=%zu payload-len=%zu mask=0x%x" "\n", ioc, headerlen, payloadlen, mask);
#line 1620 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_websock_header_full_decode(void * ioc, size_t headerlen, size_t payloadlen, uint32_t mask)
{
    if (true) {
        _nocheck__trace_qio_channel_websock_header_full_decode(ioc, headerlen, payloadlen, mask);
    }
}

#define TRACE_QIO_CHANNEL_WEBSOCK_PAYLOAD_DECODE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_WEBSOCK_PAYLOAD_DECODE) || \
    false)

static inline void _nocheck__trace_qio_channel_websock_payload_decode(void * ioc, uint8_t opcode, size_t payload_remain)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_WEBSOCK_PAYLOAD_DECODE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 61 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_websock_payload_decode " "Websocket header decoded ioc=%p opcode=0x%x payload-remain=%zu" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc, opcode, payload_remain);
#line 1647 "trace/trace-io.h"
        } else {
#line 61 "../io/trace-events"
            qemu_log("qio_channel_websock_payload_decode " "Websocket header decoded ioc=%p opcode=0x%x payload-remain=%zu" "\n", ioc, opcode, payload_remain);
#line 1651 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_websock_payload_decode(void * ioc, uint8_t opcode, size_t payload_remain)
{
    if (true) {
        _nocheck__trace_qio_channel_websock_payload_decode(ioc, opcode, payload_remain);
    }
}

#define TRACE_QIO_CHANNEL_WEBSOCK_ENCODE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_WEBSOCK_ENCODE) || \
    false)

static inline void _nocheck__trace_qio_channel_websock_encode(void * ioc, uint8_t opcode, size_t payloadlen, size_t headerlen)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_WEBSOCK_ENCODE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 62 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_websock_encode " "Websocket encoded ioc=%p opcode=0x%x header-len=%zu payload-len=%zu" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc, opcode, payloadlen, headerlen);
#line 1678 "trace/trace-io.h"
        } else {
#line 62 "../io/trace-events"
            qemu_log("qio_channel_websock_encode " "Websocket encoded ioc=%p opcode=0x%x header-len=%zu payload-len=%zu" "\n", ioc, opcode, payloadlen, headerlen);
#line 1682 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_websock_encode(void * ioc, uint8_t opcode, size_t payloadlen, size_t headerlen)
{
    if (true) {
        _nocheck__trace_qio_channel_websock_encode(ioc, opcode, payloadlen, headerlen);
    }
}

#define TRACE_QIO_CHANNEL_WEBSOCK_CLOSE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_WEBSOCK_CLOSE) || \
    false)

static inline void _nocheck__trace_qio_channel_websock_close(void * ioc)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_WEBSOCK_CLOSE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 63 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_websock_close " "Websocket close ioc=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc);
#line 1709 "trace/trace-io.h"
        } else {
#line 63 "../io/trace-events"
            qemu_log("qio_channel_websock_close " "Websocket close ioc=%p" "\n", ioc);
#line 1713 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_websock_close(void * ioc)
{
    if (true) {
        _nocheck__trace_qio_channel_websock_close(ioc);
    }
}

#define TRACE_QIO_CHANNEL_COMMAND_NEW_PID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_COMMAND_NEW_PID) || \
    false)

static inline void _nocheck__trace_qio_channel_command_new_pid(void * ioc, int writefd, int readfd, int pid)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_COMMAND_NEW_PID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 66 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_command_new_pid " "Command new pid ioc=%p writefd=%d readfd=%d pid=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc, writefd, readfd, pid);
#line 1740 "trace/trace-io.h"
        } else {
#line 66 "../io/trace-events"
            qemu_log("qio_channel_command_new_pid " "Command new pid ioc=%p writefd=%d readfd=%d pid=%d" "\n", ioc, writefd, readfd, pid);
#line 1744 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_command_new_pid(void * ioc, int writefd, int readfd, int pid)
{
    if (true) {
        _nocheck__trace_qio_channel_command_new_pid(ioc, writefd, readfd, pid);
    }
}

#define TRACE_QIO_CHANNEL_COMMAND_NEW_SPAWN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_COMMAND_NEW_SPAWN) || \
    false)

static inline void _nocheck__trace_qio_channel_command_new_spawn(void * ioc, const char * binary, int flags)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_COMMAND_NEW_SPAWN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 67 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_command_new_spawn " "Command new spawn ioc=%p binary=%s flags=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc, binary, flags);
#line 1771 "trace/trace-io.h"
        } else {
#line 67 "../io/trace-events"
            qemu_log("qio_channel_command_new_spawn " "Command new spawn ioc=%p binary=%s flags=%d" "\n", ioc, binary, flags);
#line 1775 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_command_new_spawn(void * ioc, const char * binary, int flags)
{
    if (true) {
        _nocheck__trace_qio_channel_command_new_spawn(ioc, binary, flags);
    }
}

#define TRACE_QIO_CHANNEL_COMMAND_ABORT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_COMMAND_ABORT) || \
    false)

static inline void _nocheck__trace_qio_channel_command_abort(void * ioc, int pid)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_COMMAND_ABORT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 68 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_command_abort " "Command abort ioc=%p pid=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc, pid);
#line 1802 "trace/trace-io.h"
        } else {
#line 68 "../io/trace-events"
            qemu_log("qio_channel_command_abort " "Command abort ioc=%p pid=%d" "\n", ioc, pid);
#line 1806 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_command_abort(void * ioc, int pid)
{
    if (true) {
        _nocheck__trace_qio_channel_command_abort(ioc, pid);
    }
}

#define TRACE_QIO_CHANNEL_COMMAND_WAIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QIO_CHANNEL_COMMAND_WAIT) || \
    false)

static inline void _nocheck__trace_qio_channel_command_wait(void * ioc, int pid, int ret, int status)
{
    if (trace_event_get_state(TRACE_QIO_CHANNEL_COMMAND_WAIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 69 "../io/trace-events"
            qemu_log("%d@%zu.%06zu:qio_channel_command_wait " "Command abort ioc=%p pid=%d ret=%d status=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioc, pid, ret, status);
#line 1833 "trace/trace-io.h"
        } else {
#line 69 "../io/trace-events"
            qemu_log("qio_channel_command_wait " "Command abort ioc=%p pid=%d ret=%d status=%d" "\n", ioc, pid, ret, status);
#line 1837 "trace/trace-io.h"
        }
    }
}

static inline void trace_qio_channel_command_wait(void * ioc, int pid, int ret, int status)
{
    if (true) {
        _nocheck__trace_qio_channel_command_wait(ioc, pid, ret, status);
    }
}
#endif /* TRACE_IO_GENERATED_TRACERS_H */
