/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_ACPI_GENERATED_TRACERS_H
#define TRACE_HW_ACPI_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_MHP_ACPI_INVALID_SLOT_SELECTED_EVENT;
extern TraceEvent _TRACE_MHP_ACPI_EJECTING_INVALID_SLOT_EVENT;
extern TraceEvent _TRACE_MHP_ACPI_READ_ADDR_LO_EVENT;
extern TraceEvent _TRACE_MHP_ACPI_READ_ADDR_HI_EVENT;
extern TraceEvent _TRACE_MHP_ACPI_READ_SIZE_LO_EVENT;
extern TraceEvent _TRACE_MHP_ACPI_READ_SIZE_HI_EVENT;
extern TraceEvent _TRACE_MHP_ACPI_READ_PXM_EVENT;
extern TraceEvent _TRACE_MHP_ACPI_READ_FLAGS_EVENT;
extern TraceEvent _TRACE_MHP_ACPI_WRITE_SLOT_EVENT;
extern TraceEvent _TRACE_MHP_ACPI_WRITE_OST_EV_EVENT;
extern TraceEvent _TRACE_MHP_ACPI_WRITE_OST_STATUS_EVENT;
extern TraceEvent _TRACE_MHP_ACPI_CLEAR_INSERT_EVT_EVENT;
extern TraceEvent _TRACE_MHP_ACPI_CLEAR_REMOVE_EVT_EVENT;
extern TraceEvent _TRACE_MHP_ACPI_PC_DIMM_DELETED_EVENT;
extern TraceEvent _TRACE_MHP_ACPI_PC_DIMM_DELETE_FAILED_EVENT;
extern TraceEvent _TRACE_ACPI_GPE_EN_IOPORT_READB_EVENT;
extern TraceEvent _TRACE_ACPI_GPE_EN_IOPORT_WRITEB_EVENT;
extern TraceEvent _TRACE_ACPI_GPE_STS_IOPORT_READB_EVENT;
extern TraceEvent _TRACE_ACPI_GPE_STS_IOPORT_WRITEB_EVENT;
extern TraceEvent _TRACE_CPUHP_ACPI_INVALID_IDX_SELECTED_EVENT;
extern TraceEvent _TRACE_CPUHP_ACPI_READ_FLAGS_EVENT;
extern TraceEvent _TRACE_CPUHP_ACPI_WRITE_IDX_EVENT;
extern TraceEvent _TRACE_CPUHP_ACPI_WRITE_CMD_EVENT;
extern TraceEvent _TRACE_CPUHP_ACPI_READ_CMD_DATA_EVENT;
extern TraceEvent _TRACE_CPUHP_ACPI_READ_CMD_DATA2_EVENT;
extern TraceEvent _TRACE_CPUHP_ACPI_CPU_HAS_EVENTS_EVENT;
extern TraceEvent _TRACE_CPUHP_ACPI_CLEAR_INSERTING_EVT_EVENT;
extern TraceEvent _TRACE_CPUHP_ACPI_CLEAR_REMOVE_EVT_EVENT;
extern TraceEvent _TRACE_CPUHP_ACPI_EJECTING_INVALID_CPU_EVENT;
extern TraceEvent _TRACE_CPUHP_ACPI_EJECTING_CPU_EVENT;
extern TraceEvent _TRACE_CPUHP_ACPI_FW_REMOVE_INVALID_CPU_EVENT;
extern TraceEvent _TRACE_CPUHP_ACPI_FW_REMOVE_CPU_EVENT;
extern TraceEvent _TRACE_CPUHP_ACPI_WRITE_OST_EV_EVENT;
extern TraceEvent _TRACE_CPUHP_ACPI_WRITE_OST_STATUS_EVENT;
extern TraceEvent _TRACE_ACPI_PCI_EJECT_SLOT_EVENT;
extern TraceEvent _TRACE_ACPI_PCI_UNPLUG_EVENT;
extern TraceEvent _TRACE_ACPI_PCI_UNPLUG_REQUEST_EVENT;
extern TraceEvent _TRACE_ACPI_PCI_UP_READ_EVENT;
extern TraceEvent _TRACE_ACPI_PCI_DOWN_READ_EVENT;
extern TraceEvent _TRACE_ACPI_PCI_FEATURES_READ_EVENT;
extern TraceEvent _TRACE_ACPI_PCI_ACPI_INDEX_READ_EVENT;
extern TraceEvent _TRACE_ACPI_PCI_ACPI_INDEX_WRITE_EVENT;
extern TraceEvent _TRACE_ACPI_PCI_RMV_READ_EVENT;
extern TraceEvent _TRACE_ACPI_PCI_SEL_READ_EVENT;
extern TraceEvent _TRACE_ACPI_PCI_EJ_WRITE_EVENT;
extern TraceEvent _TRACE_ACPI_PCI_SEL_WRITE_EVENT;
extern TraceEvent _TRACE_TCO_TIMER_RELOAD_EVENT;
extern TraceEvent _TRACE_TCO_TIMER_EXPIRED_EVENT;
extern TraceEvent _TRACE_TCO_IO_WRITE_EVENT;
extern TraceEvent _TRACE_TCO_IO_READ_EVENT;
extern TraceEvent _TRACE_ACPI_ERST_REG_WRITE_EVENT;
extern TraceEvent _TRACE_ACPI_ERST_REG_READ_EVENT;
extern TraceEvent _TRACE_ACPI_ERST_MEM_WRITE_EVENT;
extern TraceEvent _TRACE_ACPI_ERST_MEM_READ_EVENT;
extern TraceEvent _TRACE_ACPI_ERST_PCI_BAR_0_EVENT;
extern TraceEvent _TRACE_ACPI_ERST_PCI_BAR_1_EVENT;
extern TraceEvent _TRACE_ACPI_ERST_REALIZEFN_IN_EVENT;
extern TraceEvent _TRACE_ACPI_ERST_REALIZEFN_OUT_EVENT;
extern TraceEvent _TRACE_ACPI_ERST_RESET_IN_EVENT;
extern TraceEvent _TRACE_ACPI_ERST_RESET_OUT_EVENT;
extern TraceEvent _TRACE_ACPI_ERST_POST_LOAD_EVENT;
extern TraceEvent _TRACE_ACPI_ERST_CLASS_INIT_IN_EVENT;
extern TraceEvent _TRACE_ACPI_ERST_CLASS_INIT_OUT_EVENT;
extern TraceEvent _TRACE_ACPI_NVDIMM_READ_FIT_EVENT;
extern TraceEvent _TRACE_ACPI_NVDIMM_LABEL_INFO_EVENT;
extern TraceEvent _TRACE_ACPI_NVDIMM_LABEL_OVERFLOW_EVENT;
extern TraceEvent _TRACE_ACPI_NVDIMM_LABEL_OVERSIZE_EVENT;
extern TraceEvent _TRACE_ACPI_NVDIMM_LABEL_XFER_EXCEED_EVENT;
extern TraceEvent _TRACE_ACPI_NVDIMM_READ_LABEL_EVENT;
extern TraceEvent _TRACE_ACPI_NVDIMM_WRITE_LABEL_EVENT;
extern TraceEvent _TRACE_ACPI_NVDIMM_READ_IO_PORT_EVENT;
extern TraceEvent _TRACE_ACPI_NVDIMM_DSM_MEM_ADDR_EVENT;
extern TraceEvent _TRACE_ACPI_NVDIMM_DSM_INFO_EVENT;
extern TraceEvent _TRACE_ACPI_NVDIMM_INVALID_REVISION_EVENT;
extern uint16_t _TRACE_MHP_ACPI_INVALID_SLOT_SELECTED_DSTATE;
extern uint16_t _TRACE_MHP_ACPI_EJECTING_INVALID_SLOT_DSTATE;
extern uint16_t _TRACE_MHP_ACPI_READ_ADDR_LO_DSTATE;
extern uint16_t _TRACE_MHP_ACPI_READ_ADDR_HI_DSTATE;
extern uint16_t _TRACE_MHP_ACPI_READ_SIZE_LO_DSTATE;
extern uint16_t _TRACE_MHP_ACPI_READ_SIZE_HI_DSTATE;
extern uint16_t _TRACE_MHP_ACPI_READ_PXM_DSTATE;
extern uint16_t _TRACE_MHP_ACPI_READ_FLAGS_DSTATE;
extern uint16_t _TRACE_MHP_ACPI_WRITE_SLOT_DSTATE;
extern uint16_t _TRACE_MHP_ACPI_WRITE_OST_EV_DSTATE;
extern uint16_t _TRACE_MHP_ACPI_WRITE_OST_STATUS_DSTATE;
extern uint16_t _TRACE_MHP_ACPI_CLEAR_INSERT_EVT_DSTATE;
extern uint16_t _TRACE_MHP_ACPI_CLEAR_REMOVE_EVT_DSTATE;
extern uint16_t _TRACE_MHP_ACPI_PC_DIMM_DELETED_DSTATE;
extern uint16_t _TRACE_MHP_ACPI_PC_DIMM_DELETE_FAILED_DSTATE;
extern uint16_t _TRACE_ACPI_GPE_EN_IOPORT_READB_DSTATE;
extern uint16_t _TRACE_ACPI_GPE_EN_IOPORT_WRITEB_DSTATE;
extern uint16_t _TRACE_ACPI_GPE_STS_IOPORT_READB_DSTATE;
extern uint16_t _TRACE_ACPI_GPE_STS_IOPORT_WRITEB_DSTATE;
extern uint16_t _TRACE_CPUHP_ACPI_INVALID_IDX_SELECTED_DSTATE;
extern uint16_t _TRACE_CPUHP_ACPI_READ_FLAGS_DSTATE;
extern uint16_t _TRACE_CPUHP_ACPI_WRITE_IDX_DSTATE;
extern uint16_t _TRACE_CPUHP_ACPI_WRITE_CMD_DSTATE;
extern uint16_t _TRACE_CPUHP_ACPI_READ_CMD_DATA_DSTATE;
extern uint16_t _TRACE_CPUHP_ACPI_READ_CMD_DATA2_DSTATE;
extern uint16_t _TRACE_CPUHP_ACPI_CPU_HAS_EVENTS_DSTATE;
extern uint16_t _TRACE_CPUHP_ACPI_CLEAR_INSERTING_EVT_DSTATE;
extern uint16_t _TRACE_CPUHP_ACPI_CLEAR_REMOVE_EVT_DSTATE;
extern uint16_t _TRACE_CPUHP_ACPI_EJECTING_INVALID_CPU_DSTATE;
extern uint16_t _TRACE_CPUHP_ACPI_EJECTING_CPU_DSTATE;
extern uint16_t _TRACE_CPUHP_ACPI_FW_REMOVE_INVALID_CPU_DSTATE;
extern uint16_t _TRACE_CPUHP_ACPI_FW_REMOVE_CPU_DSTATE;
extern uint16_t _TRACE_CPUHP_ACPI_WRITE_OST_EV_DSTATE;
extern uint16_t _TRACE_CPUHP_ACPI_WRITE_OST_STATUS_DSTATE;
extern uint16_t _TRACE_ACPI_PCI_EJECT_SLOT_DSTATE;
extern uint16_t _TRACE_ACPI_PCI_UNPLUG_DSTATE;
extern uint16_t _TRACE_ACPI_PCI_UNPLUG_REQUEST_DSTATE;
extern uint16_t _TRACE_ACPI_PCI_UP_READ_DSTATE;
extern uint16_t _TRACE_ACPI_PCI_DOWN_READ_DSTATE;
extern uint16_t _TRACE_ACPI_PCI_FEATURES_READ_DSTATE;
extern uint16_t _TRACE_ACPI_PCI_ACPI_INDEX_READ_DSTATE;
extern uint16_t _TRACE_ACPI_PCI_ACPI_INDEX_WRITE_DSTATE;
extern uint16_t _TRACE_ACPI_PCI_RMV_READ_DSTATE;
extern uint16_t _TRACE_ACPI_PCI_SEL_READ_DSTATE;
extern uint16_t _TRACE_ACPI_PCI_EJ_WRITE_DSTATE;
extern uint16_t _TRACE_ACPI_PCI_SEL_WRITE_DSTATE;
extern uint16_t _TRACE_TCO_TIMER_RELOAD_DSTATE;
extern uint16_t _TRACE_TCO_TIMER_EXPIRED_DSTATE;
extern uint16_t _TRACE_TCO_IO_WRITE_DSTATE;
extern uint16_t _TRACE_TCO_IO_READ_DSTATE;
extern uint16_t _TRACE_ACPI_ERST_REG_WRITE_DSTATE;
extern uint16_t _TRACE_ACPI_ERST_REG_READ_DSTATE;
extern uint16_t _TRACE_ACPI_ERST_MEM_WRITE_DSTATE;
extern uint16_t _TRACE_ACPI_ERST_MEM_READ_DSTATE;
extern uint16_t _TRACE_ACPI_ERST_PCI_BAR_0_DSTATE;
extern uint16_t _TRACE_ACPI_ERST_PCI_BAR_1_DSTATE;
extern uint16_t _TRACE_ACPI_ERST_REALIZEFN_IN_DSTATE;
extern uint16_t _TRACE_ACPI_ERST_REALIZEFN_OUT_DSTATE;
extern uint16_t _TRACE_ACPI_ERST_RESET_IN_DSTATE;
extern uint16_t _TRACE_ACPI_ERST_RESET_OUT_DSTATE;
extern uint16_t _TRACE_ACPI_ERST_POST_LOAD_DSTATE;
extern uint16_t _TRACE_ACPI_ERST_CLASS_INIT_IN_DSTATE;
extern uint16_t _TRACE_ACPI_ERST_CLASS_INIT_OUT_DSTATE;
extern uint16_t _TRACE_ACPI_NVDIMM_READ_FIT_DSTATE;
extern uint16_t _TRACE_ACPI_NVDIMM_LABEL_INFO_DSTATE;
extern uint16_t _TRACE_ACPI_NVDIMM_LABEL_OVERFLOW_DSTATE;
extern uint16_t _TRACE_ACPI_NVDIMM_LABEL_OVERSIZE_DSTATE;
extern uint16_t _TRACE_ACPI_NVDIMM_LABEL_XFER_EXCEED_DSTATE;
extern uint16_t _TRACE_ACPI_NVDIMM_READ_LABEL_DSTATE;
extern uint16_t _TRACE_ACPI_NVDIMM_WRITE_LABEL_DSTATE;
extern uint16_t _TRACE_ACPI_NVDIMM_READ_IO_PORT_DSTATE;
extern uint16_t _TRACE_ACPI_NVDIMM_DSM_MEM_ADDR_DSTATE;
extern uint16_t _TRACE_ACPI_NVDIMM_DSM_INFO_DSTATE;
extern uint16_t _TRACE_ACPI_NVDIMM_INVALID_REVISION_DSTATE;
#define TRACE_MHP_ACPI_INVALID_SLOT_SELECTED_ENABLED 1
#define TRACE_MHP_ACPI_EJECTING_INVALID_SLOT_ENABLED 1
#define TRACE_MHP_ACPI_READ_ADDR_LO_ENABLED 1
#define TRACE_MHP_ACPI_READ_ADDR_HI_ENABLED 1
#define TRACE_MHP_ACPI_READ_SIZE_LO_ENABLED 1
#define TRACE_MHP_ACPI_READ_SIZE_HI_ENABLED 1
#define TRACE_MHP_ACPI_READ_PXM_ENABLED 1
#define TRACE_MHP_ACPI_READ_FLAGS_ENABLED 1
#define TRACE_MHP_ACPI_WRITE_SLOT_ENABLED 1
#define TRACE_MHP_ACPI_WRITE_OST_EV_ENABLED 1
#define TRACE_MHP_ACPI_WRITE_OST_STATUS_ENABLED 1
#define TRACE_MHP_ACPI_CLEAR_INSERT_EVT_ENABLED 1
#define TRACE_MHP_ACPI_CLEAR_REMOVE_EVT_ENABLED 1
#define TRACE_MHP_ACPI_PC_DIMM_DELETED_ENABLED 1
#define TRACE_MHP_ACPI_PC_DIMM_DELETE_FAILED_ENABLED 1
#define TRACE_ACPI_GPE_EN_IOPORT_READB_ENABLED 1
#define TRACE_ACPI_GPE_EN_IOPORT_WRITEB_ENABLED 1
#define TRACE_ACPI_GPE_STS_IOPORT_READB_ENABLED 1
#define TRACE_ACPI_GPE_STS_IOPORT_WRITEB_ENABLED 1
#define TRACE_CPUHP_ACPI_INVALID_IDX_SELECTED_ENABLED 1
#define TRACE_CPUHP_ACPI_READ_FLAGS_ENABLED 1
#define TRACE_CPUHP_ACPI_WRITE_IDX_ENABLED 1
#define TRACE_CPUHP_ACPI_WRITE_CMD_ENABLED 1
#define TRACE_CPUHP_ACPI_READ_CMD_DATA_ENABLED 1
#define TRACE_CPUHP_ACPI_READ_CMD_DATA2_ENABLED 1
#define TRACE_CPUHP_ACPI_CPU_HAS_EVENTS_ENABLED 1
#define TRACE_CPUHP_ACPI_CLEAR_INSERTING_EVT_ENABLED 1
#define TRACE_CPUHP_ACPI_CLEAR_REMOVE_EVT_ENABLED 1
#define TRACE_CPUHP_ACPI_EJECTING_INVALID_CPU_ENABLED 1
#define TRACE_CPUHP_ACPI_EJECTING_CPU_ENABLED 1
#define TRACE_CPUHP_ACPI_FW_REMOVE_INVALID_CPU_ENABLED 1
#define TRACE_CPUHP_ACPI_FW_REMOVE_CPU_ENABLED 1
#define TRACE_CPUHP_ACPI_WRITE_OST_EV_ENABLED 1
#define TRACE_CPUHP_ACPI_WRITE_OST_STATUS_ENABLED 1
#define TRACE_ACPI_PCI_EJECT_SLOT_ENABLED 1
#define TRACE_ACPI_PCI_UNPLUG_ENABLED 1
#define TRACE_ACPI_PCI_UNPLUG_REQUEST_ENABLED 1
#define TRACE_ACPI_PCI_UP_READ_ENABLED 1
#define TRACE_ACPI_PCI_DOWN_READ_ENABLED 1
#define TRACE_ACPI_PCI_FEATURES_READ_ENABLED 1
#define TRACE_ACPI_PCI_ACPI_INDEX_READ_ENABLED 1
#define TRACE_ACPI_PCI_ACPI_INDEX_WRITE_ENABLED 1
#define TRACE_ACPI_PCI_RMV_READ_ENABLED 1
#define TRACE_ACPI_PCI_SEL_READ_ENABLED 1
#define TRACE_ACPI_PCI_EJ_WRITE_ENABLED 1
#define TRACE_ACPI_PCI_SEL_WRITE_ENABLED 1
#define TRACE_TCO_TIMER_RELOAD_ENABLED 1
#define TRACE_TCO_TIMER_EXPIRED_ENABLED 1
#define TRACE_TCO_IO_WRITE_ENABLED 1
#define TRACE_TCO_IO_READ_ENABLED 1
#define TRACE_ACPI_ERST_REG_WRITE_ENABLED 1
#define TRACE_ACPI_ERST_REG_READ_ENABLED 1
#define TRACE_ACPI_ERST_MEM_WRITE_ENABLED 1
#define TRACE_ACPI_ERST_MEM_READ_ENABLED 1
#define TRACE_ACPI_ERST_PCI_BAR_0_ENABLED 1
#define TRACE_ACPI_ERST_PCI_BAR_1_ENABLED 1
#define TRACE_ACPI_ERST_REALIZEFN_IN_ENABLED 1
#define TRACE_ACPI_ERST_REALIZEFN_OUT_ENABLED 1
#define TRACE_ACPI_ERST_RESET_IN_ENABLED 1
#define TRACE_ACPI_ERST_RESET_OUT_ENABLED 1
#define TRACE_ACPI_ERST_POST_LOAD_ENABLED 1
#define TRACE_ACPI_ERST_CLASS_INIT_IN_ENABLED 1
#define TRACE_ACPI_ERST_CLASS_INIT_OUT_ENABLED 1
#define TRACE_ACPI_NVDIMM_READ_FIT_ENABLED 1
#define TRACE_ACPI_NVDIMM_LABEL_INFO_ENABLED 1
#define TRACE_ACPI_NVDIMM_LABEL_OVERFLOW_ENABLED 1
#define TRACE_ACPI_NVDIMM_LABEL_OVERSIZE_ENABLED 1
#define TRACE_ACPI_NVDIMM_LABEL_XFER_EXCEED_ENABLED 1
#define TRACE_ACPI_NVDIMM_READ_LABEL_ENABLED 1
#define TRACE_ACPI_NVDIMM_WRITE_LABEL_ENABLED 1
#define TRACE_ACPI_NVDIMM_READ_IO_PORT_ENABLED 1
#define TRACE_ACPI_NVDIMM_DSM_MEM_ADDR_ENABLED 1
#define TRACE_ACPI_NVDIMM_DSM_INFO_ENABLED 1
#define TRACE_ACPI_NVDIMM_INVALID_REVISION_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_MHP_ACPI_INVALID_SLOT_SELECTED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MHP_ACPI_INVALID_SLOT_SELECTED) || \
    false)

static inline void _nocheck__trace_mhp_acpi_invalid_slot_selected(uint32_t slot)
{
    if (trace_event_get_state(TRACE_MHP_ACPI_INVALID_SLOT_SELECTED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 4 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:mhp_acpi_invalid_slot_selected " "0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slot);
#line 250 "trace/trace-hw_acpi.h"
        } else {
#line 4 "../hw/acpi/trace-events"
            qemu_log("mhp_acpi_invalid_slot_selected " "0x%"PRIx32 "\n", slot);
#line 254 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_mhp_acpi_invalid_slot_selected(uint32_t slot)
{
    if (true) {
        _nocheck__trace_mhp_acpi_invalid_slot_selected(slot);
    }
}

#define TRACE_MHP_ACPI_EJECTING_INVALID_SLOT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MHP_ACPI_EJECTING_INVALID_SLOT) || \
    false)

static inline void _nocheck__trace_mhp_acpi_ejecting_invalid_slot(uint32_t slot)
{
    if (trace_event_get_state(TRACE_MHP_ACPI_EJECTING_INVALID_SLOT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 5 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:mhp_acpi_ejecting_invalid_slot " "0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slot);
#line 281 "trace/trace-hw_acpi.h"
        } else {
#line 5 "../hw/acpi/trace-events"
            qemu_log("mhp_acpi_ejecting_invalid_slot " "0x%"PRIx32 "\n", slot);
#line 285 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_mhp_acpi_ejecting_invalid_slot(uint32_t slot)
{
    if (true) {
        _nocheck__trace_mhp_acpi_ejecting_invalid_slot(slot);
    }
}

#define TRACE_MHP_ACPI_READ_ADDR_LO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MHP_ACPI_READ_ADDR_LO) || \
    false)

static inline void _nocheck__trace_mhp_acpi_read_addr_lo(uint32_t slot, uint32_t addr)
{
    if (trace_event_get_state(TRACE_MHP_ACPI_READ_ADDR_LO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 6 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:mhp_acpi_read_addr_lo " "slot[0x%"PRIx32"] addr lo: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slot, addr);
#line 312 "trace/trace-hw_acpi.h"
        } else {
#line 6 "../hw/acpi/trace-events"
            qemu_log("mhp_acpi_read_addr_lo " "slot[0x%"PRIx32"] addr lo: 0x%"PRIx32 "\n", slot, addr);
#line 316 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_mhp_acpi_read_addr_lo(uint32_t slot, uint32_t addr)
{
    if (true) {
        _nocheck__trace_mhp_acpi_read_addr_lo(slot, addr);
    }
}

#define TRACE_MHP_ACPI_READ_ADDR_HI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MHP_ACPI_READ_ADDR_HI) || \
    false)

static inline void _nocheck__trace_mhp_acpi_read_addr_hi(uint32_t slot, uint32_t addr)
{
    if (trace_event_get_state(TRACE_MHP_ACPI_READ_ADDR_HI) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 7 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:mhp_acpi_read_addr_hi " "slot[0x%"PRIx32"] addr hi: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slot, addr);
#line 343 "trace/trace-hw_acpi.h"
        } else {
#line 7 "../hw/acpi/trace-events"
            qemu_log("mhp_acpi_read_addr_hi " "slot[0x%"PRIx32"] addr hi: 0x%"PRIx32 "\n", slot, addr);
#line 347 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_mhp_acpi_read_addr_hi(uint32_t slot, uint32_t addr)
{
    if (true) {
        _nocheck__trace_mhp_acpi_read_addr_hi(slot, addr);
    }
}

#define TRACE_MHP_ACPI_READ_SIZE_LO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MHP_ACPI_READ_SIZE_LO) || \
    false)

static inline void _nocheck__trace_mhp_acpi_read_size_lo(uint32_t slot, uint32_t size)
{
    if (trace_event_get_state(TRACE_MHP_ACPI_READ_SIZE_LO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 8 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:mhp_acpi_read_size_lo " "slot[0x%"PRIx32"] size lo: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slot, size);
#line 374 "trace/trace-hw_acpi.h"
        } else {
#line 8 "../hw/acpi/trace-events"
            qemu_log("mhp_acpi_read_size_lo " "slot[0x%"PRIx32"] size lo: 0x%"PRIx32 "\n", slot, size);
#line 378 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_mhp_acpi_read_size_lo(uint32_t slot, uint32_t size)
{
    if (true) {
        _nocheck__trace_mhp_acpi_read_size_lo(slot, size);
    }
}

#define TRACE_MHP_ACPI_READ_SIZE_HI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MHP_ACPI_READ_SIZE_HI) || \
    false)

static inline void _nocheck__trace_mhp_acpi_read_size_hi(uint32_t slot, uint32_t size)
{
    if (trace_event_get_state(TRACE_MHP_ACPI_READ_SIZE_HI) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 9 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:mhp_acpi_read_size_hi " "slot[0x%"PRIx32"] size hi: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slot, size);
#line 405 "trace/trace-hw_acpi.h"
        } else {
#line 9 "../hw/acpi/trace-events"
            qemu_log("mhp_acpi_read_size_hi " "slot[0x%"PRIx32"] size hi: 0x%"PRIx32 "\n", slot, size);
#line 409 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_mhp_acpi_read_size_hi(uint32_t slot, uint32_t size)
{
    if (true) {
        _nocheck__trace_mhp_acpi_read_size_hi(slot, size);
    }
}

#define TRACE_MHP_ACPI_READ_PXM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MHP_ACPI_READ_PXM) || \
    false)

static inline void _nocheck__trace_mhp_acpi_read_pxm(uint32_t slot, uint32_t pxm)
{
    if (trace_event_get_state(TRACE_MHP_ACPI_READ_PXM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 10 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:mhp_acpi_read_pxm " "slot[0x%"PRIx32"] proximity: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slot, pxm);
#line 436 "trace/trace-hw_acpi.h"
        } else {
#line 10 "../hw/acpi/trace-events"
            qemu_log("mhp_acpi_read_pxm " "slot[0x%"PRIx32"] proximity: 0x%"PRIx32 "\n", slot, pxm);
#line 440 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_mhp_acpi_read_pxm(uint32_t slot, uint32_t pxm)
{
    if (true) {
        _nocheck__trace_mhp_acpi_read_pxm(slot, pxm);
    }
}

#define TRACE_MHP_ACPI_READ_FLAGS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MHP_ACPI_READ_FLAGS) || \
    false)

static inline void _nocheck__trace_mhp_acpi_read_flags(uint32_t slot, uint32_t flags)
{
    if (trace_event_get_state(TRACE_MHP_ACPI_READ_FLAGS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 11 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:mhp_acpi_read_flags " "slot[0x%"PRIx32"] flags: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slot, flags);
#line 467 "trace/trace-hw_acpi.h"
        } else {
#line 11 "../hw/acpi/trace-events"
            qemu_log("mhp_acpi_read_flags " "slot[0x%"PRIx32"] flags: 0x%"PRIx32 "\n", slot, flags);
#line 471 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_mhp_acpi_read_flags(uint32_t slot, uint32_t flags)
{
    if (true) {
        _nocheck__trace_mhp_acpi_read_flags(slot, flags);
    }
}

#define TRACE_MHP_ACPI_WRITE_SLOT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MHP_ACPI_WRITE_SLOT) || \
    false)

static inline void _nocheck__trace_mhp_acpi_write_slot(uint32_t slot)
{
    if (trace_event_get_state(TRACE_MHP_ACPI_WRITE_SLOT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 12 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:mhp_acpi_write_slot " "set active slot: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slot);
#line 498 "trace/trace-hw_acpi.h"
        } else {
#line 12 "../hw/acpi/trace-events"
            qemu_log("mhp_acpi_write_slot " "set active slot: 0x%"PRIx32 "\n", slot);
#line 502 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_mhp_acpi_write_slot(uint32_t slot)
{
    if (true) {
        _nocheck__trace_mhp_acpi_write_slot(slot);
    }
}

#define TRACE_MHP_ACPI_WRITE_OST_EV_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MHP_ACPI_WRITE_OST_EV) || \
    false)

static inline void _nocheck__trace_mhp_acpi_write_ost_ev(uint32_t slot, uint32_t ev)
{
    if (trace_event_get_state(TRACE_MHP_ACPI_WRITE_OST_EV) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 13 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:mhp_acpi_write_ost_ev " "slot[0x%"PRIx32"] OST EVENT: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slot, ev);
#line 529 "trace/trace-hw_acpi.h"
        } else {
#line 13 "../hw/acpi/trace-events"
            qemu_log("mhp_acpi_write_ost_ev " "slot[0x%"PRIx32"] OST EVENT: 0x%"PRIx32 "\n", slot, ev);
#line 533 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_mhp_acpi_write_ost_ev(uint32_t slot, uint32_t ev)
{
    if (true) {
        _nocheck__trace_mhp_acpi_write_ost_ev(slot, ev);
    }
}

#define TRACE_MHP_ACPI_WRITE_OST_STATUS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MHP_ACPI_WRITE_OST_STATUS) || \
    false)

static inline void _nocheck__trace_mhp_acpi_write_ost_status(uint32_t slot, uint32_t st)
{
    if (trace_event_get_state(TRACE_MHP_ACPI_WRITE_OST_STATUS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 14 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:mhp_acpi_write_ost_status " "slot[0x%"PRIx32"] OST STATUS: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slot, st);
#line 560 "trace/trace-hw_acpi.h"
        } else {
#line 14 "../hw/acpi/trace-events"
            qemu_log("mhp_acpi_write_ost_status " "slot[0x%"PRIx32"] OST STATUS: 0x%"PRIx32 "\n", slot, st);
#line 564 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_mhp_acpi_write_ost_status(uint32_t slot, uint32_t st)
{
    if (true) {
        _nocheck__trace_mhp_acpi_write_ost_status(slot, st);
    }
}

#define TRACE_MHP_ACPI_CLEAR_INSERT_EVT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MHP_ACPI_CLEAR_INSERT_EVT) || \
    false)

static inline void _nocheck__trace_mhp_acpi_clear_insert_evt(uint32_t slot)
{
    if (trace_event_get_state(TRACE_MHP_ACPI_CLEAR_INSERT_EVT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 15 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:mhp_acpi_clear_insert_evt " "slot[0x%"PRIx32"] clear insert event" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slot);
#line 591 "trace/trace-hw_acpi.h"
        } else {
#line 15 "../hw/acpi/trace-events"
            qemu_log("mhp_acpi_clear_insert_evt " "slot[0x%"PRIx32"] clear insert event" "\n", slot);
#line 595 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_mhp_acpi_clear_insert_evt(uint32_t slot)
{
    if (true) {
        _nocheck__trace_mhp_acpi_clear_insert_evt(slot);
    }
}

#define TRACE_MHP_ACPI_CLEAR_REMOVE_EVT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MHP_ACPI_CLEAR_REMOVE_EVT) || \
    false)

static inline void _nocheck__trace_mhp_acpi_clear_remove_evt(uint32_t slot)
{
    if (trace_event_get_state(TRACE_MHP_ACPI_CLEAR_REMOVE_EVT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 16 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:mhp_acpi_clear_remove_evt " "slot[0x%"PRIx32"] clear remove event" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slot);
#line 622 "trace/trace-hw_acpi.h"
        } else {
#line 16 "../hw/acpi/trace-events"
            qemu_log("mhp_acpi_clear_remove_evt " "slot[0x%"PRIx32"] clear remove event" "\n", slot);
#line 626 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_mhp_acpi_clear_remove_evt(uint32_t slot)
{
    if (true) {
        _nocheck__trace_mhp_acpi_clear_remove_evt(slot);
    }
}

#define TRACE_MHP_ACPI_PC_DIMM_DELETED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MHP_ACPI_PC_DIMM_DELETED) || \
    false)

static inline void _nocheck__trace_mhp_acpi_pc_dimm_deleted(uint32_t slot)
{
    if (trace_event_get_state(TRACE_MHP_ACPI_PC_DIMM_DELETED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 17 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:mhp_acpi_pc_dimm_deleted " "slot[0x%"PRIx32"] pc-dimm deleted" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slot);
#line 653 "trace/trace-hw_acpi.h"
        } else {
#line 17 "../hw/acpi/trace-events"
            qemu_log("mhp_acpi_pc_dimm_deleted " "slot[0x%"PRIx32"] pc-dimm deleted" "\n", slot);
#line 657 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_mhp_acpi_pc_dimm_deleted(uint32_t slot)
{
    if (true) {
        _nocheck__trace_mhp_acpi_pc_dimm_deleted(slot);
    }
}

#define TRACE_MHP_ACPI_PC_DIMM_DELETE_FAILED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MHP_ACPI_PC_DIMM_DELETE_FAILED) || \
    false)

static inline void _nocheck__trace_mhp_acpi_pc_dimm_delete_failed(uint32_t slot)
{
    if (trace_event_get_state(TRACE_MHP_ACPI_PC_DIMM_DELETE_FAILED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 18 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:mhp_acpi_pc_dimm_delete_failed " "slot[0x%"PRIx32"] pc-dimm delete failed" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slot);
#line 684 "trace/trace-hw_acpi.h"
        } else {
#line 18 "../hw/acpi/trace-events"
            qemu_log("mhp_acpi_pc_dimm_delete_failed " "slot[0x%"PRIx32"] pc-dimm delete failed" "\n", slot);
#line 688 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_mhp_acpi_pc_dimm_delete_failed(uint32_t slot)
{
    if (true) {
        _nocheck__trace_mhp_acpi_pc_dimm_delete_failed(slot);
    }
}

#define TRACE_ACPI_GPE_EN_IOPORT_READB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_GPE_EN_IOPORT_READB) || \
    false)

static inline void _nocheck__trace_acpi_gpe_en_ioport_readb(uint32_t addr, uint8_t val)
{
    if (trace_event_get_state(TRACE_ACPI_GPE_EN_IOPORT_READB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 21 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_gpe_en_ioport_readb " "addr: 0x%" PRIx32 " ==> 0x%02" PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 715 "trace/trace-hw_acpi.h"
        } else {
#line 21 "../hw/acpi/trace-events"
            qemu_log("acpi_gpe_en_ioport_readb " "addr: 0x%" PRIx32 " ==> 0x%02" PRIx8 "\n", addr, val);
#line 719 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_gpe_en_ioport_readb(uint32_t addr, uint8_t val)
{
    if (true) {
        _nocheck__trace_acpi_gpe_en_ioport_readb(addr, val);
    }
}

#define TRACE_ACPI_GPE_EN_IOPORT_WRITEB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_GPE_EN_IOPORT_WRITEB) || \
    false)

static inline void _nocheck__trace_acpi_gpe_en_ioport_writeb(uint32_t addr, uint8_t val)
{
    if (trace_event_get_state(TRACE_ACPI_GPE_EN_IOPORT_WRITEB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 22 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_gpe_en_ioport_writeb " "addr: 0x%" PRIx32 " <== 0x%02" PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 746 "trace/trace-hw_acpi.h"
        } else {
#line 22 "../hw/acpi/trace-events"
            qemu_log("acpi_gpe_en_ioport_writeb " "addr: 0x%" PRIx32 " <== 0x%02" PRIx8 "\n", addr, val);
#line 750 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_gpe_en_ioport_writeb(uint32_t addr, uint8_t val)
{
    if (true) {
        _nocheck__trace_acpi_gpe_en_ioport_writeb(addr, val);
    }
}

#define TRACE_ACPI_GPE_STS_IOPORT_READB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_GPE_STS_IOPORT_READB) || \
    false)

static inline void _nocheck__trace_acpi_gpe_sts_ioport_readb(uint32_t addr, uint8_t val)
{
    if (trace_event_get_state(TRACE_ACPI_GPE_STS_IOPORT_READB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 23 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_gpe_sts_ioport_readb " "addr: 0x%" PRIx32 " ==> 0x%02" PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 777 "trace/trace-hw_acpi.h"
        } else {
#line 23 "../hw/acpi/trace-events"
            qemu_log("acpi_gpe_sts_ioport_readb " "addr: 0x%" PRIx32 " ==> 0x%02" PRIx8 "\n", addr, val);
#line 781 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_gpe_sts_ioport_readb(uint32_t addr, uint8_t val)
{
    if (true) {
        _nocheck__trace_acpi_gpe_sts_ioport_readb(addr, val);
    }
}

#define TRACE_ACPI_GPE_STS_IOPORT_WRITEB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_GPE_STS_IOPORT_WRITEB) || \
    false)

static inline void _nocheck__trace_acpi_gpe_sts_ioport_writeb(uint32_t addr, uint8_t val)
{
    if (trace_event_get_state(TRACE_ACPI_GPE_STS_IOPORT_WRITEB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 24 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_gpe_sts_ioport_writeb " "addr: 0x%" PRIx32 " <== 0x%02" PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 808 "trace/trace-hw_acpi.h"
        } else {
#line 24 "../hw/acpi/trace-events"
            qemu_log("acpi_gpe_sts_ioport_writeb " "addr: 0x%" PRIx32 " <== 0x%02" PRIx8 "\n", addr, val);
#line 812 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_gpe_sts_ioport_writeb(uint32_t addr, uint8_t val)
{
    if (true) {
        _nocheck__trace_acpi_gpe_sts_ioport_writeb(addr, val);
    }
}

#define TRACE_CPUHP_ACPI_INVALID_IDX_SELECTED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPUHP_ACPI_INVALID_IDX_SELECTED) || \
    false)

static inline void _nocheck__trace_cpuhp_acpi_invalid_idx_selected(uint32_t idx)
{
    if (trace_event_get_state(TRACE_CPUHP_ACPI_INVALID_IDX_SELECTED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 27 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:cpuhp_acpi_invalid_idx_selected " "0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , idx);
#line 839 "trace/trace-hw_acpi.h"
        } else {
#line 27 "../hw/acpi/trace-events"
            qemu_log("cpuhp_acpi_invalid_idx_selected " "0x%"PRIx32 "\n", idx);
#line 843 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_cpuhp_acpi_invalid_idx_selected(uint32_t idx)
{
    if (true) {
        _nocheck__trace_cpuhp_acpi_invalid_idx_selected(idx);
    }
}

#define TRACE_CPUHP_ACPI_READ_FLAGS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPUHP_ACPI_READ_FLAGS) || \
    false)

static inline void _nocheck__trace_cpuhp_acpi_read_flags(uint32_t idx, uint8_t flags)
{
    if (trace_event_get_state(TRACE_CPUHP_ACPI_READ_FLAGS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 28 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:cpuhp_acpi_read_flags " "idx[0x%"PRIx32"] flags: 0x%"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , idx, flags);
#line 870 "trace/trace-hw_acpi.h"
        } else {
#line 28 "../hw/acpi/trace-events"
            qemu_log("cpuhp_acpi_read_flags " "idx[0x%"PRIx32"] flags: 0x%"PRIx8 "\n", idx, flags);
#line 874 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_cpuhp_acpi_read_flags(uint32_t idx, uint8_t flags)
{
    if (true) {
        _nocheck__trace_cpuhp_acpi_read_flags(idx, flags);
    }
}

#define TRACE_CPUHP_ACPI_WRITE_IDX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPUHP_ACPI_WRITE_IDX) || \
    false)

static inline void _nocheck__trace_cpuhp_acpi_write_idx(uint32_t idx)
{
    if (trace_event_get_state(TRACE_CPUHP_ACPI_WRITE_IDX) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 29 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:cpuhp_acpi_write_idx " "set active cpu idx: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , idx);
#line 901 "trace/trace-hw_acpi.h"
        } else {
#line 29 "../hw/acpi/trace-events"
            qemu_log("cpuhp_acpi_write_idx " "set active cpu idx: 0x%"PRIx32 "\n", idx);
#line 905 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_cpuhp_acpi_write_idx(uint32_t idx)
{
    if (true) {
        _nocheck__trace_cpuhp_acpi_write_idx(idx);
    }
}

#define TRACE_CPUHP_ACPI_WRITE_CMD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPUHP_ACPI_WRITE_CMD) || \
    false)

static inline void _nocheck__trace_cpuhp_acpi_write_cmd(uint32_t idx, uint8_t cmd)
{
    if (trace_event_get_state(TRACE_CPUHP_ACPI_WRITE_CMD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 30 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:cpuhp_acpi_write_cmd " "idx[0x%"PRIx32"] cmd: 0x%"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , idx, cmd);
#line 932 "trace/trace-hw_acpi.h"
        } else {
#line 30 "../hw/acpi/trace-events"
            qemu_log("cpuhp_acpi_write_cmd " "idx[0x%"PRIx32"] cmd: 0x%"PRIx8 "\n", idx, cmd);
#line 936 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_cpuhp_acpi_write_cmd(uint32_t idx, uint8_t cmd)
{
    if (true) {
        _nocheck__trace_cpuhp_acpi_write_cmd(idx, cmd);
    }
}

#define TRACE_CPUHP_ACPI_READ_CMD_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPUHP_ACPI_READ_CMD_DATA) || \
    false)

static inline void _nocheck__trace_cpuhp_acpi_read_cmd_data(uint32_t idx, uint32_t data)
{
    if (trace_event_get_state(TRACE_CPUHP_ACPI_READ_CMD_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 31 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:cpuhp_acpi_read_cmd_data " "idx[0x%"PRIx32"] data: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , idx, data);
#line 963 "trace/trace-hw_acpi.h"
        } else {
#line 31 "../hw/acpi/trace-events"
            qemu_log("cpuhp_acpi_read_cmd_data " "idx[0x%"PRIx32"] data: 0x%"PRIx32 "\n", idx, data);
#line 967 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_cpuhp_acpi_read_cmd_data(uint32_t idx, uint32_t data)
{
    if (true) {
        _nocheck__trace_cpuhp_acpi_read_cmd_data(idx, data);
    }
}

#define TRACE_CPUHP_ACPI_READ_CMD_DATA2_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPUHP_ACPI_READ_CMD_DATA2) || \
    false)

static inline void _nocheck__trace_cpuhp_acpi_read_cmd_data2(uint32_t idx, uint32_t data)
{
    if (trace_event_get_state(TRACE_CPUHP_ACPI_READ_CMD_DATA2) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 32 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:cpuhp_acpi_read_cmd_data2 " "idx[0x%"PRIx32"] data: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , idx, data);
#line 994 "trace/trace-hw_acpi.h"
        } else {
#line 32 "../hw/acpi/trace-events"
            qemu_log("cpuhp_acpi_read_cmd_data2 " "idx[0x%"PRIx32"] data: 0x%"PRIx32 "\n", idx, data);
#line 998 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_cpuhp_acpi_read_cmd_data2(uint32_t idx, uint32_t data)
{
    if (true) {
        _nocheck__trace_cpuhp_acpi_read_cmd_data2(idx, data);
    }
}

#define TRACE_CPUHP_ACPI_CPU_HAS_EVENTS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPUHP_ACPI_CPU_HAS_EVENTS) || \
    false)

static inline void _nocheck__trace_cpuhp_acpi_cpu_has_events(uint32_t idx, bool ins, bool rm)
{
    if (trace_event_get_state(TRACE_CPUHP_ACPI_CPU_HAS_EVENTS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 33 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:cpuhp_acpi_cpu_has_events " "idx[0x%"PRIx32"] inserting: %d, removing: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , idx, ins, rm);
#line 1025 "trace/trace-hw_acpi.h"
        } else {
#line 33 "../hw/acpi/trace-events"
            qemu_log("cpuhp_acpi_cpu_has_events " "idx[0x%"PRIx32"] inserting: %d, removing: %d" "\n", idx, ins, rm);
#line 1029 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_cpuhp_acpi_cpu_has_events(uint32_t idx, bool ins, bool rm)
{
    if (true) {
        _nocheck__trace_cpuhp_acpi_cpu_has_events(idx, ins, rm);
    }
}

#define TRACE_CPUHP_ACPI_CLEAR_INSERTING_EVT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPUHP_ACPI_CLEAR_INSERTING_EVT) || \
    false)

static inline void _nocheck__trace_cpuhp_acpi_clear_inserting_evt(uint32_t idx)
{
    if (trace_event_get_state(TRACE_CPUHP_ACPI_CLEAR_INSERTING_EVT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 34 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:cpuhp_acpi_clear_inserting_evt " "idx[0x%"PRIx32"]" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , idx);
#line 1056 "trace/trace-hw_acpi.h"
        } else {
#line 34 "../hw/acpi/trace-events"
            qemu_log("cpuhp_acpi_clear_inserting_evt " "idx[0x%"PRIx32"]" "\n", idx);
#line 1060 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_cpuhp_acpi_clear_inserting_evt(uint32_t idx)
{
    if (true) {
        _nocheck__trace_cpuhp_acpi_clear_inserting_evt(idx);
    }
}

#define TRACE_CPUHP_ACPI_CLEAR_REMOVE_EVT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPUHP_ACPI_CLEAR_REMOVE_EVT) || \
    false)

static inline void _nocheck__trace_cpuhp_acpi_clear_remove_evt(uint32_t idx)
{
    if (trace_event_get_state(TRACE_CPUHP_ACPI_CLEAR_REMOVE_EVT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 35 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:cpuhp_acpi_clear_remove_evt " "idx[0x%"PRIx32"]" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , idx);
#line 1087 "trace/trace-hw_acpi.h"
        } else {
#line 35 "../hw/acpi/trace-events"
            qemu_log("cpuhp_acpi_clear_remove_evt " "idx[0x%"PRIx32"]" "\n", idx);
#line 1091 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_cpuhp_acpi_clear_remove_evt(uint32_t idx)
{
    if (true) {
        _nocheck__trace_cpuhp_acpi_clear_remove_evt(idx);
    }
}

#define TRACE_CPUHP_ACPI_EJECTING_INVALID_CPU_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPUHP_ACPI_EJECTING_INVALID_CPU) || \
    false)

static inline void _nocheck__trace_cpuhp_acpi_ejecting_invalid_cpu(uint32_t idx)
{
    if (trace_event_get_state(TRACE_CPUHP_ACPI_EJECTING_INVALID_CPU) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 36 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:cpuhp_acpi_ejecting_invalid_cpu " "0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , idx);
#line 1118 "trace/trace-hw_acpi.h"
        } else {
#line 36 "../hw/acpi/trace-events"
            qemu_log("cpuhp_acpi_ejecting_invalid_cpu " "0x%"PRIx32 "\n", idx);
#line 1122 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_cpuhp_acpi_ejecting_invalid_cpu(uint32_t idx)
{
    if (true) {
        _nocheck__trace_cpuhp_acpi_ejecting_invalid_cpu(idx);
    }
}

#define TRACE_CPUHP_ACPI_EJECTING_CPU_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPUHP_ACPI_EJECTING_CPU) || \
    false)

static inline void _nocheck__trace_cpuhp_acpi_ejecting_cpu(uint32_t idx)
{
    if (trace_event_get_state(TRACE_CPUHP_ACPI_EJECTING_CPU) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 37 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:cpuhp_acpi_ejecting_cpu " "0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , idx);
#line 1149 "trace/trace-hw_acpi.h"
        } else {
#line 37 "../hw/acpi/trace-events"
            qemu_log("cpuhp_acpi_ejecting_cpu " "0x%"PRIx32 "\n", idx);
#line 1153 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_cpuhp_acpi_ejecting_cpu(uint32_t idx)
{
    if (true) {
        _nocheck__trace_cpuhp_acpi_ejecting_cpu(idx);
    }
}

#define TRACE_CPUHP_ACPI_FW_REMOVE_INVALID_CPU_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPUHP_ACPI_FW_REMOVE_INVALID_CPU) || \
    false)

static inline void _nocheck__trace_cpuhp_acpi_fw_remove_invalid_cpu(uint32_t idx)
{
    if (trace_event_get_state(TRACE_CPUHP_ACPI_FW_REMOVE_INVALID_CPU) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 38 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:cpuhp_acpi_fw_remove_invalid_cpu " "0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , idx);
#line 1180 "trace/trace-hw_acpi.h"
        } else {
#line 38 "../hw/acpi/trace-events"
            qemu_log("cpuhp_acpi_fw_remove_invalid_cpu " "0x%"PRIx32 "\n", idx);
#line 1184 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_cpuhp_acpi_fw_remove_invalid_cpu(uint32_t idx)
{
    if (true) {
        _nocheck__trace_cpuhp_acpi_fw_remove_invalid_cpu(idx);
    }
}

#define TRACE_CPUHP_ACPI_FW_REMOVE_CPU_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPUHP_ACPI_FW_REMOVE_CPU) || \
    false)

static inline void _nocheck__trace_cpuhp_acpi_fw_remove_cpu(uint32_t idx)
{
    if (trace_event_get_state(TRACE_CPUHP_ACPI_FW_REMOVE_CPU) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 39 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:cpuhp_acpi_fw_remove_cpu " "0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , idx);
#line 1211 "trace/trace-hw_acpi.h"
        } else {
#line 39 "../hw/acpi/trace-events"
            qemu_log("cpuhp_acpi_fw_remove_cpu " "0x%"PRIx32 "\n", idx);
#line 1215 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_cpuhp_acpi_fw_remove_cpu(uint32_t idx)
{
    if (true) {
        _nocheck__trace_cpuhp_acpi_fw_remove_cpu(idx);
    }
}

#define TRACE_CPUHP_ACPI_WRITE_OST_EV_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPUHP_ACPI_WRITE_OST_EV) || \
    false)

static inline void _nocheck__trace_cpuhp_acpi_write_ost_ev(uint32_t slot, uint32_t ev)
{
    if (trace_event_get_state(TRACE_CPUHP_ACPI_WRITE_OST_EV) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 40 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:cpuhp_acpi_write_ost_ev " "idx[0x%"PRIx32"] OST EVENT: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slot, ev);
#line 1242 "trace/trace-hw_acpi.h"
        } else {
#line 40 "../hw/acpi/trace-events"
            qemu_log("cpuhp_acpi_write_ost_ev " "idx[0x%"PRIx32"] OST EVENT: 0x%"PRIx32 "\n", slot, ev);
#line 1246 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_cpuhp_acpi_write_ost_ev(uint32_t slot, uint32_t ev)
{
    if (true) {
        _nocheck__trace_cpuhp_acpi_write_ost_ev(slot, ev);
    }
}

#define TRACE_CPUHP_ACPI_WRITE_OST_STATUS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPUHP_ACPI_WRITE_OST_STATUS) || \
    false)

static inline void _nocheck__trace_cpuhp_acpi_write_ost_status(uint32_t slot, uint32_t st)
{
    if (trace_event_get_state(TRACE_CPUHP_ACPI_WRITE_OST_STATUS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 41 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:cpuhp_acpi_write_ost_status " "idx[0x%"PRIx32"] OST STATUS: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slot, st);
#line 1273 "trace/trace-hw_acpi.h"
        } else {
#line 41 "../hw/acpi/trace-events"
            qemu_log("cpuhp_acpi_write_ost_status " "idx[0x%"PRIx32"] OST STATUS: 0x%"PRIx32 "\n", slot, st);
#line 1277 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_cpuhp_acpi_write_ost_status(uint32_t slot, uint32_t st)
{
    if (true) {
        _nocheck__trace_cpuhp_acpi_write_ost_status(slot, st);
    }
}

#define TRACE_ACPI_PCI_EJECT_SLOT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_PCI_EJECT_SLOT) || \
    false)

static inline void _nocheck__trace_acpi_pci_eject_slot(unsigned bsel, unsigned slot)
{
    if (trace_event_get_state(TRACE_ACPI_PCI_EJECT_SLOT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 44 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_pci_eject_slot " "bsel: %u slot: %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bsel, slot);
#line 1304 "trace/trace-hw_acpi.h"
        } else {
#line 44 "../hw/acpi/trace-events"
            qemu_log("acpi_pci_eject_slot " "bsel: %u slot: %u" "\n", bsel, slot);
#line 1308 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_pci_eject_slot(unsigned bsel, unsigned slot)
{
    if (true) {
        _nocheck__trace_acpi_pci_eject_slot(bsel, slot);
    }
}

#define TRACE_ACPI_PCI_UNPLUG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_PCI_UNPLUG) || \
    false)

static inline void _nocheck__trace_acpi_pci_unplug(int bsel, int slot)
{
    if (trace_event_get_state(TRACE_ACPI_PCI_UNPLUG) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 45 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_pci_unplug " "bsel: %d slot: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bsel, slot);
#line 1335 "trace/trace-hw_acpi.h"
        } else {
#line 45 "../hw/acpi/trace-events"
            qemu_log("acpi_pci_unplug " "bsel: %d slot: %d" "\n", bsel, slot);
#line 1339 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_pci_unplug(int bsel, int slot)
{
    if (true) {
        _nocheck__trace_acpi_pci_unplug(bsel, slot);
    }
}

#define TRACE_ACPI_PCI_UNPLUG_REQUEST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_PCI_UNPLUG_REQUEST) || \
    false)

static inline void _nocheck__trace_acpi_pci_unplug_request(int bsel, int slot)
{
    if (trace_event_get_state(TRACE_ACPI_PCI_UNPLUG_REQUEST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 46 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_pci_unplug_request " "bsel: %d slot: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bsel, slot);
#line 1366 "trace/trace-hw_acpi.h"
        } else {
#line 46 "../hw/acpi/trace-events"
            qemu_log("acpi_pci_unplug_request " "bsel: %d slot: %d" "\n", bsel, slot);
#line 1370 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_pci_unplug_request(int bsel, int slot)
{
    if (true) {
        _nocheck__trace_acpi_pci_unplug_request(bsel, slot);
    }
}

#define TRACE_ACPI_PCI_UP_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_PCI_UP_READ) || \
    false)

static inline void _nocheck__trace_acpi_pci_up_read(uint32_t val)
{
    if (trace_event_get_state(TRACE_ACPI_PCI_UP_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 47 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_pci_up_read " "%" PRIu32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 1397 "trace/trace-hw_acpi.h"
        } else {
#line 47 "../hw/acpi/trace-events"
            qemu_log("acpi_pci_up_read " "%" PRIu32 "\n", val);
#line 1401 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_pci_up_read(uint32_t val)
{
    if (true) {
        _nocheck__trace_acpi_pci_up_read(val);
    }
}

#define TRACE_ACPI_PCI_DOWN_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_PCI_DOWN_READ) || \
    false)

static inline void _nocheck__trace_acpi_pci_down_read(uint32_t val)
{
    if (trace_event_get_state(TRACE_ACPI_PCI_DOWN_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 48 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_pci_down_read " "%" PRIu32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 1428 "trace/trace-hw_acpi.h"
        } else {
#line 48 "../hw/acpi/trace-events"
            qemu_log("acpi_pci_down_read " "%" PRIu32 "\n", val);
#line 1432 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_pci_down_read(uint32_t val)
{
    if (true) {
        _nocheck__trace_acpi_pci_down_read(val);
    }
}

#define TRACE_ACPI_PCI_FEATURES_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_PCI_FEATURES_READ) || \
    false)

static inline void _nocheck__trace_acpi_pci_features_read(uint32_t val)
{
    if (trace_event_get_state(TRACE_ACPI_PCI_FEATURES_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 49 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_pci_features_read " "%" PRIu32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 1459 "trace/trace-hw_acpi.h"
        } else {
#line 49 "../hw/acpi/trace-events"
            qemu_log("acpi_pci_features_read " "%" PRIu32 "\n", val);
#line 1463 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_pci_features_read(uint32_t val)
{
    if (true) {
        _nocheck__trace_acpi_pci_features_read(val);
    }
}

#define TRACE_ACPI_PCI_ACPI_INDEX_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_PCI_ACPI_INDEX_READ) || \
    false)

static inline void _nocheck__trace_acpi_pci_acpi_index_read(uint32_t val)
{
    if (trace_event_get_state(TRACE_ACPI_PCI_ACPI_INDEX_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 50 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_pci_acpi_index_read " "%" PRIu32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 1490 "trace/trace-hw_acpi.h"
        } else {
#line 50 "../hw/acpi/trace-events"
            qemu_log("acpi_pci_acpi_index_read " "%" PRIu32 "\n", val);
#line 1494 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_pci_acpi_index_read(uint32_t val)
{
    if (true) {
        _nocheck__trace_acpi_pci_acpi_index_read(val);
    }
}

#define TRACE_ACPI_PCI_ACPI_INDEX_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_PCI_ACPI_INDEX_WRITE) || \
    false)

static inline void _nocheck__trace_acpi_pci_acpi_index_write(unsigned bsel, unsigned slot, uint32_t aidx)
{
    if (trace_event_get_state(TRACE_ACPI_PCI_ACPI_INDEX_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 51 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_pci_acpi_index_write " "bsel: %u slot: %u aidx: %" PRIu32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bsel, slot, aidx);
#line 1521 "trace/trace-hw_acpi.h"
        } else {
#line 51 "../hw/acpi/trace-events"
            qemu_log("acpi_pci_acpi_index_write " "bsel: %u slot: %u aidx: %" PRIu32 "\n", bsel, slot, aidx);
#line 1525 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_pci_acpi_index_write(unsigned bsel, unsigned slot, uint32_t aidx)
{
    if (true) {
        _nocheck__trace_acpi_pci_acpi_index_write(bsel, slot, aidx);
    }
}

#define TRACE_ACPI_PCI_RMV_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_PCI_RMV_READ) || \
    false)

static inline void _nocheck__trace_acpi_pci_rmv_read(uint32_t val)
{
    if (trace_event_get_state(TRACE_ACPI_PCI_RMV_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 52 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_pci_rmv_read " "%" PRIu32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 1552 "trace/trace-hw_acpi.h"
        } else {
#line 52 "../hw/acpi/trace-events"
            qemu_log("acpi_pci_rmv_read " "%" PRIu32 "\n", val);
#line 1556 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_pci_rmv_read(uint32_t val)
{
    if (true) {
        _nocheck__trace_acpi_pci_rmv_read(val);
    }
}

#define TRACE_ACPI_PCI_SEL_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_PCI_SEL_READ) || \
    false)

static inline void _nocheck__trace_acpi_pci_sel_read(uint32_t val)
{
    if (trace_event_get_state(TRACE_ACPI_PCI_SEL_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 53 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_pci_sel_read " "%" PRIu32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 1583 "trace/trace-hw_acpi.h"
        } else {
#line 53 "../hw/acpi/trace-events"
            qemu_log("acpi_pci_sel_read " "%" PRIu32 "\n", val);
#line 1587 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_pci_sel_read(uint32_t val)
{
    if (true) {
        _nocheck__trace_acpi_pci_sel_read(val);
    }
}

#define TRACE_ACPI_PCI_EJ_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_PCI_EJ_WRITE) || \
    false)

static inline void _nocheck__trace_acpi_pci_ej_write(uint64_t addr, uint64_t data)
{
    if (trace_event_get_state(TRACE_ACPI_PCI_EJ_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 54 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_pci_ej_write " "0x%" PRIx64 " <== %" PRIu64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, data);
#line 1614 "trace/trace-hw_acpi.h"
        } else {
#line 54 "../hw/acpi/trace-events"
            qemu_log("acpi_pci_ej_write " "0x%" PRIx64 " <== %" PRIu64 "\n", addr, data);
#line 1618 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_pci_ej_write(uint64_t addr, uint64_t data)
{
    if (true) {
        _nocheck__trace_acpi_pci_ej_write(addr, data);
    }
}

#define TRACE_ACPI_PCI_SEL_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_PCI_SEL_WRITE) || \
    false)

static inline void _nocheck__trace_acpi_pci_sel_write(uint64_t addr, uint64_t data)
{
    if (trace_event_get_state(TRACE_ACPI_PCI_SEL_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 55 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_pci_sel_write " "0x%" PRIx64 " <== %" PRIu64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, data);
#line 1645 "trace/trace-hw_acpi.h"
        } else {
#line 55 "../hw/acpi/trace-events"
            qemu_log("acpi_pci_sel_write " "0x%" PRIx64 " <== %" PRIu64 "\n", addr, data);
#line 1649 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_pci_sel_write(uint64_t addr, uint64_t data)
{
    if (true) {
        _nocheck__trace_acpi_pci_sel_write(addr, data);
    }
}

#define TRACE_TCO_TIMER_RELOAD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_TCO_TIMER_RELOAD) || \
    false)

static inline void _nocheck__trace_tco_timer_reload(int ticks, int msec)
{
    if (trace_event_get_state(TRACE_TCO_TIMER_RELOAD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 58 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:tco_timer_reload " "ticks=%d (%d ms)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ticks, msec);
#line 1676 "trace/trace-hw_acpi.h"
        } else {
#line 58 "../hw/acpi/trace-events"
            qemu_log("tco_timer_reload " "ticks=%d (%d ms)" "\n", ticks, msec);
#line 1680 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_tco_timer_reload(int ticks, int msec)
{
    if (true) {
        _nocheck__trace_tco_timer_reload(ticks, msec);
    }
}

#define TRACE_TCO_TIMER_EXPIRED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_TCO_TIMER_EXPIRED) || \
    false)

static inline void _nocheck__trace_tco_timer_expired(int timeouts_no, bool strap, bool no_reboot)
{
    if (trace_event_get_state(TRACE_TCO_TIMER_EXPIRED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 59 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:tco_timer_expired " "timeouts_no=%d no_reboot=%d/%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , timeouts_no, strap, no_reboot);
#line 1707 "trace/trace-hw_acpi.h"
        } else {
#line 59 "../hw/acpi/trace-events"
            qemu_log("tco_timer_expired " "timeouts_no=%d no_reboot=%d/%d" "\n", timeouts_no, strap, no_reboot);
#line 1711 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_tco_timer_expired(int timeouts_no, bool strap, bool no_reboot)
{
    if (true) {
        _nocheck__trace_tco_timer_expired(timeouts_no, strap, no_reboot);
    }
}

#define TRACE_TCO_IO_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_TCO_IO_WRITE) || \
    false)

static inline void _nocheck__trace_tco_io_write(uint64_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_TCO_IO_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 60 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:tco_io_write " "addr=0x%" PRIx64 " val=0x%" PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 1738 "trace/trace-hw_acpi.h"
        } else {
#line 60 "../hw/acpi/trace-events"
            qemu_log("tco_io_write " "addr=0x%" PRIx64 " val=0x%" PRIx32 "\n", addr, val);
#line 1742 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_tco_io_write(uint64_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_tco_io_write(addr, val);
    }
}

#define TRACE_TCO_IO_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_TCO_IO_READ) || \
    false)

static inline void _nocheck__trace_tco_io_read(uint64_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_TCO_IO_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 61 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:tco_io_read " "addr=0x%" PRIx64 " val=0x%" PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 1769 "trace/trace-hw_acpi.h"
        } else {
#line 61 "../hw/acpi/trace-events"
            qemu_log("tco_io_read " "addr=0x%" PRIx64 " val=0x%" PRIx32 "\n", addr, val);
#line 1773 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_tco_io_read(uint64_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_tco_io_read(addr, val);
    }
}

#define TRACE_ACPI_ERST_REG_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_ERST_REG_WRITE) || \
    false)

static inline void _nocheck__trace_acpi_erst_reg_write(uint64_t addr, uint64_t val, unsigned size)
{
    if (trace_event_get_state(TRACE_ACPI_ERST_REG_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 64 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_erst_reg_write " "addr: 0x%04" PRIx64 " <== 0x%016" PRIx64 " (size: %u)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val, size);
#line 1800 "trace/trace-hw_acpi.h"
        } else {
#line 64 "../hw/acpi/trace-events"
            qemu_log("acpi_erst_reg_write " "addr: 0x%04" PRIx64 " <== 0x%016" PRIx64 " (size: %u)" "\n", addr, val, size);
#line 1804 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_erst_reg_write(uint64_t addr, uint64_t val, unsigned size)
{
    if (true) {
        _nocheck__trace_acpi_erst_reg_write(addr, val, size);
    }
}

#define TRACE_ACPI_ERST_REG_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_ERST_REG_READ) || \
    false)

static inline void _nocheck__trace_acpi_erst_reg_read(uint64_t addr, uint64_t val, unsigned size)
{
    if (trace_event_get_state(TRACE_ACPI_ERST_REG_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 65 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_erst_reg_read " " addr: 0x%04" PRIx64 " ==> 0x%016" PRIx64 " (size: %u)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val, size);
#line 1831 "trace/trace-hw_acpi.h"
        } else {
#line 65 "../hw/acpi/trace-events"
            qemu_log("acpi_erst_reg_read " " addr: 0x%04" PRIx64 " ==> 0x%016" PRIx64 " (size: %u)" "\n", addr, val, size);
#line 1835 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_erst_reg_read(uint64_t addr, uint64_t val, unsigned size)
{
    if (true) {
        _nocheck__trace_acpi_erst_reg_read(addr, val, size);
    }
}

#define TRACE_ACPI_ERST_MEM_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_ERST_MEM_WRITE) || \
    false)

static inline void _nocheck__trace_acpi_erst_mem_write(uint64_t addr, uint64_t val, unsigned size)
{
    if (trace_event_get_state(TRACE_ACPI_ERST_MEM_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 66 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_erst_mem_write " "addr: 0x%06" PRIx64 " <== 0x%016" PRIx64 " (size: %u)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val, size);
#line 1862 "trace/trace-hw_acpi.h"
        } else {
#line 66 "../hw/acpi/trace-events"
            qemu_log("acpi_erst_mem_write " "addr: 0x%06" PRIx64 " <== 0x%016" PRIx64 " (size: %u)" "\n", addr, val, size);
#line 1866 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_erst_mem_write(uint64_t addr, uint64_t val, unsigned size)
{
    if (true) {
        _nocheck__trace_acpi_erst_mem_write(addr, val, size);
    }
}

#define TRACE_ACPI_ERST_MEM_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_ERST_MEM_READ) || \
    false)

static inline void _nocheck__trace_acpi_erst_mem_read(uint64_t addr, uint64_t val, unsigned size)
{
    if (trace_event_get_state(TRACE_ACPI_ERST_MEM_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 67 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_erst_mem_read " " addr: 0x%06" PRIx64 " ==> 0x%016" PRIx64 " (size: %u)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val, size);
#line 1893 "trace/trace-hw_acpi.h"
        } else {
#line 67 "../hw/acpi/trace-events"
            qemu_log("acpi_erst_mem_read " " addr: 0x%06" PRIx64 " ==> 0x%016" PRIx64 " (size: %u)" "\n", addr, val, size);
#line 1897 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_erst_mem_read(uint64_t addr, uint64_t val, unsigned size)
{
    if (true) {
        _nocheck__trace_acpi_erst_mem_read(addr, val, size);
    }
}

#define TRACE_ACPI_ERST_PCI_BAR_0_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_ERST_PCI_BAR_0) || \
    false)

static inline void _nocheck__trace_acpi_erst_pci_bar_0(uint64_t addr)
{
    if (trace_event_get_state(TRACE_ACPI_ERST_PCI_BAR_0) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 68 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_erst_pci_bar_0 " "BAR0: 0x%016" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 1924 "trace/trace-hw_acpi.h"
        } else {
#line 68 "../hw/acpi/trace-events"
            qemu_log("acpi_erst_pci_bar_0 " "BAR0: 0x%016" PRIx64 "\n", addr);
#line 1928 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_erst_pci_bar_0(uint64_t addr)
{
    if (true) {
        _nocheck__trace_acpi_erst_pci_bar_0(addr);
    }
}

#define TRACE_ACPI_ERST_PCI_BAR_1_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_ERST_PCI_BAR_1) || \
    false)

static inline void _nocheck__trace_acpi_erst_pci_bar_1(uint64_t addr)
{
    if (trace_event_get_state(TRACE_ACPI_ERST_PCI_BAR_1) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 69 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_erst_pci_bar_1 " "BAR1: 0x%016" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 1955 "trace/trace-hw_acpi.h"
        } else {
#line 69 "../hw/acpi/trace-events"
            qemu_log("acpi_erst_pci_bar_1 " "BAR1: 0x%016" PRIx64 "\n", addr);
#line 1959 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_erst_pci_bar_1(uint64_t addr)
{
    if (true) {
        _nocheck__trace_acpi_erst_pci_bar_1(addr);
    }
}

#define TRACE_ACPI_ERST_REALIZEFN_IN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_ERST_REALIZEFN_IN) || \
    false)

static inline void _nocheck__trace_acpi_erst_realizefn_in(void)
{
    if (trace_event_get_state(TRACE_ACPI_ERST_REALIZEFN_IN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 70 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_erst_realizefn_in "  "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1986 "trace/trace-hw_acpi.h"
        } else {
#line 70 "../hw/acpi/trace-events"
            qemu_log("acpi_erst_realizefn_in "  "\n");
#line 1990 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_erst_realizefn_in(void)
{
    if (true) {
        _nocheck__trace_acpi_erst_realizefn_in();
    }
}

#define TRACE_ACPI_ERST_REALIZEFN_OUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_ERST_REALIZEFN_OUT) || \
    false)

static inline void _nocheck__trace_acpi_erst_realizefn_out(unsigned size)
{
    if (trace_event_get_state(TRACE_ACPI_ERST_REALIZEFN_OUT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 71 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_erst_realizefn_out " "total nvram size %u bytes" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , size);
#line 2017 "trace/trace-hw_acpi.h"
        } else {
#line 71 "../hw/acpi/trace-events"
            qemu_log("acpi_erst_realizefn_out " "total nvram size %u bytes" "\n", size);
#line 2021 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_erst_realizefn_out(unsigned size)
{
    if (true) {
        _nocheck__trace_acpi_erst_realizefn_out(size);
    }
}

#define TRACE_ACPI_ERST_RESET_IN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_ERST_RESET_IN) || \
    false)

static inline void _nocheck__trace_acpi_erst_reset_in(unsigned record_count)
{
    if (trace_event_get_state(TRACE_ACPI_ERST_RESET_IN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 72 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_erst_reset_in " "record_count %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , record_count);
#line 2048 "trace/trace-hw_acpi.h"
        } else {
#line 72 "../hw/acpi/trace-events"
            qemu_log("acpi_erst_reset_in " "record_count %u" "\n", record_count);
#line 2052 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_erst_reset_in(unsigned record_count)
{
    if (true) {
        _nocheck__trace_acpi_erst_reset_in(record_count);
    }
}

#define TRACE_ACPI_ERST_RESET_OUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_ERST_RESET_OUT) || \
    false)

static inline void _nocheck__trace_acpi_erst_reset_out(unsigned record_count)
{
    if (trace_event_get_state(TRACE_ACPI_ERST_RESET_OUT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 73 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_erst_reset_out " "record_count %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , record_count);
#line 2079 "trace/trace-hw_acpi.h"
        } else {
#line 73 "../hw/acpi/trace-events"
            qemu_log("acpi_erst_reset_out " "record_count %u" "\n", record_count);
#line 2083 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_erst_reset_out(unsigned record_count)
{
    if (true) {
        _nocheck__trace_acpi_erst_reset_out(record_count);
    }
}

#define TRACE_ACPI_ERST_POST_LOAD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_ERST_POST_LOAD) || \
    false)

static inline void _nocheck__trace_acpi_erst_post_load(void * header, unsigned slot_size)
{
    if (trace_event_get_state(TRACE_ACPI_ERST_POST_LOAD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 74 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_erst_post_load " "header: 0x%p slot_size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , header, slot_size);
#line 2110 "trace/trace-hw_acpi.h"
        } else {
#line 74 "../hw/acpi/trace-events"
            qemu_log("acpi_erst_post_load " "header: 0x%p slot_size %u" "\n", header, slot_size);
#line 2114 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_erst_post_load(void * header, unsigned slot_size)
{
    if (true) {
        _nocheck__trace_acpi_erst_post_load(header, slot_size);
    }
}

#define TRACE_ACPI_ERST_CLASS_INIT_IN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_ERST_CLASS_INIT_IN) || \
    false)

static inline void _nocheck__trace_acpi_erst_class_init_in(void)
{
    if (trace_event_get_state(TRACE_ACPI_ERST_CLASS_INIT_IN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 75 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_erst_class_init_in "  "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2141 "trace/trace-hw_acpi.h"
        } else {
#line 75 "../hw/acpi/trace-events"
            qemu_log("acpi_erst_class_init_in "  "\n");
#line 2145 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_erst_class_init_in(void)
{
    if (true) {
        _nocheck__trace_acpi_erst_class_init_in();
    }
}

#define TRACE_ACPI_ERST_CLASS_INIT_OUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_ERST_CLASS_INIT_OUT) || \
    false)

static inline void _nocheck__trace_acpi_erst_class_init_out(void)
{
    if (trace_event_get_state(TRACE_ACPI_ERST_CLASS_INIT_OUT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 76 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_erst_class_init_out "  "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2172 "trace/trace-hw_acpi.h"
        } else {
#line 76 "../hw/acpi/trace-events"
            qemu_log("acpi_erst_class_init_out "  "\n");
#line 2176 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_erst_class_init_out(void)
{
    if (true) {
        _nocheck__trace_acpi_erst_class_init_out();
    }
}

#define TRACE_ACPI_NVDIMM_READ_FIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_NVDIMM_READ_FIT) || \
    false)

static inline void _nocheck__trace_acpi_nvdimm_read_fit(uint32_t offset, uint32_t len, const char * dirty)
{
    if (trace_event_get_state(TRACE_ACPI_NVDIMM_READ_FIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 79 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_nvdimm_read_fit " "Read FIT: offset 0x%" PRIx32 " FIT size 0x%" PRIx32 " Dirty %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, len, dirty);
#line 2203 "trace/trace-hw_acpi.h"
        } else {
#line 79 "../hw/acpi/trace-events"
            qemu_log("acpi_nvdimm_read_fit " "Read FIT: offset 0x%" PRIx32 " FIT size 0x%" PRIx32 " Dirty %s" "\n", offset, len, dirty);
#line 2207 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_nvdimm_read_fit(uint32_t offset, uint32_t len, const char * dirty)
{
    if (true) {
        _nocheck__trace_acpi_nvdimm_read_fit(offset, len, dirty);
    }
}

#define TRACE_ACPI_NVDIMM_LABEL_INFO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_NVDIMM_LABEL_INFO) || \
    false)

static inline void _nocheck__trace_acpi_nvdimm_label_info(uint32_t label_size, uint32_t mxfer)
{
    if (trace_event_get_state(TRACE_ACPI_NVDIMM_LABEL_INFO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 80 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_nvdimm_label_info " "label_size 0x%" PRIx32 ", max_xfer 0x%" PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , label_size, mxfer);
#line 2234 "trace/trace-hw_acpi.h"
        } else {
#line 80 "../hw/acpi/trace-events"
            qemu_log("acpi_nvdimm_label_info " "label_size 0x%" PRIx32 ", max_xfer 0x%" PRIx32 "\n", label_size, mxfer);
#line 2238 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_nvdimm_label_info(uint32_t label_size, uint32_t mxfer)
{
    if (true) {
        _nocheck__trace_acpi_nvdimm_label_info(label_size, mxfer);
    }
}

#define TRACE_ACPI_NVDIMM_LABEL_OVERFLOW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_NVDIMM_LABEL_OVERFLOW) || \
    false)

static inline void _nocheck__trace_acpi_nvdimm_label_overflow(uint32_t offset, uint32_t length)
{
    if (trace_event_get_state(TRACE_ACPI_NVDIMM_LABEL_OVERFLOW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 81 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_nvdimm_label_overflow " "offset 0x%" PRIx32 " + length 0x%" PRIx32 " is overflow" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, length);
#line 2265 "trace/trace-hw_acpi.h"
        } else {
#line 81 "../hw/acpi/trace-events"
            qemu_log("acpi_nvdimm_label_overflow " "offset 0x%" PRIx32 " + length 0x%" PRIx32 " is overflow" "\n", offset, length);
#line 2269 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_nvdimm_label_overflow(uint32_t offset, uint32_t length)
{
    if (true) {
        _nocheck__trace_acpi_nvdimm_label_overflow(offset, length);
    }
}

#define TRACE_ACPI_NVDIMM_LABEL_OVERSIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_NVDIMM_LABEL_OVERSIZE) || \
    false)

static inline void _nocheck__trace_acpi_nvdimm_label_oversize(uint32_t pos, uint64_t size)
{
    if (trace_event_get_state(TRACE_ACPI_NVDIMM_LABEL_OVERSIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 82 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_nvdimm_label_oversize " "position 0x%" PRIx32 " is beyond label data (len = %" PRIu64 ")" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , pos, size);
#line 2296 "trace/trace-hw_acpi.h"
        } else {
#line 82 "../hw/acpi/trace-events"
            qemu_log("acpi_nvdimm_label_oversize " "position 0x%" PRIx32 " is beyond label data (len = %" PRIu64 ")" "\n", pos, size);
#line 2300 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_nvdimm_label_oversize(uint32_t pos, uint64_t size)
{
    if (true) {
        _nocheck__trace_acpi_nvdimm_label_oversize(pos, size);
    }
}

#define TRACE_ACPI_NVDIMM_LABEL_XFER_EXCEED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_NVDIMM_LABEL_XFER_EXCEED) || \
    false)

static inline void _nocheck__trace_acpi_nvdimm_label_xfer_exceed(uint32_t length, uint32_t max_xfer)
{
    if (trace_event_get_state(TRACE_ACPI_NVDIMM_LABEL_XFER_EXCEED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 83 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_nvdimm_label_xfer_exceed " "length (0x%" PRIx32 ") is larger than max_xfer (0x%" PRIx32 ")" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , length, max_xfer);
#line 2327 "trace/trace-hw_acpi.h"
        } else {
#line 83 "../hw/acpi/trace-events"
            qemu_log("acpi_nvdimm_label_xfer_exceed " "length (0x%" PRIx32 ") is larger than max_xfer (0x%" PRIx32 ")" "\n", length, max_xfer);
#line 2331 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_nvdimm_label_xfer_exceed(uint32_t length, uint32_t max_xfer)
{
    if (true) {
        _nocheck__trace_acpi_nvdimm_label_xfer_exceed(length, max_xfer);
    }
}

#define TRACE_ACPI_NVDIMM_READ_LABEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_NVDIMM_READ_LABEL) || \
    false)

static inline void _nocheck__trace_acpi_nvdimm_read_label(uint32_t offset, uint32_t length)
{
    if (trace_event_get_state(TRACE_ACPI_NVDIMM_READ_LABEL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 84 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_nvdimm_read_label " "Read Label Data: offset 0x%" PRIx32 " length 0x%" PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, length);
#line 2358 "trace/trace-hw_acpi.h"
        } else {
#line 84 "../hw/acpi/trace-events"
            qemu_log("acpi_nvdimm_read_label " "Read Label Data: offset 0x%" PRIx32 " length 0x%" PRIx32 "\n", offset, length);
#line 2362 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_nvdimm_read_label(uint32_t offset, uint32_t length)
{
    if (true) {
        _nocheck__trace_acpi_nvdimm_read_label(offset, length);
    }
}

#define TRACE_ACPI_NVDIMM_WRITE_LABEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_NVDIMM_WRITE_LABEL) || \
    false)

static inline void _nocheck__trace_acpi_nvdimm_write_label(uint32_t offset, uint32_t length)
{
    if (trace_event_get_state(TRACE_ACPI_NVDIMM_WRITE_LABEL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 85 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_nvdimm_write_label " "Write Label Data: offset 0x%" PRIx32 " length 0x%" PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, length);
#line 2389 "trace/trace-hw_acpi.h"
        } else {
#line 85 "../hw/acpi/trace-events"
            qemu_log("acpi_nvdimm_write_label " "Write Label Data: offset 0x%" PRIx32 " length 0x%" PRIx32 "\n", offset, length);
#line 2393 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_nvdimm_write_label(uint32_t offset, uint32_t length)
{
    if (true) {
        _nocheck__trace_acpi_nvdimm_write_label(offset, length);
    }
}

#define TRACE_ACPI_NVDIMM_READ_IO_PORT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_NVDIMM_READ_IO_PORT) || \
    false)

static inline void _nocheck__trace_acpi_nvdimm_read_io_port(void)
{
    if (trace_event_get_state(TRACE_ACPI_NVDIMM_READ_IO_PORT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 86 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_nvdimm_read_io_port " "Alert: we never read _DSM IO Port" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2420 "trace/trace-hw_acpi.h"
        } else {
#line 86 "../hw/acpi/trace-events"
            qemu_log("acpi_nvdimm_read_io_port " "Alert: we never read _DSM IO Port" "\n");
#line 2424 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_nvdimm_read_io_port(void)
{
    if (true) {
        _nocheck__trace_acpi_nvdimm_read_io_port();
    }
}

#define TRACE_ACPI_NVDIMM_DSM_MEM_ADDR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_NVDIMM_DSM_MEM_ADDR) || \
    false)

static inline void _nocheck__trace_acpi_nvdimm_dsm_mem_addr(uint64_t dsm_mem_addr)
{
    if (trace_event_get_state(TRACE_ACPI_NVDIMM_DSM_MEM_ADDR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 87 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_nvdimm_dsm_mem_addr " "dsm memory address 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dsm_mem_addr);
#line 2451 "trace/trace-hw_acpi.h"
        } else {
#line 87 "../hw/acpi/trace-events"
            qemu_log("acpi_nvdimm_dsm_mem_addr " "dsm memory address 0x%" PRIx64 "\n", dsm_mem_addr);
#line 2455 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_nvdimm_dsm_mem_addr(uint64_t dsm_mem_addr)
{
    if (true) {
        _nocheck__trace_acpi_nvdimm_dsm_mem_addr(dsm_mem_addr);
    }
}

#define TRACE_ACPI_NVDIMM_DSM_INFO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_NVDIMM_DSM_INFO) || \
    false)

static inline void _nocheck__trace_acpi_nvdimm_dsm_info(uint32_t revision, uint32_t handle, uint32_t function)
{
    if (trace_event_get_state(TRACE_ACPI_NVDIMM_DSM_INFO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 88 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_nvdimm_dsm_info " "Revision 0x%" PRIx32 " Handle 0x%" PRIx32 " Function 0x%" PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , revision, handle, function);
#line 2482 "trace/trace-hw_acpi.h"
        } else {
#line 88 "../hw/acpi/trace-events"
            qemu_log("acpi_nvdimm_dsm_info " "Revision 0x%" PRIx32 " Handle 0x%" PRIx32 " Function 0x%" PRIx32 "\n", revision, handle, function);
#line 2486 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_nvdimm_dsm_info(uint32_t revision, uint32_t handle, uint32_t function)
{
    if (true) {
        _nocheck__trace_acpi_nvdimm_dsm_info(revision, handle, function);
    }
}

#define TRACE_ACPI_NVDIMM_INVALID_REVISION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_NVDIMM_INVALID_REVISION) || \
    false)

static inline void _nocheck__trace_acpi_nvdimm_invalid_revision(uint32_t revision)
{
    if (trace_event_get_state(TRACE_ACPI_NVDIMM_INVALID_REVISION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 89 "../hw/acpi/trace-events"
            qemu_log("%d@%zu.%06zu:acpi_nvdimm_invalid_revision " "Revision 0x%" PRIx32 " is not supported, expect 0x1" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , revision);
#line 2513 "trace/trace-hw_acpi.h"
        } else {
#line 89 "../hw/acpi/trace-events"
            qemu_log("acpi_nvdimm_invalid_revision " "Revision 0x%" PRIx32 " is not supported, expect 0x1" "\n", revision);
#line 2517 "trace/trace-hw_acpi.h"
        }
    }
}

static inline void trace_acpi_nvdimm_invalid_revision(uint32_t revision)
{
    if (true) {
        _nocheck__trace_acpi_nvdimm_invalid_revision(revision);
    }
}
#endif /* TRACE_HW_ACPI_GENERATED_TRACERS_H */
