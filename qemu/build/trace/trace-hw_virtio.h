/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_VIRTIO_GENERATED_TRACERS_H
#define TRACE_HW_VIRTIO_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_VHOST_COMMIT_EVENT;
extern TraceEvent _TRACE_VHOST_REGION_ADD_SECTION_EVENT;
extern TraceEvent _TRACE_VHOST_REGION_ADD_SECTION_MERGE_EVENT;
extern TraceEvent _TRACE_VHOST_REGION_ADD_SECTION_ALIGNED_EVENT;
extern TraceEvent _TRACE_VHOST_SECTION_EVENT;
extern TraceEvent _TRACE_VHOST_REJECT_SECTION_EVENT;
extern TraceEvent _TRACE_VHOST_IOTLB_MISS_EVENT;
extern TraceEvent _TRACE_VHOST_DEV_CLEANUP_EVENT;
extern TraceEvent _TRACE_VHOST_DEV_START_EVENT;
extern TraceEvent _TRACE_VHOST_DEV_STOP_EVENT;
extern TraceEvent _TRACE_VHOST_USER_POSTCOPY_END_ENTRY_EVENT;
extern TraceEvent _TRACE_VHOST_USER_POSTCOPY_END_EXIT_EVENT;
extern TraceEvent _TRACE_VHOST_USER_POSTCOPY_FAULT_HANDLER_EVENT;
extern TraceEvent _TRACE_VHOST_USER_POSTCOPY_FAULT_HANDLER_LOOP_EVENT;
extern TraceEvent _TRACE_VHOST_USER_POSTCOPY_FAULT_HANDLER_FOUND_EVENT;
extern TraceEvent _TRACE_VHOST_USER_POSTCOPY_LISTEN_EVENT;
extern TraceEvent _TRACE_VHOST_USER_SET_MEM_TABLE_POSTCOPY_EVENT;
extern TraceEvent _TRACE_VHOST_USER_SET_MEM_TABLE_WITHFD_EVENT;
extern TraceEvent _TRACE_VHOST_USER_POSTCOPY_WAKER_EVENT;
extern TraceEvent _TRACE_VHOST_USER_POSTCOPY_WAKER_FOUND_EVENT;
extern TraceEvent _TRACE_VHOST_USER_POSTCOPY_WAKER_NOMATCH_EVENT;
extern TraceEvent _TRACE_VHOST_USER_READ_EVENT;
extern TraceEvent _TRACE_VHOST_USER_WRITE_EVENT;
extern TraceEvent _TRACE_VHOST_USER_CREATE_NOTIFIER_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_SKIPPED_MEMORY_SECTION_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_DMA_MAP_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_DMA_UNMAP_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_LISTENER_BEGIN_BATCH_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_LISTENER_COMMIT_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_LISTENER_REGION_ADD_UNALIGNED_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_LISTENER_REGION_ADD_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_LISTENER_REGION_DEL_UNALIGNED_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_LISTENER_REGION_DEL_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_ADD_STATUS_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_INIT_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_CLEANUP_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_MEMSLOTS_LIMIT_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_SET_MEM_TABLE_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_DUMP_REGIONS_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_SET_FEATURES_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_GET_DEVICE_ID_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_RESET_DEVICE_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_GET_VQ_INDEX_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_SET_VRING_ENABLE_ONE_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_DUMP_CONFIG_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_SET_CONFIG_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_GET_CONFIG_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_SUSPEND_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_DEV_START_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_SET_LOG_BASE_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_SET_VRING_ADDR_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_SET_VRING_NUM_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_SET_DEV_VRING_BASE_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_GET_VRING_BASE_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_SET_VRING_KICK_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_SET_VRING_CALL_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_GET_FEATURES_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_SET_OWNER_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_VQ_GET_ADDR_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_GET_IOVA_RANGE_EVENT;
extern TraceEvent _TRACE_VHOST_VDPA_SET_CONFIG_CALL_EVENT;
extern TraceEvent _TRACE_VIRTQUEUE_ALLOC_ELEMENT_EVENT;
extern TraceEvent _TRACE_VIRTQUEUE_FILL_EVENT;
extern TraceEvent _TRACE_VIRTQUEUE_FLUSH_EVENT;
extern TraceEvent _TRACE_VIRTQUEUE_POP_EVENT;
extern TraceEvent _TRACE_VIRTIO_QUEUE_NOTIFY_EVENT;
extern TraceEvent _TRACE_VIRTIO_NOTIFY_IRQFD_DEFERRED_FN_EVENT;
extern TraceEvent _TRACE_VIRTIO_NOTIFY_IRQFD_EVENT;
extern TraceEvent _TRACE_VIRTIO_NOTIFY_EVENT;
extern TraceEvent _TRACE_VIRTIO_SET_STATUS_EVENT;
extern TraceEvent _TRACE_VIRTIO_RNG_GUEST_NOT_READY_EVENT;
extern TraceEvent _TRACE_VIRTIO_RNG_CPU_IS_STOPPED_EVENT;
extern TraceEvent _TRACE_VIRTIO_RNG_POPPED_EVENT;
extern TraceEvent _TRACE_VIRTIO_RNG_PUSHED_EVENT;
extern TraceEvent _TRACE_VIRTIO_RNG_REQUEST_EVENT;
extern TraceEvent _TRACE_VIRTIO_RNG_VM_STATE_CHANGE_EVENT;
extern TraceEvent _TRACE_VIRTIO_BALLOON_BAD_ADDR_EVENT;
extern TraceEvent _TRACE_VIRTIO_BALLOON_HANDLE_OUTPUT_EVENT;
extern TraceEvent _TRACE_VIRTIO_BALLOON_GET_CONFIG_EVENT;
extern TraceEvent _TRACE_VIRTIO_BALLOON_SET_CONFIG_EVENT;
extern TraceEvent _TRACE_VIRTIO_BALLOON_TO_TARGET_EVENT;
extern TraceEvent _TRACE_VIRTIO_MMIO_READ_EVENT;
extern TraceEvent _TRACE_VIRTIO_MMIO_WRITE_OFFSET_EVENT;
extern TraceEvent _TRACE_VIRTIO_MMIO_GUEST_PAGE_EVENT;
extern TraceEvent _TRACE_VIRTIO_MMIO_QUEUE_WRITE_EVENT;
extern TraceEvent _TRACE_VIRTIO_MMIO_SETTING_IRQ_EVENT;
extern TraceEvent _TRACE_VIRTIO_PCI_NOTIFY_EVENT;
extern TraceEvent _TRACE_VIRTIO_PCI_NOTIFY_WRITE_EVENT;
extern TraceEvent _TRACE_VIRTIO_PCI_NOTIFY_WRITE_PIO_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_DEVICE_RESET_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_SYSTEM_RESET_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_GET_FEATURES_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_DEVICE_STATUS_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_GET_CONFIG_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_SET_CONFIG_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_ATTACH_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_DETACH_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_DETACH_ENDPOINT_FROM_DOMAIN_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_MAP_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_UNMAP_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_UNMAP_DONE_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_TRANSLATE_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_INIT_IOMMU_MR_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_GET_ENDPOINT_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_PUT_ENDPOINT_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_GET_DOMAIN_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_PUT_DOMAIN_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_TRANSLATE_OUT_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_REPORT_FAULT_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_FILL_RESV_PROPERTY_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_NOTIFY_MAP_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_NOTIFY_UNMAP_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_REMAP_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_UPDATE_PAGE_SIZE_MASK_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_NOTIFY_FLAG_ADD_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_NOTIFY_FLAG_DEL_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_SWITCH_ADDRESS_SPACE_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_FREEZE_GRANULE_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_HOST_RESV_REGIONS_EVENT;
extern TraceEvent _TRACE_VIRTIO_MEM_SEND_RESPONSE_EVENT;
extern TraceEvent _TRACE_VIRTIO_MEM_PLUG_REQUEST_EVENT;
extern TraceEvent _TRACE_VIRTIO_MEM_UNPLUG_REQUEST_EVENT;
extern TraceEvent _TRACE_VIRTIO_MEM_UNPLUGGED_ALL_EVENT;
extern TraceEvent _TRACE_VIRTIO_MEM_UNPLUG_ALL_REQUEST_EVENT;
extern TraceEvent _TRACE_VIRTIO_MEM_RESIZED_USABLE_REGION_EVENT;
extern TraceEvent _TRACE_VIRTIO_MEM_STATE_REQUEST_EVENT;
extern TraceEvent _TRACE_VIRTIO_MEM_STATE_RESPONSE_EVENT;
extern TraceEvent _TRACE_VIRTIO_PMEM_FLUSH_REQUEST_EVENT;
extern TraceEvent _TRACE_VIRTIO_PMEM_RESPONSE_EVENT;
extern TraceEvent _TRACE_VIRTIO_PMEM_FLUSH_DONE_EVENT;
extern TraceEvent _TRACE_VIRTIO_GPIO_START_EVENT;
extern TraceEvent _TRACE_VIRTIO_GPIO_STOP_EVENT;
extern TraceEvent _TRACE_VIRTIO_GPIO_SET_STATUS_EVENT;
extern uint16_t _TRACE_VHOST_COMMIT_DSTATE;
extern uint16_t _TRACE_VHOST_REGION_ADD_SECTION_DSTATE;
extern uint16_t _TRACE_VHOST_REGION_ADD_SECTION_MERGE_DSTATE;
extern uint16_t _TRACE_VHOST_REGION_ADD_SECTION_ALIGNED_DSTATE;
extern uint16_t _TRACE_VHOST_SECTION_DSTATE;
extern uint16_t _TRACE_VHOST_REJECT_SECTION_DSTATE;
extern uint16_t _TRACE_VHOST_IOTLB_MISS_DSTATE;
extern uint16_t _TRACE_VHOST_DEV_CLEANUP_DSTATE;
extern uint16_t _TRACE_VHOST_DEV_START_DSTATE;
extern uint16_t _TRACE_VHOST_DEV_STOP_DSTATE;
extern uint16_t _TRACE_VHOST_USER_POSTCOPY_END_ENTRY_DSTATE;
extern uint16_t _TRACE_VHOST_USER_POSTCOPY_END_EXIT_DSTATE;
extern uint16_t _TRACE_VHOST_USER_POSTCOPY_FAULT_HANDLER_DSTATE;
extern uint16_t _TRACE_VHOST_USER_POSTCOPY_FAULT_HANDLER_LOOP_DSTATE;
extern uint16_t _TRACE_VHOST_USER_POSTCOPY_FAULT_HANDLER_FOUND_DSTATE;
extern uint16_t _TRACE_VHOST_USER_POSTCOPY_LISTEN_DSTATE;
extern uint16_t _TRACE_VHOST_USER_SET_MEM_TABLE_POSTCOPY_DSTATE;
extern uint16_t _TRACE_VHOST_USER_SET_MEM_TABLE_WITHFD_DSTATE;
extern uint16_t _TRACE_VHOST_USER_POSTCOPY_WAKER_DSTATE;
extern uint16_t _TRACE_VHOST_USER_POSTCOPY_WAKER_FOUND_DSTATE;
extern uint16_t _TRACE_VHOST_USER_POSTCOPY_WAKER_NOMATCH_DSTATE;
extern uint16_t _TRACE_VHOST_USER_READ_DSTATE;
extern uint16_t _TRACE_VHOST_USER_WRITE_DSTATE;
extern uint16_t _TRACE_VHOST_USER_CREATE_NOTIFIER_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_SKIPPED_MEMORY_SECTION_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_DMA_MAP_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_DMA_UNMAP_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_LISTENER_BEGIN_BATCH_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_LISTENER_COMMIT_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_LISTENER_REGION_ADD_UNALIGNED_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_LISTENER_REGION_ADD_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_LISTENER_REGION_DEL_UNALIGNED_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_LISTENER_REGION_DEL_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_ADD_STATUS_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_INIT_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_CLEANUP_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_MEMSLOTS_LIMIT_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_SET_MEM_TABLE_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_DUMP_REGIONS_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_SET_FEATURES_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_GET_DEVICE_ID_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_RESET_DEVICE_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_GET_VQ_INDEX_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_SET_VRING_ENABLE_ONE_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_DUMP_CONFIG_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_SET_CONFIG_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_GET_CONFIG_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_SUSPEND_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_DEV_START_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_SET_LOG_BASE_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_SET_VRING_ADDR_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_SET_VRING_NUM_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_SET_DEV_VRING_BASE_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_GET_VRING_BASE_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_SET_VRING_KICK_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_SET_VRING_CALL_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_GET_FEATURES_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_SET_OWNER_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_VQ_GET_ADDR_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_GET_IOVA_RANGE_DSTATE;
extern uint16_t _TRACE_VHOST_VDPA_SET_CONFIG_CALL_DSTATE;
extern uint16_t _TRACE_VIRTQUEUE_ALLOC_ELEMENT_DSTATE;
extern uint16_t _TRACE_VIRTQUEUE_FILL_DSTATE;
extern uint16_t _TRACE_VIRTQUEUE_FLUSH_DSTATE;
extern uint16_t _TRACE_VIRTQUEUE_POP_DSTATE;
extern uint16_t _TRACE_VIRTIO_QUEUE_NOTIFY_DSTATE;
extern uint16_t _TRACE_VIRTIO_NOTIFY_IRQFD_DEFERRED_FN_DSTATE;
extern uint16_t _TRACE_VIRTIO_NOTIFY_IRQFD_DSTATE;
extern uint16_t _TRACE_VIRTIO_NOTIFY_DSTATE;
extern uint16_t _TRACE_VIRTIO_SET_STATUS_DSTATE;
extern uint16_t _TRACE_VIRTIO_RNG_GUEST_NOT_READY_DSTATE;
extern uint16_t _TRACE_VIRTIO_RNG_CPU_IS_STOPPED_DSTATE;
extern uint16_t _TRACE_VIRTIO_RNG_POPPED_DSTATE;
extern uint16_t _TRACE_VIRTIO_RNG_PUSHED_DSTATE;
extern uint16_t _TRACE_VIRTIO_RNG_REQUEST_DSTATE;
extern uint16_t _TRACE_VIRTIO_RNG_VM_STATE_CHANGE_DSTATE;
extern uint16_t _TRACE_VIRTIO_BALLOON_BAD_ADDR_DSTATE;
extern uint16_t _TRACE_VIRTIO_BALLOON_HANDLE_OUTPUT_DSTATE;
extern uint16_t _TRACE_VIRTIO_BALLOON_GET_CONFIG_DSTATE;
extern uint16_t _TRACE_VIRTIO_BALLOON_SET_CONFIG_DSTATE;
extern uint16_t _TRACE_VIRTIO_BALLOON_TO_TARGET_DSTATE;
extern uint16_t _TRACE_VIRTIO_MMIO_READ_DSTATE;
extern uint16_t _TRACE_VIRTIO_MMIO_WRITE_OFFSET_DSTATE;
extern uint16_t _TRACE_VIRTIO_MMIO_GUEST_PAGE_DSTATE;
extern uint16_t _TRACE_VIRTIO_MMIO_QUEUE_WRITE_DSTATE;
extern uint16_t _TRACE_VIRTIO_MMIO_SETTING_IRQ_DSTATE;
extern uint16_t _TRACE_VIRTIO_PCI_NOTIFY_DSTATE;
extern uint16_t _TRACE_VIRTIO_PCI_NOTIFY_WRITE_DSTATE;
extern uint16_t _TRACE_VIRTIO_PCI_NOTIFY_WRITE_PIO_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_DEVICE_RESET_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_SYSTEM_RESET_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_GET_FEATURES_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_DEVICE_STATUS_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_GET_CONFIG_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_SET_CONFIG_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_ATTACH_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_DETACH_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_DETACH_ENDPOINT_FROM_DOMAIN_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_MAP_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_UNMAP_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_UNMAP_DONE_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_TRANSLATE_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_INIT_IOMMU_MR_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_GET_ENDPOINT_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_PUT_ENDPOINT_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_GET_DOMAIN_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_PUT_DOMAIN_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_TRANSLATE_OUT_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_REPORT_FAULT_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_FILL_RESV_PROPERTY_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_NOTIFY_MAP_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_NOTIFY_UNMAP_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_REMAP_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_UPDATE_PAGE_SIZE_MASK_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_NOTIFY_FLAG_ADD_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_NOTIFY_FLAG_DEL_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_SWITCH_ADDRESS_SPACE_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_FREEZE_GRANULE_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_HOST_RESV_REGIONS_DSTATE;
extern uint16_t _TRACE_VIRTIO_MEM_SEND_RESPONSE_DSTATE;
extern uint16_t _TRACE_VIRTIO_MEM_PLUG_REQUEST_DSTATE;
extern uint16_t _TRACE_VIRTIO_MEM_UNPLUG_REQUEST_DSTATE;
extern uint16_t _TRACE_VIRTIO_MEM_UNPLUGGED_ALL_DSTATE;
extern uint16_t _TRACE_VIRTIO_MEM_UNPLUG_ALL_REQUEST_DSTATE;
extern uint16_t _TRACE_VIRTIO_MEM_RESIZED_USABLE_REGION_DSTATE;
extern uint16_t _TRACE_VIRTIO_MEM_STATE_REQUEST_DSTATE;
extern uint16_t _TRACE_VIRTIO_MEM_STATE_RESPONSE_DSTATE;
extern uint16_t _TRACE_VIRTIO_PMEM_FLUSH_REQUEST_DSTATE;
extern uint16_t _TRACE_VIRTIO_PMEM_RESPONSE_DSTATE;
extern uint16_t _TRACE_VIRTIO_PMEM_FLUSH_DONE_DSTATE;
extern uint16_t _TRACE_VIRTIO_GPIO_START_DSTATE;
extern uint16_t _TRACE_VIRTIO_GPIO_STOP_DSTATE;
extern uint16_t _TRACE_VIRTIO_GPIO_SET_STATUS_DSTATE;
#define TRACE_VHOST_COMMIT_ENABLED 1
#define TRACE_VHOST_REGION_ADD_SECTION_ENABLED 1
#define TRACE_VHOST_REGION_ADD_SECTION_MERGE_ENABLED 1
#define TRACE_VHOST_REGION_ADD_SECTION_ALIGNED_ENABLED 1
#define TRACE_VHOST_SECTION_ENABLED 1
#define TRACE_VHOST_REJECT_SECTION_ENABLED 1
#define TRACE_VHOST_IOTLB_MISS_ENABLED 1
#define TRACE_VHOST_DEV_CLEANUP_ENABLED 1
#define TRACE_VHOST_DEV_START_ENABLED 1
#define TRACE_VHOST_DEV_STOP_ENABLED 1
#define TRACE_VHOST_USER_POSTCOPY_END_ENTRY_ENABLED 1
#define TRACE_VHOST_USER_POSTCOPY_END_EXIT_ENABLED 1
#define TRACE_VHOST_USER_POSTCOPY_FAULT_HANDLER_ENABLED 1
#define TRACE_VHOST_USER_POSTCOPY_FAULT_HANDLER_LOOP_ENABLED 1
#define TRACE_VHOST_USER_POSTCOPY_FAULT_HANDLER_FOUND_ENABLED 1
#define TRACE_VHOST_USER_POSTCOPY_LISTEN_ENABLED 1
#define TRACE_VHOST_USER_SET_MEM_TABLE_POSTCOPY_ENABLED 1
#define TRACE_VHOST_USER_SET_MEM_TABLE_WITHFD_ENABLED 1
#define TRACE_VHOST_USER_POSTCOPY_WAKER_ENABLED 1
#define TRACE_VHOST_USER_POSTCOPY_WAKER_FOUND_ENABLED 1
#define TRACE_VHOST_USER_POSTCOPY_WAKER_NOMATCH_ENABLED 1
#define TRACE_VHOST_USER_READ_ENABLED 1
#define TRACE_VHOST_USER_WRITE_ENABLED 1
#define TRACE_VHOST_USER_CREATE_NOTIFIER_ENABLED 1
#define TRACE_VHOST_VDPA_SKIPPED_MEMORY_SECTION_ENABLED 1
#define TRACE_VHOST_VDPA_DMA_MAP_ENABLED 1
#define TRACE_VHOST_VDPA_DMA_UNMAP_ENABLED 1
#define TRACE_VHOST_VDPA_LISTENER_BEGIN_BATCH_ENABLED 1
#define TRACE_VHOST_VDPA_LISTENER_COMMIT_ENABLED 1
#define TRACE_VHOST_VDPA_LISTENER_REGION_ADD_UNALIGNED_ENABLED 1
#define TRACE_VHOST_VDPA_LISTENER_REGION_ADD_ENABLED 1
#define TRACE_VHOST_VDPA_LISTENER_REGION_DEL_UNALIGNED_ENABLED 1
#define TRACE_VHOST_VDPA_LISTENER_REGION_DEL_ENABLED 1
#define TRACE_VHOST_VDPA_ADD_STATUS_ENABLED 1
#define TRACE_VHOST_VDPA_INIT_ENABLED 1
#define TRACE_VHOST_VDPA_CLEANUP_ENABLED 1
#define TRACE_VHOST_VDPA_MEMSLOTS_LIMIT_ENABLED 1
#define TRACE_VHOST_VDPA_SET_MEM_TABLE_ENABLED 1
#define TRACE_VHOST_VDPA_DUMP_REGIONS_ENABLED 1
#define TRACE_VHOST_VDPA_SET_FEATURES_ENABLED 1
#define TRACE_VHOST_VDPA_GET_DEVICE_ID_ENABLED 1
#define TRACE_VHOST_VDPA_RESET_DEVICE_ENABLED 1
#define TRACE_VHOST_VDPA_GET_VQ_INDEX_ENABLED 1
#define TRACE_VHOST_VDPA_SET_VRING_ENABLE_ONE_ENABLED 1
#define TRACE_VHOST_VDPA_DUMP_CONFIG_ENABLED 1
#define TRACE_VHOST_VDPA_SET_CONFIG_ENABLED 1
#define TRACE_VHOST_VDPA_GET_CONFIG_ENABLED 1
#define TRACE_VHOST_VDPA_SUSPEND_ENABLED 1
#define TRACE_VHOST_VDPA_DEV_START_ENABLED 1
#define TRACE_VHOST_VDPA_SET_LOG_BASE_ENABLED 1
#define TRACE_VHOST_VDPA_SET_VRING_ADDR_ENABLED 1
#define TRACE_VHOST_VDPA_SET_VRING_NUM_ENABLED 1
#define TRACE_VHOST_VDPA_SET_DEV_VRING_BASE_ENABLED 1
#define TRACE_VHOST_VDPA_GET_VRING_BASE_ENABLED 1
#define TRACE_VHOST_VDPA_SET_VRING_KICK_ENABLED 1
#define TRACE_VHOST_VDPA_SET_VRING_CALL_ENABLED 1
#define TRACE_VHOST_VDPA_GET_FEATURES_ENABLED 1
#define TRACE_VHOST_VDPA_SET_OWNER_ENABLED 1
#define TRACE_VHOST_VDPA_VQ_GET_ADDR_ENABLED 1
#define TRACE_VHOST_VDPA_GET_IOVA_RANGE_ENABLED 1
#define TRACE_VHOST_VDPA_SET_CONFIG_CALL_ENABLED 1
#define TRACE_VIRTQUEUE_ALLOC_ELEMENT_ENABLED 1
#define TRACE_VIRTQUEUE_FILL_ENABLED 1
#define TRACE_VIRTQUEUE_FLUSH_ENABLED 1
#define TRACE_VIRTQUEUE_POP_ENABLED 1
#define TRACE_VIRTIO_QUEUE_NOTIFY_ENABLED 1
#define TRACE_VIRTIO_NOTIFY_IRQFD_DEFERRED_FN_ENABLED 1
#define TRACE_VIRTIO_NOTIFY_IRQFD_ENABLED 1
#define TRACE_VIRTIO_NOTIFY_ENABLED 1
#define TRACE_VIRTIO_SET_STATUS_ENABLED 1
#define TRACE_VIRTIO_RNG_GUEST_NOT_READY_ENABLED 1
#define TRACE_VIRTIO_RNG_CPU_IS_STOPPED_ENABLED 1
#define TRACE_VIRTIO_RNG_POPPED_ENABLED 1
#define TRACE_VIRTIO_RNG_PUSHED_ENABLED 1
#define TRACE_VIRTIO_RNG_REQUEST_ENABLED 1
#define TRACE_VIRTIO_RNG_VM_STATE_CHANGE_ENABLED 1
#define TRACE_VIRTIO_BALLOON_BAD_ADDR_ENABLED 1
#define TRACE_VIRTIO_BALLOON_HANDLE_OUTPUT_ENABLED 1
#define TRACE_VIRTIO_BALLOON_GET_CONFIG_ENABLED 1
#define TRACE_VIRTIO_BALLOON_SET_CONFIG_ENABLED 1
#define TRACE_VIRTIO_BALLOON_TO_TARGET_ENABLED 1
#define TRACE_VIRTIO_MMIO_READ_ENABLED 1
#define TRACE_VIRTIO_MMIO_WRITE_OFFSET_ENABLED 1
#define TRACE_VIRTIO_MMIO_GUEST_PAGE_ENABLED 1
#define TRACE_VIRTIO_MMIO_QUEUE_WRITE_ENABLED 1
#define TRACE_VIRTIO_MMIO_SETTING_IRQ_ENABLED 1
#define TRACE_VIRTIO_PCI_NOTIFY_ENABLED 1
#define TRACE_VIRTIO_PCI_NOTIFY_WRITE_ENABLED 1
#define TRACE_VIRTIO_PCI_NOTIFY_WRITE_PIO_ENABLED 1
#define TRACE_VIRTIO_IOMMU_DEVICE_RESET_ENABLED 1
#define TRACE_VIRTIO_IOMMU_SYSTEM_RESET_ENABLED 1
#define TRACE_VIRTIO_IOMMU_GET_FEATURES_ENABLED 1
#define TRACE_VIRTIO_IOMMU_DEVICE_STATUS_ENABLED 1
#define TRACE_VIRTIO_IOMMU_GET_CONFIG_ENABLED 1
#define TRACE_VIRTIO_IOMMU_SET_CONFIG_ENABLED 1
#define TRACE_VIRTIO_IOMMU_ATTACH_ENABLED 1
#define TRACE_VIRTIO_IOMMU_DETACH_ENABLED 1
#define TRACE_VIRTIO_IOMMU_DETACH_ENDPOINT_FROM_DOMAIN_ENABLED 1
#define TRACE_VIRTIO_IOMMU_MAP_ENABLED 1
#define TRACE_VIRTIO_IOMMU_UNMAP_ENABLED 1
#define TRACE_VIRTIO_IOMMU_UNMAP_DONE_ENABLED 1
#define TRACE_VIRTIO_IOMMU_TRANSLATE_ENABLED 1
#define TRACE_VIRTIO_IOMMU_INIT_IOMMU_MR_ENABLED 1
#define TRACE_VIRTIO_IOMMU_GET_ENDPOINT_ENABLED 1
#define TRACE_VIRTIO_IOMMU_PUT_ENDPOINT_ENABLED 1
#define TRACE_VIRTIO_IOMMU_GET_DOMAIN_ENABLED 1
#define TRACE_VIRTIO_IOMMU_PUT_DOMAIN_ENABLED 1
#define TRACE_VIRTIO_IOMMU_TRANSLATE_OUT_ENABLED 1
#define TRACE_VIRTIO_IOMMU_REPORT_FAULT_ENABLED 1
#define TRACE_VIRTIO_IOMMU_FILL_RESV_PROPERTY_ENABLED 1
#define TRACE_VIRTIO_IOMMU_NOTIFY_MAP_ENABLED 1
#define TRACE_VIRTIO_IOMMU_NOTIFY_UNMAP_ENABLED 1
#define TRACE_VIRTIO_IOMMU_REMAP_ENABLED 1
#define TRACE_VIRTIO_IOMMU_UPDATE_PAGE_SIZE_MASK_ENABLED 1
#define TRACE_VIRTIO_IOMMU_NOTIFY_FLAG_ADD_ENABLED 1
#define TRACE_VIRTIO_IOMMU_NOTIFY_FLAG_DEL_ENABLED 1
#define TRACE_VIRTIO_IOMMU_SWITCH_ADDRESS_SPACE_ENABLED 1
#define TRACE_VIRTIO_IOMMU_FREEZE_GRANULE_ENABLED 1
#define TRACE_VIRTIO_IOMMU_HOST_RESV_REGIONS_ENABLED 1
#define TRACE_VIRTIO_MEM_SEND_RESPONSE_ENABLED 1
#define TRACE_VIRTIO_MEM_PLUG_REQUEST_ENABLED 1
#define TRACE_VIRTIO_MEM_UNPLUG_REQUEST_ENABLED 1
#define TRACE_VIRTIO_MEM_UNPLUGGED_ALL_ENABLED 1
#define TRACE_VIRTIO_MEM_UNPLUG_ALL_REQUEST_ENABLED 1
#define TRACE_VIRTIO_MEM_RESIZED_USABLE_REGION_ENABLED 1
#define TRACE_VIRTIO_MEM_STATE_REQUEST_ENABLED 1
#define TRACE_VIRTIO_MEM_STATE_RESPONSE_ENABLED 1
#define TRACE_VIRTIO_PMEM_FLUSH_REQUEST_ENABLED 1
#define TRACE_VIRTIO_PMEM_RESPONSE_ENABLED 1
#define TRACE_VIRTIO_PMEM_FLUSH_DONE_ENABLED 1
#define TRACE_VIRTIO_GPIO_START_ENABLED 1
#define TRACE_VIRTIO_GPIO_STOP_ENABLED 1
#define TRACE_VIRTIO_GPIO_SET_STATUS_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_VHOST_COMMIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_COMMIT) || \
    false)

static inline void _nocheck__trace_vhost_commit(bool started, bool changed)
{
    if (trace_event_get_state(TRACE_VHOST_COMMIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 4 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_commit " "Started: %d Changed: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , started, changed);
#line 427 "trace/trace-hw_virtio.h"
        } else {
#line 4 "../hw/virtio/trace-events"
            qemu_log("vhost_commit " "Started: %d Changed: %d" "\n", started, changed);
#line 431 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_commit(bool started, bool changed)
{
    if (true) {
        _nocheck__trace_vhost_commit(started, changed);
    }
}

#define TRACE_VHOST_REGION_ADD_SECTION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_REGION_ADD_SECTION) || \
    false)

static inline void _nocheck__trace_vhost_region_add_section(const char * name, uint64_t gpa, uint64_t size, uint64_t host)
{
    if (trace_event_get_state(TRACE_VHOST_REGION_ADD_SECTION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 5 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_region_add_section " "%s: 0x%"PRIx64"+0x%"PRIx64" @ 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, gpa, size, host);
#line 458 "trace/trace-hw_virtio.h"
        } else {
#line 5 "../hw/virtio/trace-events"
            qemu_log("vhost_region_add_section " "%s: 0x%"PRIx64"+0x%"PRIx64" @ 0x%"PRIx64 "\n", name, gpa, size, host);
#line 462 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_region_add_section(const char * name, uint64_t gpa, uint64_t size, uint64_t host)
{
    if (true) {
        _nocheck__trace_vhost_region_add_section(name, gpa, size, host);
    }
}

#define TRACE_VHOST_REGION_ADD_SECTION_MERGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_REGION_ADD_SECTION_MERGE) || \
    false)

static inline void _nocheck__trace_vhost_region_add_section_merge(const char * name, uint64_t new_size, uint64_t gpa, uint64_t owr)
{
    if (trace_event_get_state(TRACE_VHOST_REGION_ADD_SECTION_MERGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 6 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_region_add_section_merge " "%s: size: 0x%"PRIx64 " gpa: 0x%"PRIx64 " owr: 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, new_size, gpa, owr);
#line 489 "trace/trace-hw_virtio.h"
        } else {
#line 6 "../hw/virtio/trace-events"
            qemu_log("vhost_region_add_section_merge " "%s: size: 0x%"PRIx64 " gpa: 0x%"PRIx64 " owr: 0x%"PRIx64 "\n", name, new_size, gpa, owr);
#line 493 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_region_add_section_merge(const char * name, uint64_t new_size, uint64_t gpa, uint64_t owr)
{
    if (true) {
        _nocheck__trace_vhost_region_add_section_merge(name, new_size, gpa, owr);
    }
}

#define TRACE_VHOST_REGION_ADD_SECTION_ALIGNED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_REGION_ADD_SECTION_ALIGNED) || \
    false)

static inline void _nocheck__trace_vhost_region_add_section_aligned(const char * name, uint64_t gpa, uint64_t size, uint64_t host)
{
    if (trace_event_get_state(TRACE_VHOST_REGION_ADD_SECTION_ALIGNED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 7 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_region_add_section_aligned " "%s: 0x%"PRIx64"+0x%"PRIx64" @ 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, gpa, size, host);
#line 520 "trace/trace-hw_virtio.h"
        } else {
#line 7 "../hw/virtio/trace-events"
            qemu_log("vhost_region_add_section_aligned " "%s: 0x%"PRIx64"+0x%"PRIx64" @ 0x%"PRIx64 "\n", name, gpa, size, host);
#line 524 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_region_add_section_aligned(const char * name, uint64_t gpa, uint64_t size, uint64_t host)
{
    if (true) {
        _nocheck__trace_vhost_region_add_section_aligned(name, gpa, size, host);
    }
}

#define TRACE_VHOST_SECTION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_SECTION) || \
    false)

static inline void _nocheck__trace_vhost_section(const char * name)
{
    if (trace_event_get_state(TRACE_VHOST_SECTION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 8 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_section " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 551 "trace/trace-hw_virtio.h"
        } else {
#line 8 "../hw/virtio/trace-events"
            qemu_log("vhost_section " "%s" "\n", name);
#line 555 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_section(const char * name)
{
    if (true) {
        _nocheck__trace_vhost_section(name);
    }
}

#define TRACE_VHOST_REJECT_SECTION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_REJECT_SECTION) || \
    false)

static inline void _nocheck__trace_vhost_reject_section(const char * name, int d)
{
    if (trace_event_get_state(TRACE_VHOST_REJECT_SECTION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 9 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_reject_section " "%s:%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, d);
#line 582 "trace/trace-hw_virtio.h"
        } else {
#line 9 "../hw/virtio/trace-events"
            qemu_log("vhost_reject_section " "%s:%d" "\n", name, d);
#line 586 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_reject_section(const char * name, int d)
{
    if (true) {
        _nocheck__trace_vhost_reject_section(name, d);
    }
}

#define TRACE_VHOST_IOTLB_MISS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_IOTLB_MISS) || \
    false)

static inline void _nocheck__trace_vhost_iotlb_miss(void * dev, int step)
{
    if (trace_event_get_state(TRACE_VHOST_IOTLB_MISS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 10 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_iotlb_miss " "%p step %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, step);
#line 613 "trace/trace-hw_virtio.h"
        } else {
#line 10 "../hw/virtio/trace-events"
            qemu_log("vhost_iotlb_miss " "%p step %d" "\n", dev, step);
#line 617 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_iotlb_miss(void * dev, int step)
{
    if (true) {
        _nocheck__trace_vhost_iotlb_miss(dev, step);
    }
}

#define TRACE_VHOST_DEV_CLEANUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_DEV_CLEANUP) || \
    false)

static inline void _nocheck__trace_vhost_dev_cleanup(void * dev)
{
    if (trace_event_get_state(TRACE_VHOST_DEV_CLEANUP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 11 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_dev_cleanup " "%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev);
#line 644 "trace/trace-hw_virtio.h"
        } else {
#line 11 "../hw/virtio/trace-events"
            qemu_log("vhost_dev_cleanup " "%p" "\n", dev);
#line 648 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_dev_cleanup(void * dev)
{
    if (true) {
        _nocheck__trace_vhost_dev_cleanup(dev);
    }
}

#define TRACE_VHOST_DEV_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_DEV_START) || \
    false)

static inline void _nocheck__trace_vhost_dev_start(void * dev, const char * name, bool vrings)
{
    if (trace_event_get_state(TRACE_VHOST_DEV_START) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 12 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_dev_start " "%p:%s vrings:%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, name, vrings);
#line 675 "trace/trace-hw_virtio.h"
        } else {
#line 12 "../hw/virtio/trace-events"
            qemu_log("vhost_dev_start " "%p:%s vrings:%d" "\n", dev, name, vrings);
#line 679 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_dev_start(void * dev, const char * name, bool vrings)
{
    if (true) {
        _nocheck__trace_vhost_dev_start(dev, name, vrings);
    }
}

#define TRACE_VHOST_DEV_STOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_DEV_STOP) || \
    false)

static inline void _nocheck__trace_vhost_dev_stop(void * dev, const char * name, bool vrings)
{
    if (trace_event_get_state(TRACE_VHOST_DEV_STOP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 13 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_dev_stop " "%p:%s vrings:%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, name, vrings);
#line 706 "trace/trace-hw_virtio.h"
        } else {
#line 13 "../hw/virtio/trace-events"
            qemu_log("vhost_dev_stop " "%p:%s vrings:%d" "\n", dev, name, vrings);
#line 710 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_dev_stop(void * dev, const char * name, bool vrings)
{
    if (true) {
        _nocheck__trace_vhost_dev_stop(dev, name, vrings);
    }
}

#define TRACE_VHOST_USER_POSTCOPY_END_ENTRY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_USER_POSTCOPY_END_ENTRY) || \
    false)

static inline void _nocheck__trace_vhost_user_postcopy_end_entry(void)
{
    if (trace_event_get_state(TRACE_VHOST_USER_POSTCOPY_END_ENTRY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 17 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_user_postcopy_end_entry " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 737 "trace/trace-hw_virtio.h"
        } else {
#line 17 "../hw/virtio/trace-events"
            qemu_log("vhost_user_postcopy_end_entry " "" "\n");
#line 741 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_user_postcopy_end_entry(void)
{
    if (true) {
        _nocheck__trace_vhost_user_postcopy_end_entry();
    }
}

#define TRACE_VHOST_USER_POSTCOPY_END_EXIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_USER_POSTCOPY_END_EXIT) || \
    false)

static inline void _nocheck__trace_vhost_user_postcopy_end_exit(void)
{
    if (trace_event_get_state(TRACE_VHOST_USER_POSTCOPY_END_EXIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 18 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_user_postcopy_end_exit " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 768 "trace/trace-hw_virtio.h"
        } else {
#line 18 "../hw/virtio/trace-events"
            qemu_log("vhost_user_postcopy_end_exit " "" "\n");
#line 772 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_user_postcopy_end_exit(void)
{
    if (true) {
        _nocheck__trace_vhost_user_postcopy_end_exit();
    }
}

#define TRACE_VHOST_USER_POSTCOPY_FAULT_HANDLER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_USER_POSTCOPY_FAULT_HANDLER) || \
    false)

static inline void _nocheck__trace_vhost_user_postcopy_fault_handler(const char * name, uint64_t fault_address, int nregions)
{
    if (trace_event_get_state(TRACE_VHOST_USER_POSTCOPY_FAULT_HANDLER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 19 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_user_postcopy_fault_handler " "%s: @0x%"PRIx64" nregions:%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, fault_address, nregions);
#line 799 "trace/trace-hw_virtio.h"
        } else {
#line 19 "../hw/virtio/trace-events"
            qemu_log("vhost_user_postcopy_fault_handler " "%s: @0x%"PRIx64" nregions:%d" "\n", name, fault_address, nregions);
#line 803 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_user_postcopy_fault_handler(const char * name, uint64_t fault_address, int nregions)
{
    if (true) {
        _nocheck__trace_vhost_user_postcopy_fault_handler(name, fault_address, nregions);
    }
}

#define TRACE_VHOST_USER_POSTCOPY_FAULT_HANDLER_LOOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_USER_POSTCOPY_FAULT_HANDLER_LOOP) || \
    false)

static inline void _nocheck__trace_vhost_user_postcopy_fault_handler_loop(int i, uint64_t client_base, uint64_t size)
{
    if (trace_event_get_state(TRACE_VHOST_USER_POSTCOPY_FAULT_HANDLER_LOOP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 20 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_user_postcopy_fault_handler_loop " "%d: client 0x%"PRIx64" +0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , i, client_base, size);
#line 830 "trace/trace-hw_virtio.h"
        } else {
#line 20 "../hw/virtio/trace-events"
            qemu_log("vhost_user_postcopy_fault_handler_loop " "%d: client 0x%"PRIx64" +0x%"PRIx64 "\n", i, client_base, size);
#line 834 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_user_postcopy_fault_handler_loop(int i, uint64_t client_base, uint64_t size)
{
    if (true) {
        _nocheck__trace_vhost_user_postcopy_fault_handler_loop(i, client_base, size);
    }
}

#define TRACE_VHOST_USER_POSTCOPY_FAULT_HANDLER_FOUND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_USER_POSTCOPY_FAULT_HANDLER_FOUND) || \
    false)

static inline void _nocheck__trace_vhost_user_postcopy_fault_handler_found(int i, uint64_t region_offset, uint64_t rb_offset)
{
    if (trace_event_get_state(TRACE_VHOST_USER_POSTCOPY_FAULT_HANDLER_FOUND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 21 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_user_postcopy_fault_handler_found " "%d: region_offset: 0x%"PRIx64" rb_offset:0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , i, region_offset, rb_offset);
#line 861 "trace/trace-hw_virtio.h"
        } else {
#line 21 "../hw/virtio/trace-events"
            qemu_log("vhost_user_postcopy_fault_handler_found " "%d: region_offset: 0x%"PRIx64" rb_offset:0x%"PRIx64 "\n", i, region_offset, rb_offset);
#line 865 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_user_postcopy_fault_handler_found(int i, uint64_t region_offset, uint64_t rb_offset)
{
    if (true) {
        _nocheck__trace_vhost_user_postcopy_fault_handler_found(i, region_offset, rb_offset);
    }
}

#define TRACE_VHOST_USER_POSTCOPY_LISTEN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_USER_POSTCOPY_LISTEN) || \
    false)

static inline void _nocheck__trace_vhost_user_postcopy_listen(void)
{
    if (trace_event_get_state(TRACE_VHOST_USER_POSTCOPY_LISTEN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 22 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_user_postcopy_listen " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 892 "trace/trace-hw_virtio.h"
        } else {
#line 22 "../hw/virtio/trace-events"
            qemu_log("vhost_user_postcopy_listen " "" "\n");
#line 896 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_user_postcopy_listen(void)
{
    if (true) {
        _nocheck__trace_vhost_user_postcopy_listen();
    }
}

#define TRACE_VHOST_USER_SET_MEM_TABLE_POSTCOPY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_USER_SET_MEM_TABLE_POSTCOPY) || \
    false)

static inline void _nocheck__trace_vhost_user_set_mem_table_postcopy(uint64_t client_addr, uint64_t qhva, int reply_i, int region_i)
{
    if (trace_event_get_state(TRACE_VHOST_USER_SET_MEM_TABLE_POSTCOPY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 23 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_user_set_mem_table_postcopy " "client:0x%"PRIx64" for hva: 0x%"PRIx64" reply %d region %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , client_addr, qhva, reply_i, region_i);
#line 923 "trace/trace-hw_virtio.h"
        } else {
#line 23 "../hw/virtio/trace-events"
            qemu_log("vhost_user_set_mem_table_postcopy " "client:0x%"PRIx64" for hva: 0x%"PRIx64" reply %d region %d" "\n", client_addr, qhva, reply_i, region_i);
#line 927 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_user_set_mem_table_postcopy(uint64_t client_addr, uint64_t qhva, int reply_i, int region_i)
{
    if (true) {
        _nocheck__trace_vhost_user_set_mem_table_postcopy(client_addr, qhva, reply_i, region_i);
    }
}

#define TRACE_VHOST_USER_SET_MEM_TABLE_WITHFD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_USER_SET_MEM_TABLE_WITHFD) || \
    false)

static inline void _nocheck__trace_vhost_user_set_mem_table_withfd(int index, const char * name, uint64_t memory_size, uint64_t guest_phys_addr, uint64_t userspace_addr, uint64_t offset)
{
    if (trace_event_get_state(TRACE_VHOST_USER_SET_MEM_TABLE_WITHFD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 24 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_user_set_mem_table_withfd " "%d:%s: size:0x%"PRIx64" GPA:0x%"PRIx64" QVA/userspace:0x%"PRIx64" RB offset:0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index, name, memory_size, guest_phys_addr, userspace_addr, offset);
#line 954 "trace/trace-hw_virtio.h"
        } else {
#line 24 "../hw/virtio/trace-events"
            qemu_log("vhost_user_set_mem_table_withfd " "%d:%s: size:0x%"PRIx64" GPA:0x%"PRIx64" QVA/userspace:0x%"PRIx64" RB offset:0x%"PRIx64 "\n", index, name, memory_size, guest_phys_addr, userspace_addr, offset);
#line 958 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_user_set_mem_table_withfd(int index, const char * name, uint64_t memory_size, uint64_t guest_phys_addr, uint64_t userspace_addr, uint64_t offset)
{
    if (true) {
        _nocheck__trace_vhost_user_set_mem_table_withfd(index, name, memory_size, guest_phys_addr, userspace_addr, offset);
    }
}

#define TRACE_VHOST_USER_POSTCOPY_WAKER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_USER_POSTCOPY_WAKER) || \
    false)

static inline void _nocheck__trace_vhost_user_postcopy_waker(const char * rb, uint64_t rb_offset)
{
    if (trace_event_get_state(TRACE_VHOST_USER_POSTCOPY_WAKER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 25 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_user_postcopy_waker " "%s + 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , rb, rb_offset);
#line 985 "trace/trace-hw_virtio.h"
        } else {
#line 25 "../hw/virtio/trace-events"
            qemu_log("vhost_user_postcopy_waker " "%s + 0x%"PRIx64 "\n", rb, rb_offset);
#line 989 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_user_postcopy_waker(const char * rb, uint64_t rb_offset)
{
    if (true) {
        _nocheck__trace_vhost_user_postcopy_waker(rb, rb_offset);
    }
}

#define TRACE_VHOST_USER_POSTCOPY_WAKER_FOUND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_USER_POSTCOPY_WAKER_FOUND) || \
    false)

static inline void _nocheck__trace_vhost_user_postcopy_waker_found(uint64_t client_addr)
{
    if (trace_event_get_state(TRACE_VHOST_USER_POSTCOPY_WAKER_FOUND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 26 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_user_postcopy_waker_found " "0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , client_addr);
#line 1016 "trace/trace-hw_virtio.h"
        } else {
#line 26 "../hw/virtio/trace-events"
            qemu_log("vhost_user_postcopy_waker_found " "0x%"PRIx64 "\n", client_addr);
#line 1020 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_user_postcopy_waker_found(uint64_t client_addr)
{
    if (true) {
        _nocheck__trace_vhost_user_postcopy_waker_found(client_addr);
    }
}

#define TRACE_VHOST_USER_POSTCOPY_WAKER_NOMATCH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_USER_POSTCOPY_WAKER_NOMATCH) || \
    false)

static inline void _nocheck__trace_vhost_user_postcopy_waker_nomatch(const char * rb, uint64_t rb_offset)
{
    if (trace_event_get_state(TRACE_VHOST_USER_POSTCOPY_WAKER_NOMATCH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 27 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_user_postcopy_waker_nomatch " "%s + 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , rb, rb_offset);
#line 1047 "trace/trace-hw_virtio.h"
        } else {
#line 27 "../hw/virtio/trace-events"
            qemu_log("vhost_user_postcopy_waker_nomatch " "%s + 0x%"PRIx64 "\n", rb, rb_offset);
#line 1051 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_user_postcopy_waker_nomatch(const char * rb, uint64_t rb_offset)
{
    if (true) {
        _nocheck__trace_vhost_user_postcopy_waker_nomatch(rb, rb_offset);
    }
}

#define TRACE_VHOST_USER_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_USER_READ) || \
    false)

static inline void _nocheck__trace_vhost_user_read(uint32_t req, uint32_t flags)
{
    if (trace_event_get_state(TRACE_VHOST_USER_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 28 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_user_read " "req:%d flags:0x%"PRIx32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , req, flags);
#line 1078 "trace/trace-hw_virtio.h"
        } else {
#line 28 "../hw/virtio/trace-events"
            qemu_log("vhost_user_read " "req:%d flags:0x%"PRIx32"" "\n", req, flags);
#line 1082 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_user_read(uint32_t req, uint32_t flags)
{
    if (true) {
        _nocheck__trace_vhost_user_read(req, flags);
    }
}

#define TRACE_VHOST_USER_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_USER_WRITE) || \
    false)

static inline void _nocheck__trace_vhost_user_write(uint32_t req, uint32_t flags)
{
    if (trace_event_get_state(TRACE_VHOST_USER_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 29 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_user_write " "req:%d flags:0x%"PRIx32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , req, flags);
#line 1109 "trace/trace-hw_virtio.h"
        } else {
#line 29 "../hw/virtio/trace-events"
            qemu_log("vhost_user_write " "req:%d flags:0x%"PRIx32"" "\n", req, flags);
#line 1113 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_user_write(uint32_t req, uint32_t flags)
{
    if (true) {
        _nocheck__trace_vhost_user_write(req, flags);
    }
}

#define TRACE_VHOST_USER_CREATE_NOTIFIER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_USER_CREATE_NOTIFIER) || \
    false)

static inline void _nocheck__trace_vhost_user_create_notifier(int idx, void * n)
{
    if (trace_event_get_state(TRACE_VHOST_USER_CREATE_NOTIFIER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 30 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_user_create_notifier " "idx:%d n:%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , idx, n);
#line 1140 "trace/trace-hw_virtio.h"
        } else {
#line 30 "../hw/virtio/trace-events"
            qemu_log("vhost_user_create_notifier " "idx:%d n:%p" "\n", idx, n);
#line 1144 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_user_create_notifier(int idx, void * n)
{
    if (true) {
        _nocheck__trace_vhost_user_create_notifier(idx, n);
    }
}

#define TRACE_VHOST_VDPA_SKIPPED_MEMORY_SECTION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_SKIPPED_MEMORY_SECTION) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_skipped_memory_section(int is_ram, int is_iommu, int is_protected, int is_ram_device, uint64_t first, uint64_t last, int page_mask)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_SKIPPED_MEMORY_SECTION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 33 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_skipped_memory_section " "is_ram=%d, is_iommu=%d, is_protected=%d, is_ram_device=%d iova_min=0x%"PRIx64" iova_last=0x%"PRIx64" page_mask=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , is_ram, is_iommu, is_protected, is_ram_device, first, last, page_mask);
#line 1171 "trace/trace-hw_virtio.h"
        } else {
#line 33 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_skipped_memory_section " "is_ram=%d, is_iommu=%d, is_protected=%d, is_ram_device=%d iova_min=0x%"PRIx64" iova_last=0x%"PRIx64" page_mask=0x%x" "\n", is_ram, is_iommu, is_protected, is_ram_device, first, last, page_mask);
#line 1175 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_skipped_memory_section(int is_ram, int is_iommu, int is_protected, int is_ram_device, uint64_t first, uint64_t last, int page_mask)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_skipped_memory_section(is_ram, is_iommu, is_protected, is_ram_device, first, last, page_mask);
    }
}

#define TRACE_VHOST_VDPA_DMA_MAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_DMA_MAP) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_dma_map(void * vdpa, int fd, uint32_t msg_type, uint32_t asid, uint64_t iova, uint64_t size, uint64_t uaddr, uint8_t perm, uint8_t type)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_DMA_MAP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 34 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_dma_map " "vdpa_shared:%p fd: %d msg_type: %"PRIu32" asid: %"PRIu32" iova: 0x%"PRIx64" size: 0x%"PRIx64" uaddr: 0x%"PRIx64" perm: 0x%"PRIx8" type: %"PRIu8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vdpa, fd, msg_type, asid, iova, size, uaddr, perm, type);
#line 1202 "trace/trace-hw_virtio.h"
        } else {
#line 34 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_dma_map " "vdpa_shared:%p fd: %d msg_type: %"PRIu32" asid: %"PRIu32" iova: 0x%"PRIx64" size: 0x%"PRIx64" uaddr: 0x%"PRIx64" perm: 0x%"PRIx8" type: %"PRIu8 "\n", vdpa, fd, msg_type, asid, iova, size, uaddr, perm, type);
#line 1206 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_dma_map(void * vdpa, int fd, uint32_t msg_type, uint32_t asid, uint64_t iova, uint64_t size, uint64_t uaddr, uint8_t perm, uint8_t type)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_dma_map(vdpa, fd, msg_type, asid, iova, size, uaddr, perm, type);
    }
}

#define TRACE_VHOST_VDPA_DMA_UNMAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_DMA_UNMAP) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_dma_unmap(void * vdpa, int fd, uint32_t msg_type, uint32_t asid, uint64_t iova, uint64_t size, uint8_t type)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_DMA_UNMAP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 35 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_dma_unmap " "vdpa_shared:%p fd: %d msg_type: %"PRIu32" asid: %"PRIu32" iova: 0x%"PRIx64" size: 0x%"PRIx64" type: %"PRIu8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vdpa, fd, msg_type, asid, iova, size, type);
#line 1233 "trace/trace-hw_virtio.h"
        } else {
#line 35 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_dma_unmap " "vdpa_shared:%p fd: %d msg_type: %"PRIu32" asid: %"PRIu32" iova: 0x%"PRIx64" size: 0x%"PRIx64" type: %"PRIu8 "\n", vdpa, fd, msg_type, asid, iova, size, type);
#line 1237 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_dma_unmap(void * vdpa, int fd, uint32_t msg_type, uint32_t asid, uint64_t iova, uint64_t size, uint8_t type)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_dma_unmap(vdpa, fd, msg_type, asid, iova, size, type);
    }
}

#define TRACE_VHOST_VDPA_LISTENER_BEGIN_BATCH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_LISTENER_BEGIN_BATCH) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_listener_begin_batch(void * v, int fd, uint32_t msg_type, uint8_t type)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_LISTENER_BEGIN_BATCH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 36 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_listener_begin_batch " "vdpa_shared:%p fd: %d msg_type: %"PRIu32" type: %"PRIu8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , v, fd, msg_type, type);
#line 1264 "trace/trace-hw_virtio.h"
        } else {
#line 36 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_listener_begin_batch " "vdpa_shared:%p fd: %d msg_type: %"PRIu32" type: %"PRIu8 "\n", v, fd, msg_type, type);
#line 1268 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_listener_begin_batch(void * v, int fd, uint32_t msg_type, uint8_t type)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_listener_begin_batch(v, fd, msg_type, type);
    }
}

#define TRACE_VHOST_VDPA_LISTENER_COMMIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_LISTENER_COMMIT) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_listener_commit(void * v, int fd, uint32_t msg_type, uint8_t type)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_LISTENER_COMMIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 37 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_listener_commit " "vdpa_shared:%p fd: %d msg_type: %"PRIu32" type: %"PRIu8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , v, fd, msg_type, type);
#line 1295 "trace/trace-hw_virtio.h"
        } else {
#line 37 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_listener_commit " "vdpa_shared:%p fd: %d msg_type: %"PRIu32" type: %"PRIu8 "\n", v, fd, msg_type, type);
#line 1299 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_listener_commit(void * v, int fd, uint32_t msg_type, uint8_t type)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_listener_commit(v, fd, msg_type, type);
    }
}

#define TRACE_VHOST_VDPA_LISTENER_REGION_ADD_UNALIGNED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_LISTENER_REGION_ADD_UNALIGNED) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_listener_region_add_unaligned(void * v, const char * name, uint64_t offset_as, uint64_t offset_page)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_LISTENER_REGION_ADD_UNALIGNED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 38 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_listener_region_add_unaligned " "vdpa_shared: %p region %s offset_within_address_space %"PRIu64" offset_within_region %"PRIu64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , v, name, offset_as, offset_page);
#line 1326 "trace/trace-hw_virtio.h"
        } else {
#line 38 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_listener_region_add_unaligned " "vdpa_shared: %p region %s offset_within_address_space %"PRIu64" offset_within_region %"PRIu64 "\n", v, name, offset_as, offset_page);
#line 1330 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_listener_region_add_unaligned(void * v, const char * name, uint64_t offset_as, uint64_t offset_page)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_listener_region_add_unaligned(v, name, offset_as, offset_page);
    }
}

#define TRACE_VHOST_VDPA_LISTENER_REGION_ADD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_LISTENER_REGION_ADD) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_listener_region_add(void * vdpa, uint64_t iova, uint64_t llend, void * vaddr, bool readonly)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_LISTENER_REGION_ADD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 39 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_listener_region_add " "vdpa: %p iova 0x%"PRIx64" llend 0x%"PRIx64" vaddr: %p read-only: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vdpa, iova, llend, vaddr, readonly);
#line 1357 "trace/trace-hw_virtio.h"
        } else {
#line 39 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_listener_region_add " "vdpa: %p iova 0x%"PRIx64" llend 0x%"PRIx64" vaddr: %p read-only: %d" "\n", vdpa, iova, llend, vaddr, readonly);
#line 1361 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_listener_region_add(void * vdpa, uint64_t iova, uint64_t llend, void * vaddr, bool readonly)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_listener_region_add(vdpa, iova, llend, vaddr, readonly);
    }
}

#define TRACE_VHOST_VDPA_LISTENER_REGION_DEL_UNALIGNED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_LISTENER_REGION_DEL_UNALIGNED) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_listener_region_del_unaligned(void * v, const char * name, uint64_t offset_as, uint64_t offset_page)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_LISTENER_REGION_DEL_UNALIGNED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 40 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_listener_region_del_unaligned " "vdpa_shared: %p region %s offset_within_address_space %"PRIu64" offset_within_region %"PRIu64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , v, name, offset_as, offset_page);
#line 1388 "trace/trace-hw_virtio.h"
        } else {
#line 40 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_listener_region_del_unaligned " "vdpa_shared: %p region %s offset_within_address_space %"PRIu64" offset_within_region %"PRIu64 "\n", v, name, offset_as, offset_page);
#line 1392 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_listener_region_del_unaligned(void * v, const char * name, uint64_t offset_as, uint64_t offset_page)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_listener_region_del_unaligned(v, name, offset_as, offset_page);
    }
}

#define TRACE_VHOST_VDPA_LISTENER_REGION_DEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_LISTENER_REGION_DEL) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_listener_region_del(void * vdpa, uint64_t iova, uint64_t llend)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_LISTENER_REGION_DEL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 41 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_listener_region_del " "vdpa: %p iova 0x%"PRIx64" llend 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vdpa, iova, llend);
#line 1419 "trace/trace-hw_virtio.h"
        } else {
#line 41 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_listener_region_del " "vdpa: %p iova 0x%"PRIx64" llend 0x%"PRIx64 "\n", vdpa, iova, llend);
#line 1423 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_listener_region_del(void * vdpa, uint64_t iova, uint64_t llend)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_listener_region_del(vdpa, iova, llend);
    }
}

#define TRACE_VHOST_VDPA_ADD_STATUS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_ADD_STATUS) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_add_status(void * dev, uint8_t status)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_ADD_STATUS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 42 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_add_status " "dev: %p status: 0x%"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, status);
#line 1450 "trace/trace-hw_virtio.h"
        } else {
#line 42 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_add_status " "dev: %p status: 0x%"PRIx8 "\n", dev, status);
#line 1454 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_add_status(void * dev, uint8_t status)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_add_status(dev, status);
    }
}

#define TRACE_VHOST_VDPA_INIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_INIT) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_init(void * dev, void * s, void * vdpa)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_INIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 43 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_init " "dev: %p, common dev: %p vdpa: %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, s, vdpa);
#line 1481 "trace/trace-hw_virtio.h"
        } else {
#line 43 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_init " "dev: %p, common dev: %p vdpa: %p" "\n", dev, s, vdpa);
#line 1485 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_init(void * dev, void * s, void * vdpa)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_init(dev, s, vdpa);
    }
}

#define TRACE_VHOST_VDPA_CLEANUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_CLEANUP) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_cleanup(void * dev, void * vdpa)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_CLEANUP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 44 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_cleanup " "dev: %p vdpa: %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, vdpa);
#line 1512 "trace/trace-hw_virtio.h"
        } else {
#line 44 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_cleanup " "dev: %p vdpa: %p" "\n", dev, vdpa);
#line 1516 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_cleanup(void * dev, void * vdpa)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_cleanup(dev, vdpa);
    }
}

#define TRACE_VHOST_VDPA_MEMSLOTS_LIMIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_MEMSLOTS_LIMIT) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_memslots_limit(void * dev, int ret)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_MEMSLOTS_LIMIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 45 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_memslots_limit " "dev: %p = 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, ret);
#line 1543 "trace/trace-hw_virtio.h"
        } else {
#line 45 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_memslots_limit " "dev: %p = 0x%x" "\n", dev, ret);
#line 1547 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_memslots_limit(void * dev, int ret)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_memslots_limit(dev, ret);
    }
}

#define TRACE_VHOST_VDPA_SET_MEM_TABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_SET_MEM_TABLE) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_set_mem_table(void * dev, uint32_t nregions, uint32_t padding)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_SET_MEM_TABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 46 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_set_mem_table " "dev: %p nregions: %"PRIu32" padding: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, nregions, padding);
#line 1574 "trace/trace-hw_virtio.h"
        } else {
#line 46 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_set_mem_table " "dev: %p nregions: %"PRIu32" padding: 0x%"PRIx32 "\n", dev, nregions, padding);
#line 1578 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_set_mem_table(void * dev, uint32_t nregions, uint32_t padding)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_set_mem_table(dev, nregions, padding);
    }
}

#define TRACE_VHOST_VDPA_DUMP_REGIONS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_DUMP_REGIONS) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_dump_regions(void * dev, int i, uint64_t guest_phys_addr, uint64_t memory_size, uint64_t userspace_addr, uint64_t flags_padding)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_DUMP_REGIONS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 47 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_dump_regions " "dev: %p %d: guest_phys_addr: 0x%"PRIx64" memory_size: 0x%"PRIx64" userspace_addr: 0x%"PRIx64" flags_padding: 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, i, guest_phys_addr, memory_size, userspace_addr, flags_padding);
#line 1605 "trace/trace-hw_virtio.h"
        } else {
#line 47 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_dump_regions " "dev: %p %d: guest_phys_addr: 0x%"PRIx64" memory_size: 0x%"PRIx64" userspace_addr: 0x%"PRIx64" flags_padding: 0x%"PRIx64 "\n", dev, i, guest_phys_addr, memory_size, userspace_addr, flags_padding);
#line 1609 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_dump_regions(void * dev, int i, uint64_t guest_phys_addr, uint64_t memory_size, uint64_t userspace_addr, uint64_t flags_padding)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_dump_regions(dev, i, guest_phys_addr, memory_size, userspace_addr, flags_padding);
    }
}

#define TRACE_VHOST_VDPA_SET_FEATURES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_SET_FEATURES) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_set_features(void * dev, uint64_t features)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_SET_FEATURES) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 48 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_set_features " "dev: %p features: 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, features);
#line 1636 "trace/trace-hw_virtio.h"
        } else {
#line 48 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_set_features " "dev: %p features: 0x%"PRIx64 "\n", dev, features);
#line 1640 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_set_features(void * dev, uint64_t features)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_set_features(dev, features);
    }
}

#define TRACE_VHOST_VDPA_GET_DEVICE_ID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_GET_DEVICE_ID) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_get_device_id(void * dev, uint32_t device_id)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_GET_DEVICE_ID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 49 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_get_device_id " "dev: %p device_id %"PRIu32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, device_id);
#line 1667 "trace/trace-hw_virtio.h"
        } else {
#line 49 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_get_device_id " "dev: %p device_id %"PRIu32 "\n", dev, device_id);
#line 1671 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_get_device_id(void * dev, uint32_t device_id)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_get_device_id(dev, device_id);
    }
}

#define TRACE_VHOST_VDPA_RESET_DEVICE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_RESET_DEVICE) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_reset_device(void * dev)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_RESET_DEVICE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 50 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_reset_device " "dev: %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev);
#line 1698 "trace/trace-hw_virtio.h"
        } else {
#line 50 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_reset_device " "dev: %p" "\n", dev);
#line 1702 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_reset_device(void * dev)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_reset_device(dev);
    }
}

#define TRACE_VHOST_VDPA_GET_VQ_INDEX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_GET_VQ_INDEX) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_get_vq_index(void * dev, int idx, int vq_idx)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_GET_VQ_INDEX) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 51 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_get_vq_index " "dev: %p idx: %d vq idx: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, idx, vq_idx);
#line 1729 "trace/trace-hw_virtio.h"
        } else {
#line 51 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_get_vq_index " "dev: %p idx: %d vq idx: %d" "\n", dev, idx, vq_idx);
#line 1733 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_get_vq_index(void * dev, int idx, int vq_idx)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_get_vq_index(dev, idx, vq_idx);
    }
}

#define TRACE_VHOST_VDPA_SET_VRING_ENABLE_ONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_SET_VRING_ENABLE_ONE) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_set_vring_enable_one(void * dev, unsigned i, int enable, int r)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_SET_VRING_ENABLE_ONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 52 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_set_vring_enable_one " "dev: %p, idx: %u, enable: %u, r: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, i, enable, r);
#line 1760 "trace/trace-hw_virtio.h"
        } else {
#line 52 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_set_vring_enable_one " "dev: %p, idx: %u, enable: %u, r: %d" "\n", dev, i, enable, r);
#line 1764 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_set_vring_enable_one(void * dev, unsigned i, int enable, int r)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_set_vring_enable_one(dev, i, enable, r);
    }
}

#define TRACE_VHOST_VDPA_DUMP_CONFIG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_DUMP_CONFIG) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_dump_config(void * dev, unsigned ofs, const char * line)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_DUMP_CONFIG) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 53 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_dump_config " "dev: %p 0x%04x: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, ofs, line);
#line 1791 "trace/trace-hw_virtio.h"
        } else {
#line 53 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_dump_config " "dev: %p 0x%04x: %s" "\n", dev, ofs, line);
#line 1795 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_dump_config(void * dev, unsigned ofs, const char * line)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_dump_config(dev, ofs, line);
    }
}

#define TRACE_VHOST_VDPA_SET_CONFIG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_SET_CONFIG) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_set_config(void * dev, uint32_t offset, uint32_t size, uint32_t flags)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_SET_CONFIG) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 54 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_set_config " "dev: %p offset: %"PRIu32" size: %"PRIu32" flags: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, offset, size, flags);
#line 1822 "trace/trace-hw_virtio.h"
        } else {
#line 54 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_set_config " "dev: %p offset: %"PRIu32" size: %"PRIu32" flags: 0x%"PRIx32 "\n", dev, offset, size, flags);
#line 1826 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_set_config(void * dev, uint32_t offset, uint32_t size, uint32_t flags)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_set_config(dev, offset, size, flags);
    }
}

#define TRACE_VHOST_VDPA_GET_CONFIG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_GET_CONFIG) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_get_config(void * dev, void * config, uint32_t config_len)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_GET_CONFIG) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 55 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_get_config " "dev: %p config: %p config_len: %"PRIu32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, config, config_len);
#line 1853 "trace/trace-hw_virtio.h"
        } else {
#line 55 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_get_config " "dev: %p config: %p config_len: %"PRIu32 "\n", dev, config, config_len);
#line 1857 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_get_config(void * dev, void * config, uint32_t config_len)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_get_config(dev, config, config_len);
    }
}

#define TRACE_VHOST_VDPA_SUSPEND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_SUSPEND) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_suspend(void * dev)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_SUSPEND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 56 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_suspend " "dev: %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev);
#line 1884 "trace/trace-hw_virtio.h"
        } else {
#line 56 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_suspend " "dev: %p" "\n", dev);
#line 1888 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_suspend(void * dev)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_suspend(dev);
    }
}

#define TRACE_VHOST_VDPA_DEV_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_DEV_START) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_dev_start(void * dev, bool started)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_DEV_START) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 57 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_dev_start " "dev: %p started: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, started);
#line 1915 "trace/trace-hw_virtio.h"
        } else {
#line 57 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_dev_start " "dev: %p started: %d" "\n", dev, started);
#line 1919 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_dev_start(void * dev, bool started)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_dev_start(dev, started);
    }
}

#define TRACE_VHOST_VDPA_SET_LOG_BASE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_SET_LOG_BASE) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_set_log_base(void * dev, uint64_t base, unsigned long long size, int refcnt, int fd, void * log)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_SET_LOG_BASE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 58 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_set_log_base " "dev: %p base: 0x%"PRIx64" size: %llu refcnt: %d fd: %d log: %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, base, size, refcnt, fd, log);
#line 1946 "trace/trace-hw_virtio.h"
        } else {
#line 58 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_set_log_base " "dev: %p base: 0x%"PRIx64" size: %llu refcnt: %d fd: %d log: %p" "\n", dev, base, size, refcnt, fd, log);
#line 1950 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_set_log_base(void * dev, uint64_t base, unsigned long long size, int refcnt, int fd, void * log)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_set_log_base(dev, base, size, refcnt, fd, log);
    }
}

#define TRACE_VHOST_VDPA_SET_VRING_ADDR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_SET_VRING_ADDR) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_set_vring_addr(void * dev, unsigned int index, unsigned int flags, uint64_t desc_user_addr, uint64_t used_user_addr, uint64_t avail_user_addr, uint64_t log_guest_addr)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_SET_VRING_ADDR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 59 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_set_vring_addr " "dev: %p index: %u flags: 0x%x desc_user_addr: 0x%"PRIx64" used_user_addr: 0x%"PRIx64" avail_user_addr: 0x%"PRIx64" log_guest_addr: 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, index, flags, desc_user_addr, used_user_addr, avail_user_addr, log_guest_addr);
#line 1977 "trace/trace-hw_virtio.h"
        } else {
#line 59 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_set_vring_addr " "dev: %p index: %u flags: 0x%x desc_user_addr: 0x%"PRIx64" used_user_addr: 0x%"PRIx64" avail_user_addr: 0x%"PRIx64" log_guest_addr: 0x%"PRIx64 "\n", dev, index, flags, desc_user_addr, used_user_addr, avail_user_addr, log_guest_addr);
#line 1981 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_set_vring_addr(void * dev, unsigned int index, unsigned int flags, uint64_t desc_user_addr, uint64_t used_user_addr, uint64_t avail_user_addr, uint64_t log_guest_addr)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_set_vring_addr(dev, index, flags, desc_user_addr, used_user_addr, avail_user_addr, log_guest_addr);
    }
}

#define TRACE_VHOST_VDPA_SET_VRING_NUM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_SET_VRING_NUM) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_set_vring_num(void * dev, unsigned int index, unsigned int num)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_SET_VRING_NUM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 60 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_set_vring_num " "dev: %p index: %u num: %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, index, num);
#line 2008 "trace/trace-hw_virtio.h"
        } else {
#line 60 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_set_vring_num " "dev: %p index: %u num: %u" "\n", dev, index, num);
#line 2012 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_set_vring_num(void * dev, unsigned int index, unsigned int num)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_set_vring_num(dev, index, num);
    }
}

#define TRACE_VHOST_VDPA_SET_DEV_VRING_BASE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_SET_DEV_VRING_BASE) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_set_dev_vring_base(void * dev, unsigned int index, unsigned int num, bool svq)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_SET_DEV_VRING_BASE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 61 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_set_dev_vring_base " "dev: %p index: %u num: %u svq: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, index, num, svq);
#line 2039 "trace/trace-hw_virtio.h"
        } else {
#line 61 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_set_dev_vring_base " "dev: %p index: %u num: %u svq: %d" "\n", dev, index, num, svq);
#line 2043 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_set_dev_vring_base(void * dev, unsigned int index, unsigned int num, bool svq)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_set_dev_vring_base(dev, index, num, svq);
    }
}

#define TRACE_VHOST_VDPA_GET_VRING_BASE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_GET_VRING_BASE) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_get_vring_base(void * dev, unsigned int index, unsigned int num, bool svq)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_GET_VRING_BASE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 62 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_get_vring_base " "dev: %p index: %u num: %u svq: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, index, num, svq);
#line 2070 "trace/trace-hw_virtio.h"
        } else {
#line 62 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_get_vring_base " "dev: %p index: %u num: %u svq: %d" "\n", dev, index, num, svq);
#line 2074 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_get_vring_base(void * dev, unsigned int index, unsigned int num, bool svq)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_get_vring_base(dev, index, num, svq);
    }
}

#define TRACE_VHOST_VDPA_SET_VRING_KICK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_SET_VRING_KICK) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_set_vring_kick(void * dev, unsigned int index, int fd)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_SET_VRING_KICK) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 63 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_set_vring_kick " "dev: %p index: %u fd: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, index, fd);
#line 2101 "trace/trace-hw_virtio.h"
        } else {
#line 63 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_set_vring_kick " "dev: %p index: %u fd: %d" "\n", dev, index, fd);
#line 2105 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_set_vring_kick(void * dev, unsigned int index, int fd)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_set_vring_kick(dev, index, fd);
    }
}

#define TRACE_VHOST_VDPA_SET_VRING_CALL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_SET_VRING_CALL) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_set_vring_call(void * dev, unsigned int index, int fd)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_SET_VRING_CALL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 64 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_set_vring_call " "dev: %p index: %u fd: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, index, fd);
#line 2132 "trace/trace-hw_virtio.h"
        } else {
#line 64 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_set_vring_call " "dev: %p index: %u fd: %d" "\n", dev, index, fd);
#line 2136 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_set_vring_call(void * dev, unsigned int index, int fd)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_set_vring_call(dev, index, fd);
    }
}

#define TRACE_VHOST_VDPA_GET_FEATURES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_GET_FEATURES) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_get_features(void * dev, uint64_t features)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_GET_FEATURES) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 65 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_get_features " "dev: %p features: 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, features);
#line 2163 "trace/trace-hw_virtio.h"
        } else {
#line 65 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_get_features " "dev: %p features: 0x%"PRIx64 "\n", dev, features);
#line 2167 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_get_features(void * dev, uint64_t features)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_get_features(dev, features);
    }
}

#define TRACE_VHOST_VDPA_SET_OWNER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_SET_OWNER) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_set_owner(void * dev)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_SET_OWNER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 66 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_set_owner " "dev: %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev);
#line 2194 "trace/trace-hw_virtio.h"
        } else {
#line 66 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_set_owner " "dev: %p" "\n", dev);
#line 2198 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_set_owner(void * dev)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_set_owner(dev);
    }
}

#define TRACE_VHOST_VDPA_VQ_GET_ADDR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_VQ_GET_ADDR) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_vq_get_addr(void * dev, void * vq, uint64_t desc_user_addr, uint64_t avail_user_addr, uint64_t used_user_addr)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_VQ_GET_ADDR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 67 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_vq_get_addr " "dev: %p vq: %p desc_user_addr: 0x%"PRIx64" avail_user_addr: 0x%"PRIx64" used_user_addr: 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, vq, desc_user_addr, avail_user_addr, used_user_addr);
#line 2225 "trace/trace-hw_virtio.h"
        } else {
#line 67 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_vq_get_addr " "dev: %p vq: %p desc_user_addr: 0x%"PRIx64" avail_user_addr: 0x%"PRIx64" used_user_addr: 0x%"PRIx64 "\n", dev, vq, desc_user_addr, avail_user_addr, used_user_addr);
#line 2229 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_vq_get_addr(void * dev, void * vq, uint64_t desc_user_addr, uint64_t avail_user_addr, uint64_t used_user_addr)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_vq_get_addr(dev, vq, desc_user_addr, avail_user_addr, used_user_addr);
    }
}

#define TRACE_VHOST_VDPA_GET_IOVA_RANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_GET_IOVA_RANGE) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_get_iova_range(void * dev, uint64_t first, uint64_t last)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_GET_IOVA_RANGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 68 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_get_iova_range " "dev: %p first: 0x%"PRIx64" last: 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, first, last);
#line 2256 "trace/trace-hw_virtio.h"
        } else {
#line 68 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_get_iova_range " "dev: %p first: 0x%"PRIx64" last: 0x%"PRIx64 "\n", dev, first, last);
#line 2260 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_get_iova_range(void * dev, uint64_t first, uint64_t last)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_get_iova_range(dev, first, last);
    }
}

#define TRACE_VHOST_VDPA_SET_CONFIG_CALL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_VDPA_SET_CONFIG_CALL) || \
    false)

static inline void _nocheck__trace_vhost_vdpa_set_config_call(void * dev, int fd)
{
    if (trace_event_get_state(TRACE_VHOST_VDPA_SET_CONFIG_CALL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 69 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:vhost_vdpa_set_config_call " "dev: %p fd: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, fd);
#line 2287 "trace/trace-hw_virtio.h"
        } else {
#line 69 "../hw/virtio/trace-events"
            qemu_log("vhost_vdpa_set_config_call " "dev: %p fd: %d" "\n", dev, fd);
#line 2291 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_vhost_vdpa_set_config_call(void * dev, int fd)
{
    if (true) {
        _nocheck__trace_vhost_vdpa_set_config_call(dev, fd);
    }
}

#define TRACE_VIRTQUEUE_ALLOC_ELEMENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTQUEUE_ALLOC_ELEMENT) || \
    false)

static inline void _nocheck__trace_virtqueue_alloc_element(void * elem, size_t sz, unsigned in_num, unsigned out_num)
{
    if (trace_event_get_state(TRACE_VIRTQUEUE_ALLOC_ELEMENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 72 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtqueue_alloc_element " "elem %p size %zd in_num %u out_num %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , elem, sz, in_num, out_num);
#line 2318 "trace/trace-hw_virtio.h"
        } else {
#line 72 "../hw/virtio/trace-events"
            qemu_log("virtqueue_alloc_element " "elem %p size %zd in_num %u out_num %u" "\n", elem, sz, in_num, out_num);
#line 2322 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtqueue_alloc_element(void * elem, size_t sz, unsigned in_num, unsigned out_num)
{
    if (true) {
        _nocheck__trace_virtqueue_alloc_element(elem, sz, in_num, out_num);
    }
}

#define TRACE_VIRTQUEUE_FILL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTQUEUE_FILL) || \
    false)

static inline void _nocheck__trace_virtqueue_fill(void * vq, const void * elem, unsigned int len, unsigned int idx)
{
    if (trace_event_get_state(TRACE_VIRTQUEUE_FILL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 73 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtqueue_fill " "vq %p elem %p len %u idx %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vq, elem, len, idx);
#line 2349 "trace/trace-hw_virtio.h"
        } else {
#line 73 "../hw/virtio/trace-events"
            qemu_log("virtqueue_fill " "vq %p elem %p len %u idx %u" "\n", vq, elem, len, idx);
#line 2353 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtqueue_fill(void * vq, const void * elem, unsigned int len, unsigned int idx)
{
    if (true) {
        _nocheck__trace_virtqueue_fill(vq, elem, len, idx);
    }
}

#define TRACE_VIRTQUEUE_FLUSH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTQUEUE_FLUSH) || \
    false)

static inline void _nocheck__trace_virtqueue_flush(void * vq, unsigned int count)
{
    if (trace_event_get_state(TRACE_VIRTQUEUE_FLUSH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 74 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtqueue_flush " "vq %p count %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vq, count);
#line 2380 "trace/trace-hw_virtio.h"
        } else {
#line 74 "../hw/virtio/trace-events"
            qemu_log("virtqueue_flush " "vq %p count %u" "\n", vq, count);
#line 2384 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtqueue_flush(void * vq, unsigned int count)
{
    if (true) {
        _nocheck__trace_virtqueue_flush(vq, count);
    }
}

#define TRACE_VIRTQUEUE_POP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTQUEUE_POP) || \
    false)

static inline void _nocheck__trace_virtqueue_pop(void * vq, void * elem, unsigned int in_num, unsigned int out_num)
{
    if (trace_event_get_state(TRACE_VIRTQUEUE_POP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 75 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtqueue_pop " "vq %p elem %p in_num %u out_num %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vq, elem, in_num, out_num);
#line 2411 "trace/trace-hw_virtio.h"
        } else {
#line 75 "../hw/virtio/trace-events"
            qemu_log("virtqueue_pop " "vq %p elem %p in_num %u out_num %u" "\n", vq, elem, in_num, out_num);
#line 2415 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtqueue_pop(void * vq, void * elem, unsigned int in_num, unsigned int out_num)
{
    if (true) {
        _nocheck__trace_virtqueue_pop(vq, elem, in_num, out_num);
    }
}

#define TRACE_VIRTIO_QUEUE_NOTIFY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_QUEUE_NOTIFY) || \
    false)

static inline void _nocheck__trace_virtio_queue_notify(void * vdev, int n, void * vq)
{
    if (trace_event_get_state(TRACE_VIRTIO_QUEUE_NOTIFY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 76 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_queue_notify " "vdev %p n %d vq %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vdev, n, vq);
#line 2442 "trace/trace-hw_virtio.h"
        } else {
#line 76 "../hw/virtio/trace-events"
            qemu_log("virtio_queue_notify " "vdev %p n %d vq %p" "\n", vdev, n, vq);
#line 2446 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_queue_notify(void * vdev, int n, void * vq)
{
    if (true) {
        _nocheck__trace_virtio_queue_notify(vdev, n, vq);
    }
}

#define TRACE_VIRTIO_NOTIFY_IRQFD_DEFERRED_FN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_NOTIFY_IRQFD_DEFERRED_FN) || \
    false)

static inline void _nocheck__trace_virtio_notify_irqfd_deferred_fn(void * vdev, void * vq)
{
    if (trace_event_get_state(TRACE_VIRTIO_NOTIFY_IRQFD_DEFERRED_FN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 77 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_notify_irqfd_deferred_fn " "vdev %p vq %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vdev, vq);
#line 2473 "trace/trace-hw_virtio.h"
        } else {
#line 77 "../hw/virtio/trace-events"
            qemu_log("virtio_notify_irqfd_deferred_fn " "vdev %p vq %p" "\n", vdev, vq);
#line 2477 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_notify_irqfd_deferred_fn(void * vdev, void * vq)
{
    if (true) {
        _nocheck__trace_virtio_notify_irqfd_deferred_fn(vdev, vq);
    }
}

#define TRACE_VIRTIO_NOTIFY_IRQFD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_NOTIFY_IRQFD) || \
    false)

static inline void _nocheck__trace_virtio_notify_irqfd(void * vdev, void * vq)
{
    if (trace_event_get_state(TRACE_VIRTIO_NOTIFY_IRQFD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 78 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_notify_irqfd " "vdev %p vq %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vdev, vq);
#line 2504 "trace/trace-hw_virtio.h"
        } else {
#line 78 "../hw/virtio/trace-events"
            qemu_log("virtio_notify_irqfd " "vdev %p vq %p" "\n", vdev, vq);
#line 2508 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_notify_irqfd(void * vdev, void * vq)
{
    if (true) {
        _nocheck__trace_virtio_notify_irqfd(vdev, vq);
    }
}

#define TRACE_VIRTIO_NOTIFY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_NOTIFY) || \
    false)

static inline void _nocheck__trace_virtio_notify(void * vdev, void * vq)
{
    if (trace_event_get_state(TRACE_VIRTIO_NOTIFY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 79 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_notify " "vdev %p vq %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vdev, vq);
#line 2535 "trace/trace-hw_virtio.h"
        } else {
#line 79 "../hw/virtio/trace-events"
            qemu_log("virtio_notify " "vdev %p vq %p" "\n", vdev, vq);
#line 2539 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_notify(void * vdev, void * vq)
{
    if (true) {
        _nocheck__trace_virtio_notify(vdev, vq);
    }
}

#define TRACE_VIRTIO_SET_STATUS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_SET_STATUS) || \
    false)

static inline void _nocheck__trace_virtio_set_status(void * vdev, uint8_t val)
{
    if (trace_event_get_state(TRACE_VIRTIO_SET_STATUS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 80 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_set_status " "vdev %p val %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vdev, val);
#line 2566 "trace/trace-hw_virtio.h"
        } else {
#line 80 "../hw/virtio/trace-events"
            qemu_log("virtio_set_status " "vdev %p val %u" "\n", vdev, val);
#line 2570 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_set_status(void * vdev, uint8_t val)
{
    if (true) {
        _nocheck__trace_virtio_set_status(vdev, val);
    }
}

#define TRACE_VIRTIO_RNG_GUEST_NOT_READY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_RNG_GUEST_NOT_READY) || \
    false)

static inline void _nocheck__trace_virtio_rng_guest_not_ready(void * rng)
{
    if (trace_event_get_state(TRACE_VIRTIO_RNG_GUEST_NOT_READY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 83 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_rng_guest_not_ready " "rng %p: guest not ready" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , rng);
#line 2597 "trace/trace-hw_virtio.h"
        } else {
#line 83 "../hw/virtio/trace-events"
            qemu_log("virtio_rng_guest_not_ready " "rng %p: guest not ready" "\n", rng);
#line 2601 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_rng_guest_not_ready(void * rng)
{
    if (true) {
        _nocheck__trace_virtio_rng_guest_not_ready(rng);
    }
}

#define TRACE_VIRTIO_RNG_CPU_IS_STOPPED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_RNG_CPU_IS_STOPPED) || \
    false)

static inline void _nocheck__trace_virtio_rng_cpu_is_stopped(void * rng, int size)
{
    if (trace_event_get_state(TRACE_VIRTIO_RNG_CPU_IS_STOPPED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 84 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_rng_cpu_is_stopped " "rng %p: cpu is stopped, dropping %d bytes" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , rng, size);
#line 2628 "trace/trace-hw_virtio.h"
        } else {
#line 84 "../hw/virtio/trace-events"
            qemu_log("virtio_rng_cpu_is_stopped " "rng %p: cpu is stopped, dropping %d bytes" "\n", rng, size);
#line 2632 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_rng_cpu_is_stopped(void * rng, int size)
{
    if (true) {
        _nocheck__trace_virtio_rng_cpu_is_stopped(rng, size);
    }
}

#define TRACE_VIRTIO_RNG_POPPED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_RNG_POPPED) || \
    false)

static inline void _nocheck__trace_virtio_rng_popped(void * rng)
{
    if (trace_event_get_state(TRACE_VIRTIO_RNG_POPPED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 85 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_rng_popped " "rng %p: elem popped" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , rng);
#line 2659 "trace/trace-hw_virtio.h"
        } else {
#line 85 "../hw/virtio/trace-events"
            qemu_log("virtio_rng_popped " "rng %p: elem popped" "\n", rng);
#line 2663 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_rng_popped(void * rng)
{
    if (true) {
        _nocheck__trace_virtio_rng_popped(rng);
    }
}

#define TRACE_VIRTIO_RNG_PUSHED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_RNG_PUSHED) || \
    false)

static inline void _nocheck__trace_virtio_rng_pushed(void * rng, size_t len)
{
    if (trace_event_get_state(TRACE_VIRTIO_RNG_PUSHED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 86 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_rng_pushed " "rng %p: %zd bytes pushed" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , rng, len);
#line 2690 "trace/trace-hw_virtio.h"
        } else {
#line 86 "../hw/virtio/trace-events"
            qemu_log("virtio_rng_pushed " "rng %p: %zd bytes pushed" "\n", rng, len);
#line 2694 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_rng_pushed(void * rng, size_t len)
{
    if (true) {
        _nocheck__trace_virtio_rng_pushed(rng, len);
    }
}

#define TRACE_VIRTIO_RNG_REQUEST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_RNG_REQUEST) || \
    false)

static inline void _nocheck__trace_virtio_rng_request(void * rng, size_t size, unsigned quota)
{
    if (trace_event_get_state(TRACE_VIRTIO_RNG_REQUEST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 87 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_rng_request " "rng %p: %zd bytes requested, %u bytes quota left" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , rng, size, quota);
#line 2721 "trace/trace-hw_virtio.h"
        } else {
#line 87 "../hw/virtio/trace-events"
            qemu_log("virtio_rng_request " "rng %p: %zd bytes requested, %u bytes quota left" "\n", rng, size, quota);
#line 2725 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_rng_request(void * rng, size_t size, unsigned quota)
{
    if (true) {
        _nocheck__trace_virtio_rng_request(rng, size, quota);
    }
}

#define TRACE_VIRTIO_RNG_VM_STATE_CHANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_RNG_VM_STATE_CHANGE) || \
    false)

static inline void _nocheck__trace_virtio_rng_vm_state_change(void * rng, int running, int state)
{
    if (trace_event_get_state(TRACE_VIRTIO_RNG_VM_STATE_CHANGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 88 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_rng_vm_state_change " "rng %p: state change to running %d state %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , rng, running, state);
#line 2752 "trace/trace-hw_virtio.h"
        } else {
#line 88 "../hw/virtio/trace-events"
            qemu_log("virtio_rng_vm_state_change " "rng %p: state change to running %d state %d" "\n", rng, running, state);
#line 2756 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_rng_vm_state_change(void * rng, int running, int state)
{
    if (true) {
        _nocheck__trace_virtio_rng_vm_state_change(rng, running, state);
    }
}

#define TRACE_VIRTIO_BALLOON_BAD_ADDR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BALLOON_BAD_ADDR) || \
    false)

static inline void _nocheck__trace_virtio_balloon_bad_addr(uint64_t gpa)
{
    if (trace_event_get_state(TRACE_VIRTIO_BALLOON_BAD_ADDR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 92 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_balloon_bad_addr " "0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , gpa);
#line 2783 "trace/trace-hw_virtio.h"
        } else {
#line 92 "../hw/virtio/trace-events"
            qemu_log("virtio_balloon_bad_addr " "0x%"PRIx64 "\n", gpa);
#line 2787 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_balloon_bad_addr(uint64_t gpa)
{
    if (true) {
        _nocheck__trace_virtio_balloon_bad_addr(gpa);
    }
}

#define TRACE_VIRTIO_BALLOON_HANDLE_OUTPUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BALLOON_HANDLE_OUTPUT) || \
    false)

static inline void _nocheck__trace_virtio_balloon_handle_output(const char * name, uint64_t gpa)
{
    if (trace_event_get_state(TRACE_VIRTIO_BALLOON_HANDLE_OUTPUT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 93 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_balloon_handle_output " "section name: %s gpa: 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, gpa);
#line 2814 "trace/trace-hw_virtio.h"
        } else {
#line 93 "../hw/virtio/trace-events"
            qemu_log("virtio_balloon_handle_output " "section name: %s gpa: 0x%"PRIx64 "\n", name, gpa);
#line 2818 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_balloon_handle_output(const char * name, uint64_t gpa)
{
    if (true) {
        _nocheck__trace_virtio_balloon_handle_output(name, gpa);
    }
}

#define TRACE_VIRTIO_BALLOON_GET_CONFIG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BALLOON_GET_CONFIG) || \
    false)

static inline void _nocheck__trace_virtio_balloon_get_config(uint32_t num_pages, uint32_t actual)
{
    if (trace_event_get_state(TRACE_VIRTIO_BALLOON_GET_CONFIG) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 94 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_balloon_get_config " "num_pages: %d actual: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , num_pages, actual);
#line 2845 "trace/trace-hw_virtio.h"
        } else {
#line 94 "../hw/virtio/trace-events"
            qemu_log("virtio_balloon_get_config " "num_pages: %d actual: %d" "\n", num_pages, actual);
#line 2849 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_balloon_get_config(uint32_t num_pages, uint32_t actual)
{
    if (true) {
        _nocheck__trace_virtio_balloon_get_config(num_pages, actual);
    }
}

#define TRACE_VIRTIO_BALLOON_SET_CONFIG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BALLOON_SET_CONFIG) || \
    false)

static inline void _nocheck__trace_virtio_balloon_set_config(uint32_t actual, uint32_t oldactual)
{
    if (trace_event_get_state(TRACE_VIRTIO_BALLOON_SET_CONFIG) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 95 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_balloon_set_config " "actual: %d oldactual: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , actual, oldactual);
#line 2876 "trace/trace-hw_virtio.h"
        } else {
#line 95 "../hw/virtio/trace-events"
            qemu_log("virtio_balloon_set_config " "actual: %d oldactual: %d" "\n", actual, oldactual);
#line 2880 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_balloon_set_config(uint32_t actual, uint32_t oldactual)
{
    if (true) {
        _nocheck__trace_virtio_balloon_set_config(actual, oldactual);
    }
}

#define TRACE_VIRTIO_BALLOON_TO_TARGET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BALLOON_TO_TARGET) || \
    false)

static inline void _nocheck__trace_virtio_balloon_to_target(uint64_t target, uint32_t num_pages)
{
    if (trace_event_get_state(TRACE_VIRTIO_BALLOON_TO_TARGET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 96 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_balloon_to_target " "balloon target: 0x%"PRIx64" num_pages: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , target, num_pages);
#line 2907 "trace/trace-hw_virtio.h"
        } else {
#line 96 "../hw/virtio/trace-events"
            qemu_log("virtio_balloon_to_target " "balloon target: 0x%"PRIx64" num_pages: %d" "\n", target, num_pages);
#line 2911 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_balloon_to_target(uint64_t target, uint32_t num_pages)
{
    if (true) {
        _nocheck__trace_virtio_balloon_to_target(target, num_pages);
    }
}

#define TRACE_VIRTIO_MMIO_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_MMIO_READ) || \
    false)

static inline void _nocheck__trace_virtio_mmio_read(uint64_t offset)
{
    if (trace_event_get_state(TRACE_VIRTIO_MMIO_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 99 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_mmio_read " "virtio_mmio_read offset 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset);
#line 2938 "trace/trace-hw_virtio.h"
        } else {
#line 99 "../hw/virtio/trace-events"
            qemu_log("virtio_mmio_read " "virtio_mmio_read offset 0x%" PRIx64 "\n", offset);
#line 2942 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_mmio_read(uint64_t offset)
{
    if (true) {
        _nocheck__trace_virtio_mmio_read(offset);
    }
}

#define TRACE_VIRTIO_MMIO_WRITE_OFFSET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_MMIO_WRITE_OFFSET) || \
    false)

static inline void _nocheck__trace_virtio_mmio_write_offset(uint64_t offset, uint64_t value)
{
    if (trace_event_get_state(TRACE_VIRTIO_MMIO_WRITE_OFFSET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 100 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_mmio_write_offset " "virtio_mmio_write offset 0x%" PRIx64 " value 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, value);
#line 2969 "trace/trace-hw_virtio.h"
        } else {
#line 100 "../hw/virtio/trace-events"
            qemu_log("virtio_mmio_write_offset " "virtio_mmio_write offset 0x%" PRIx64 " value 0x%" PRIx64 "\n", offset, value);
#line 2973 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_mmio_write_offset(uint64_t offset, uint64_t value)
{
    if (true) {
        _nocheck__trace_virtio_mmio_write_offset(offset, value);
    }
}

#define TRACE_VIRTIO_MMIO_GUEST_PAGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_MMIO_GUEST_PAGE) || \
    false)

static inline void _nocheck__trace_virtio_mmio_guest_page(uint64_t size, int shift)
{
    if (trace_event_get_state(TRACE_VIRTIO_MMIO_GUEST_PAGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 101 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_mmio_guest_page " "guest page size 0x%" PRIx64 " shift %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , size, shift);
#line 3000 "trace/trace-hw_virtio.h"
        } else {
#line 101 "../hw/virtio/trace-events"
            qemu_log("virtio_mmio_guest_page " "guest page size 0x%" PRIx64 " shift %d" "\n", size, shift);
#line 3004 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_mmio_guest_page(uint64_t size, int shift)
{
    if (true) {
        _nocheck__trace_virtio_mmio_guest_page(size, shift);
    }
}

#define TRACE_VIRTIO_MMIO_QUEUE_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_MMIO_QUEUE_WRITE) || \
    false)

static inline void _nocheck__trace_virtio_mmio_queue_write(uint64_t value, int max_size)
{
    if (trace_event_get_state(TRACE_VIRTIO_MMIO_QUEUE_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 102 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_mmio_queue_write " "mmio_queue write 0x%" PRIx64 " max %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , value, max_size);
#line 3031 "trace/trace-hw_virtio.h"
        } else {
#line 102 "../hw/virtio/trace-events"
            qemu_log("virtio_mmio_queue_write " "mmio_queue write 0x%" PRIx64 " max %d" "\n", value, max_size);
#line 3035 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_mmio_queue_write(uint64_t value, int max_size)
{
    if (true) {
        _nocheck__trace_virtio_mmio_queue_write(value, max_size);
    }
}

#define TRACE_VIRTIO_MMIO_SETTING_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_MMIO_SETTING_IRQ) || \
    false)

static inline void _nocheck__trace_virtio_mmio_setting_irq(int level)
{
    if (trace_event_get_state(TRACE_VIRTIO_MMIO_SETTING_IRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 103 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_mmio_setting_irq " "virtio_mmio setting IRQ %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , level);
#line 3062 "trace/trace-hw_virtio.h"
        } else {
#line 103 "../hw/virtio/trace-events"
            qemu_log("virtio_mmio_setting_irq " "virtio_mmio setting IRQ %d" "\n", level);
#line 3066 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_mmio_setting_irq(int level)
{
    if (true) {
        _nocheck__trace_virtio_mmio_setting_irq(level);
    }
}

#define TRACE_VIRTIO_PCI_NOTIFY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_PCI_NOTIFY) || \
    false)

static inline void _nocheck__trace_virtio_pci_notify(uint16_t vector)
{
    if (trace_event_get_state(TRACE_VIRTIO_PCI_NOTIFY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 106 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_pci_notify " "virtio_pci_notify vec 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vector);
#line 3093 "trace/trace-hw_virtio.h"
        } else {
#line 106 "../hw/virtio/trace-events"
            qemu_log("virtio_pci_notify " "virtio_pci_notify vec 0x%x" "\n", vector);
#line 3097 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_pci_notify(uint16_t vector)
{
    if (true) {
        _nocheck__trace_virtio_pci_notify(vector);
    }
}

#define TRACE_VIRTIO_PCI_NOTIFY_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_PCI_NOTIFY_WRITE) || \
    false)

static inline void _nocheck__trace_virtio_pci_notify_write(uint64_t addr, uint64_t val, unsigned int size)
{
    if (trace_event_get_state(TRACE_VIRTIO_PCI_NOTIFY_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 107 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_pci_notify_write " "0x%" PRIx64" = 0x%" PRIx64 " (%d)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val, size);
#line 3124 "trace/trace-hw_virtio.h"
        } else {
#line 107 "../hw/virtio/trace-events"
            qemu_log("virtio_pci_notify_write " "0x%" PRIx64" = 0x%" PRIx64 " (%d)" "\n", addr, val, size);
#line 3128 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_pci_notify_write(uint64_t addr, uint64_t val, unsigned int size)
{
    if (true) {
        _nocheck__trace_virtio_pci_notify_write(addr, val, size);
    }
}

#define TRACE_VIRTIO_PCI_NOTIFY_WRITE_PIO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_PCI_NOTIFY_WRITE_PIO) || \
    false)

static inline void _nocheck__trace_virtio_pci_notify_write_pio(uint64_t addr, uint64_t val, unsigned int size)
{
    if (trace_event_get_state(TRACE_VIRTIO_PCI_NOTIFY_WRITE_PIO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 108 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_pci_notify_write_pio " "0x%" PRIx64" = 0x%" PRIx64 " (%d)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val, size);
#line 3155 "trace/trace-hw_virtio.h"
        } else {
#line 108 "../hw/virtio/trace-events"
            qemu_log("virtio_pci_notify_write_pio " "0x%" PRIx64" = 0x%" PRIx64 " (%d)" "\n", addr, val, size);
#line 3159 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_pci_notify_write_pio(uint64_t addr, uint64_t val, unsigned int size)
{
    if (true) {
        _nocheck__trace_virtio_pci_notify_write_pio(addr, val, size);
    }
}

#define TRACE_VIRTIO_IOMMU_DEVICE_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_DEVICE_RESET) || \
    false)

static inline void _nocheck__trace_virtio_iommu_device_reset(void)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_DEVICE_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 111 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_iommu_device_reset " "reset!" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 3186 "trace/trace-hw_virtio.h"
        } else {
#line 111 "../hw/virtio/trace-events"
            qemu_log("virtio_iommu_device_reset " "reset!" "\n");
#line 3190 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_iommu_device_reset(void)
{
    if (true) {
        _nocheck__trace_virtio_iommu_device_reset();
    }
}

#define TRACE_VIRTIO_IOMMU_SYSTEM_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_SYSTEM_RESET) || \
    false)

static inline void _nocheck__trace_virtio_iommu_system_reset(void)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_SYSTEM_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 112 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_iommu_system_reset " "system reset!" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 3217 "trace/trace-hw_virtio.h"
        } else {
#line 112 "../hw/virtio/trace-events"
            qemu_log("virtio_iommu_system_reset " "system reset!" "\n");
#line 3221 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_iommu_system_reset(void)
{
    if (true) {
        _nocheck__trace_virtio_iommu_system_reset();
    }
}

#define TRACE_VIRTIO_IOMMU_GET_FEATURES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_GET_FEATURES) || \
    false)

static inline void _nocheck__trace_virtio_iommu_get_features(uint64_t features)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_GET_FEATURES) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 113 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_iommu_get_features " "device supports features=0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , features);
#line 3248 "trace/trace-hw_virtio.h"
        } else {
#line 113 "../hw/virtio/trace-events"
            qemu_log("virtio_iommu_get_features " "device supports features=0x%"PRIx64 "\n", features);
#line 3252 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_iommu_get_features(uint64_t features)
{
    if (true) {
        _nocheck__trace_virtio_iommu_get_features(features);
    }
}

#define TRACE_VIRTIO_IOMMU_DEVICE_STATUS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_DEVICE_STATUS) || \
    false)

static inline void _nocheck__trace_virtio_iommu_device_status(uint8_t status)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_DEVICE_STATUS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 114 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_iommu_device_status " "driver status = %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , status);
#line 3279 "trace/trace-hw_virtio.h"
        } else {
#line 114 "../hw/virtio/trace-events"
            qemu_log("virtio_iommu_device_status " "driver status = %d" "\n", status);
#line 3283 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_iommu_device_status(uint8_t status)
{
    if (true) {
        _nocheck__trace_virtio_iommu_device_status(status);
    }
}

#define TRACE_VIRTIO_IOMMU_GET_CONFIG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_GET_CONFIG) || \
    false)

static inline void _nocheck__trace_virtio_iommu_get_config(uint64_t page_size_mask, uint64_t start, uint64_t end, uint32_t domain_start, uint32_t domain_end, uint32_t probe_size, uint8_t bypass)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_GET_CONFIG) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 115 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_iommu_get_config " "page_size_mask=0x%"PRIx64" input range start=0x%"PRIx64" input range end=0x%"PRIx64" domain range start=%u domain range end=%u probe_size=0x%x bypass=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , page_size_mask, start, end, domain_start, domain_end, probe_size, bypass);
#line 3310 "trace/trace-hw_virtio.h"
        } else {
#line 115 "../hw/virtio/trace-events"
            qemu_log("virtio_iommu_get_config " "page_size_mask=0x%"PRIx64" input range start=0x%"PRIx64" input range end=0x%"PRIx64" domain range start=%u domain range end=%u probe_size=0x%x bypass=0x%x" "\n", page_size_mask, start, end, domain_start, domain_end, probe_size, bypass);
#line 3314 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_iommu_get_config(uint64_t page_size_mask, uint64_t start, uint64_t end, uint32_t domain_start, uint32_t domain_end, uint32_t probe_size, uint8_t bypass)
{
    if (true) {
        _nocheck__trace_virtio_iommu_get_config(page_size_mask, start, end, domain_start, domain_end, probe_size, bypass);
    }
}

#define TRACE_VIRTIO_IOMMU_SET_CONFIG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_SET_CONFIG) || \
    false)

static inline void _nocheck__trace_virtio_iommu_set_config(uint8_t bypass)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_SET_CONFIG) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 116 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_iommu_set_config " "bypass=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bypass);
#line 3341 "trace/trace-hw_virtio.h"
        } else {
#line 116 "../hw/virtio/trace-events"
            qemu_log("virtio_iommu_set_config " "bypass=0x%x" "\n", bypass);
#line 3345 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_iommu_set_config(uint8_t bypass)
{
    if (true) {
        _nocheck__trace_virtio_iommu_set_config(bypass);
    }
}

#define TRACE_VIRTIO_IOMMU_ATTACH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_ATTACH) || \
    false)

static inline void _nocheck__trace_virtio_iommu_attach(uint32_t domain_id, uint32_t ep_id)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_ATTACH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 117 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_iommu_attach " "domain=%d endpoint=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , domain_id, ep_id);
#line 3372 "trace/trace-hw_virtio.h"
        } else {
#line 117 "../hw/virtio/trace-events"
            qemu_log("virtio_iommu_attach " "domain=%d endpoint=%d" "\n", domain_id, ep_id);
#line 3376 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_iommu_attach(uint32_t domain_id, uint32_t ep_id)
{
    if (true) {
        _nocheck__trace_virtio_iommu_attach(domain_id, ep_id);
    }
}

#define TRACE_VIRTIO_IOMMU_DETACH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_DETACH) || \
    false)

static inline void _nocheck__trace_virtio_iommu_detach(uint32_t domain_id, uint32_t ep_id)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_DETACH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 118 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_iommu_detach " "domain=%d endpoint=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , domain_id, ep_id);
#line 3403 "trace/trace-hw_virtio.h"
        } else {
#line 118 "../hw/virtio/trace-events"
            qemu_log("virtio_iommu_detach " "domain=%d endpoint=%d" "\n", domain_id, ep_id);
#line 3407 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_iommu_detach(uint32_t domain_id, uint32_t ep_id)
{
    if (true) {
        _nocheck__trace_virtio_iommu_detach(domain_id, ep_id);
    }
}

#define TRACE_VIRTIO_IOMMU_DETACH_ENDPOINT_FROM_DOMAIN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_DETACH_ENDPOINT_FROM_DOMAIN) || \
    false)

static inline void _nocheck__trace_virtio_iommu_detach_endpoint_from_domain(uint32_t domain_id, uint32_t ep_id)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_DETACH_ENDPOINT_FROM_DOMAIN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 119 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_iommu_detach_endpoint_from_domain " "domain=%d endpoint=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , domain_id, ep_id);
#line 3434 "trace/trace-hw_virtio.h"
        } else {
#line 119 "../hw/virtio/trace-events"
            qemu_log("virtio_iommu_detach_endpoint_from_domain " "domain=%d endpoint=%d" "\n", domain_id, ep_id);
#line 3438 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_iommu_detach_endpoint_from_domain(uint32_t domain_id, uint32_t ep_id)
{
    if (true) {
        _nocheck__trace_virtio_iommu_detach_endpoint_from_domain(domain_id, ep_id);
    }
}

#define TRACE_VIRTIO_IOMMU_MAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_MAP) || \
    false)

static inline void _nocheck__trace_virtio_iommu_map(uint32_t domain_id, uint64_t virt_start, uint64_t virt_end, uint64_t phys_start, uint32_t flags)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_MAP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 120 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_iommu_map " "domain=%d virt_start=0x%"PRIx64" virt_end=0x%"PRIx64 " phys_start=0x%"PRIx64" flags=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , domain_id, virt_start, virt_end, phys_start, flags);
#line 3465 "trace/trace-hw_virtio.h"
        } else {
#line 120 "../hw/virtio/trace-events"
            qemu_log("virtio_iommu_map " "domain=%d virt_start=0x%"PRIx64" virt_end=0x%"PRIx64 " phys_start=0x%"PRIx64" flags=%d" "\n", domain_id, virt_start, virt_end, phys_start, flags);
#line 3469 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_iommu_map(uint32_t domain_id, uint64_t virt_start, uint64_t virt_end, uint64_t phys_start, uint32_t flags)
{
    if (true) {
        _nocheck__trace_virtio_iommu_map(domain_id, virt_start, virt_end, phys_start, flags);
    }
}

#define TRACE_VIRTIO_IOMMU_UNMAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_UNMAP) || \
    false)

static inline void _nocheck__trace_virtio_iommu_unmap(uint32_t domain_id, uint64_t virt_start, uint64_t virt_end)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_UNMAP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 121 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_iommu_unmap " "domain=%d virt_start=0x%"PRIx64" virt_end=0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , domain_id, virt_start, virt_end);
#line 3496 "trace/trace-hw_virtio.h"
        } else {
#line 121 "../hw/virtio/trace-events"
            qemu_log("virtio_iommu_unmap " "domain=%d virt_start=0x%"PRIx64" virt_end=0x%"PRIx64 "\n", domain_id, virt_start, virt_end);
#line 3500 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_iommu_unmap(uint32_t domain_id, uint64_t virt_start, uint64_t virt_end)
{
    if (true) {
        _nocheck__trace_virtio_iommu_unmap(domain_id, virt_start, virt_end);
    }
}

#define TRACE_VIRTIO_IOMMU_UNMAP_DONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_UNMAP_DONE) || \
    false)

static inline void _nocheck__trace_virtio_iommu_unmap_done(uint32_t domain_id, uint64_t virt_start, uint64_t virt_end)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_UNMAP_DONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 122 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_iommu_unmap_done " "domain=%d virt_start=0x%"PRIx64" virt_end=0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , domain_id, virt_start, virt_end);
#line 3527 "trace/trace-hw_virtio.h"
        } else {
#line 122 "../hw/virtio/trace-events"
            qemu_log("virtio_iommu_unmap_done " "domain=%d virt_start=0x%"PRIx64" virt_end=0x%"PRIx64 "\n", domain_id, virt_start, virt_end);
#line 3531 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_iommu_unmap_done(uint32_t domain_id, uint64_t virt_start, uint64_t virt_end)
{
    if (true) {
        _nocheck__trace_virtio_iommu_unmap_done(domain_id, virt_start, virt_end);
    }
}

#define TRACE_VIRTIO_IOMMU_TRANSLATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_TRANSLATE) || \
    false)

static inline void _nocheck__trace_virtio_iommu_translate(const char * name, uint32_t rid, uint64_t iova, int flag)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_TRANSLATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 123 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_iommu_translate " "mr=%s rid=%d addr=0x%"PRIx64" flag=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, rid, iova, flag);
#line 3558 "trace/trace-hw_virtio.h"
        } else {
#line 123 "../hw/virtio/trace-events"
            qemu_log("virtio_iommu_translate " "mr=%s rid=%d addr=0x%"PRIx64" flag=%d" "\n", name, rid, iova, flag);
#line 3562 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_iommu_translate(const char * name, uint32_t rid, uint64_t iova, int flag)
{
    if (true) {
        _nocheck__trace_virtio_iommu_translate(name, rid, iova, flag);
    }
}

#define TRACE_VIRTIO_IOMMU_INIT_IOMMU_MR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_INIT_IOMMU_MR) || \
    false)

static inline void _nocheck__trace_virtio_iommu_init_iommu_mr(char * iommu_mr)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_INIT_IOMMU_MR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 124 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_iommu_init_iommu_mr " "init %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , iommu_mr);
#line 3589 "trace/trace-hw_virtio.h"
        } else {
#line 124 "../hw/virtio/trace-events"
            qemu_log("virtio_iommu_init_iommu_mr " "init %s" "\n", iommu_mr);
#line 3593 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_iommu_init_iommu_mr(char * iommu_mr)
{
    if (true) {
        _nocheck__trace_virtio_iommu_init_iommu_mr(iommu_mr);
    }
}

#define TRACE_VIRTIO_IOMMU_GET_ENDPOINT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_GET_ENDPOINT) || \
    false)

static inline void _nocheck__trace_virtio_iommu_get_endpoint(uint32_t ep_id)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_GET_ENDPOINT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 125 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_iommu_get_endpoint " "Alloc endpoint=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ep_id);
#line 3620 "trace/trace-hw_virtio.h"
        } else {
#line 125 "../hw/virtio/trace-events"
            qemu_log("virtio_iommu_get_endpoint " "Alloc endpoint=%d" "\n", ep_id);
#line 3624 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_iommu_get_endpoint(uint32_t ep_id)
{
    if (true) {
        _nocheck__trace_virtio_iommu_get_endpoint(ep_id);
    }
}

#define TRACE_VIRTIO_IOMMU_PUT_ENDPOINT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_PUT_ENDPOINT) || \
    false)

static inline void _nocheck__trace_virtio_iommu_put_endpoint(uint32_t ep_id)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_PUT_ENDPOINT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 126 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_iommu_put_endpoint " "Free endpoint=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ep_id);
#line 3651 "trace/trace-hw_virtio.h"
        } else {
#line 126 "../hw/virtio/trace-events"
            qemu_log("virtio_iommu_put_endpoint " "Free endpoint=%d" "\n", ep_id);
#line 3655 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_iommu_put_endpoint(uint32_t ep_id)
{
    if (true) {
        _nocheck__trace_virtio_iommu_put_endpoint(ep_id);
    }
}

#define TRACE_VIRTIO_IOMMU_GET_DOMAIN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_GET_DOMAIN) || \
    false)

static inline void _nocheck__trace_virtio_iommu_get_domain(uint32_t domain_id)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_GET_DOMAIN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 127 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_iommu_get_domain " "Alloc domain=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , domain_id);
#line 3682 "trace/trace-hw_virtio.h"
        } else {
#line 127 "../hw/virtio/trace-events"
            qemu_log("virtio_iommu_get_domain " "Alloc domain=%d" "\n", domain_id);
#line 3686 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_iommu_get_domain(uint32_t domain_id)
{
    if (true) {
        _nocheck__trace_virtio_iommu_get_domain(domain_id);
    }
}

#define TRACE_VIRTIO_IOMMU_PUT_DOMAIN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_PUT_DOMAIN) || \
    false)

static inline void _nocheck__trace_virtio_iommu_put_domain(uint32_t domain_id)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_PUT_DOMAIN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 128 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_iommu_put_domain " "Free domain=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , domain_id);
#line 3713 "trace/trace-hw_virtio.h"
        } else {
#line 128 "../hw/virtio/trace-events"
            qemu_log("virtio_iommu_put_domain " "Free domain=%d" "\n", domain_id);
#line 3717 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_iommu_put_domain(uint32_t domain_id)
{
    if (true) {
        _nocheck__trace_virtio_iommu_put_domain(domain_id);
    }
}

#define TRACE_VIRTIO_IOMMU_TRANSLATE_OUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_TRANSLATE_OUT) || \
    false)

static inline void _nocheck__trace_virtio_iommu_translate_out(uint64_t virt_addr, uint64_t phys_addr, uint32_t sid)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_TRANSLATE_OUT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 129 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_iommu_translate_out " "0x%"PRIx64" -> 0x%"PRIx64 " for sid=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , virt_addr, phys_addr, sid);
#line 3744 "trace/trace-hw_virtio.h"
        } else {
#line 129 "../hw/virtio/trace-events"
            qemu_log("virtio_iommu_translate_out " "0x%"PRIx64" -> 0x%"PRIx64 " for sid=%d" "\n", virt_addr, phys_addr, sid);
#line 3748 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_iommu_translate_out(uint64_t virt_addr, uint64_t phys_addr, uint32_t sid)
{
    if (true) {
        _nocheck__trace_virtio_iommu_translate_out(virt_addr, phys_addr, sid);
    }
}

#define TRACE_VIRTIO_IOMMU_REPORT_FAULT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_REPORT_FAULT) || \
    false)

static inline void _nocheck__trace_virtio_iommu_report_fault(uint8_t reason, uint32_t flags, uint32_t endpoint, uint64_t addr)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_REPORT_FAULT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 130 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_iommu_report_fault " "FAULT reason=%d flags=%d endpoint=%d address =0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reason, flags, endpoint, addr);
#line 3775 "trace/trace-hw_virtio.h"
        } else {
#line 130 "../hw/virtio/trace-events"
            qemu_log("virtio_iommu_report_fault " "FAULT reason=%d flags=%d endpoint=%d address =0x%"PRIx64 "\n", reason, flags, endpoint, addr);
#line 3779 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_iommu_report_fault(uint8_t reason, uint32_t flags, uint32_t endpoint, uint64_t addr)
{
    if (true) {
        _nocheck__trace_virtio_iommu_report_fault(reason, flags, endpoint, addr);
    }
}

#define TRACE_VIRTIO_IOMMU_FILL_RESV_PROPERTY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_FILL_RESV_PROPERTY) || \
    false)

static inline void _nocheck__trace_virtio_iommu_fill_resv_property(uint32_t devid, uint8_t subtype, uint64_t start, uint64_t end)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_FILL_RESV_PROPERTY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 131 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_iommu_fill_resv_property " "dev= %d, type=%d start=0x%"PRIx64" end=0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , devid, subtype, start, end);
#line 3806 "trace/trace-hw_virtio.h"
        } else {
#line 131 "../hw/virtio/trace-events"
            qemu_log("virtio_iommu_fill_resv_property " "dev= %d, type=%d start=0x%"PRIx64" end=0x%"PRIx64 "\n", devid, subtype, start, end);
#line 3810 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_iommu_fill_resv_property(uint32_t devid, uint8_t subtype, uint64_t start, uint64_t end)
{
    if (true) {
        _nocheck__trace_virtio_iommu_fill_resv_property(devid, subtype, start, end);
    }
}

#define TRACE_VIRTIO_IOMMU_NOTIFY_MAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_NOTIFY_MAP) || \
    false)

static inline void _nocheck__trace_virtio_iommu_notify_map(const char * name, uint64_t virt_start, uint64_t virt_end, uint64_t phys_start, uint32_t flags)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_NOTIFY_MAP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 132 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_iommu_notify_map " "mr=%s virt_start=0x%"PRIx64" virt_end=0x%"PRIx64" phys_start=0x%"PRIx64" flags=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, virt_start, virt_end, phys_start, flags);
#line 3837 "trace/trace-hw_virtio.h"
        } else {
#line 132 "../hw/virtio/trace-events"
            qemu_log("virtio_iommu_notify_map " "mr=%s virt_start=0x%"PRIx64" virt_end=0x%"PRIx64" phys_start=0x%"PRIx64" flags=%d" "\n", name, virt_start, virt_end, phys_start, flags);
#line 3841 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_iommu_notify_map(const char * name, uint64_t virt_start, uint64_t virt_end, uint64_t phys_start, uint32_t flags)
{
    if (true) {
        _nocheck__trace_virtio_iommu_notify_map(name, virt_start, virt_end, phys_start, flags);
    }
}

#define TRACE_VIRTIO_IOMMU_NOTIFY_UNMAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_NOTIFY_UNMAP) || \
    false)

static inline void _nocheck__trace_virtio_iommu_notify_unmap(const char * name, uint64_t virt_start, uint64_t virt_end)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_NOTIFY_UNMAP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 133 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_iommu_notify_unmap " "mr=%s virt_start=0x%"PRIx64" virt_end=0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, virt_start, virt_end);
#line 3868 "trace/trace-hw_virtio.h"
        } else {
#line 133 "../hw/virtio/trace-events"
            qemu_log("virtio_iommu_notify_unmap " "mr=%s virt_start=0x%"PRIx64" virt_end=0x%"PRIx64 "\n", name, virt_start, virt_end);
#line 3872 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_iommu_notify_unmap(const char * name, uint64_t virt_start, uint64_t virt_end)
{
    if (true) {
        _nocheck__trace_virtio_iommu_notify_unmap(name, virt_start, virt_end);
    }
}

#define TRACE_VIRTIO_IOMMU_REMAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_REMAP) || \
    false)

static inline void _nocheck__trace_virtio_iommu_remap(const char * name, uint64_t virt_start, uint64_t virt_end, uint64_t phys_start)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_REMAP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 134 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_iommu_remap " "mr=%s virt_start=0x%"PRIx64" virt_end=0x%"PRIx64" phys_start=0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, virt_start, virt_end, phys_start);
#line 3899 "trace/trace-hw_virtio.h"
        } else {
#line 134 "../hw/virtio/trace-events"
            qemu_log("virtio_iommu_remap " "mr=%s virt_start=0x%"PRIx64" virt_end=0x%"PRIx64" phys_start=0x%"PRIx64 "\n", name, virt_start, virt_end, phys_start);
#line 3903 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_iommu_remap(const char * name, uint64_t virt_start, uint64_t virt_end, uint64_t phys_start)
{
    if (true) {
        _nocheck__trace_virtio_iommu_remap(name, virt_start, virt_end, phys_start);
    }
}

#define TRACE_VIRTIO_IOMMU_UPDATE_PAGE_SIZE_MASK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_UPDATE_PAGE_SIZE_MASK) || \
    false)

static inline void _nocheck__trace_virtio_iommu_update_page_size_mask(const char * name, uint64_t old, uint64_t new)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_UPDATE_PAGE_SIZE_MASK) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 135 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_iommu_update_page_size_mask " "host iommu device=%s old_mask=0x%"PRIx64" new_mask=0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, old, new);
#line 3930 "trace/trace-hw_virtio.h"
        } else {
#line 135 "../hw/virtio/trace-events"
            qemu_log("virtio_iommu_update_page_size_mask " "host iommu device=%s old_mask=0x%"PRIx64" new_mask=0x%"PRIx64 "\n", name, old, new);
#line 3934 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_iommu_update_page_size_mask(const char * name, uint64_t old, uint64_t new)
{
    if (true) {
        _nocheck__trace_virtio_iommu_update_page_size_mask(name, old, new);
    }
}

#define TRACE_VIRTIO_IOMMU_NOTIFY_FLAG_ADD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_NOTIFY_FLAG_ADD) || \
    false)

static inline void _nocheck__trace_virtio_iommu_notify_flag_add(const char * name)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_NOTIFY_FLAG_ADD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 136 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_iommu_notify_flag_add " "add notifier to mr %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 3961 "trace/trace-hw_virtio.h"
        } else {
#line 136 "../hw/virtio/trace-events"
            qemu_log("virtio_iommu_notify_flag_add " "add notifier to mr %s" "\n", name);
#line 3965 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_iommu_notify_flag_add(const char * name)
{
    if (true) {
        _nocheck__trace_virtio_iommu_notify_flag_add(name);
    }
}

#define TRACE_VIRTIO_IOMMU_NOTIFY_FLAG_DEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_NOTIFY_FLAG_DEL) || \
    false)

static inline void _nocheck__trace_virtio_iommu_notify_flag_del(const char * name)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_NOTIFY_FLAG_DEL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 137 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_iommu_notify_flag_del " "del notifier from mr %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 3992 "trace/trace-hw_virtio.h"
        } else {
#line 137 "../hw/virtio/trace-events"
            qemu_log("virtio_iommu_notify_flag_del " "del notifier from mr %s" "\n", name);
#line 3996 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_iommu_notify_flag_del(const char * name)
{
    if (true) {
        _nocheck__trace_virtio_iommu_notify_flag_del(name);
    }
}

#define TRACE_VIRTIO_IOMMU_SWITCH_ADDRESS_SPACE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_SWITCH_ADDRESS_SPACE) || \
    false)

static inline void _nocheck__trace_virtio_iommu_switch_address_space(uint8_t bus, uint8_t slot, uint8_t fn, bool on)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_SWITCH_ADDRESS_SPACE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 138 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_iommu_switch_address_space " "Device %02x:%02x.%x switching address space (iommu enabled=%d)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bus, slot, fn, on);
#line 4023 "trace/trace-hw_virtio.h"
        } else {
#line 138 "../hw/virtio/trace-events"
            qemu_log("virtio_iommu_switch_address_space " "Device %02x:%02x.%x switching address space (iommu enabled=%d)" "\n", bus, slot, fn, on);
#line 4027 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_iommu_switch_address_space(uint8_t bus, uint8_t slot, uint8_t fn, bool on)
{
    if (true) {
        _nocheck__trace_virtio_iommu_switch_address_space(bus, slot, fn, on);
    }
}

#define TRACE_VIRTIO_IOMMU_FREEZE_GRANULE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_FREEZE_GRANULE) || \
    false)

static inline void _nocheck__trace_virtio_iommu_freeze_granule(uint64_t page_size_mask)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_FREEZE_GRANULE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 139 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_iommu_freeze_granule " "granule set to 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , page_size_mask);
#line 4054 "trace/trace-hw_virtio.h"
        } else {
#line 139 "../hw/virtio/trace-events"
            qemu_log("virtio_iommu_freeze_granule " "granule set to 0x%"PRIx64 "\n", page_size_mask);
#line 4058 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_iommu_freeze_granule(uint64_t page_size_mask)
{
    if (true) {
        _nocheck__trace_virtio_iommu_freeze_granule(page_size_mask);
    }
}

#define TRACE_VIRTIO_IOMMU_HOST_RESV_REGIONS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_HOST_RESV_REGIONS) || \
    false)

static inline void _nocheck__trace_virtio_iommu_host_resv_regions(const char * name, uint32_t index, uint64_t lob, uint64_t upb)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_HOST_RESV_REGIONS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 140 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_iommu_host_resv_regions " "mr=%s host-resv-reg[%d] = [0x%"PRIx64",0x%"PRIx64"]" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, index, lob, upb);
#line 4085 "trace/trace-hw_virtio.h"
        } else {
#line 140 "../hw/virtio/trace-events"
            qemu_log("virtio_iommu_host_resv_regions " "mr=%s host-resv-reg[%d] = [0x%"PRIx64",0x%"PRIx64"]" "\n", name, index, lob, upb);
#line 4089 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_iommu_host_resv_regions(const char * name, uint32_t index, uint64_t lob, uint64_t upb)
{
    if (true) {
        _nocheck__trace_virtio_iommu_host_resv_regions(name, index, lob, upb);
    }
}

#define TRACE_VIRTIO_MEM_SEND_RESPONSE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_MEM_SEND_RESPONSE) || \
    false)

static inline void _nocheck__trace_virtio_mem_send_response(uint16_t type)
{
    if (trace_event_get_state(TRACE_VIRTIO_MEM_SEND_RESPONSE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 143 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_mem_send_response " "type=%" PRIu16 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type);
#line 4116 "trace/trace-hw_virtio.h"
        } else {
#line 143 "../hw/virtio/trace-events"
            qemu_log("virtio_mem_send_response " "type=%" PRIu16 "\n", type);
#line 4120 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_mem_send_response(uint16_t type)
{
    if (true) {
        _nocheck__trace_virtio_mem_send_response(type);
    }
}

#define TRACE_VIRTIO_MEM_PLUG_REQUEST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_MEM_PLUG_REQUEST) || \
    false)

static inline void _nocheck__trace_virtio_mem_plug_request(uint64_t addr, uint16_t nb_blocks)
{
    if (trace_event_get_state(TRACE_VIRTIO_MEM_PLUG_REQUEST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 144 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_mem_plug_request " "addr=0x%" PRIx64 " nb_blocks=%" PRIu16 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, nb_blocks);
#line 4147 "trace/trace-hw_virtio.h"
        } else {
#line 144 "../hw/virtio/trace-events"
            qemu_log("virtio_mem_plug_request " "addr=0x%" PRIx64 " nb_blocks=%" PRIu16 "\n", addr, nb_blocks);
#line 4151 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_mem_plug_request(uint64_t addr, uint16_t nb_blocks)
{
    if (true) {
        _nocheck__trace_virtio_mem_plug_request(addr, nb_blocks);
    }
}

#define TRACE_VIRTIO_MEM_UNPLUG_REQUEST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_MEM_UNPLUG_REQUEST) || \
    false)

static inline void _nocheck__trace_virtio_mem_unplug_request(uint64_t addr, uint16_t nb_blocks)
{
    if (trace_event_get_state(TRACE_VIRTIO_MEM_UNPLUG_REQUEST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 145 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_mem_unplug_request " "addr=0x%" PRIx64 " nb_blocks=%" PRIu16 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, nb_blocks);
#line 4178 "trace/trace-hw_virtio.h"
        } else {
#line 145 "../hw/virtio/trace-events"
            qemu_log("virtio_mem_unplug_request " "addr=0x%" PRIx64 " nb_blocks=%" PRIu16 "\n", addr, nb_blocks);
#line 4182 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_mem_unplug_request(uint64_t addr, uint16_t nb_blocks)
{
    if (true) {
        _nocheck__trace_virtio_mem_unplug_request(addr, nb_blocks);
    }
}

#define TRACE_VIRTIO_MEM_UNPLUGGED_ALL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_MEM_UNPLUGGED_ALL) || \
    false)

static inline void _nocheck__trace_virtio_mem_unplugged_all(void)
{
    if (trace_event_get_state(TRACE_VIRTIO_MEM_UNPLUGGED_ALL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 146 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_mem_unplugged_all " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 4209 "trace/trace-hw_virtio.h"
        } else {
#line 146 "../hw/virtio/trace-events"
            qemu_log("virtio_mem_unplugged_all " "" "\n");
#line 4213 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_mem_unplugged_all(void)
{
    if (true) {
        _nocheck__trace_virtio_mem_unplugged_all();
    }
}

#define TRACE_VIRTIO_MEM_UNPLUG_ALL_REQUEST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_MEM_UNPLUG_ALL_REQUEST) || \
    false)

static inline void _nocheck__trace_virtio_mem_unplug_all_request(void)
{
    if (trace_event_get_state(TRACE_VIRTIO_MEM_UNPLUG_ALL_REQUEST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 147 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_mem_unplug_all_request " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 4240 "trace/trace-hw_virtio.h"
        } else {
#line 147 "../hw/virtio/trace-events"
            qemu_log("virtio_mem_unplug_all_request " "" "\n");
#line 4244 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_mem_unplug_all_request(void)
{
    if (true) {
        _nocheck__trace_virtio_mem_unplug_all_request();
    }
}

#define TRACE_VIRTIO_MEM_RESIZED_USABLE_REGION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_MEM_RESIZED_USABLE_REGION) || \
    false)

static inline void _nocheck__trace_virtio_mem_resized_usable_region(uint64_t old_size, uint64_t new_size)
{
    if (trace_event_get_state(TRACE_VIRTIO_MEM_RESIZED_USABLE_REGION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 148 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_mem_resized_usable_region " "old_size=0x%" PRIx64 "new_size=0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , old_size, new_size);
#line 4271 "trace/trace-hw_virtio.h"
        } else {
#line 148 "../hw/virtio/trace-events"
            qemu_log("virtio_mem_resized_usable_region " "old_size=0x%" PRIx64 "new_size=0x%" PRIx64 "\n", old_size, new_size);
#line 4275 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_mem_resized_usable_region(uint64_t old_size, uint64_t new_size)
{
    if (true) {
        _nocheck__trace_virtio_mem_resized_usable_region(old_size, new_size);
    }
}

#define TRACE_VIRTIO_MEM_STATE_REQUEST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_MEM_STATE_REQUEST) || \
    false)

static inline void _nocheck__trace_virtio_mem_state_request(uint64_t addr, uint16_t nb_blocks)
{
    if (trace_event_get_state(TRACE_VIRTIO_MEM_STATE_REQUEST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 149 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_mem_state_request " "addr=0x%" PRIx64 " nb_blocks=%" PRIu16 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, nb_blocks);
#line 4302 "trace/trace-hw_virtio.h"
        } else {
#line 149 "../hw/virtio/trace-events"
            qemu_log("virtio_mem_state_request " "addr=0x%" PRIx64 " nb_blocks=%" PRIu16 "\n", addr, nb_blocks);
#line 4306 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_mem_state_request(uint64_t addr, uint16_t nb_blocks)
{
    if (true) {
        _nocheck__trace_virtio_mem_state_request(addr, nb_blocks);
    }
}

#define TRACE_VIRTIO_MEM_STATE_RESPONSE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_MEM_STATE_RESPONSE) || \
    false)

static inline void _nocheck__trace_virtio_mem_state_response(uint16_t state)
{
    if (trace_event_get_state(TRACE_VIRTIO_MEM_STATE_RESPONSE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 150 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_mem_state_response " "state=%" PRIu16 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state);
#line 4333 "trace/trace-hw_virtio.h"
        } else {
#line 150 "../hw/virtio/trace-events"
            qemu_log("virtio_mem_state_response " "state=%" PRIu16 "\n", state);
#line 4337 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_mem_state_response(uint16_t state)
{
    if (true) {
        _nocheck__trace_virtio_mem_state_response(state);
    }
}

#define TRACE_VIRTIO_PMEM_FLUSH_REQUEST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_PMEM_FLUSH_REQUEST) || \
    false)

static inline void _nocheck__trace_virtio_pmem_flush_request(void)
{
    if (trace_event_get_state(TRACE_VIRTIO_PMEM_FLUSH_REQUEST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 153 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_pmem_flush_request " "flush request" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 4364 "trace/trace-hw_virtio.h"
        } else {
#line 153 "../hw/virtio/trace-events"
            qemu_log("virtio_pmem_flush_request " "flush request" "\n");
#line 4368 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_pmem_flush_request(void)
{
    if (true) {
        _nocheck__trace_virtio_pmem_flush_request();
    }
}

#define TRACE_VIRTIO_PMEM_RESPONSE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_PMEM_RESPONSE) || \
    false)

static inline void _nocheck__trace_virtio_pmem_response(void)
{
    if (trace_event_get_state(TRACE_VIRTIO_PMEM_RESPONSE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 154 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_pmem_response " "flush response" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 4395 "trace/trace-hw_virtio.h"
        } else {
#line 154 "../hw/virtio/trace-events"
            qemu_log("virtio_pmem_response " "flush response" "\n");
#line 4399 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_pmem_response(void)
{
    if (true) {
        _nocheck__trace_virtio_pmem_response();
    }
}

#define TRACE_VIRTIO_PMEM_FLUSH_DONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_PMEM_FLUSH_DONE) || \
    false)

static inline void _nocheck__trace_virtio_pmem_flush_done(int type)
{
    if (trace_event_get_state(TRACE_VIRTIO_PMEM_FLUSH_DONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 155 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_pmem_flush_done " "fsync return=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type);
#line 4426 "trace/trace-hw_virtio.h"
        } else {
#line 155 "../hw/virtio/trace-events"
            qemu_log("virtio_pmem_flush_done " "fsync return=%d" "\n", type);
#line 4430 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_pmem_flush_done(int type)
{
    if (true) {
        _nocheck__trace_virtio_pmem_flush_done(type);
    }
}

#define TRACE_VIRTIO_GPIO_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_GPIO_START) || \
    false)

static inline void _nocheck__trace_virtio_gpio_start(void)
{
    if (trace_event_get_state(TRACE_VIRTIO_GPIO_START) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 158 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_gpio_start " "start" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 4457 "trace/trace-hw_virtio.h"
        } else {
#line 158 "../hw/virtio/trace-events"
            qemu_log("virtio_gpio_start " "start" "\n");
#line 4461 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_gpio_start(void)
{
    if (true) {
        _nocheck__trace_virtio_gpio_start();
    }
}

#define TRACE_VIRTIO_GPIO_STOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_GPIO_STOP) || \
    false)

static inline void _nocheck__trace_virtio_gpio_stop(void)
{
    if (trace_event_get_state(TRACE_VIRTIO_GPIO_STOP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 159 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_gpio_stop " "stop" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 4488 "trace/trace-hw_virtio.h"
        } else {
#line 159 "../hw/virtio/trace-events"
            qemu_log("virtio_gpio_stop " "stop" "\n");
#line 4492 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_gpio_stop(void)
{
    if (true) {
        _nocheck__trace_virtio_gpio_stop();
    }
}

#define TRACE_VIRTIO_GPIO_SET_STATUS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_GPIO_SET_STATUS) || \
    false)

static inline void _nocheck__trace_virtio_gpio_set_status(uint8_t status)
{
    if (trace_event_get_state(TRACE_VIRTIO_GPIO_SET_STATUS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 160 "../hw/virtio/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_gpio_set_status " "0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , status);
#line 4519 "trace/trace-hw_virtio.h"
        } else {
#line 160 "../hw/virtio/trace-events"
            qemu_log("virtio_gpio_set_status " "0x%x" "\n", status);
#line 4523 "trace/trace-hw_virtio.h"
        }
    }
}

static inline void trace_virtio_gpio_set_status(uint8_t status)
{
    if (true) {
        _nocheck__trace_virtio_gpio_set_status(status);
    }
}
#endif /* TRACE_HW_VIRTIO_GENERATED_TRACERS_H */
