/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_HYPERV_GENERATED_TRACERS_H
#define TRACE_HW_HYPERV_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_VMBUS_RECV_MESSAGE_EVENT;
extern TraceEvent _TRACE_VMBUS_SIGNAL_EVENT_EVENT;
extern TraceEvent _TRACE_VMBUS_CHANNEL_NOTIFY_GUEST_EVENT;
extern TraceEvent _TRACE_VMBUS_POST_MSG_EVENT;
extern TraceEvent _TRACE_VMBUS_MSG_CB_EVENT;
extern TraceEvent _TRACE_VMBUS_PROCESS_INCOMING_MESSAGE_EVENT;
extern TraceEvent _TRACE_VMBUS_INITIATE_CONTACT_EVENT;
extern TraceEvent _TRACE_VMBUS_SEND_OFFER_EVENT;
extern TraceEvent _TRACE_VMBUS_TERMINATE_OFFERS_EVENT;
extern TraceEvent _TRACE_VMBUS_GPADL_HEADER_EVENT;
extern TraceEvent _TRACE_VMBUS_GPADL_BODY_EVENT;
extern TraceEvent _TRACE_VMBUS_GPADL_CREATED_EVENT;
extern TraceEvent _TRACE_VMBUS_GPADL_TEARDOWN_EVENT;
extern TraceEvent _TRACE_VMBUS_GPADL_TORNDOWN_EVENT;
extern TraceEvent _TRACE_VMBUS_OPEN_CHANNEL_EVENT;
extern TraceEvent _TRACE_VMBUS_CHANNEL_OPEN_EVENT;
extern TraceEvent _TRACE_VMBUS_CLOSE_CHANNEL_EVENT;
extern TraceEvent _TRACE_HV_BALLOON_STATE_CHANGE_EVENT;
extern TraceEvent _TRACE_HV_BALLOON_INCOMING_VERSION_EVENT;
extern TraceEvent _TRACE_HV_BALLOON_INCOMING_CAPS_EVENT;
extern TraceEvent _TRACE_HV_BALLOON_OUTGOING_UNBALLOON_EVENT;
extern TraceEvent _TRACE_HV_BALLOON_INCOMING_UNBALLOON_EVENT;
extern TraceEvent _TRACE_HV_BALLOON_OUTGOING_HOT_ADD_EVENT;
extern TraceEvent _TRACE_HV_BALLOON_INCOMING_HOT_ADD_EVENT;
extern TraceEvent _TRACE_HV_BALLOON_OUTGOING_BALLOON_EVENT;
extern TraceEvent _TRACE_HV_BALLOON_INCOMING_BALLOON_EVENT;
extern TraceEvent _TRACE_HV_BALLOON_OUR_RANGE_ADD_EVENT;
extern TraceEvent _TRACE_HV_BALLOON_REMOVE_RESPONSE_EVENT;
extern TraceEvent _TRACE_HV_BALLOON_REMOVE_RESPONSE_HOLE_EVENT;
extern TraceEvent _TRACE_HV_BALLOON_REMOVE_RESPONSE_COMMON_EVENT;
extern TraceEvent _TRACE_HV_BALLOON_REMOVE_RESPONSE_REMAINDER_EVENT;
extern TraceEvent _TRACE_HV_BALLOON_MAP_SLOT_EVENT;
extern TraceEvent _TRACE_HV_BALLOON_UNMAP_SLOT_EVENT;
extern uint16_t _TRACE_VMBUS_RECV_MESSAGE_DSTATE;
extern uint16_t _TRACE_VMBUS_SIGNAL_EVENT_DSTATE;
extern uint16_t _TRACE_VMBUS_CHANNEL_NOTIFY_GUEST_DSTATE;
extern uint16_t _TRACE_VMBUS_POST_MSG_DSTATE;
extern uint16_t _TRACE_VMBUS_MSG_CB_DSTATE;
extern uint16_t _TRACE_VMBUS_PROCESS_INCOMING_MESSAGE_DSTATE;
extern uint16_t _TRACE_VMBUS_INITIATE_CONTACT_DSTATE;
extern uint16_t _TRACE_VMBUS_SEND_OFFER_DSTATE;
extern uint16_t _TRACE_VMBUS_TERMINATE_OFFERS_DSTATE;
extern uint16_t _TRACE_VMBUS_GPADL_HEADER_DSTATE;
extern uint16_t _TRACE_VMBUS_GPADL_BODY_DSTATE;
extern uint16_t _TRACE_VMBUS_GPADL_CREATED_DSTATE;
extern uint16_t _TRACE_VMBUS_GPADL_TEARDOWN_DSTATE;
extern uint16_t _TRACE_VMBUS_GPADL_TORNDOWN_DSTATE;
extern uint16_t _TRACE_VMBUS_OPEN_CHANNEL_DSTATE;
extern uint16_t _TRACE_VMBUS_CHANNEL_OPEN_DSTATE;
extern uint16_t _TRACE_VMBUS_CLOSE_CHANNEL_DSTATE;
extern uint16_t _TRACE_HV_BALLOON_STATE_CHANGE_DSTATE;
extern uint16_t _TRACE_HV_BALLOON_INCOMING_VERSION_DSTATE;
extern uint16_t _TRACE_HV_BALLOON_INCOMING_CAPS_DSTATE;
extern uint16_t _TRACE_HV_BALLOON_OUTGOING_UNBALLOON_DSTATE;
extern uint16_t _TRACE_HV_BALLOON_INCOMING_UNBALLOON_DSTATE;
extern uint16_t _TRACE_HV_BALLOON_OUTGOING_HOT_ADD_DSTATE;
extern uint16_t _TRACE_HV_BALLOON_INCOMING_HOT_ADD_DSTATE;
extern uint16_t _TRACE_HV_BALLOON_OUTGOING_BALLOON_DSTATE;
extern uint16_t _TRACE_HV_BALLOON_INCOMING_BALLOON_DSTATE;
extern uint16_t _TRACE_HV_BALLOON_OUR_RANGE_ADD_DSTATE;
extern uint16_t _TRACE_HV_BALLOON_REMOVE_RESPONSE_DSTATE;
extern uint16_t _TRACE_HV_BALLOON_REMOVE_RESPONSE_HOLE_DSTATE;
extern uint16_t _TRACE_HV_BALLOON_REMOVE_RESPONSE_COMMON_DSTATE;
extern uint16_t _TRACE_HV_BALLOON_REMOVE_RESPONSE_REMAINDER_DSTATE;
extern uint16_t _TRACE_HV_BALLOON_MAP_SLOT_DSTATE;
extern uint16_t _TRACE_HV_BALLOON_UNMAP_SLOT_DSTATE;
#define TRACE_VMBUS_RECV_MESSAGE_ENABLED 1
#define TRACE_VMBUS_SIGNAL_EVENT_ENABLED 1
#define TRACE_VMBUS_CHANNEL_NOTIFY_GUEST_ENABLED 1
#define TRACE_VMBUS_POST_MSG_ENABLED 1
#define TRACE_VMBUS_MSG_CB_ENABLED 1
#define TRACE_VMBUS_PROCESS_INCOMING_MESSAGE_ENABLED 1
#define TRACE_VMBUS_INITIATE_CONTACT_ENABLED 1
#define TRACE_VMBUS_SEND_OFFER_ENABLED 1
#define TRACE_VMBUS_TERMINATE_OFFERS_ENABLED 1
#define TRACE_VMBUS_GPADL_HEADER_ENABLED 1
#define TRACE_VMBUS_GPADL_BODY_ENABLED 1
#define TRACE_VMBUS_GPADL_CREATED_ENABLED 1
#define TRACE_VMBUS_GPADL_TEARDOWN_ENABLED 1
#define TRACE_VMBUS_GPADL_TORNDOWN_ENABLED 1
#define TRACE_VMBUS_OPEN_CHANNEL_ENABLED 1
#define TRACE_VMBUS_CHANNEL_OPEN_ENABLED 1
#define TRACE_VMBUS_CLOSE_CHANNEL_ENABLED 1
#define TRACE_HV_BALLOON_STATE_CHANGE_ENABLED 1
#define TRACE_HV_BALLOON_INCOMING_VERSION_ENABLED 1
#define TRACE_HV_BALLOON_INCOMING_CAPS_ENABLED 1
#define TRACE_HV_BALLOON_OUTGOING_UNBALLOON_ENABLED 1
#define TRACE_HV_BALLOON_INCOMING_UNBALLOON_ENABLED 1
#define TRACE_HV_BALLOON_OUTGOING_HOT_ADD_ENABLED 1
#define TRACE_HV_BALLOON_INCOMING_HOT_ADD_ENABLED 1
#define TRACE_HV_BALLOON_OUTGOING_BALLOON_ENABLED 1
#define TRACE_HV_BALLOON_INCOMING_BALLOON_ENABLED 1
#define TRACE_HV_BALLOON_OUR_RANGE_ADD_ENABLED 1
#define TRACE_HV_BALLOON_REMOVE_RESPONSE_ENABLED 1
#define TRACE_HV_BALLOON_REMOVE_RESPONSE_HOLE_ENABLED 1
#define TRACE_HV_BALLOON_REMOVE_RESPONSE_COMMON_ENABLED 1
#define TRACE_HV_BALLOON_REMOVE_RESPONSE_REMAINDER_ENABLED 1
#define TRACE_HV_BALLOON_MAP_SLOT_ENABLED 1
#define TRACE_HV_BALLOON_UNMAP_SLOT_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_VMBUS_RECV_MESSAGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMBUS_RECV_MESSAGE) || \
    false)

static inline void _nocheck__trace_vmbus_recv_message(uint32_t type, uint32_t size)
{
    if (trace_event_get_state(TRACE_VMBUS_RECV_MESSAGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 2 "../hw/hyperv/trace-events"
            qemu_log("%d@%zu.%06zu:vmbus_recv_message " "type %d size %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, size);
#line 127 "trace/trace-hw_hyperv.h"
        } else {
#line 2 "../hw/hyperv/trace-events"
            qemu_log("vmbus_recv_message " "type %d size %d" "\n", type, size);
#line 131 "trace/trace-hw_hyperv.h"
        }
    }
}

static inline void trace_vmbus_recv_message(uint32_t type, uint32_t size)
{
    if (true) {
        _nocheck__trace_vmbus_recv_message(type, size);
    }
}

#define TRACE_VMBUS_SIGNAL_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMBUS_SIGNAL_EVENT) || \
    false)

static inline void _nocheck__trace_vmbus_signal_event(void)
{
    if (trace_event_get_state(TRACE_VMBUS_SIGNAL_EVENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 3 "../hw/hyperv/trace-events"
            qemu_log("%d@%zu.%06zu:vmbus_signal_event " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 158 "trace/trace-hw_hyperv.h"
        } else {
#line 3 "../hw/hyperv/trace-events"
            qemu_log("vmbus_signal_event " "" "\n");
#line 162 "trace/trace-hw_hyperv.h"
        }
    }
}

static inline void trace_vmbus_signal_event(void)
{
    if (true) {
        _nocheck__trace_vmbus_signal_event();
    }
}

#define TRACE_VMBUS_CHANNEL_NOTIFY_GUEST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMBUS_CHANNEL_NOTIFY_GUEST) || \
    false)

static inline void _nocheck__trace_vmbus_channel_notify_guest(uint32_t chan_id)
{
    if (trace_event_get_state(TRACE_VMBUS_CHANNEL_NOTIFY_GUEST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 4 "../hw/hyperv/trace-events"
            qemu_log("%d@%zu.%06zu:vmbus_channel_notify_guest " "channel #%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , chan_id);
#line 189 "trace/trace-hw_hyperv.h"
        } else {
#line 4 "../hw/hyperv/trace-events"
            qemu_log("vmbus_channel_notify_guest " "channel #%d" "\n", chan_id);
#line 193 "trace/trace-hw_hyperv.h"
        }
    }
}

static inline void trace_vmbus_channel_notify_guest(uint32_t chan_id)
{
    if (true) {
        _nocheck__trace_vmbus_channel_notify_guest(chan_id);
    }
}

#define TRACE_VMBUS_POST_MSG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMBUS_POST_MSG) || \
    false)

static inline void _nocheck__trace_vmbus_post_msg(uint32_t type, uint32_t size)
{
    if (trace_event_get_state(TRACE_VMBUS_POST_MSG) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 5 "../hw/hyperv/trace-events"
            qemu_log("%d@%zu.%06zu:vmbus_post_msg " "type %d size %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, size);
#line 220 "trace/trace-hw_hyperv.h"
        } else {
#line 5 "../hw/hyperv/trace-events"
            qemu_log("vmbus_post_msg " "type %d size %d" "\n", type, size);
#line 224 "trace/trace-hw_hyperv.h"
        }
    }
}

static inline void trace_vmbus_post_msg(uint32_t type, uint32_t size)
{
    if (true) {
        _nocheck__trace_vmbus_post_msg(type, size);
    }
}

#define TRACE_VMBUS_MSG_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMBUS_MSG_CB) || \
    false)

static inline void _nocheck__trace_vmbus_msg_cb(int status)
{
    if (trace_event_get_state(TRACE_VMBUS_MSG_CB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 6 "../hw/hyperv/trace-events"
            qemu_log("%d@%zu.%06zu:vmbus_msg_cb " "message status %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , status);
#line 251 "trace/trace-hw_hyperv.h"
        } else {
#line 6 "../hw/hyperv/trace-events"
            qemu_log("vmbus_msg_cb " "message status %d" "\n", status);
#line 255 "trace/trace-hw_hyperv.h"
        }
    }
}

static inline void trace_vmbus_msg_cb(int status)
{
    if (true) {
        _nocheck__trace_vmbus_msg_cb(status);
    }
}

#define TRACE_VMBUS_PROCESS_INCOMING_MESSAGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMBUS_PROCESS_INCOMING_MESSAGE) || \
    false)

static inline void _nocheck__trace_vmbus_process_incoming_message(uint32_t message_type)
{
    if (trace_event_get_state(TRACE_VMBUS_PROCESS_INCOMING_MESSAGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 7 "../hw/hyperv/trace-events"
            qemu_log("%d@%zu.%06zu:vmbus_process_incoming_message " "type %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , message_type);
#line 282 "trace/trace-hw_hyperv.h"
        } else {
#line 7 "../hw/hyperv/trace-events"
            qemu_log("vmbus_process_incoming_message " "type %d" "\n", message_type);
#line 286 "trace/trace-hw_hyperv.h"
        }
    }
}

static inline void trace_vmbus_process_incoming_message(uint32_t message_type)
{
    if (true) {
        _nocheck__trace_vmbus_process_incoming_message(message_type);
    }
}

#define TRACE_VMBUS_INITIATE_CONTACT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMBUS_INITIATE_CONTACT) || \
    false)

static inline void _nocheck__trace_vmbus_initiate_contact(uint16_t major, uint16_t minor, uint32_t vcpu, uint64_t monitor_page1, uint64_t monitor_page2, uint64_t interrupt_page)
{
    if (trace_event_get_state(TRACE_VMBUS_INITIATE_CONTACT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 8 "../hw/hyperv/trace-events"
            qemu_log("%d@%zu.%06zu:vmbus_initiate_contact " "version %d.%d target vp %d mon pages 0x%"PRIx64",0x%"PRIx64" int page 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , major, minor, vcpu, monitor_page1, monitor_page2, interrupt_page);
#line 313 "trace/trace-hw_hyperv.h"
        } else {
#line 8 "../hw/hyperv/trace-events"
            qemu_log("vmbus_initiate_contact " "version %d.%d target vp %d mon pages 0x%"PRIx64",0x%"PRIx64" int page 0x%"PRIx64 "\n", major, minor, vcpu, monitor_page1, monitor_page2, interrupt_page);
#line 317 "trace/trace-hw_hyperv.h"
        }
    }
}

static inline void trace_vmbus_initiate_contact(uint16_t major, uint16_t minor, uint32_t vcpu, uint64_t monitor_page1, uint64_t monitor_page2, uint64_t interrupt_page)
{
    if (true) {
        _nocheck__trace_vmbus_initiate_contact(major, minor, vcpu, monitor_page1, monitor_page2, interrupt_page);
    }
}

#define TRACE_VMBUS_SEND_OFFER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMBUS_SEND_OFFER) || \
    false)

static inline void _nocheck__trace_vmbus_send_offer(uint32_t chan_id, void * dev)
{
    if (trace_event_get_state(TRACE_VMBUS_SEND_OFFER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 9 "../hw/hyperv/trace-events"
            qemu_log("%d@%zu.%06zu:vmbus_send_offer " "channel #%d dev %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , chan_id, dev);
#line 344 "trace/trace-hw_hyperv.h"
        } else {
#line 9 "../hw/hyperv/trace-events"
            qemu_log("vmbus_send_offer " "channel #%d dev %p" "\n", chan_id, dev);
#line 348 "trace/trace-hw_hyperv.h"
        }
    }
}

static inline void trace_vmbus_send_offer(uint32_t chan_id, void * dev)
{
    if (true) {
        _nocheck__trace_vmbus_send_offer(chan_id, dev);
    }
}

#define TRACE_VMBUS_TERMINATE_OFFERS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMBUS_TERMINATE_OFFERS) || \
    false)

static inline void _nocheck__trace_vmbus_terminate_offers(void)
{
    if (trace_event_get_state(TRACE_VMBUS_TERMINATE_OFFERS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 10 "../hw/hyperv/trace-events"
            qemu_log("%d@%zu.%06zu:vmbus_terminate_offers " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 375 "trace/trace-hw_hyperv.h"
        } else {
#line 10 "../hw/hyperv/trace-events"
            qemu_log("vmbus_terminate_offers " "" "\n");
#line 379 "trace/trace-hw_hyperv.h"
        }
    }
}

static inline void trace_vmbus_terminate_offers(void)
{
    if (true) {
        _nocheck__trace_vmbus_terminate_offers();
    }
}

#define TRACE_VMBUS_GPADL_HEADER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMBUS_GPADL_HEADER) || \
    false)

static inline void _nocheck__trace_vmbus_gpadl_header(uint32_t gpadl_id, uint16_t num_gfns)
{
    if (trace_event_get_state(TRACE_VMBUS_GPADL_HEADER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 11 "../hw/hyperv/trace-events"
            qemu_log("%d@%zu.%06zu:vmbus_gpadl_header " "gpadl #%d gfns %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , gpadl_id, num_gfns);
#line 406 "trace/trace-hw_hyperv.h"
        } else {
#line 11 "../hw/hyperv/trace-events"
            qemu_log("vmbus_gpadl_header " "gpadl #%d gfns %d" "\n", gpadl_id, num_gfns);
#line 410 "trace/trace-hw_hyperv.h"
        }
    }
}

static inline void trace_vmbus_gpadl_header(uint32_t gpadl_id, uint16_t num_gfns)
{
    if (true) {
        _nocheck__trace_vmbus_gpadl_header(gpadl_id, num_gfns);
    }
}

#define TRACE_VMBUS_GPADL_BODY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMBUS_GPADL_BODY) || \
    false)

static inline void _nocheck__trace_vmbus_gpadl_body(uint32_t gpadl_id)
{
    if (trace_event_get_state(TRACE_VMBUS_GPADL_BODY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 12 "../hw/hyperv/trace-events"
            qemu_log("%d@%zu.%06zu:vmbus_gpadl_body " "gpadl #%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , gpadl_id);
#line 437 "trace/trace-hw_hyperv.h"
        } else {
#line 12 "../hw/hyperv/trace-events"
            qemu_log("vmbus_gpadl_body " "gpadl #%d" "\n", gpadl_id);
#line 441 "trace/trace-hw_hyperv.h"
        }
    }
}

static inline void trace_vmbus_gpadl_body(uint32_t gpadl_id)
{
    if (true) {
        _nocheck__trace_vmbus_gpadl_body(gpadl_id);
    }
}

#define TRACE_VMBUS_GPADL_CREATED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMBUS_GPADL_CREATED) || \
    false)

static inline void _nocheck__trace_vmbus_gpadl_created(uint32_t gpadl_id)
{
    if (trace_event_get_state(TRACE_VMBUS_GPADL_CREATED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 13 "../hw/hyperv/trace-events"
            qemu_log("%d@%zu.%06zu:vmbus_gpadl_created " "gpadl #%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , gpadl_id);
#line 468 "trace/trace-hw_hyperv.h"
        } else {
#line 13 "../hw/hyperv/trace-events"
            qemu_log("vmbus_gpadl_created " "gpadl #%d" "\n", gpadl_id);
#line 472 "trace/trace-hw_hyperv.h"
        }
    }
}

static inline void trace_vmbus_gpadl_created(uint32_t gpadl_id)
{
    if (true) {
        _nocheck__trace_vmbus_gpadl_created(gpadl_id);
    }
}

#define TRACE_VMBUS_GPADL_TEARDOWN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMBUS_GPADL_TEARDOWN) || \
    false)

static inline void _nocheck__trace_vmbus_gpadl_teardown(uint32_t gpadl_id)
{
    if (trace_event_get_state(TRACE_VMBUS_GPADL_TEARDOWN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 14 "../hw/hyperv/trace-events"
            qemu_log("%d@%zu.%06zu:vmbus_gpadl_teardown " "gpadl #%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , gpadl_id);
#line 499 "trace/trace-hw_hyperv.h"
        } else {
#line 14 "../hw/hyperv/trace-events"
            qemu_log("vmbus_gpadl_teardown " "gpadl #%d" "\n", gpadl_id);
#line 503 "trace/trace-hw_hyperv.h"
        }
    }
}

static inline void trace_vmbus_gpadl_teardown(uint32_t gpadl_id)
{
    if (true) {
        _nocheck__trace_vmbus_gpadl_teardown(gpadl_id);
    }
}

#define TRACE_VMBUS_GPADL_TORNDOWN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMBUS_GPADL_TORNDOWN) || \
    false)

static inline void _nocheck__trace_vmbus_gpadl_torndown(uint32_t gpadl_id)
{
    if (trace_event_get_state(TRACE_VMBUS_GPADL_TORNDOWN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 15 "../hw/hyperv/trace-events"
            qemu_log("%d@%zu.%06zu:vmbus_gpadl_torndown " "gpadl #%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , gpadl_id);
#line 530 "trace/trace-hw_hyperv.h"
        } else {
#line 15 "../hw/hyperv/trace-events"
            qemu_log("vmbus_gpadl_torndown " "gpadl #%d" "\n", gpadl_id);
#line 534 "trace/trace-hw_hyperv.h"
        }
    }
}

static inline void trace_vmbus_gpadl_torndown(uint32_t gpadl_id)
{
    if (true) {
        _nocheck__trace_vmbus_gpadl_torndown(gpadl_id);
    }
}

#define TRACE_VMBUS_OPEN_CHANNEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMBUS_OPEN_CHANNEL) || \
    false)

static inline void _nocheck__trace_vmbus_open_channel(uint32_t chan_id, uint32_t gpadl_id, uint32_t target_vp)
{
    if (trace_event_get_state(TRACE_VMBUS_OPEN_CHANNEL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 16 "../hw/hyperv/trace-events"
            qemu_log("%d@%zu.%06zu:vmbus_open_channel " "channel #%d gpadl #%d target vp %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , chan_id, gpadl_id, target_vp);
#line 561 "trace/trace-hw_hyperv.h"
        } else {
#line 16 "../hw/hyperv/trace-events"
            qemu_log("vmbus_open_channel " "channel #%d gpadl #%d target vp %d" "\n", chan_id, gpadl_id, target_vp);
#line 565 "trace/trace-hw_hyperv.h"
        }
    }
}

static inline void trace_vmbus_open_channel(uint32_t chan_id, uint32_t gpadl_id, uint32_t target_vp)
{
    if (true) {
        _nocheck__trace_vmbus_open_channel(chan_id, gpadl_id, target_vp);
    }
}

#define TRACE_VMBUS_CHANNEL_OPEN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMBUS_CHANNEL_OPEN) || \
    false)

static inline void _nocheck__trace_vmbus_channel_open(uint32_t chan_id, uint32_t status)
{
    if (trace_event_get_state(TRACE_VMBUS_CHANNEL_OPEN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 17 "../hw/hyperv/trace-events"
            qemu_log("%d@%zu.%06zu:vmbus_channel_open " "channel #%d status %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , chan_id, status);
#line 592 "trace/trace-hw_hyperv.h"
        } else {
#line 17 "../hw/hyperv/trace-events"
            qemu_log("vmbus_channel_open " "channel #%d status %d" "\n", chan_id, status);
#line 596 "trace/trace-hw_hyperv.h"
        }
    }
}

static inline void trace_vmbus_channel_open(uint32_t chan_id, uint32_t status)
{
    if (true) {
        _nocheck__trace_vmbus_channel_open(chan_id, status);
    }
}

#define TRACE_VMBUS_CLOSE_CHANNEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMBUS_CLOSE_CHANNEL) || \
    false)

static inline void _nocheck__trace_vmbus_close_channel(uint32_t chan_id)
{
    if (trace_event_get_state(TRACE_VMBUS_CLOSE_CHANNEL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 18 "../hw/hyperv/trace-events"
            qemu_log("%d@%zu.%06zu:vmbus_close_channel " "channel #%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , chan_id);
#line 623 "trace/trace-hw_hyperv.h"
        } else {
#line 18 "../hw/hyperv/trace-events"
            qemu_log("vmbus_close_channel " "channel #%d" "\n", chan_id);
#line 627 "trace/trace-hw_hyperv.h"
        }
    }
}

static inline void trace_vmbus_close_channel(uint32_t chan_id)
{
    if (true) {
        _nocheck__trace_vmbus_close_channel(chan_id);
    }
}

#define TRACE_HV_BALLOON_STATE_CHANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HV_BALLOON_STATE_CHANGE) || \
    false)

static inline void _nocheck__trace_hv_balloon_state_change(const char * tostr)
{
    if (trace_event_get_state(TRACE_HV_BALLOON_STATE_CHANGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 21 "../hw/hyperv/trace-events"
            qemu_log("%d@%zu.%06zu:hv_balloon_state_change " "-> %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tostr);
#line 654 "trace/trace-hw_hyperv.h"
        } else {
#line 21 "../hw/hyperv/trace-events"
            qemu_log("hv_balloon_state_change " "-> %s" "\n", tostr);
#line 658 "trace/trace-hw_hyperv.h"
        }
    }
}

static inline void trace_hv_balloon_state_change(const char * tostr)
{
    if (true) {
        _nocheck__trace_hv_balloon_state_change(tostr);
    }
}

#define TRACE_HV_BALLOON_INCOMING_VERSION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HV_BALLOON_INCOMING_VERSION) || \
    false)

static inline void _nocheck__trace_hv_balloon_incoming_version(uint16_t major, uint16_t minor)
{
    if (trace_event_get_state(TRACE_HV_BALLOON_INCOMING_VERSION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 22 "../hw/hyperv/trace-events"
            qemu_log("%d@%zu.%06zu:hv_balloon_incoming_version " "incoming proto version %u.%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , major, minor);
#line 685 "trace/trace-hw_hyperv.h"
        } else {
#line 22 "../hw/hyperv/trace-events"
            qemu_log("hv_balloon_incoming_version " "incoming proto version %u.%u" "\n", major, minor);
#line 689 "trace/trace-hw_hyperv.h"
        }
    }
}

static inline void trace_hv_balloon_incoming_version(uint16_t major, uint16_t minor)
{
    if (true) {
        _nocheck__trace_hv_balloon_incoming_version(major, minor);
    }
}

#define TRACE_HV_BALLOON_INCOMING_CAPS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HV_BALLOON_INCOMING_CAPS) || \
    false)

static inline void _nocheck__trace_hv_balloon_incoming_caps(uint32_t caps)
{
    if (trace_event_get_state(TRACE_HV_BALLOON_INCOMING_CAPS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 23 "../hw/hyperv/trace-events"
            qemu_log("%d@%zu.%06zu:hv_balloon_incoming_caps " "incoming caps 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , caps);
#line 716 "trace/trace-hw_hyperv.h"
        } else {
#line 23 "../hw/hyperv/trace-events"
            qemu_log("hv_balloon_incoming_caps " "incoming caps 0x%x" "\n", caps);
#line 720 "trace/trace-hw_hyperv.h"
        }
    }
}

static inline void trace_hv_balloon_incoming_caps(uint32_t caps)
{
    if (true) {
        _nocheck__trace_hv_balloon_incoming_caps(caps);
    }
}

#define TRACE_HV_BALLOON_OUTGOING_UNBALLOON_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HV_BALLOON_OUTGOING_UNBALLOON) || \
    false)

static inline void _nocheck__trace_hv_balloon_outgoing_unballoon(uint32_t trans_id, uint64_t count, uint64_t start, uint64_t rempages)
{
    if (trace_event_get_state(TRACE_HV_BALLOON_OUTGOING_UNBALLOON) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 24 "../hw/hyperv/trace-events"
            qemu_log("%d@%zu.%06zu:hv_balloon_outgoing_unballoon " "posting unballoon %"PRIu32" for %"PRIu64" @ 0x%"PRIx64", remaining %"PRIu64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , trans_id, count, start, rempages);
#line 747 "trace/trace-hw_hyperv.h"
        } else {
#line 24 "../hw/hyperv/trace-events"
            qemu_log("hv_balloon_outgoing_unballoon " "posting unballoon %"PRIu32" for %"PRIu64" @ 0x%"PRIx64", remaining %"PRIu64 "\n", trans_id, count, start, rempages);
#line 751 "trace/trace-hw_hyperv.h"
        }
    }
}

static inline void trace_hv_balloon_outgoing_unballoon(uint32_t trans_id, uint64_t count, uint64_t start, uint64_t rempages)
{
    if (true) {
        _nocheck__trace_hv_balloon_outgoing_unballoon(trans_id, count, start, rempages);
    }
}

#define TRACE_HV_BALLOON_INCOMING_UNBALLOON_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HV_BALLOON_INCOMING_UNBALLOON) || \
    false)

static inline void _nocheck__trace_hv_balloon_incoming_unballoon(uint32_t trans_id)
{
    if (trace_event_get_state(TRACE_HV_BALLOON_INCOMING_UNBALLOON) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 25 "../hw/hyperv/trace-events"
            qemu_log("%d@%zu.%06zu:hv_balloon_incoming_unballoon " "incoming unballoon response %"PRIu32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , trans_id);
#line 778 "trace/trace-hw_hyperv.h"
        } else {
#line 25 "../hw/hyperv/trace-events"
            qemu_log("hv_balloon_incoming_unballoon " "incoming unballoon response %"PRIu32 "\n", trans_id);
#line 782 "trace/trace-hw_hyperv.h"
        }
    }
}

static inline void trace_hv_balloon_incoming_unballoon(uint32_t trans_id)
{
    if (true) {
        _nocheck__trace_hv_balloon_incoming_unballoon(trans_id);
    }
}

#define TRACE_HV_BALLOON_OUTGOING_HOT_ADD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HV_BALLOON_OUTGOING_HOT_ADD) || \
    false)

static inline void _nocheck__trace_hv_balloon_outgoing_hot_add(uint32_t trans_id, uint64_t count, uint64_t start)
{
    if (trace_event_get_state(TRACE_HV_BALLOON_OUTGOING_HOT_ADD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 26 "../hw/hyperv/trace-events"
            qemu_log("%d@%zu.%06zu:hv_balloon_outgoing_hot_add " "posting hot add %"PRIu32" for %"PRIu64" @ 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , trans_id, count, start);
#line 809 "trace/trace-hw_hyperv.h"
        } else {
#line 26 "../hw/hyperv/trace-events"
            qemu_log("hv_balloon_outgoing_hot_add " "posting hot add %"PRIu32" for %"PRIu64" @ 0x%"PRIx64 "\n", trans_id, count, start);
#line 813 "trace/trace-hw_hyperv.h"
        }
    }
}

static inline void trace_hv_balloon_outgoing_hot_add(uint32_t trans_id, uint64_t count, uint64_t start)
{
    if (true) {
        _nocheck__trace_hv_balloon_outgoing_hot_add(trans_id, count, start);
    }
}

#define TRACE_HV_BALLOON_INCOMING_HOT_ADD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HV_BALLOON_INCOMING_HOT_ADD) || \
    false)

static inline void _nocheck__trace_hv_balloon_incoming_hot_add(uint32_t trans_id, uint32_t result, uint32_t count)
{
    if (trace_event_get_state(TRACE_HV_BALLOON_INCOMING_HOT_ADD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 27 "../hw/hyperv/trace-events"
            qemu_log("%d@%zu.%06zu:hv_balloon_incoming_hot_add " "incoming hot add response %"PRIu32", result %"PRIu32", count %"PRIu32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , trans_id, result, count);
#line 840 "trace/trace-hw_hyperv.h"
        } else {
#line 27 "../hw/hyperv/trace-events"
            qemu_log("hv_balloon_incoming_hot_add " "incoming hot add response %"PRIu32", result %"PRIu32", count %"PRIu32 "\n", trans_id, result, count);
#line 844 "trace/trace-hw_hyperv.h"
        }
    }
}

static inline void trace_hv_balloon_incoming_hot_add(uint32_t trans_id, uint32_t result, uint32_t count)
{
    if (true) {
        _nocheck__trace_hv_balloon_incoming_hot_add(trans_id, result, count);
    }
}

#define TRACE_HV_BALLOON_OUTGOING_BALLOON_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HV_BALLOON_OUTGOING_BALLOON) || \
    false)

static inline void _nocheck__trace_hv_balloon_outgoing_balloon(uint32_t trans_id, uint64_t count, uint64_t rempages)
{
    if (trace_event_get_state(TRACE_HV_BALLOON_OUTGOING_BALLOON) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 28 "../hw/hyperv/trace-events"
            qemu_log("%d@%zu.%06zu:hv_balloon_outgoing_balloon " "posting balloon %"PRIu32" for %"PRIu64", remaining %"PRIu64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , trans_id, count, rempages);
#line 871 "trace/trace-hw_hyperv.h"
        } else {
#line 28 "../hw/hyperv/trace-events"
            qemu_log("hv_balloon_outgoing_balloon " "posting balloon %"PRIu32" for %"PRIu64", remaining %"PRIu64 "\n", trans_id, count, rempages);
#line 875 "trace/trace-hw_hyperv.h"
        }
    }
}

static inline void trace_hv_balloon_outgoing_balloon(uint32_t trans_id, uint64_t count, uint64_t rempages)
{
    if (true) {
        _nocheck__trace_hv_balloon_outgoing_balloon(trans_id, count, rempages);
    }
}

#define TRACE_HV_BALLOON_INCOMING_BALLOON_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HV_BALLOON_INCOMING_BALLOON) || \
    false)

static inline void _nocheck__trace_hv_balloon_incoming_balloon(uint32_t trans_id, uint32_t range_count, uint32_t more_pages)
{
    if (trace_event_get_state(TRACE_HV_BALLOON_INCOMING_BALLOON) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 29 "../hw/hyperv/trace-events"
            qemu_log("%d@%zu.%06zu:hv_balloon_incoming_balloon " "incoming balloon response %"PRIu32", ranges %"PRIu32", more %"PRIu32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , trans_id, range_count, more_pages);
#line 902 "trace/trace-hw_hyperv.h"
        } else {
#line 29 "../hw/hyperv/trace-events"
            qemu_log("hv_balloon_incoming_balloon " "incoming balloon response %"PRIu32", ranges %"PRIu32", more %"PRIu32 "\n", trans_id, range_count, more_pages);
#line 906 "trace/trace-hw_hyperv.h"
        }
    }
}

static inline void trace_hv_balloon_incoming_balloon(uint32_t trans_id, uint32_t range_count, uint32_t more_pages)
{
    if (true) {
        _nocheck__trace_hv_balloon_incoming_balloon(trans_id, range_count, more_pages);
    }
}

#define TRACE_HV_BALLOON_OUR_RANGE_ADD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HV_BALLOON_OUR_RANGE_ADD) || \
    false)

static inline void _nocheck__trace_hv_balloon_our_range_add(uint64_t count, uint64_t start)
{
    if (trace_event_get_state(TRACE_HV_BALLOON_OUR_RANGE_ADD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 30 "../hw/hyperv/trace-events"
            qemu_log("%d@%zu.%06zu:hv_balloon_our_range_add " "adding our range %"PRIu64" @ 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , count, start);
#line 933 "trace/trace-hw_hyperv.h"
        } else {
#line 30 "../hw/hyperv/trace-events"
            qemu_log("hv_balloon_our_range_add " "adding our range %"PRIu64" @ 0x%"PRIx64 "\n", count, start);
#line 937 "trace/trace-hw_hyperv.h"
        }
    }
}

static inline void trace_hv_balloon_our_range_add(uint64_t count, uint64_t start)
{
    if (true) {
        _nocheck__trace_hv_balloon_our_range_add(count, start);
    }
}

#define TRACE_HV_BALLOON_REMOVE_RESPONSE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HV_BALLOON_REMOVE_RESPONSE) || \
    false)

static inline void _nocheck__trace_hv_balloon_remove_response(uint64_t count, uint64_t start, unsigned int both)
{
    if (trace_event_get_state(TRACE_HV_BALLOON_REMOVE_RESPONSE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 31 "../hw/hyperv/trace-events"
            qemu_log("%d@%zu.%06zu:hv_balloon_remove_response " "processing remove response range %"PRIu64" @ 0x%"PRIx64", both %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , count, start, both);
#line 964 "trace/trace-hw_hyperv.h"
        } else {
#line 31 "../hw/hyperv/trace-events"
            qemu_log("hv_balloon_remove_response " "processing remove response range %"PRIu64" @ 0x%"PRIx64", both %u" "\n", count, start, both);
#line 968 "trace/trace-hw_hyperv.h"
        }
    }
}

static inline void trace_hv_balloon_remove_response(uint64_t count, uint64_t start, unsigned int both)
{
    if (true) {
        _nocheck__trace_hv_balloon_remove_response(count, start, both);
    }
}

#define TRACE_HV_BALLOON_REMOVE_RESPONSE_HOLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HV_BALLOON_REMOVE_RESPONSE_HOLE) || \
    false)

static inline void _nocheck__trace_hv_balloon_remove_response_hole(uint64_t counthole, uint64_t starthole, uint64_t countrange, uint64_t startrange, uint64_t starthpr, unsigned int both)
{
    if (trace_event_get_state(TRACE_HV_BALLOON_REMOVE_RESPONSE_HOLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 32 "../hw/hyperv/trace-events"
            qemu_log("%d@%zu.%06zu:hv_balloon_remove_response_hole " "response range hole %"PRIu64" @ 0x%"PRIx64" from range %"PRIu64" @ 0x%"PRIx64", before our start 0x%"PRIx64", both %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , counthole, starthole, countrange, startrange, starthpr, both);
#line 995 "trace/trace-hw_hyperv.h"
        } else {
#line 32 "../hw/hyperv/trace-events"
            qemu_log("hv_balloon_remove_response_hole " "response range hole %"PRIu64" @ 0x%"PRIx64" from range %"PRIu64" @ 0x%"PRIx64", before our start 0x%"PRIx64", both %u" "\n", counthole, starthole, countrange, startrange, starthpr, both);
#line 999 "trace/trace-hw_hyperv.h"
        }
    }
}

static inline void trace_hv_balloon_remove_response_hole(uint64_t counthole, uint64_t starthole, uint64_t countrange, uint64_t startrange, uint64_t starthpr, unsigned int both)
{
    if (true) {
        _nocheck__trace_hv_balloon_remove_response_hole(counthole, starthole, countrange, startrange, starthpr, both);
    }
}

#define TRACE_HV_BALLOON_REMOVE_RESPONSE_COMMON_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HV_BALLOON_REMOVE_RESPONSE_COMMON) || \
    false)

static inline void _nocheck__trace_hv_balloon_remove_response_common(uint64_t countcommon, uint64_t startcommon, uint64_t countrange, uint64_t startrange, uint64_t counthpr, uint64_t starthpr, uint64_t removed, unsigned int both)
{
    if (trace_event_get_state(TRACE_HV_BALLOON_REMOVE_RESPONSE_COMMON) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 33 "../hw/hyperv/trace-events"
            qemu_log("%d@%zu.%06zu:hv_balloon_remove_response_common " "response common range %"PRIu64" @ 0x%"PRIx64" from range %"PRIu64" @ 0x%"PRIx64" with our %"PRIu64" @ 0x%"PRIx64", removed %"PRIu64", both %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , countcommon, startcommon, countrange, startrange, counthpr, starthpr, removed, both);
#line 1026 "trace/trace-hw_hyperv.h"
        } else {
#line 33 "../hw/hyperv/trace-events"
            qemu_log("hv_balloon_remove_response_common " "response common range %"PRIu64" @ 0x%"PRIx64" from range %"PRIu64" @ 0x%"PRIx64" with our %"PRIu64" @ 0x%"PRIx64", removed %"PRIu64", both %u" "\n", countcommon, startcommon, countrange, startrange, counthpr, starthpr, removed, both);
#line 1030 "trace/trace-hw_hyperv.h"
        }
    }
}

static inline void trace_hv_balloon_remove_response_common(uint64_t countcommon, uint64_t startcommon, uint64_t countrange, uint64_t startrange, uint64_t counthpr, uint64_t starthpr, uint64_t removed, unsigned int both)
{
    if (true) {
        _nocheck__trace_hv_balloon_remove_response_common(countcommon, startcommon, countrange, startrange, counthpr, starthpr, removed, both);
    }
}

#define TRACE_HV_BALLOON_REMOVE_RESPONSE_REMAINDER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HV_BALLOON_REMOVE_RESPONSE_REMAINDER) || \
    false)

static inline void _nocheck__trace_hv_balloon_remove_response_remainder(uint64_t count, uint64_t start, unsigned int both)
{
    if (trace_event_get_state(TRACE_HV_BALLOON_REMOVE_RESPONSE_REMAINDER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 34 "../hw/hyperv/trace-events"
            qemu_log("%d@%zu.%06zu:hv_balloon_remove_response_remainder " "remove response remaining range %"PRIu64" @ 0x%"PRIx64", both %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , count, start, both);
#line 1057 "trace/trace-hw_hyperv.h"
        } else {
#line 34 "../hw/hyperv/trace-events"
            qemu_log("hv_balloon_remove_response_remainder " "remove response remaining range %"PRIu64" @ 0x%"PRIx64", both %u" "\n", count, start, both);
#line 1061 "trace/trace-hw_hyperv.h"
        }
    }
}

static inline void trace_hv_balloon_remove_response_remainder(uint64_t count, uint64_t start, unsigned int both)
{
    if (true) {
        _nocheck__trace_hv_balloon_remove_response_remainder(count, start, both);
    }
}

#define TRACE_HV_BALLOON_MAP_SLOT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HV_BALLOON_MAP_SLOT) || \
    false)

static inline void _nocheck__trace_hv_balloon_map_slot(unsigned int idx, unsigned int total_slots, uint64_t offset)
{
    if (trace_event_get_state(TRACE_HV_BALLOON_MAP_SLOT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 35 "../hw/hyperv/trace-events"
            qemu_log("%d@%zu.%06zu:hv_balloon_map_slot " "mapping memslot %u / %u @ 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , idx, total_slots, offset);
#line 1088 "trace/trace-hw_hyperv.h"
        } else {
#line 35 "../hw/hyperv/trace-events"
            qemu_log("hv_balloon_map_slot " "mapping memslot %u / %u @ 0x%"PRIx64 "\n", idx, total_slots, offset);
#line 1092 "trace/trace-hw_hyperv.h"
        }
    }
}

static inline void trace_hv_balloon_map_slot(unsigned int idx, unsigned int total_slots, uint64_t offset)
{
    if (true) {
        _nocheck__trace_hv_balloon_map_slot(idx, total_slots, offset);
    }
}

#define TRACE_HV_BALLOON_UNMAP_SLOT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HV_BALLOON_UNMAP_SLOT) || \
    false)

static inline void _nocheck__trace_hv_balloon_unmap_slot(unsigned int idx, unsigned int total_slots, uint64_t offset)
{
    if (trace_event_get_state(TRACE_HV_BALLOON_UNMAP_SLOT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 36 "../hw/hyperv/trace-events"
            qemu_log("%d@%zu.%06zu:hv_balloon_unmap_slot " "unmapping memslot %u / %u @ 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , idx, total_slots, offset);
#line 1119 "trace/trace-hw_hyperv.h"
        } else {
#line 36 "../hw/hyperv/trace-events"
            qemu_log("hv_balloon_unmap_slot " "unmapping memslot %u / %u @ 0x%"PRIx64 "\n", idx, total_slots, offset);
#line 1123 "trace/trace-hw_hyperv.h"
        }
    }
}

static inline void trace_hv_balloon_unmap_slot(unsigned int idx, unsigned int total_slots, uint64_t offset)
{
    if (true) {
        _nocheck__trace_hv_balloon_unmap_slot(idx, total_slots, offset);
    }
}
#endif /* TRACE_HW_HYPERV_GENERATED_TRACERS_H */
