/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_BLOCK_GENERATED_TRACERS_H
#define TRACE_BLOCK_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_BDRV_OPEN_COMMON_EVENT;
extern TraceEvent _TRACE_BDRV_LOCK_MEDIUM_EVENT;
extern TraceEvent _TRACE_BLK_CO_PREADV_EVENT;
extern TraceEvent _TRACE_BLK_CO_PWRITEV_EVENT;
extern TraceEvent _TRACE_BLK_ROOT_ATTACH_EVENT;
extern TraceEvent _TRACE_BLK_ROOT_DETACH_EVENT;
extern TraceEvent _TRACE_BDRV_CO_PREADV_PART_EVENT;
extern TraceEvent _TRACE_BDRV_CO_PWRITEV_PART_EVENT;
extern TraceEvent _TRACE_BDRV_CO_PWRITE_ZEROES_EVENT;
extern TraceEvent _TRACE_BDRV_CO_DO_COPY_ON_READV_EVENT;
extern TraceEvent _TRACE_BDRV_CO_COPY_RANGE_FROM_EVENT;
extern TraceEvent _TRACE_BDRV_CO_COPY_RANGE_TO_EVENT;
extern TraceEvent _TRACE_STREAM_ONE_ITERATION_EVENT;
extern TraceEvent _TRACE_STREAM_START_EVENT;
extern TraceEvent _TRACE_COMMIT_ONE_ITERATION_EVENT;
extern TraceEvent _TRACE_COMMIT_START_EVENT;
extern TraceEvent _TRACE_MIRROR_START_EVENT;
extern TraceEvent _TRACE_MIRROR_RESTART_ITER_EVENT;
extern TraceEvent _TRACE_MIRROR_BEFORE_FLUSH_EVENT;
extern TraceEvent _TRACE_MIRROR_BEFORE_DRAIN_EVENT;
extern TraceEvent _TRACE_MIRROR_BEFORE_SLEEP_EVENT;
extern TraceEvent _TRACE_MIRROR_ONE_ITERATION_EVENT;
extern TraceEvent _TRACE_MIRROR_ITERATION_DONE_EVENT;
extern TraceEvent _TRACE_MIRROR_YIELD_EVENT;
extern TraceEvent _TRACE_MIRROR_YIELD_IN_FLIGHT_EVENT;
extern TraceEvent _TRACE_BACKUP_DO_COW_ENTER_EVENT;
extern TraceEvent _TRACE_BACKUP_DO_COW_RETURN_EVENT;
extern TraceEvent _TRACE_BLOCK_COPY_SKIP_RANGE_EVENT;
extern TraceEvent _TRACE_BLOCK_COPY_PROCESS_EVENT;
extern TraceEvent _TRACE_BLOCK_COPY_COPY_RANGE_FAIL_EVENT;
extern TraceEvent _TRACE_BLOCK_COPY_READ_FAIL_EVENT;
extern TraceEvent _TRACE_BLOCK_COPY_WRITE_FAIL_EVENT;
extern TraceEvent _TRACE_BLOCK_COPY_WRITE_ZEROES_FAIL_EVENT;
extern TraceEvent _TRACE_QMP_BLOCK_JOB_CANCEL_EVENT;
extern TraceEvent _TRACE_QMP_BLOCK_JOB_PAUSE_EVENT;
extern TraceEvent _TRACE_QMP_BLOCK_JOB_RESUME_EVENT;
extern TraceEvent _TRACE_QMP_BLOCK_JOB_COMPLETE_EVENT;
extern TraceEvent _TRACE_QMP_BLOCK_JOB_FINALIZE_EVENT;
extern TraceEvent _TRACE_QMP_BLOCK_JOB_DISMISS_EVENT;
extern TraceEvent _TRACE_QMP_BLOCK_STREAM_EVENT;
extern TraceEvent _TRACE_FILE_PAIO_SUBMIT_EVENT;
extern TraceEvent _TRACE_LURING_INIT_STATE_EVENT;
extern TraceEvent _TRACE_LURING_CLEANUP_STATE_EVENT;
extern TraceEvent _TRACE_LURING_UNPLUG_FN_EVENT;
extern TraceEvent _TRACE_LURING_DO_SUBMIT_EVENT;
extern TraceEvent _TRACE_LURING_DO_SUBMIT_DONE_EVENT;
extern TraceEvent _TRACE_LURING_CO_SUBMIT_EVENT;
extern TraceEvent _TRACE_LURING_PROCESS_COMPLETION_EVENT;
extern TraceEvent _TRACE_LURING_IO_URING_SUBMIT_EVENT;
extern TraceEvent _TRACE_LURING_RESUBMIT_SHORT_READ_EVENT;
extern TraceEvent _TRACE_QCOW2_ADD_TASK_EVENT;
extern TraceEvent _TRACE_QCOW2_WRITEV_START_REQ_EVENT;
extern TraceEvent _TRACE_QCOW2_WRITEV_DONE_REQ_EVENT;
extern TraceEvent _TRACE_QCOW2_WRITEV_START_PART_EVENT;
extern TraceEvent _TRACE_QCOW2_WRITEV_DONE_PART_EVENT;
extern TraceEvent _TRACE_QCOW2_WRITEV_DATA_EVENT;
extern TraceEvent _TRACE_QCOW2_PWRITE_ZEROES_START_REQ_EVENT;
extern TraceEvent _TRACE_QCOW2_PWRITE_ZEROES_EVENT;
extern TraceEvent _TRACE_QCOW2_SKIP_COW_EVENT;
extern TraceEvent _TRACE_QCOW2_ALLOC_CLUSTERS_OFFSET_EVENT;
extern TraceEvent _TRACE_QCOW2_HANDLE_COPIED_EVENT;
extern TraceEvent _TRACE_QCOW2_HANDLE_ALLOC_EVENT;
extern TraceEvent _TRACE_QCOW2_DO_ALLOC_CLUSTERS_OFFSET_EVENT;
extern TraceEvent _TRACE_QCOW2_CLUSTER_ALLOC_PHYS_EVENT;
extern TraceEvent _TRACE_QCOW2_CLUSTER_LINK_L2_EVENT;
extern TraceEvent _TRACE_QCOW2_L2_ALLOCATE_EVENT;
extern TraceEvent _TRACE_QCOW2_L2_ALLOCATE_GET_EMPTY_EVENT;
extern TraceEvent _TRACE_QCOW2_L2_ALLOCATE_WRITE_L2_EVENT;
extern TraceEvent _TRACE_QCOW2_L2_ALLOCATE_WRITE_L1_EVENT;
extern TraceEvent _TRACE_QCOW2_L2_ALLOCATE_DONE_EVENT;
extern TraceEvent _TRACE_QCOW2_CACHE_GET_EVENT;
extern TraceEvent _TRACE_QCOW2_CACHE_GET_REPLACE_ENTRY_EVENT;
extern TraceEvent _TRACE_QCOW2_CACHE_GET_READ_EVENT;
extern TraceEvent _TRACE_QCOW2_CACHE_GET_DONE_EVENT;
extern TraceEvent _TRACE_QCOW2_CACHE_FLUSH_EVENT;
extern TraceEvent _TRACE_QCOW2_CACHE_ENTRY_FLUSH_EVENT;
extern TraceEvent _TRACE_QCOW2_PROCESS_DISCARDS_FAILED_REGION_EVENT;
extern TraceEvent _TRACE_QED_ALLOC_L2_CACHE_ENTRY_EVENT;
extern TraceEvent _TRACE_QED_UNREF_L2_CACHE_ENTRY_EVENT;
extern TraceEvent _TRACE_QED_FIND_L2_CACHE_ENTRY_EVENT;
extern TraceEvent _TRACE_QED_READ_TABLE_EVENT;
extern TraceEvent _TRACE_QED_READ_TABLE_CB_EVENT;
extern TraceEvent _TRACE_QED_WRITE_TABLE_EVENT;
extern TraceEvent _TRACE_QED_WRITE_TABLE_CB_EVENT;
extern TraceEvent _TRACE_QED_NEED_CHECK_TIMER_CB_EVENT;
extern TraceEvent _TRACE_QED_START_NEED_CHECK_TIMER_EVENT;
extern TraceEvent _TRACE_QED_CANCEL_NEED_CHECK_TIMER_EVENT;
extern TraceEvent _TRACE_QED_AIO_COMPLETE_EVENT;
extern TraceEvent _TRACE_QED_AIO_SETUP_EVENT;
extern TraceEvent _TRACE_QED_AIO_NEXT_IO_EVENT;
extern TraceEvent _TRACE_QED_AIO_READ_DATA_EVENT;
extern TraceEvent _TRACE_QED_AIO_WRITE_DATA_EVENT;
extern TraceEvent _TRACE_QED_AIO_WRITE_PREFILL_EVENT;
extern TraceEvent _TRACE_QED_AIO_WRITE_POSTFILL_EVENT;
extern TraceEvent _TRACE_QED_AIO_WRITE_MAIN_EVENT;
extern TraceEvent _TRACE_NVME_CONTROLLER_CAPABILITY_RAW_EVENT;
extern TraceEvent _TRACE_NVME_CONTROLLER_CAPABILITY_EVENT;
extern TraceEvent _TRACE_NVME_CONTROLLER_SPEC_VERSION_EVENT;
extern TraceEvent _TRACE_NVME_KICK_EVENT;
extern TraceEvent _TRACE_NVME_DMA_FLUSH_QUEUE_WAIT_EVENT;
extern TraceEvent _TRACE_NVME_ERROR_EVENT;
extern TraceEvent _TRACE_NVME_PROCESS_COMPLETION_EVENT;
extern TraceEvent _TRACE_NVME_COMPLETE_COMMAND_EVENT;
extern TraceEvent _TRACE_NVME_SUBMIT_COMMAND_EVENT;
extern TraceEvent _TRACE_NVME_SUBMIT_COMMAND_RAW_EVENT;
extern TraceEvent _TRACE_NVME_HANDLE_EVENT_EVENT;
extern TraceEvent _TRACE_NVME_POLL_QUEUE_EVENT;
extern TraceEvent _TRACE_NVME_PRW_ALIGNED_EVENT;
extern TraceEvent _TRACE_NVME_WRITE_ZEROES_EVENT;
extern TraceEvent _TRACE_NVME_QIOV_UNALIGNED_EVENT;
extern TraceEvent _TRACE_NVME_PRW_BUFFERED_EVENT;
extern TraceEvent _TRACE_NVME_RW_DONE_EVENT;
extern TraceEvent _TRACE_NVME_DSM_EVENT;
extern TraceEvent _TRACE_NVME_DSM_DONE_EVENT;
extern TraceEvent _TRACE_NVME_DMA_MAP_FLUSH_EVENT;
extern TraceEvent _TRACE_NVME_FREE_REQ_QUEUE_WAIT_EVENT;
extern TraceEvent _TRACE_NVME_CREATE_QUEUE_PAIR_EVENT;
extern TraceEvent _TRACE_NVME_FREE_QUEUE_PAIR_EVENT;
extern TraceEvent _TRACE_NVME_CMD_MAP_QIOV_EVENT;
extern TraceEvent _TRACE_NVME_CMD_MAP_QIOV_PAGES_EVENT;
extern TraceEvent _TRACE_NVME_CMD_MAP_QIOV_IOV_EVENT;
extern TraceEvent _TRACE_ISCSI_XCOPY_EVENT;
extern TraceEvent _TRACE_NBD_PARSE_BLOCKSTATUS_COMPLIANCE_EVENT;
extern TraceEvent _TRACE_NBD_STRUCTURED_READ_COMPLIANCE_EVENT;
extern TraceEvent _TRACE_NBD_EXTENDED_HEADERS_COMPLIANCE_EVENT;
extern TraceEvent _TRACE_NBD_READ_REPLY_ENTRY_FAIL_EVENT;
extern TraceEvent _TRACE_NBD_CO_REQUEST_FAIL_EVENT;
extern TraceEvent _TRACE_NBD_CLIENT_HANDSHAKE_EVENT;
extern TraceEvent _TRACE_NBD_CLIENT_HANDSHAKE_SUCCESS_EVENT;
extern TraceEvent _TRACE_NBD_RECONNECT_ATTEMPT_EVENT;
extern TraceEvent _TRACE_NBD_RECONNECT_ATTEMPT_RESULT_EVENT;
extern TraceEvent _TRACE_SSH_RESTART_COROUTINE_EVENT;
extern TraceEvent _TRACE_SSH_FLUSH_EVENT;
extern TraceEvent _TRACE_SSH_CHECK_HOST_KEY_KNOWNHOSTS_EVENT;
extern TraceEvent _TRACE_SSH_CONNECT_TO_SSH_EVENT;
extern TraceEvent _TRACE_SSH_CO_YIELD_EVENT;
extern TraceEvent _TRACE_SSH_CO_YIELD_BACK_EVENT;
extern TraceEvent _TRACE_SSH_GETLENGTH_EVENT;
extern TraceEvent _TRACE_SSH_CO_CREATE_OPTS_EVENT;
extern TraceEvent _TRACE_SSH_READ_EVENT;
extern TraceEvent _TRACE_SSH_READ_BUF_EVENT;
extern TraceEvent _TRACE_SSH_READ_RETURN_EVENT;
extern TraceEvent _TRACE_SSH_WRITE_EVENT;
extern TraceEvent _TRACE_SSH_WRITE_BUF_EVENT;
extern TraceEvent _TRACE_SSH_WRITE_RETURN_EVENT;
extern TraceEvent _TRACE_SSH_SEEK_EVENT;
extern TraceEvent _TRACE_SSH_AUTH_METHODS_EVENT;
extern TraceEvent _TRACE_SSH_SERVER_STATUS_EVENT;
extern TraceEvent _TRACE_CURL_TIMER_CB_EVENT;
extern TraceEvent _TRACE_CURL_SOCK_CB_EVENT;
extern TraceEvent _TRACE_CURL_READ_CB_EVENT;
extern TraceEvent _TRACE_CURL_OPEN_EVENT;
extern TraceEvent _TRACE_CURL_OPEN_SIZE_EVENT;
extern TraceEvent _TRACE_CURL_SETUP_PREADV_EVENT;
extern TraceEvent _TRACE_CURL_CLOSE_EVENT;
extern TraceEvent _TRACE_FILE_COPY_FILE_RANGE_EVENT;
extern TraceEvent _TRACE_FILE_FINDEJECTABLEOPTICALMEDIA_EVENT;
extern TraceEvent _TRACE_FILE_SETUP_CDROM_EVENT;
extern TraceEvent _TRACE_FILE_HDEV_IS_SG_EVENT;
extern TraceEvent _TRACE_FILE_FLUSH_FDATASYNC_FAILED_EVENT;
extern TraceEvent _TRACE_ZBD_ZONE_REPORT_EVENT;
extern TraceEvent _TRACE_ZBD_ZONE_MGMT_EVENT;
extern TraceEvent _TRACE_ZBD_ZONE_APPEND_EVENT;
extern TraceEvent _TRACE_ZBD_ZONE_APPEND_COMPLETE_EVENT;
extern TraceEvent _TRACE_SFTP_ERROR_EVENT;
extern uint16_t _TRACE_BDRV_OPEN_COMMON_DSTATE;
extern uint16_t _TRACE_BDRV_LOCK_MEDIUM_DSTATE;
extern uint16_t _TRACE_BLK_CO_PREADV_DSTATE;
extern uint16_t _TRACE_BLK_CO_PWRITEV_DSTATE;
extern uint16_t _TRACE_BLK_ROOT_ATTACH_DSTATE;
extern uint16_t _TRACE_BLK_ROOT_DETACH_DSTATE;
extern uint16_t _TRACE_BDRV_CO_PREADV_PART_DSTATE;
extern uint16_t _TRACE_BDRV_CO_PWRITEV_PART_DSTATE;
extern uint16_t _TRACE_BDRV_CO_PWRITE_ZEROES_DSTATE;
extern uint16_t _TRACE_BDRV_CO_DO_COPY_ON_READV_DSTATE;
extern uint16_t _TRACE_BDRV_CO_COPY_RANGE_FROM_DSTATE;
extern uint16_t _TRACE_BDRV_CO_COPY_RANGE_TO_DSTATE;
extern uint16_t _TRACE_STREAM_ONE_ITERATION_DSTATE;
extern uint16_t _TRACE_STREAM_START_DSTATE;
extern uint16_t _TRACE_COMMIT_ONE_ITERATION_DSTATE;
extern uint16_t _TRACE_COMMIT_START_DSTATE;
extern uint16_t _TRACE_MIRROR_START_DSTATE;
extern uint16_t _TRACE_MIRROR_RESTART_ITER_DSTATE;
extern uint16_t _TRACE_MIRROR_BEFORE_FLUSH_DSTATE;
extern uint16_t _TRACE_MIRROR_BEFORE_DRAIN_DSTATE;
extern uint16_t _TRACE_MIRROR_BEFORE_SLEEP_DSTATE;
extern uint16_t _TRACE_MIRROR_ONE_ITERATION_DSTATE;
extern uint16_t _TRACE_MIRROR_ITERATION_DONE_DSTATE;
extern uint16_t _TRACE_MIRROR_YIELD_DSTATE;
extern uint16_t _TRACE_MIRROR_YIELD_IN_FLIGHT_DSTATE;
extern uint16_t _TRACE_BACKUP_DO_COW_ENTER_DSTATE;
extern uint16_t _TRACE_BACKUP_DO_COW_RETURN_DSTATE;
extern uint16_t _TRACE_BLOCK_COPY_SKIP_RANGE_DSTATE;
extern uint16_t _TRACE_BLOCK_COPY_PROCESS_DSTATE;
extern uint16_t _TRACE_BLOCK_COPY_COPY_RANGE_FAIL_DSTATE;
extern uint16_t _TRACE_BLOCK_COPY_READ_FAIL_DSTATE;
extern uint16_t _TRACE_BLOCK_COPY_WRITE_FAIL_DSTATE;
extern uint16_t _TRACE_BLOCK_COPY_WRITE_ZEROES_FAIL_DSTATE;
extern uint16_t _TRACE_QMP_BLOCK_JOB_CANCEL_DSTATE;
extern uint16_t _TRACE_QMP_BLOCK_JOB_PAUSE_DSTATE;
extern uint16_t _TRACE_QMP_BLOCK_JOB_RESUME_DSTATE;
extern uint16_t _TRACE_QMP_BLOCK_JOB_COMPLETE_DSTATE;
extern uint16_t _TRACE_QMP_BLOCK_JOB_FINALIZE_DSTATE;
extern uint16_t _TRACE_QMP_BLOCK_JOB_DISMISS_DSTATE;
extern uint16_t _TRACE_QMP_BLOCK_STREAM_DSTATE;
extern uint16_t _TRACE_FILE_PAIO_SUBMIT_DSTATE;
extern uint16_t _TRACE_LURING_INIT_STATE_DSTATE;
extern uint16_t _TRACE_LURING_CLEANUP_STATE_DSTATE;
extern uint16_t _TRACE_LURING_UNPLUG_FN_DSTATE;
extern uint16_t _TRACE_LURING_DO_SUBMIT_DSTATE;
extern uint16_t _TRACE_LURING_DO_SUBMIT_DONE_DSTATE;
extern uint16_t _TRACE_LURING_CO_SUBMIT_DSTATE;
extern uint16_t _TRACE_LURING_PROCESS_COMPLETION_DSTATE;
extern uint16_t _TRACE_LURING_IO_URING_SUBMIT_DSTATE;
extern uint16_t _TRACE_LURING_RESUBMIT_SHORT_READ_DSTATE;
extern uint16_t _TRACE_QCOW2_ADD_TASK_DSTATE;
extern uint16_t _TRACE_QCOW2_WRITEV_START_REQ_DSTATE;
extern uint16_t _TRACE_QCOW2_WRITEV_DONE_REQ_DSTATE;
extern uint16_t _TRACE_QCOW2_WRITEV_START_PART_DSTATE;
extern uint16_t _TRACE_QCOW2_WRITEV_DONE_PART_DSTATE;
extern uint16_t _TRACE_QCOW2_WRITEV_DATA_DSTATE;
extern uint16_t _TRACE_QCOW2_PWRITE_ZEROES_START_REQ_DSTATE;
extern uint16_t _TRACE_QCOW2_PWRITE_ZEROES_DSTATE;
extern uint16_t _TRACE_QCOW2_SKIP_COW_DSTATE;
extern uint16_t _TRACE_QCOW2_ALLOC_CLUSTERS_OFFSET_DSTATE;
extern uint16_t _TRACE_QCOW2_HANDLE_COPIED_DSTATE;
extern uint16_t _TRACE_QCOW2_HANDLE_ALLOC_DSTATE;
extern uint16_t _TRACE_QCOW2_DO_ALLOC_CLUSTERS_OFFSET_DSTATE;
extern uint16_t _TRACE_QCOW2_CLUSTER_ALLOC_PHYS_DSTATE;
extern uint16_t _TRACE_QCOW2_CLUSTER_LINK_L2_DSTATE;
extern uint16_t _TRACE_QCOW2_L2_ALLOCATE_DSTATE;
extern uint16_t _TRACE_QCOW2_L2_ALLOCATE_GET_EMPTY_DSTATE;
extern uint16_t _TRACE_QCOW2_L2_ALLOCATE_WRITE_L2_DSTATE;
extern uint16_t _TRACE_QCOW2_L2_ALLOCATE_WRITE_L1_DSTATE;
extern uint16_t _TRACE_QCOW2_L2_ALLOCATE_DONE_DSTATE;
extern uint16_t _TRACE_QCOW2_CACHE_GET_DSTATE;
extern uint16_t _TRACE_QCOW2_CACHE_GET_REPLACE_ENTRY_DSTATE;
extern uint16_t _TRACE_QCOW2_CACHE_GET_READ_DSTATE;
extern uint16_t _TRACE_QCOW2_CACHE_GET_DONE_DSTATE;
extern uint16_t _TRACE_QCOW2_CACHE_FLUSH_DSTATE;
extern uint16_t _TRACE_QCOW2_CACHE_ENTRY_FLUSH_DSTATE;
extern uint16_t _TRACE_QCOW2_PROCESS_DISCARDS_FAILED_REGION_DSTATE;
extern uint16_t _TRACE_QED_ALLOC_L2_CACHE_ENTRY_DSTATE;
extern uint16_t _TRACE_QED_UNREF_L2_CACHE_ENTRY_DSTATE;
extern uint16_t _TRACE_QED_FIND_L2_CACHE_ENTRY_DSTATE;
extern uint16_t _TRACE_QED_READ_TABLE_DSTATE;
extern uint16_t _TRACE_QED_READ_TABLE_CB_DSTATE;
extern uint16_t _TRACE_QED_WRITE_TABLE_DSTATE;
extern uint16_t _TRACE_QED_WRITE_TABLE_CB_DSTATE;
extern uint16_t _TRACE_QED_NEED_CHECK_TIMER_CB_DSTATE;
extern uint16_t _TRACE_QED_START_NEED_CHECK_TIMER_DSTATE;
extern uint16_t _TRACE_QED_CANCEL_NEED_CHECK_TIMER_DSTATE;
extern uint16_t _TRACE_QED_AIO_COMPLETE_DSTATE;
extern uint16_t _TRACE_QED_AIO_SETUP_DSTATE;
extern uint16_t _TRACE_QED_AIO_NEXT_IO_DSTATE;
extern uint16_t _TRACE_QED_AIO_READ_DATA_DSTATE;
extern uint16_t _TRACE_QED_AIO_WRITE_DATA_DSTATE;
extern uint16_t _TRACE_QED_AIO_WRITE_PREFILL_DSTATE;
extern uint16_t _TRACE_QED_AIO_WRITE_POSTFILL_DSTATE;
extern uint16_t _TRACE_QED_AIO_WRITE_MAIN_DSTATE;
extern uint16_t _TRACE_NVME_CONTROLLER_CAPABILITY_RAW_DSTATE;
extern uint16_t _TRACE_NVME_CONTROLLER_CAPABILITY_DSTATE;
extern uint16_t _TRACE_NVME_CONTROLLER_SPEC_VERSION_DSTATE;
extern uint16_t _TRACE_NVME_KICK_DSTATE;
extern uint16_t _TRACE_NVME_DMA_FLUSH_QUEUE_WAIT_DSTATE;
extern uint16_t _TRACE_NVME_ERROR_DSTATE;
extern uint16_t _TRACE_NVME_PROCESS_COMPLETION_DSTATE;
extern uint16_t _TRACE_NVME_COMPLETE_COMMAND_DSTATE;
extern uint16_t _TRACE_NVME_SUBMIT_COMMAND_DSTATE;
extern uint16_t _TRACE_NVME_SUBMIT_COMMAND_RAW_DSTATE;
extern uint16_t _TRACE_NVME_HANDLE_EVENT_DSTATE;
extern uint16_t _TRACE_NVME_POLL_QUEUE_DSTATE;
extern uint16_t _TRACE_NVME_PRW_ALIGNED_DSTATE;
extern uint16_t _TRACE_NVME_WRITE_ZEROES_DSTATE;
extern uint16_t _TRACE_NVME_QIOV_UNALIGNED_DSTATE;
extern uint16_t _TRACE_NVME_PRW_BUFFERED_DSTATE;
extern uint16_t _TRACE_NVME_RW_DONE_DSTATE;
extern uint16_t _TRACE_NVME_DSM_DSTATE;
extern uint16_t _TRACE_NVME_DSM_DONE_DSTATE;
extern uint16_t _TRACE_NVME_DMA_MAP_FLUSH_DSTATE;
extern uint16_t _TRACE_NVME_FREE_REQ_QUEUE_WAIT_DSTATE;
extern uint16_t _TRACE_NVME_CREATE_QUEUE_PAIR_DSTATE;
extern uint16_t _TRACE_NVME_FREE_QUEUE_PAIR_DSTATE;
extern uint16_t _TRACE_NVME_CMD_MAP_QIOV_DSTATE;
extern uint16_t _TRACE_NVME_CMD_MAP_QIOV_PAGES_DSTATE;
extern uint16_t _TRACE_NVME_CMD_MAP_QIOV_IOV_DSTATE;
extern uint16_t _TRACE_ISCSI_XCOPY_DSTATE;
extern uint16_t _TRACE_NBD_PARSE_BLOCKSTATUS_COMPLIANCE_DSTATE;
extern uint16_t _TRACE_NBD_STRUCTURED_READ_COMPLIANCE_DSTATE;
extern uint16_t _TRACE_NBD_EXTENDED_HEADERS_COMPLIANCE_DSTATE;
extern uint16_t _TRACE_NBD_READ_REPLY_ENTRY_FAIL_DSTATE;
extern uint16_t _TRACE_NBD_CO_REQUEST_FAIL_DSTATE;
extern uint16_t _TRACE_NBD_CLIENT_HANDSHAKE_DSTATE;
extern uint16_t _TRACE_NBD_CLIENT_HANDSHAKE_SUCCESS_DSTATE;
extern uint16_t _TRACE_NBD_RECONNECT_ATTEMPT_DSTATE;
extern uint16_t _TRACE_NBD_RECONNECT_ATTEMPT_RESULT_DSTATE;
extern uint16_t _TRACE_SSH_RESTART_COROUTINE_DSTATE;
extern uint16_t _TRACE_SSH_FLUSH_DSTATE;
extern uint16_t _TRACE_SSH_CHECK_HOST_KEY_KNOWNHOSTS_DSTATE;
extern uint16_t _TRACE_SSH_CONNECT_TO_SSH_DSTATE;
extern uint16_t _TRACE_SSH_CO_YIELD_DSTATE;
extern uint16_t _TRACE_SSH_CO_YIELD_BACK_DSTATE;
extern uint16_t _TRACE_SSH_GETLENGTH_DSTATE;
extern uint16_t _TRACE_SSH_CO_CREATE_OPTS_DSTATE;
extern uint16_t _TRACE_SSH_READ_DSTATE;
extern uint16_t _TRACE_SSH_READ_BUF_DSTATE;
extern uint16_t _TRACE_SSH_READ_RETURN_DSTATE;
extern uint16_t _TRACE_SSH_WRITE_DSTATE;
extern uint16_t _TRACE_SSH_WRITE_BUF_DSTATE;
extern uint16_t _TRACE_SSH_WRITE_RETURN_DSTATE;
extern uint16_t _TRACE_SSH_SEEK_DSTATE;
extern uint16_t _TRACE_SSH_AUTH_METHODS_DSTATE;
extern uint16_t _TRACE_SSH_SERVER_STATUS_DSTATE;
extern uint16_t _TRACE_CURL_TIMER_CB_DSTATE;
extern uint16_t _TRACE_CURL_SOCK_CB_DSTATE;
extern uint16_t _TRACE_CURL_READ_CB_DSTATE;
extern uint16_t _TRACE_CURL_OPEN_DSTATE;
extern uint16_t _TRACE_CURL_OPEN_SIZE_DSTATE;
extern uint16_t _TRACE_CURL_SETUP_PREADV_DSTATE;
extern uint16_t _TRACE_CURL_CLOSE_DSTATE;
extern uint16_t _TRACE_FILE_COPY_FILE_RANGE_DSTATE;
extern uint16_t _TRACE_FILE_FINDEJECTABLEOPTICALMEDIA_DSTATE;
extern uint16_t _TRACE_FILE_SETUP_CDROM_DSTATE;
extern uint16_t _TRACE_FILE_HDEV_IS_SG_DSTATE;
extern uint16_t _TRACE_FILE_FLUSH_FDATASYNC_FAILED_DSTATE;
extern uint16_t _TRACE_ZBD_ZONE_REPORT_DSTATE;
extern uint16_t _TRACE_ZBD_ZONE_MGMT_DSTATE;
extern uint16_t _TRACE_ZBD_ZONE_APPEND_DSTATE;
extern uint16_t _TRACE_ZBD_ZONE_APPEND_COMPLETE_DSTATE;
extern uint16_t _TRACE_SFTP_ERROR_DSTATE;
#define TRACE_BDRV_OPEN_COMMON_ENABLED 1
#define TRACE_BDRV_LOCK_MEDIUM_ENABLED 1
#define TRACE_BLK_CO_PREADV_ENABLED 1
#define TRACE_BLK_CO_PWRITEV_ENABLED 1
#define TRACE_BLK_ROOT_ATTACH_ENABLED 1
#define TRACE_BLK_ROOT_DETACH_ENABLED 1
#define TRACE_BDRV_CO_PREADV_PART_ENABLED 1
#define TRACE_BDRV_CO_PWRITEV_PART_ENABLED 1
#define TRACE_BDRV_CO_PWRITE_ZEROES_ENABLED 1
#define TRACE_BDRV_CO_DO_COPY_ON_READV_ENABLED 1
#define TRACE_BDRV_CO_COPY_RANGE_FROM_ENABLED 1
#define TRACE_BDRV_CO_COPY_RANGE_TO_ENABLED 1
#define TRACE_STREAM_ONE_ITERATION_ENABLED 1
#define TRACE_STREAM_START_ENABLED 1
#define TRACE_COMMIT_ONE_ITERATION_ENABLED 1
#define TRACE_COMMIT_START_ENABLED 1
#define TRACE_MIRROR_START_ENABLED 1
#define TRACE_MIRROR_RESTART_ITER_ENABLED 1
#define TRACE_MIRROR_BEFORE_FLUSH_ENABLED 1
#define TRACE_MIRROR_BEFORE_DRAIN_ENABLED 1
#define TRACE_MIRROR_BEFORE_SLEEP_ENABLED 1
#define TRACE_MIRROR_ONE_ITERATION_ENABLED 1
#define TRACE_MIRROR_ITERATION_DONE_ENABLED 1
#define TRACE_MIRROR_YIELD_ENABLED 1
#define TRACE_MIRROR_YIELD_IN_FLIGHT_ENABLED 1
#define TRACE_BACKUP_DO_COW_ENTER_ENABLED 1
#define TRACE_BACKUP_DO_COW_RETURN_ENABLED 1
#define TRACE_BLOCK_COPY_SKIP_RANGE_ENABLED 1
#define TRACE_BLOCK_COPY_PROCESS_ENABLED 1
#define TRACE_BLOCK_COPY_COPY_RANGE_FAIL_ENABLED 1
#define TRACE_BLOCK_COPY_READ_FAIL_ENABLED 1
#define TRACE_BLOCK_COPY_WRITE_FAIL_ENABLED 1
#define TRACE_BLOCK_COPY_WRITE_ZEROES_FAIL_ENABLED 1
#define TRACE_QMP_BLOCK_JOB_CANCEL_ENABLED 1
#define TRACE_QMP_BLOCK_JOB_PAUSE_ENABLED 1
#define TRACE_QMP_BLOCK_JOB_RESUME_ENABLED 1
#define TRACE_QMP_BLOCK_JOB_COMPLETE_ENABLED 1
#define TRACE_QMP_BLOCK_JOB_FINALIZE_ENABLED 1
#define TRACE_QMP_BLOCK_JOB_DISMISS_ENABLED 1
#define TRACE_QMP_BLOCK_STREAM_ENABLED 1
#define TRACE_FILE_PAIO_SUBMIT_ENABLED 1
#define TRACE_LURING_INIT_STATE_ENABLED 1
#define TRACE_LURING_CLEANUP_STATE_ENABLED 1
#define TRACE_LURING_UNPLUG_FN_ENABLED 1
#define TRACE_LURING_DO_SUBMIT_ENABLED 1
#define TRACE_LURING_DO_SUBMIT_DONE_ENABLED 1
#define TRACE_LURING_CO_SUBMIT_ENABLED 1
#define TRACE_LURING_PROCESS_COMPLETION_ENABLED 1
#define TRACE_LURING_IO_URING_SUBMIT_ENABLED 1
#define TRACE_LURING_RESUBMIT_SHORT_READ_ENABLED 1
#define TRACE_QCOW2_ADD_TASK_ENABLED 1
#define TRACE_QCOW2_WRITEV_START_REQ_ENABLED 1
#define TRACE_QCOW2_WRITEV_DONE_REQ_ENABLED 1
#define TRACE_QCOW2_WRITEV_START_PART_ENABLED 1
#define TRACE_QCOW2_WRITEV_DONE_PART_ENABLED 1
#define TRACE_QCOW2_WRITEV_DATA_ENABLED 1
#define TRACE_QCOW2_PWRITE_ZEROES_START_REQ_ENABLED 1
#define TRACE_QCOW2_PWRITE_ZEROES_ENABLED 1
#define TRACE_QCOW2_SKIP_COW_ENABLED 1
#define TRACE_QCOW2_ALLOC_CLUSTERS_OFFSET_ENABLED 1
#define TRACE_QCOW2_HANDLE_COPIED_ENABLED 1
#define TRACE_QCOW2_HANDLE_ALLOC_ENABLED 1
#define TRACE_QCOW2_DO_ALLOC_CLUSTERS_OFFSET_ENABLED 1
#define TRACE_QCOW2_CLUSTER_ALLOC_PHYS_ENABLED 1
#define TRACE_QCOW2_CLUSTER_LINK_L2_ENABLED 1
#define TRACE_QCOW2_L2_ALLOCATE_ENABLED 1
#define TRACE_QCOW2_L2_ALLOCATE_GET_EMPTY_ENABLED 1
#define TRACE_QCOW2_L2_ALLOCATE_WRITE_L2_ENABLED 1
#define TRACE_QCOW2_L2_ALLOCATE_WRITE_L1_ENABLED 1
#define TRACE_QCOW2_L2_ALLOCATE_DONE_ENABLED 1
#define TRACE_QCOW2_CACHE_GET_ENABLED 1
#define TRACE_QCOW2_CACHE_GET_REPLACE_ENTRY_ENABLED 1
#define TRACE_QCOW2_CACHE_GET_READ_ENABLED 1
#define TRACE_QCOW2_CACHE_GET_DONE_ENABLED 1
#define TRACE_QCOW2_CACHE_FLUSH_ENABLED 1
#define TRACE_QCOW2_CACHE_ENTRY_FLUSH_ENABLED 1
#define TRACE_QCOW2_PROCESS_DISCARDS_FAILED_REGION_ENABLED 1
#define TRACE_QED_ALLOC_L2_CACHE_ENTRY_ENABLED 1
#define TRACE_QED_UNREF_L2_CACHE_ENTRY_ENABLED 1
#define TRACE_QED_FIND_L2_CACHE_ENTRY_ENABLED 1
#define TRACE_QED_READ_TABLE_ENABLED 1
#define TRACE_QED_READ_TABLE_CB_ENABLED 1
#define TRACE_QED_WRITE_TABLE_ENABLED 1
#define TRACE_QED_WRITE_TABLE_CB_ENABLED 1
#define TRACE_QED_NEED_CHECK_TIMER_CB_ENABLED 1
#define TRACE_QED_START_NEED_CHECK_TIMER_ENABLED 1
#define TRACE_QED_CANCEL_NEED_CHECK_TIMER_ENABLED 1
#define TRACE_QED_AIO_COMPLETE_ENABLED 1
#define TRACE_QED_AIO_SETUP_ENABLED 1
#define TRACE_QED_AIO_NEXT_IO_ENABLED 1
#define TRACE_QED_AIO_READ_DATA_ENABLED 1
#define TRACE_QED_AIO_WRITE_DATA_ENABLED 1
#define TRACE_QED_AIO_WRITE_PREFILL_ENABLED 1
#define TRACE_QED_AIO_WRITE_POSTFILL_ENABLED 1
#define TRACE_QED_AIO_WRITE_MAIN_ENABLED 1
#define TRACE_NVME_CONTROLLER_CAPABILITY_RAW_ENABLED 1
#define TRACE_NVME_CONTROLLER_CAPABILITY_ENABLED 1
#define TRACE_NVME_CONTROLLER_SPEC_VERSION_ENABLED 1
#define TRACE_NVME_KICK_ENABLED 1
#define TRACE_NVME_DMA_FLUSH_QUEUE_WAIT_ENABLED 1
#define TRACE_NVME_ERROR_ENABLED 1
#define TRACE_NVME_PROCESS_COMPLETION_ENABLED 1
#define TRACE_NVME_COMPLETE_COMMAND_ENABLED 1
#define TRACE_NVME_SUBMIT_COMMAND_ENABLED 1
#define TRACE_NVME_SUBMIT_COMMAND_RAW_ENABLED 1
#define TRACE_NVME_HANDLE_EVENT_ENABLED 1
#define TRACE_NVME_POLL_QUEUE_ENABLED 1
#define TRACE_NVME_PRW_ALIGNED_ENABLED 1
#define TRACE_NVME_WRITE_ZEROES_ENABLED 1
#define TRACE_NVME_QIOV_UNALIGNED_ENABLED 1
#define TRACE_NVME_PRW_BUFFERED_ENABLED 1
#define TRACE_NVME_RW_DONE_ENABLED 1
#define TRACE_NVME_DSM_ENABLED 1
#define TRACE_NVME_DSM_DONE_ENABLED 1
#define TRACE_NVME_DMA_MAP_FLUSH_ENABLED 1
#define TRACE_NVME_FREE_REQ_QUEUE_WAIT_ENABLED 1
#define TRACE_NVME_CREATE_QUEUE_PAIR_ENABLED 1
#define TRACE_NVME_FREE_QUEUE_PAIR_ENABLED 1
#define TRACE_NVME_CMD_MAP_QIOV_ENABLED 1
#define TRACE_NVME_CMD_MAP_QIOV_PAGES_ENABLED 1
#define TRACE_NVME_CMD_MAP_QIOV_IOV_ENABLED 1
#define TRACE_ISCSI_XCOPY_ENABLED 1
#define TRACE_NBD_PARSE_BLOCKSTATUS_COMPLIANCE_ENABLED 1
#define TRACE_NBD_STRUCTURED_READ_COMPLIANCE_ENABLED 1
#define TRACE_NBD_EXTENDED_HEADERS_COMPLIANCE_ENABLED 1
#define TRACE_NBD_READ_REPLY_ENTRY_FAIL_ENABLED 1
#define TRACE_NBD_CO_REQUEST_FAIL_ENABLED 1
#define TRACE_NBD_CLIENT_HANDSHAKE_ENABLED 1
#define TRACE_NBD_CLIENT_HANDSHAKE_SUCCESS_ENABLED 1
#define TRACE_NBD_RECONNECT_ATTEMPT_ENABLED 1
#define TRACE_NBD_RECONNECT_ATTEMPT_RESULT_ENABLED 1
#define TRACE_SSH_RESTART_COROUTINE_ENABLED 1
#define TRACE_SSH_FLUSH_ENABLED 1
#define TRACE_SSH_CHECK_HOST_KEY_KNOWNHOSTS_ENABLED 1
#define TRACE_SSH_CONNECT_TO_SSH_ENABLED 1
#define TRACE_SSH_CO_YIELD_ENABLED 1
#define TRACE_SSH_CO_YIELD_BACK_ENABLED 1
#define TRACE_SSH_GETLENGTH_ENABLED 1
#define TRACE_SSH_CO_CREATE_OPTS_ENABLED 1
#define TRACE_SSH_READ_ENABLED 1
#define TRACE_SSH_READ_BUF_ENABLED 1
#define TRACE_SSH_READ_RETURN_ENABLED 1
#define TRACE_SSH_WRITE_ENABLED 1
#define TRACE_SSH_WRITE_BUF_ENABLED 1
#define TRACE_SSH_WRITE_RETURN_ENABLED 1
#define TRACE_SSH_SEEK_ENABLED 1
#define TRACE_SSH_AUTH_METHODS_ENABLED 1
#define TRACE_SSH_SERVER_STATUS_ENABLED 1
#define TRACE_CURL_TIMER_CB_ENABLED 1
#define TRACE_CURL_SOCK_CB_ENABLED 1
#define TRACE_CURL_READ_CB_ENABLED 1
#define TRACE_CURL_OPEN_ENABLED 1
#define TRACE_CURL_OPEN_SIZE_ENABLED 1
#define TRACE_CURL_SETUP_PREADV_ENABLED 1
#define TRACE_CURL_CLOSE_ENABLED 1
#define TRACE_FILE_COPY_FILE_RANGE_ENABLED 1
#define TRACE_FILE_FINDEJECTABLEOPTICALMEDIA_ENABLED 1
#define TRACE_FILE_SETUP_CDROM_ENABLED 1
#define TRACE_FILE_HDEV_IS_SG_ENABLED 1
#define TRACE_FILE_FLUSH_FDATASYNC_FAILED_ENABLED 1
#define TRACE_ZBD_ZONE_REPORT_ENABLED 1
#define TRACE_ZBD_ZONE_MGMT_ENABLED 1
#define TRACE_ZBD_ZONE_APPEND_ENABLED 1
#define TRACE_ZBD_ZONE_APPEND_COMPLETE_ENABLED 1
#define TRACE_SFTP_ERROR_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_BDRV_OPEN_COMMON_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BDRV_OPEN_COMMON) || \
    false)

static inline void _nocheck__trace_bdrv_open_common(void * bs, const char * filename, int flags, const char * format_name)
{
    if (trace_event_get_state(TRACE_BDRV_OPEN_COMMON) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 4 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:bdrv_open_common " "bs %p filename \"%s\" flags 0x%x format_name \"%s\"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bs, filename, flags, format_name);
#line 523 "trace/trace-block.h"
        } else {
#line 4 "../block/trace-events"
            qemu_log("bdrv_open_common " "bs %p filename \"%s\" flags 0x%x format_name \"%s\"" "\n", bs, filename, flags, format_name);
#line 527 "trace/trace-block.h"
        }
    }
}

static inline void trace_bdrv_open_common(void * bs, const char * filename, int flags, const char * format_name)
{
    if (true) {
        _nocheck__trace_bdrv_open_common(bs, filename, flags, format_name);
    }
}

#define TRACE_BDRV_LOCK_MEDIUM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BDRV_LOCK_MEDIUM) || \
    false)

static inline void _nocheck__trace_bdrv_lock_medium(void * bs, bool locked)
{
    if (trace_event_get_state(TRACE_BDRV_LOCK_MEDIUM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 5 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:bdrv_lock_medium " "bs %p locked %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bs, locked);
#line 554 "trace/trace-block.h"
        } else {
#line 5 "../block/trace-events"
            qemu_log("bdrv_lock_medium " "bs %p locked %d" "\n", bs, locked);
#line 558 "trace/trace-block.h"
        }
    }
}

static inline void trace_bdrv_lock_medium(void * bs, bool locked)
{
    if (true) {
        _nocheck__trace_bdrv_lock_medium(bs, locked);
    }
}

#define TRACE_BLK_CO_PREADV_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BLK_CO_PREADV) || \
    false)

static inline void _nocheck__trace_blk_co_preadv(void * blk, void * bs, int64_t offset, int64_t bytes, int flags)
{
    if (trace_event_get_state(TRACE_BLK_CO_PREADV) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 8 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:blk_co_preadv " "blk %p bs %p offset %"PRId64" bytes %" PRId64 " flags 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , blk, bs, offset, bytes, flags);
#line 585 "trace/trace-block.h"
        } else {
#line 8 "../block/trace-events"
            qemu_log("blk_co_preadv " "blk %p bs %p offset %"PRId64" bytes %" PRId64 " flags 0x%x" "\n", blk, bs, offset, bytes, flags);
#line 589 "trace/trace-block.h"
        }
    }
}

static inline void trace_blk_co_preadv(void * blk, void * bs, int64_t offset, int64_t bytes, int flags)
{
    if (true) {
        _nocheck__trace_blk_co_preadv(blk, bs, offset, bytes, flags);
    }
}

#define TRACE_BLK_CO_PWRITEV_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BLK_CO_PWRITEV) || \
    false)

static inline void _nocheck__trace_blk_co_pwritev(void * blk, void * bs, int64_t offset, int64_t bytes, int flags)
{
    if (trace_event_get_state(TRACE_BLK_CO_PWRITEV) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 9 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:blk_co_pwritev " "blk %p bs %p offset %"PRId64" bytes %" PRId64 " flags 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , blk, bs, offset, bytes, flags);
#line 616 "trace/trace-block.h"
        } else {
#line 9 "../block/trace-events"
            qemu_log("blk_co_pwritev " "blk %p bs %p offset %"PRId64" bytes %" PRId64 " flags 0x%x" "\n", blk, bs, offset, bytes, flags);
#line 620 "trace/trace-block.h"
        }
    }
}

static inline void trace_blk_co_pwritev(void * blk, void * bs, int64_t offset, int64_t bytes, int flags)
{
    if (true) {
        _nocheck__trace_blk_co_pwritev(blk, bs, offset, bytes, flags);
    }
}

#define TRACE_BLK_ROOT_ATTACH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BLK_ROOT_ATTACH) || \
    false)

static inline void _nocheck__trace_blk_root_attach(void * child, void * blk, void * bs)
{
    if (trace_event_get_state(TRACE_BLK_ROOT_ATTACH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 10 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:blk_root_attach " "child %p blk %p bs %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , child, blk, bs);
#line 647 "trace/trace-block.h"
        } else {
#line 10 "../block/trace-events"
            qemu_log("blk_root_attach " "child %p blk %p bs %p" "\n", child, blk, bs);
#line 651 "trace/trace-block.h"
        }
    }
}

static inline void trace_blk_root_attach(void * child, void * blk, void * bs)
{
    if (true) {
        _nocheck__trace_blk_root_attach(child, blk, bs);
    }
}

#define TRACE_BLK_ROOT_DETACH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BLK_ROOT_DETACH) || \
    false)

static inline void _nocheck__trace_blk_root_detach(void * child, void * blk, void * bs)
{
    if (trace_event_get_state(TRACE_BLK_ROOT_DETACH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 11 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:blk_root_detach " "child %p blk %p bs %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , child, blk, bs);
#line 678 "trace/trace-block.h"
        } else {
#line 11 "../block/trace-events"
            qemu_log("blk_root_detach " "child %p blk %p bs %p" "\n", child, blk, bs);
#line 682 "trace/trace-block.h"
        }
    }
}

static inline void trace_blk_root_detach(void * child, void * blk, void * bs)
{
    if (true) {
        _nocheck__trace_blk_root_detach(child, blk, bs);
    }
}

#define TRACE_BDRV_CO_PREADV_PART_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BDRV_CO_PREADV_PART) || \
    false)

static inline void _nocheck__trace_bdrv_co_preadv_part(void * bs, int64_t offset, int64_t bytes, unsigned int flags)
{
    if (trace_event_get_state(TRACE_BDRV_CO_PREADV_PART) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 14 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:bdrv_co_preadv_part " "bs %p offset %" PRId64 " bytes %" PRId64 " flags 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bs, offset, bytes, flags);
#line 709 "trace/trace-block.h"
        } else {
#line 14 "../block/trace-events"
            qemu_log("bdrv_co_preadv_part " "bs %p offset %" PRId64 " bytes %" PRId64 " flags 0x%x" "\n", bs, offset, bytes, flags);
#line 713 "trace/trace-block.h"
        }
    }
}

static inline void trace_bdrv_co_preadv_part(void * bs, int64_t offset, int64_t bytes, unsigned int flags)
{
    if (true) {
        _nocheck__trace_bdrv_co_preadv_part(bs, offset, bytes, flags);
    }
}

#define TRACE_BDRV_CO_PWRITEV_PART_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BDRV_CO_PWRITEV_PART) || \
    false)

static inline void _nocheck__trace_bdrv_co_pwritev_part(void * bs, int64_t offset, int64_t bytes, unsigned int flags)
{
    if (trace_event_get_state(TRACE_BDRV_CO_PWRITEV_PART) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 15 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:bdrv_co_pwritev_part " "bs %p offset %" PRId64 " bytes %" PRId64 " flags 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bs, offset, bytes, flags);
#line 740 "trace/trace-block.h"
        } else {
#line 15 "../block/trace-events"
            qemu_log("bdrv_co_pwritev_part " "bs %p offset %" PRId64 " bytes %" PRId64 " flags 0x%x" "\n", bs, offset, bytes, flags);
#line 744 "trace/trace-block.h"
        }
    }
}

static inline void trace_bdrv_co_pwritev_part(void * bs, int64_t offset, int64_t bytes, unsigned int flags)
{
    if (true) {
        _nocheck__trace_bdrv_co_pwritev_part(bs, offset, bytes, flags);
    }
}

#define TRACE_BDRV_CO_PWRITE_ZEROES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BDRV_CO_PWRITE_ZEROES) || \
    false)

static inline void _nocheck__trace_bdrv_co_pwrite_zeroes(void * bs, int64_t offset, int64_t bytes, int flags)
{
    if (trace_event_get_state(TRACE_BDRV_CO_PWRITE_ZEROES) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 16 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:bdrv_co_pwrite_zeroes " "bs %p offset %" PRId64 " bytes %" PRId64 " flags 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bs, offset, bytes, flags);
#line 771 "trace/trace-block.h"
        } else {
#line 16 "../block/trace-events"
            qemu_log("bdrv_co_pwrite_zeroes " "bs %p offset %" PRId64 " bytes %" PRId64 " flags 0x%x" "\n", bs, offset, bytes, flags);
#line 775 "trace/trace-block.h"
        }
    }
}

static inline void trace_bdrv_co_pwrite_zeroes(void * bs, int64_t offset, int64_t bytes, int flags)
{
    if (true) {
        _nocheck__trace_bdrv_co_pwrite_zeroes(bs, offset, bytes, flags);
    }
}

#define TRACE_BDRV_CO_DO_COPY_ON_READV_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BDRV_CO_DO_COPY_ON_READV) || \
    false)

static inline void _nocheck__trace_bdrv_co_do_copy_on_readv(void * bs, int64_t offset, int64_t bytes, int64_t cluster_offset, int64_t cluster_bytes)
{
    if (trace_event_get_state(TRACE_BDRV_CO_DO_COPY_ON_READV) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 17 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:bdrv_co_do_copy_on_readv " "bs %p offset %" PRId64 " bytes %" PRId64 " cluster_offset %" PRId64 " cluster_bytes %" PRId64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bs, offset, bytes, cluster_offset, cluster_bytes);
#line 802 "trace/trace-block.h"
        } else {
#line 17 "../block/trace-events"
            qemu_log("bdrv_co_do_copy_on_readv " "bs %p offset %" PRId64 " bytes %" PRId64 " cluster_offset %" PRId64 " cluster_bytes %" PRId64 "\n", bs, offset, bytes, cluster_offset, cluster_bytes);
#line 806 "trace/trace-block.h"
        }
    }
}

static inline void trace_bdrv_co_do_copy_on_readv(void * bs, int64_t offset, int64_t bytes, int64_t cluster_offset, int64_t cluster_bytes)
{
    if (true) {
        _nocheck__trace_bdrv_co_do_copy_on_readv(bs, offset, bytes, cluster_offset, cluster_bytes);
    }
}

#define TRACE_BDRV_CO_COPY_RANGE_FROM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BDRV_CO_COPY_RANGE_FROM) || \
    false)

static inline void _nocheck__trace_bdrv_co_copy_range_from(void * src, int64_t src_offset, void * dst, int64_t dst_offset, int64_t bytes, int read_flags, int write_flags)
{
    if (trace_event_get_state(TRACE_BDRV_CO_COPY_RANGE_FROM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 18 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:bdrv_co_copy_range_from " "src %p offset %" PRId64 " dst %p offset %" PRId64 " bytes %" PRId64 " rw flags 0x%x 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , src, src_offset, dst, dst_offset, bytes, read_flags, write_flags);
#line 833 "trace/trace-block.h"
        } else {
#line 18 "../block/trace-events"
            qemu_log("bdrv_co_copy_range_from " "src %p offset %" PRId64 " dst %p offset %" PRId64 " bytes %" PRId64 " rw flags 0x%x 0x%x" "\n", src, src_offset, dst, dst_offset, bytes, read_flags, write_flags);
#line 837 "trace/trace-block.h"
        }
    }
}

static inline void trace_bdrv_co_copy_range_from(void * src, int64_t src_offset, void * dst, int64_t dst_offset, int64_t bytes, int read_flags, int write_flags)
{
    if (true) {
        _nocheck__trace_bdrv_co_copy_range_from(src, src_offset, dst, dst_offset, bytes, read_flags, write_flags);
    }
}

#define TRACE_BDRV_CO_COPY_RANGE_TO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BDRV_CO_COPY_RANGE_TO) || \
    false)

static inline void _nocheck__trace_bdrv_co_copy_range_to(void * src, int64_t src_offset, void * dst, int64_t dst_offset, int64_t bytes, int read_flags, int write_flags)
{
    if (trace_event_get_state(TRACE_BDRV_CO_COPY_RANGE_TO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 19 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:bdrv_co_copy_range_to " "src %p offset %" PRId64 " dst %p offset %" PRId64 " bytes %" PRId64 " rw flags 0x%x 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , src, src_offset, dst, dst_offset, bytes, read_flags, write_flags);
#line 864 "trace/trace-block.h"
        } else {
#line 19 "../block/trace-events"
            qemu_log("bdrv_co_copy_range_to " "src %p offset %" PRId64 " dst %p offset %" PRId64 " bytes %" PRId64 " rw flags 0x%x 0x%x" "\n", src, src_offset, dst, dst_offset, bytes, read_flags, write_flags);
#line 868 "trace/trace-block.h"
        }
    }
}

static inline void trace_bdrv_co_copy_range_to(void * src, int64_t src_offset, void * dst, int64_t dst_offset, int64_t bytes, int read_flags, int write_flags)
{
    if (true) {
        _nocheck__trace_bdrv_co_copy_range_to(src, src_offset, dst, dst_offset, bytes, read_flags, write_flags);
    }
}

#define TRACE_STREAM_ONE_ITERATION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_STREAM_ONE_ITERATION) || \
    false)

static inline void _nocheck__trace_stream_one_iteration(void * s, int64_t offset, uint64_t bytes, int is_allocated)
{
    if (trace_event_get_state(TRACE_STREAM_ONE_ITERATION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 22 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:stream_one_iteration " "s %p offset %" PRId64 " bytes %" PRIu64 " is_allocated %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, offset, bytes, is_allocated);
#line 895 "trace/trace-block.h"
        } else {
#line 22 "../block/trace-events"
            qemu_log("stream_one_iteration " "s %p offset %" PRId64 " bytes %" PRIu64 " is_allocated %d" "\n", s, offset, bytes, is_allocated);
#line 899 "trace/trace-block.h"
        }
    }
}

static inline void trace_stream_one_iteration(void * s, int64_t offset, uint64_t bytes, int is_allocated)
{
    if (true) {
        _nocheck__trace_stream_one_iteration(s, offset, bytes, is_allocated);
    }
}

#define TRACE_STREAM_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_STREAM_START) || \
    false)

static inline void _nocheck__trace_stream_start(void * bs, void * base, void * s)
{
    if (trace_event_get_state(TRACE_STREAM_START) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 23 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:stream_start " "bs %p base %p s %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bs, base, s);
#line 926 "trace/trace-block.h"
        } else {
#line 23 "../block/trace-events"
            qemu_log("stream_start " "bs %p base %p s %p" "\n", bs, base, s);
#line 930 "trace/trace-block.h"
        }
    }
}

static inline void trace_stream_start(void * bs, void * base, void * s)
{
    if (true) {
        _nocheck__trace_stream_start(bs, base, s);
    }
}

#define TRACE_COMMIT_ONE_ITERATION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_COMMIT_ONE_ITERATION) || \
    false)

static inline void _nocheck__trace_commit_one_iteration(void * s, int64_t offset, uint64_t bytes, int is_allocated)
{
    if (trace_event_get_state(TRACE_COMMIT_ONE_ITERATION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 26 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:commit_one_iteration " "s %p offset %" PRId64 " bytes %" PRIu64 " is_allocated %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, offset, bytes, is_allocated);
#line 957 "trace/trace-block.h"
        } else {
#line 26 "../block/trace-events"
            qemu_log("commit_one_iteration " "s %p offset %" PRId64 " bytes %" PRIu64 " is_allocated %d" "\n", s, offset, bytes, is_allocated);
#line 961 "trace/trace-block.h"
        }
    }
}

static inline void trace_commit_one_iteration(void * s, int64_t offset, uint64_t bytes, int is_allocated)
{
    if (true) {
        _nocheck__trace_commit_one_iteration(s, offset, bytes, is_allocated);
    }
}

#define TRACE_COMMIT_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_COMMIT_START) || \
    false)

static inline void _nocheck__trace_commit_start(void * bs, void * base, void * top, void * s)
{
    if (trace_event_get_state(TRACE_COMMIT_START) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 27 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:commit_start " "bs %p base %p top %p s %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bs, base, top, s);
#line 988 "trace/trace-block.h"
        } else {
#line 27 "../block/trace-events"
            qemu_log("commit_start " "bs %p base %p top %p s %p" "\n", bs, base, top, s);
#line 992 "trace/trace-block.h"
        }
    }
}

static inline void trace_commit_start(void * bs, void * base, void * top, void * s)
{
    if (true) {
        _nocheck__trace_commit_start(bs, base, top, s);
    }
}

#define TRACE_MIRROR_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIRROR_START) || \
    false)

static inline void _nocheck__trace_mirror_start(void * bs, void * s, void * opaque)
{
    if (trace_event_get_state(TRACE_MIRROR_START) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 30 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:mirror_start " "bs %p s %p opaque %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bs, s, opaque);
#line 1019 "trace/trace-block.h"
        } else {
#line 30 "../block/trace-events"
            qemu_log("mirror_start " "bs %p s %p opaque %p" "\n", bs, s, opaque);
#line 1023 "trace/trace-block.h"
        }
    }
}

static inline void trace_mirror_start(void * bs, void * s, void * opaque)
{
    if (true) {
        _nocheck__trace_mirror_start(bs, s, opaque);
    }
}

#define TRACE_MIRROR_RESTART_ITER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIRROR_RESTART_ITER) || \
    false)

static inline void _nocheck__trace_mirror_restart_iter(void * s, int64_t cnt)
{
    if (trace_event_get_state(TRACE_MIRROR_RESTART_ITER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 31 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:mirror_restart_iter " "s %p dirty count %"PRId64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, cnt);
#line 1050 "trace/trace-block.h"
        } else {
#line 31 "../block/trace-events"
            qemu_log("mirror_restart_iter " "s %p dirty count %"PRId64 "\n", s, cnt);
#line 1054 "trace/trace-block.h"
        }
    }
}

static inline void trace_mirror_restart_iter(void * s, int64_t cnt)
{
    if (true) {
        _nocheck__trace_mirror_restart_iter(s, cnt);
    }
}

#define TRACE_MIRROR_BEFORE_FLUSH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIRROR_BEFORE_FLUSH) || \
    false)

static inline void _nocheck__trace_mirror_before_flush(void * s)
{
    if (trace_event_get_state(TRACE_MIRROR_BEFORE_FLUSH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 32 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:mirror_before_flush " "s %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s);
#line 1081 "trace/trace-block.h"
        } else {
#line 32 "../block/trace-events"
            qemu_log("mirror_before_flush " "s %p" "\n", s);
#line 1085 "trace/trace-block.h"
        }
    }
}

static inline void trace_mirror_before_flush(void * s)
{
    if (true) {
        _nocheck__trace_mirror_before_flush(s);
    }
}

#define TRACE_MIRROR_BEFORE_DRAIN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIRROR_BEFORE_DRAIN) || \
    false)

static inline void _nocheck__trace_mirror_before_drain(void * s, int64_t cnt)
{
    if (trace_event_get_state(TRACE_MIRROR_BEFORE_DRAIN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 33 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:mirror_before_drain " "s %p dirty count %"PRId64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, cnt);
#line 1112 "trace/trace-block.h"
        } else {
#line 33 "../block/trace-events"
            qemu_log("mirror_before_drain " "s %p dirty count %"PRId64 "\n", s, cnt);
#line 1116 "trace/trace-block.h"
        }
    }
}

static inline void trace_mirror_before_drain(void * s, int64_t cnt)
{
    if (true) {
        _nocheck__trace_mirror_before_drain(s, cnt);
    }
}

#define TRACE_MIRROR_BEFORE_SLEEP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIRROR_BEFORE_SLEEP) || \
    false)

static inline void _nocheck__trace_mirror_before_sleep(void * s, int64_t cnt, int synced, uint64_t delay_ns)
{
    if (trace_event_get_state(TRACE_MIRROR_BEFORE_SLEEP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 34 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:mirror_before_sleep " "s %p dirty count %"PRId64" synced %d delay %"PRIu64"ns" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, cnt, synced, delay_ns);
#line 1143 "trace/trace-block.h"
        } else {
#line 34 "../block/trace-events"
            qemu_log("mirror_before_sleep " "s %p dirty count %"PRId64" synced %d delay %"PRIu64"ns" "\n", s, cnt, synced, delay_ns);
#line 1147 "trace/trace-block.h"
        }
    }
}

static inline void trace_mirror_before_sleep(void * s, int64_t cnt, int synced, uint64_t delay_ns)
{
    if (true) {
        _nocheck__trace_mirror_before_sleep(s, cnt, synced, delay_ns);
    }
}

#define TRACE_MIRROR_ONE_ITERATION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIRROR_ONE_ITERATION) || \
    false)

static inline void _nocheck__trace_mirror_one_iteration(void * s, int64_t offset, uint64_t bytes)
{
    if (trace_event_get_state(TRACE_MIRROR_ONE_ITERATION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 35 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:mirror_one_iteration " "s %p offset %" PRId64 " bytes %" PRIu64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, offset, bytes);
#line 1174 "trace/trace-block.h"
        } else {
#line 35 "../block/trace-events"
            qemu_log("mirror_one_iteration " "s %p offset %" PRId64 " bytes %" PRIu64 "\n", s, offset, bytes);
#line 1178 "trace/trace-block.h"
        }
    }
}

static inline void trace_mirror_one_iteration(void * s, int64_t offset, uint64_t bytes)
{
    if (true) {
        _nocheck__trace_mirror_one_iteration(s, offset, bytes);
    }
}

#define TRACE_MIRROR_ITERATION_DONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIRROR_ITERATION_DONE) || \
    false)

static inline void _nocheck__trace_mirror_iteration_done(void * s, int64_t offset, uint64_t bytes, int ret)
{
    if (trace_event_get_state(TRACE_MIRROR_ITERATION_DONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 36 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:mirror_iteration_done " "s %p offset %" PRId64 " bytes %" PRIu64 " ret %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, offset, bytes, ret);
#line 1205 "trace/trace-block.h"
        } else {
#line 36 "../block/trace-events"
            qemu_log("mirror_iteration_done " "s %p offset %" PRId64 " bytes %" PRIu64 " ret %d" "\n", s, offset, bytes, ret);
#line 1209 "trace/trace-block.h"
        }
    }
}

static inline void trace_mirror_iteration_done(void * s, int64_t offset, uint64_t bytes, int ret)
{
    if (true) {
        _nocheck__trace_mirror_iteration_done(s, offset, bytes, ret);
    }
}

#define TRACE_MIRROR_YIELD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIRROR_YIELD) || \
    false)

static inline void _nocheck__trace_mirror_yield(void * s, int64_t cnt, int buf_free_count, int in_flight)
{
    if (trace_event_get_state(TRACE_MIRROR_YIELD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 37 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:mirror_yield " "s %p dirty count %"PRId64" free buffers %d in_flight %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, cnt, buf_free_count, in_flight);
#line 1236 "trace/trace-block.h"
        } else {
#line 37 "../block/trace-events"
            qemu_log("mirror_yield " "s %p dirty count %"PRId64" free buffers %d in_flight %d" "\n", s, cnt, buf_free_count, in_flight);
#line 1240 "trace/trace-block.h"
        }
    }
}

static inline void trace_mirror_yield(void * s, int64_t cnt, int buf_free_count, int in_flight)
{
    if (true) {
        _nocheck__trace_mirror_yield(s, cnt, buf_free_count, in_flight);
    }
}

#define TRACE_MIRROR_YIELD_IN_FLIGHT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIRROR_YIELD_IN_FLIGHT) || \
    false)

static inline void _nocheck__trace_mirror_yield_in_flight(void * s, int64_t offset, int in_flight)
{
    if (trace_event_get_state(TRACE_MIRROR_YIELD_IN_FLIGHT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 38 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:mirror_yield_in_flight " "s %p offset %" PRId64 " in_flight %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, offset, in_flight);
#line 1267 "trace/trace-block.h"
        } else {
#line 38 "../block/trace-events"
            qemu_log("mirror_yield_in_flight " "s %p offset %" PRId64 " in_flight %d" "\n", s, offset, in_flight);
#line 1271 "trace/trace-block.h"
        }
    }
}

static inline void trace_mirror_yield_in_flight(void * s, int64_t offset, int in_flight)
{
    if (true) {
        _nocheck__trace_mirror_yield_in_flight(s, offset, in_flight);
    }
}

#define TRACE_BACKUP_DO_COW_ENTER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BACKUP_DO_COW_ENTER) || \
    false)

static inline void _nocheck__trace_backup_do_cow_enter(void * job, int64_t start, int64_t offset, uint64_t bytes)
{
    if (trace_event_get_state(TRACE_BACKUP_DO_COW_ENTER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 41 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:backup_do_cow_enter " "job %p start %" PRId64 " offset %" PRId64 " bytes %" PRIu64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , job, start, offset, bytes);
#line 1298 "trace/trace-block.h"
        } else {
#line 41 "../block/trace-events"
            qemu_log("backup_do_cow_enter " "job %p start %" PRId64 " offset %" PRId64 " bytes %" PRIu64 "\n", job, start, offset, bytes);
#line 1302 "trace/trace-block.h"
        }
    }
}

static inline void trace_backup_do_cow_enter(void * job, int64_t start, int64_t offset, uint64_t bytes)
{
    if (true) {
        _nocheck__trace_backup_do_cow_enter(job, start, offset, bytes);
    }
}

#define TRACE_BACKUP_DO_COW_RETURN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BACKUP_DO_COW_RETURN) || \
    false)

static inline void _nocheck__trace_backup_do_cow_return(void * job, int64_t offset, uint64_t bytes, int ret)
{
    if (trace_event_get_state(TRACE_BACKUP_DO_COW_RETURN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 42 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:backup_do_cow_return " "job %p offset %" PRId64 " bytes %" PRIu64 " ret %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , job, offset, bytes, ret);
#line 1329 "trace/trace-block.h"
        } else {
#line 42 "../block/trace-events"
            qemu_log("backup_do_cow_return " "job %p offset %" PRId64 " bytes %" PRIu64 " ret %d" "\n", job, offset, bytes, ret);
#line 1333 "trace/trace-block.h"
        }
    }
}

static inline void trace_backup_do_cow_return(void * job, int64_t offset, uint64_t bytes, int ret)
{
    if (true) {
        _nocheck__trace_backup_do_cow_return(job, offset, bytes, ret);
    }
}

#define TRACE_BLOCK_COPY_SKIP_RANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BLOCK_COPY_SKIP_RANGE) || \
    false)

static inline void _nocheck__trace_block_copy_skip_range(void * bcs, int64_t start, uint64_t bytes)
{
    if (trace_event_get_state(TRACE_BLOCK_COPY_SKIP_RANGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 45 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:block_copy_skip_range " "bcs %p start %"PRId64" bytes %"PRId64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bcs, start, bytes);
#line 1360 "trace/trace-block.h"
        } else {
#line 45 "../block/trace-events"
            qemu_log("block_copy_skip_range " "bcs %p start %"PRId64" bytes %"PRId64 "\n", bcs, start, bytes);
#line 1364 "trace/trace-block.h"
        }
    }
}

static inline void trace_block_copy_skip_range(void * bcs, int64_t start, uint64_t bytes)
{
    if (true) {
        _nocheck__trace_block_copy_skip_range(bcs, start, bytes);
    }
}

#define TRACE_BLOCK_COPY_PROCESS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BLOCK_COPY_PROCESS) || \
    false)

static inline void _nocheck__trace_block_copy_process(void * bcs, int64_t start)
{
    if (trace_event_get_state(TRACE_BLOCK_COPY_PROCESS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 46 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:block_copy_process " "bcs %p start %"PRId64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bcs, start);
#line 1391 "trace/trace-block.h"
        } else {
#line 46 "../block/trace-events"
            qemu_log("block_copy_process " "bcs %p start %"PRId64 "\n", bcs, start);
#line 1395 "trace/trace-block.h"
        }
    }
}

static inline void trace_block_copy_process(void * bcs, int64_t start)
{
    if (true) {
        _nocheck__trace_block_copy_process(bcs, start);
    }
}

#define TRACE_BLOCK_COPY_COPY_RANGE_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BLOCK_COPY_COPY_RANGE_FAIL) || \
    false)

static inline void _nocheck__trace_block_copy_copy_range_fail(void * bcs, int64_t start, int ret)
{
    if (trace_event_get_state(TRACE_BLOCK_COPY_COPY_RANGE_FAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 47 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:block_copy_copy_range_fail " "bcs %p start %"PRId64" ret %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bcs, start, ret);
#line 1422 "trace/trace-block.h"
        } else {
#line 47 "../block/trace-events"
            qemu_log("block_copy_copy_range_fail " "bcs %p start %"PRId64" ret %d" "\n", bcs, start, ret);
#line 1426 "trace/trace-block.h"
        }
    }
}

static inline void trace_block_copy_copy_range_fail(void * bcs, int64_t start, int ret)
{
    if (true) {
        _nocheck__trace_block_copy_copy_range_fail(bcs, start, ret);
    }
}

#define TRACE_BLOCK_COPY_READ_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BLOCK_COPY_READ_FAIL) || \
    false)

static inline void _nocheck__trace_block_copy_read_fail(void * bcs, int64_t start, int ret)
{
    if (trace_event_get_state(TRACE_BLOCK_COPY_READ_FAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 48 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:block_copy_read_fail " "bcs %p start %"PRId64" ret %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bcs, start, ret);
#line 1453 "trace/trace-block.h"
        } else {
#line 48 "../block/trace-events"
            qemu_log("block_copy_read_fail " "bcs %p start %"PRId64" ret %d" "\n", bcs, start, ret);
#line 1457 "trace/trace-block.h"
        }
    }
}

static inline void trace_block_copy_read_fail(void * bcs, int64_t start, int ret)
{
    if (true) {
        _nocheck__trace_block_copy_read_fail(bcs, start, ret);
    }
}

#define TRACE_BLOCK_COPY_WRITE_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BLOCK_COPY_WRITE_FAIL) || \
    false)

static inline void _nocheck__trace_block_copy_write_fail(void * bcs, int64_t start, int ret)
{
    if (trace_event_get_state(TRACE_BLOCK_COPY_WRITE_FAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 49 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:block_copy_write_fail " "bcs %p start %"PRId64" ret %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bcs, start, ret);
#line 1484 "trace/trace-block.h"
        } else {
#line 49 "../block/trace-events"
            qemu_log("block_copy_write_fail " "bcs %p start %"PRId64" ret %d" "\n", bcs, start, ret);
#line 1488 "trace/trace-block.h"
        }
    }
}

static inline void trace_block_copy_write_fail(void * bcs, int64_t start, int ret)
{
    if (true) {
        _nocheck__trace_block_copy_write_fail(bcs, start, ret);
    }
}

#define TRACE_BLOCK_COPY_WRITE_ZEROES_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BLOCK_COPY_WRITE_ZEROES_FAIL) || \
    false)

static inline void _nocheck__trace_block_copy_write_zeroes_fail(void * bcs, int64_t start, int ret)
{
    if (trace_event_get_state(TRACE_BLOCK_COPY_WRITE_ZEROES_FAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 50 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:block_copy_write_zeroes_fail " "bcs %p start %"PRId64" ret %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bcs, start, ret);
#line 1515 "trace/trace-block.h"
        } else {
#line 50 "../block/trace-events"
            qemu_log("block_copy_write_zeroes_fail " "bcs %p start %"PRId64" ret %d" "\n", bcs, start, ret);
#line 1519 "trace/trace-block.h"
        }
    }
}

static inline void trace_block_copy_write_zeroes_fail(void * bcs, int64_t start, int ret)
{
    if (true) {
        _nocheck__trace_block_copy_write_zeroes_fail(bcs, start, ret);
    }
}

#define TRACE_QMP_BLOCK_JOB_CANCEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QMP_BLOCK_JOB_CANCEL) || \
    false)

static inline void _nocheck__trace_qmp_block_job_cancel(void * job)
{
    if (trace_event_get_state(TRACE_QMP_BLOCK_JOB_CANCEL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 53 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qmp_block_job_cancel " "job %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , job);
#line 1546 "trace/trace-block.h"
        } else {
#line 53 "../block/trace-events"
            qemu_log("qmp_block_job_cancel " "job %p" "\n", job);
#line 1550 "trace/trace-block.h"
        }
    }
}

static inline void trace_qmp_block_job_cancel(void * job)
{
    if (true) {
        _nocheck__trace_qmp_block_job_cancel(job);
    }
}

#define TRACE_QMP_BLOCK_JOB_PAUSE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QMP_BLOCK_JOB_PAUSE) || \
    false)

static inline void _nocheck__trace_qmp_block_job_pause(void * job)
{
    if (trace_event_get_state(TRACE_QMP_BLOCK_JOB_PAUSE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 54 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qmp_block_job_pause " "job %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , job);
#line 1577 "trace/trace-block.h"
        } else {
#line 54 "../block/trace-events"
            qemu_log("qmp_block_job_pause " "job %p" "\n", job);
#line 1581 "trace/trace-block.h"
        }
    }
}

static inline void trace_qmp_block_job_pause(void * job)
{
    if (true) {
        _nocheck__trace_qmp_block_job_pause(job);
    }
}

#define TRACE_QMP_BLOCK_JOB_RESUME_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QMP_BLOCK_JOB_RESUME) || \
    false)

static inline void _nocheck__trace_qmp_block_job_resume(void * job)
{
    if (trace_event_get_state(TRACE_QMP_BLOCK_JOB_RESUME) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 55 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qmp_block_job_resume " "job %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , job);
#line 1608 "trace/trace-block.h"
        } else {
#line 55 "../block/trace-events"
            qemu_log("qmp_block_job_resume " "job %p" "\n", job);
#line 1612 "trace/trace-block.h"
        }
    }
}

static inline void trace_qmp_block_job_resume(void * job)
{
    if (true) {
        _nocheck__trace_qmp_block_job_resume(job);
    }
}

#define TRACE_QMP_BLOCK_JOB_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QMP_BLOCK_JOB_COMPLETE) || \
    false)

static inline void _nocheck__trace_qmp_block_job_complete(void * job)
{
    if (trace_event_get_state(TRACE_QMP_BLOCK_JOB_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 56 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qmp_block_job_complete " "job %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , job);
#line 1639 "trace/trace-block.h"
        } else {
#line 56 "../block/trace-events"
            qemu_log("qmp_block_job_complete " "job %p" "\n", job);
#line 1643 "trace/trace-block.h"
        }
    }
}

static inline void trace_qmp_block_job_complete(void * job)
{
    if (true) {
        _nocheck__trace_qmp_block_job_complete(job);
    }
}

#define TRACE_QMP_BLOCK_JOB_FINALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QMP_BLOCK_JOB_FINALIZE) || \
    false)

static inline void _nocheck__trace_qmp_block_job_finalize(void * job)
{
    if (trace_event_get_state(TRACE_QMP_BLOCK_JOB_FINALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 57 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qmp_block_job_finalize " "job %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , job);
#line 1670 "trace/trace-block.h"
        } else {
#line 57 "../block/trace-events"
            qemu_log("qmp_block_job_finalize " "job %p" "\n", job);
#line 1674 "trace/trace-block.h"
        }
    }
}

static inline void trace_qmp_block_job_finalize(void * job)
{
    if (true) {
        _nocheck__trace_qmp_block_job_finalize(job);
    }
}

#define TRACE_QMP_BLOCK_JOB_DISMISS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QMP_BLOCK_JOB_DISMISS) || \
    false)

static inline void _nocheck__trace_qmp_block_job_dismiss(void * job)
{
    if (trace_event_get_state(TRACE_QMP_BLOCK_JOB_DISMISS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 58 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qmp_block_job_dismiss " "job %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , job);
#line 1701 "trace/trace-block.h"
        } else {
#line 58 "../block/trace-events"
            qemu_log("qmp_block_job_dismiss " "job %p" "\n", job);
#line 1705 "trace/trace-block.h"
        }
    }
}

static inline void trace_qmp_block_job_dismiss(void * job)
{
    if (true) {
        _nocheck__trace_qmp_block_job_dismiss(job);
    }
}

#define TRACE_QMP_BLOCK_STREAM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QMP_BLOCK_STREAM) || \
    false)

static inline void _nocheck__trace_qmp_block_stream(void * bs)
{
    if (trace_event_get_state(TRACE_QMP_BLOCK_STREAM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 59 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qmp_block_stream " "bs %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bs);
#line 1732 "trace/trace-block.h"
        } else {
#line 59 "../block/trace-events"
            qemu_log("qmp_block_stream " "bs %p" "\n", bs);
#line 1736 "trace/trace-block.h"
        }
    }
}

static inline void trace_qmp_block_stream(void * bs)
{
    if (true) {
        _nocheck__trace_qmp_block_stream(bs);
    }
}

#define TRACE_FILE_PAIO_SUBMIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_FILE_PAIO_SUBMIT) || \
    false)

static inline void _nocheck__trace_file_paio_submit(void * acb, void * opaque, int64_t offset, int count, int type)
{
    if (trace_event_get_state(TRACE_FILE_PAIO_SUBMIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 62 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:file_paio_submit " "acb %p opaque %p offset %"PRId64" count %d type %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , acb, opaque, offset, count, type);
#line 1763 "trace/trace-block.h"
        } else {
#line 62 "../block/trace-events"
            qemu_log("file_paio_submit " "acb %p opaque %p offset %"PRId64" count %d type %d" "\n", acb, opaque, offset, count, type);
#line 1767 "trace/trace-block.h"
        }
    }
}

static inline void trace_file_paio_submit(void * acb, void * opaque, int64_t offset, int count, int type)
{
    if (true) {
        _nocheck__trace_file_paio_submit(acb, opaque, offset, count, type);
    }
}

#define TRACE_LURING_INIT_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LURING_INIT_STATE) || \
    false)

static inline void _nocheck__trace_luring_init_state(void * s, size_t size)
{
    if (trace_event_get_state(TRACE_LURING_INIT_STATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 65 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:luring_init_state " "s %p size %zu" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, size);
#line 1794 "trace/trace-block.h"
        } else {
#line 65 "../block/trace-events"
            qemu_log("luring_init_state " "s %p size %zu" "\n", s, size);
#line 1798 "trace/trace-block.h"
        }
    }
}

static inline void trace_luring_init_state(void * s, size_t size)
{
    if (true) {
        _nocheck__trace_luring_init_state(s, size);
    }
}

#define TRACE_LURING_CLEANUP_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LURING_CLEANUP_STATE) || \
    false)

static inline void _nocheck__trace_luring_cleanup_state(void * s)
{
    if (trace_event_get_state(TRACE_LURING_CLEANUP_STATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 66 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:luring_cleanup_state " "%p freed" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s);
#line 1825 "trace/trace-block.h"
        } else {
#line 66 "../block/trace-events"
            qemu_log("luring_cleanup_state " "%p freed" "\n", s);
#line 1829 "trace/trace-block.h"
        }
    }
}

static inline void trace_luring_cleanup_state(void * s)
{
    if (true) {
        _nocheck__trace_luring_cleanup_state(s);
    }
}

#define TRACE_LURING_UNPLUG_FN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LURING_UNPLUG_FN) || \
    false)

static inline void _nocheck__trace_luring_unplug_fn(void * s, int blocked, int queued, int inflight)
{
    if (trace_event_get_state(TRACE_LURING_UNPLUG_FN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 67 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:luring_unplug_fn " "LuringState %p blocked %d queued %d inflight %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, blocked, queued, inflight);
#line 1856 "trace/trace-block.h"
        } else {
#line 67 "../block/trace-events"
            qemu_log("luring_unplug_fn " "LuringState %p blocked %d queued %d inflight %d" "\n", s, blocked, queued, inflight);
#line 1860 "trace/trace-block.h"
        }
    }
}

static inline void trace_luring_unplug_fn(void * s, int blocked, int queued, int inflight)
{
    if (true) {
        _nocheck__trace_luring_unplug_fn(s, blocked, queued, inflight);
    }
}

#define TRACE_LURING_DO_SUBMIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LURING_DO_SUBMIT) || \
    false)

static inline void _nocheck__trace_luring_do_submit(void * s, int blocked, int queued, int inflight)
{
    if (trace_event_get_state(TRACE_LURING_DO_SUBMIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 68 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:luring_do_submit " "LuringState %p blocked %d queued %d inflight %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, blocked, queued, inflight);
#line 1887 "trace/trace-block.h"
        } else {
#line 68 "../block/trace-events"
            qemu_log("luring_do_submit " "LuringState %p blocked %d queued %d inflight %d" "\n", s, blocked, queued, inflight);
#line 1891 "trace/trace-block.h"
        }
    }
}

static inline void trace_luring_do_submit(void * s, int blocked, int queued, int inflight)
{
    if (true) {
        _nocheck__trace_luring_do_submit(s, blocked, queued, inflight);
    }
}

#define TRACE_LURING_DO_SUBMIT_DONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LURING_DO_SUBMIT_DONE) || \
    false)

static inline void _nocheck__trace_luring_do_submit_done(void * s, int ret)
{
    if (trace_event_get_state(TRACE_LURING_DO_SUBMIT_DONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 69 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:luring_do_submit_done " "LuringState %p submitted to kernel %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, ret);
#line 1918 "trace/trace-block.h"
        } else {
#line 69 "../block/trace-events"
            qemu_log("luring_do_submit_done " "LuringState %p submitted to kernel %d" "\n", s, ret);
#line 1922 "trace/trace-block.h"
        }
    }
}

static inline void trace_luring_do_submit_done(void * s, int ret)
{
    if (true) {
        _nocheck__trace_luring_do_submit_done(s, ret);
    }
}

#define TRACE_LURING_CO_SUBMIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LURING_CO_SUBMIT) || \
    false)

static inline void _nocheck__trace_luring_co_submit(void * bs, void * s, void * luringcb, int fd, uint64_t offset, size_t nbytes, int type)
{
    if (trace_event_get_state(TRACE_LURING_CO_SUBMIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 70 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:luring_co_submit " "bs %p s %p luringcb %p fd %d offset %" PRId64 " nbytes %zd type %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bs, s, luringcb, fd, offset, nbytes, type);
#line 1949 "trace/trace-block.h"
        } else {
#line 70 "../block/trace-events"
            qemu_log("luring_co_submit " "bs %p s %p luringcb %p fd %d offset %" PRId64 " nbytes %zd type %d" "\n", bs, s, luringcb, fd, offset, nbytes, type);
#line 1953 "trace/trace-block.h"
        }
    }
}

static inline void trace_luring_co_submit(void * bs, void * s, void * luringcb, int fd, uint64_t offset, size_t nbytes, int type)
{
    if (true) {
        _nocheck__trace_luring_co_submit(bs, s, luringcb, fd, offset, nbytes, type);
    }
}

#define TRACE_LURING_PROCESS_COMPLETION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LURING_PROCESS_COMPLETION) || \
    false)

static inline void _nocheck__trace_luring_process_completion(void * s, void * aiocb, int ret)
{
    if (trace_event_get_state(TRACE_LURING_PROCESS_COMPLETION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 71 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:luring_process_completion " "LuringState %p luringcb %p ret %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, aiocb, ret);
#line 1980 "trace/trace-block.h"
        } else {
#line 71 "../block/trace-events"
            qemu_log("luring_process_completion " "LuringState %p luringcb %p ret %d" "\n", s, aiocb, ret);
#line 1984 "trace/trace-block.h"
        }
    }
}

static inline void trace_luring_process_completion(void * s, void * aiocb, int ret)
{
    if (true) {
        _nocheck__trace_luring_process_completion(s, aiocb, ret);
    }
}

#define TRACE_LURING_IO_URING_SUBMIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LURING_IO_URING_SUBMIT) || \
    false)

static inline void _nocheck__trace_luring_io_uring_submit(void * s, int ret)
{
    if (trace_event_get_state(TRACE_LURING_IO_URING_SUBMIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 72 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:luring_io_uring_submit " "LuringState %p ret %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, ret);
#line 2011 "trace/trace-block.h"
        } else {
#line 72 "../block/trace-events"
            qemu_log("luring_io_uring_submit " "LuringState %p ret %d" "\n", s, ret);
#line 2015 "trace/trace-block.h"
        }
    }
}

static inline void trace_luring_io_uring_submit(void * s, int ret)
{
    if (true) {
        _nocheck__trace_luring_io_uring_submit(s, ret);
    }
}

#define TRACE_LURING_RESUBMIT_SHORT_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LURING_RESUBMIT_SHORT_READ) || \
    false)

static inline void _nocheck__trace_luring_resubmit_short_read(void * s, void * luringcb, int nread)
{
    if (trace_event_get_state(TRACE_LURING_RESUBMIT_SHORT_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 73 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:luring_resubmit_short_read " "LuringState %p luringcb %p nread %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, luringcb, nread);
#line 2042 "trace/trace-block.h"
        } else {
#line 73 "../block/trace-events"
            qemu_log("luring_resubmit_short_read " "LuringState %p luringcb %p nread %d" "\n", s, luringcb, nread);
#line 2046 "trace/trace-block.h"
        }
    }
}

static inline void trace_luring_resubmit_short_read(void * s, void * luringcb, int nread)
{
    if (true) {
        _nocheck__trace_luring_resubmit_short_read(s, luringcb, nread);
    }
}

#define TRACE_QCOW2_ADD_TASK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_ADD_TASK) || \
    false)

static inline void _nocheck__trace_qcow2_add_task(void * co, void * bs, void * pool, const char * action, int cluster_type, uint64_t host_offset, uint64_t offset, uint64_t bytes, void * qiov, size_t qiov_offset)
{
    if (trace_event_get_state(TRACE_QCOW2_ADD_TASK) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 76 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qcow2_add_task " "co %p bs %p pool %p: %s: cluster_type %d file_cluster_offset %" PRIu64 " offset %" PRIu64 " bytes %" PRIu64 " qiov %p qiov_offset %zu" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , co, bs, pool, action, cluster_type, host_offset, offset, bytes, qiov, qiov_offset);
#line 2073 "trace/trace-block.h"
        } else {
#line 76 "../block/trace-events"
            qemu_log("qcow2_add_task " "co %p bs %p pool %p: %s: cluster_type %d file_cluster_offset %" PRIu64 " offset %" PRIu64 " bytes %" PRIu64 " qiov %p qiov_offset %zu" "\n", co, bs, pool, action, cluster_type, host_offset, offset, bytes, qiov, qiov_offset);
#line 2077 "trace/trace-block.h"
        }
    }
}

static inline void trace_qcow2_add_task(void * co, void * bs, void * pool, const char * action, int cluster_type, uint64_t host_offset, uint64_t offset, uint64_t bytes, void * qiov, size_t qiov_offset)
{
    if (true) {
        _nocheck__trace_qcow2_add_task(co, bs, pool, action, cluster_type, host_offset, offset, bytes, qiov, qiov_offset);
    }
}

#define TRACE_QCOW2_WRITEV_START_REQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_WRITEV_START_REQ) || \
    false)

static inline void _nocheck__trace_qcow2_writev_start_req(void * co, int64_t offset, int64_t bytes)
{
    if (trace_event_get_state(TRACE_QCOW2_WRITEV_START_REQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 77 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qcow2_writev_start_req " "co %p offset 0x%" PRIx64 " bytes %" PRId64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , co, offset, bytes);
#line 2104 "trace/trace-block.h"
        } else {
#line 77 "../block/trace-events"
            qemu_log("qcow2_writev_start_req " "co %p offset 0x%" PRIx64 " bytes %" PRId64 "\n", co, offset, bytes);
#line 2108 "trace/trace-block.h"
        }
    }
}

static inline void trace_qcow2_writev_start_req(void * co, int64_t offset, int64_t bytes)
{
    if (true) {
        _nocheck__trace_qcow2_writev_start_req(co, offset, bytes);
    }
}

#define TRACE_QCOW2_WRITEV_DONE_REQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_WRITEV_DONE_REQ) || \
    false)

static inline void _nocheck__trace_qcow2_writev_done_req(void * co, int ret)
{
    if (trace_event_get_state(TRACE_QCOW2_WRITEV_DONE_REQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 78 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qcow2_writev_done_req " "co %p ret %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , co, ret);
#line 2135 "trace/trace-block.h"
        } else {
#line 78 "../block/trace-events"
            qemu_log("qcow2_writev_done_req " "co %p ret %d" "\n", co, ret);
#line 2139 "trace/trace-block.h"
        }
    }
}

static inline void trace_qcow2_writev_done_req(void * co, int ret)
{
    if (true) {
        _nocheck__trace_qcow2_writev_done_req(co, ret);
    }
}

#define TRACE_QCOW2_WRITEV_START_PART_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_WRITEV_START_PART) || \
    false)

static inline void _nocheck__trace_qcow2_writev_start_part(void * co)
{
    if (trace_event_get_state(TRACE_QCOW2_WRITEV_START_PART) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 79 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qcow2_writev_start_part " "co %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , co);
#line 2166 "trace/trace-block.h"
        } else {
#line 79 "../block/trace-events"
            qemu_log("qcow2_writev_start_part " "co %p" "\n", co);
#line 2170 "trace/trace-block.h"
        }
    }
}

static inline void trace_qcow2_writev_start_part(void * co)
{
    if (true) {
        _nocheck__trace_qcow2_writev_start_part(co);
    }
}

#define TRACE_QCOW2_WRITEV_DONE_PART_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_WRITEV_DONE_PART) || \
    false)

static inline void _nocheck__trace_qcow2_writev_done_part(void * co, int cur_bytes)
{
    if (trace_event_get_state(TRACE_QCOW2_WRITEV_DONE_PART) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 80 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qcow2_writev_done_part " "co %p cur_bytes %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , co, cur_bytes);
#line 2197 "trace/trace-block.h"
        } else {
#line 80 "../block/trace-events"
            qemu_log("qcow2_writev_done_part " "co %p cur_bytes %d" "\n", co, cur_bytes);
#line 2201 "trace/trace-block.h"
        }
    }
}

static inline void trace_qcow2_writev_done_part(void * co, int cur_bytes)
{
    if (true) {
        _nocheck__trace_qcow2_writev_done_part(co, cur_bytes);
    }
}

#define TRACE_QCOW2_WRITEV_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_WRITEV_DATA) || \
    false)

static inline void _nocheck__trace_qcow2_writev_data(void * co, uint64_t offset)
{
    if (trace_event_get_state(TRACE_QCOW2_WRITEV_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 81 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qcow2_writev_data " "co %p offset 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , co, offset);
#line 2228 "trace/trace-block.h"
        } else {
#line 81 "../block/trace-events"
            qemu_log("qcow2_writev_data " "co %p offset 0x%" PRIx64 "\n", co, offset);
#line 2232 "trace/trace-block.h"
        }
    }
}

static inline void trace_qcow2_writev_data(void * co, uint64_t offset)
{
    if (true) {
        _nocheck__trace_qcow2_writev_data(co, offset);
    }
}

#define TRACE_QCOW2_PWRITE_ZEROES_START_REQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_PWRITE_ZEROES_START_REQ) || \
    false)

static inline void _nocheck__trace_qcow2_pwrite_zeroes_start_req(void * co, int64_t offset, int64_t bytes)
{
    if (trace_event_get_state(TRACE_QCOW2_PWRITE_ZEROES_START_REQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 82 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qcow2_pwrite_zeroes_start_req " "co %p offset 0x%" PRIx64 " bytes %" PRId64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , co, offset, bytes);
#line 2259 "trace/trace-block.h"
        } else {
#line 82 "../block/trace-events"
            qemu_log("qcow2_pwrite_zeroes_start_req " "co %p offset 0x%" PRIx64 " bytes %" PRId64 "\n", co, offset, bytes);
#line 2263 "trace/trace-block.h"
        }
    }
}

static inline void trace_qcow2_pwrite_zeroes_start_req(void * co, int64_t offset, int64_t bytes)
{
    if (true) {
        _nocheck__trace_qcow2_pwrite_zeroes_start_req(co, offset, bytes);
    }
}

#define TRACE_QCOW2_PWRITE_ZEROES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_PWRITE_ZEROES) || \
    false)

static inline void _nocheck__trace_qcow2_pwrite_zeroes(void * co, int64_t offset, int64_t bytes)
{
    if (trace_event_get_state(TRACE_QCOW2_PWRITE_ZEROES) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 83 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qcow2_pwrite_zeroes " "co %p offset 0x%" PRIx64 " bytes %" PRId64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , co, offset, bytes);
#line 2290 "trace/trace-block.h"
        } else {
#line 83 "../block/trace-events"
            qemu_log("qcow2_pwrite_zeroes " "co %p offset 0x%" PRIx64 " bytes %" PRId64 "\n", co, offset, bytes);
#line 2294 "trace/trace-block.h"
        }
    }
}

static inline void trace_qcow2_pwrite_zeroes(void * co, int64_t offset, int64_t bytes)
{
    if (true) {
        _nocheck__trace_qcow2_pwrite_zeroes(co, offset, bytes);
    }
}

#define TRACE_QCOW2_SKIP_COW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_SKIP_COW) || \
    false)

static inline void _nocheck__trace_qcow2_skip_cow(void * co, uint64_t offset, int nb_clusters)
{
    if (trace_event_get_state(TRACE_QCOW2_SKIP_COW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 84 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qcow2_skip_cow " "co %p offset 0x%" PRIx64 " nb_clusters %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , co, offset, nb_clusters);
#line 2321 "trace/trace-block.h"
        } else {
#line 84 "../block/trace-events"
            qemu_log("qcow2_skip_cow " "co %p offset 0x%" PRIx64 " nb_clusters %d" "\n", co, offset, nb_clusters);
#line 2325 "trace/trace-block.h"
        }
    }
}

static inline void trace_qcow2_skip_cow(void * co, uint64_t offset, int nb_clusters)
{
    if (true) {
        _nocheck__trace_qcow2_skip_cow(co, offset, nb_clusters);
    }
}

#define TRACE_QCOW2_ALLOC_CLUSTERS_OFFSET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_ALLOC_CLUSTERS_OFFSET) || \
    false)

static inline void _nocheck__trace_qcow2_alloc_clusters_offset(void * co, uint64_t offset, int bytes)
{
    if (trace_event_get_state(TRACE_QCOW2_ALLOC_CLUSTERS_OFFSET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 87 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qcow2_alloc_clusters_offset " "co %p offset 0x%" PRIx64 " bytes %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , co, offset, bytes);
#line 2352 "trace/trace-block.h"
        } else {
#line 87 "../block/trace-events"
            qemu_log("qcow2_alloc_clusters_offset " "co %p offset 0x%" PRIx64 " bytes %d" "\n", co, offset, bytes);
#line 2356 "trace/trace-block.h"
        }
    }
}

static inline void trace_qcow2_alloc_clusters_offset(void * co, uint64_t offset, int bytes)
{
    if (true) {
        _nocheck__trace_qcow2_alloc_clusters_offset(co, offset, bytes);
    }
}

#define TRACE_QCOW2_HANDLE_COPIED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_HANDLE_COPIED) || \
    false)

static inline void _nocheck__trace_qcow2_handle_copied(void * co, uint64_t guest_offset, uint64_t host_offset, uint64_t bytes)
{
    if (trace_event_get_state(TRACE_QCOW2_HANDLE_COPIED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 88 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qcow2_handle_copied " "co %p guest_offset 0x%" PRIx64 " host_offset 0x%" PRIx64 " bytes 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , co, guest_offset, host_offset, bytes);
#line 2383 "trace/trace-block.h"
        } else {
#line 88 "../block/trace-events"
            qemu_log("qcow2_handle_copied " "co %p guest_offset 0x%" PRIx64 " host_offset 0x%" PRIx64 " bytes 0x%" PRIx64 "\n", co, guest_offset, host_offset, bytes);
#line 2387 "trace/trace-block.h"
        }
    }
}

static inline void trace_qcow2_handle_copied(void * co, uint64_t guest_offset, uint64_t host_offset, uint64_t bytes)
{
    if (true) {
        _nocheck__trace_qcow2_handle_copied(co, guest_offset, host_offset, bytes);
    }
}

#define TRACE_QCOW2_HANDLE_ALLOC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_HANDLE_ALLOC) || \
    false)

static inline void _nocheck__trace_qcow2_handle_alloc(void * co, uint64_t guest_offset, uint64_t host_offset, uint64_t bytes)
{
    if (trace_event_get_state(TRACE_QCOW2_HANDLE_ALLOC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 89 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qcow2_handle_alloc " "co %p guest_offset 0x%" PRIx64 " host_offset 0x%" PRIx64 " bytes 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , co, guest_offset, host_offset, bytes);
#line 2414 "trace/trace-block.h"
        } else {
#line 89 "../block/trace-events"
            qemu_log("qcow2_handle_alloc " "co %p guest_offset 0x%" PRIx64 " host_offset 0x%" PRIx64 " bytes 0x%" PRIx64 "\n", co, guest_offset, host_offset, bytes);
#line 2418 "trace/trace-block.h"
        }
    }
}

static inline void trace_qcow2_handle_alloc(void * co, uint64_t guest_offset, uint64_t host_offset, uint64_t bytes)
{
    if (true) {
        _nocheck__trace_qcow2_handle_alloc(co, guest_offset, host_offset, bytes);
    }
}

#define TRACE_QCOW2_DO_ALLOC_CLUSTERS_OFFSET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_DO_ALLOC_CLUSTERS_OFFSET) || \
    false)

static inline void _nocheck__trace_qcow2_do_alloc_clusters_offset(void * co, uint64_t guest_offset, uint64_t host_offset, int nb_clusters)
{
    if (trace_event_get_state(TRACE_QCOW2_DO_ALLOC_CLUSTERS_OFFSET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 90 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qcow2_do_alloc_clusters_offset " "co %p guest_offset 0x%" PRIx64 " host_offset 0x%" PRIx64 " nb_clusters %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , co, guest_offset, host_offset, nb_clusters);
#line 2445 "trace/trace-block.h"
        } else {
#line 90 "../block/trace-events"
            qemu_log("qcow2_do_alloc_clusters_offset " "co %p guest_offset 0x%" PRIx64 " host_offset 0x%" PRIx64 " nb_clusters %d" "\n", co, guest_offset, host_offset, nb_clusters);
#line 2449 "trace/trace-block.h"
        }
    }
}

static inline void trace_qcow2_do_alloc_clusters_offset(void * co, uint64_t guest_offset, uint64_t host_offset, int nb_clusters)
{
    if (true) {
        _nocheck__trace_qcow2_do_alloc_clusters_offset(co, guest_offset, host_offset, nb_clusters);
    }
}

#define TRACE_QCOW2_CLUSTER_ALLOC_PHYS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_CLUSTER_ALLOC_PHYS) || \
    false)

static inline void _nocheck__trace_qcow2_cluster_alloc_phys(void * co)
{
    if (trace_event_get_state(TRACE_QCOW2_CLUSTER_ALLOC_PHYS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 91 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qcow2_cluster_alloc_phys " "co %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , co);
#line 2476 "trace/trace-block.h"
        } else {
#line 91 "../block/trace-events"
            qemu_log("qcow2_cluster_alloc_phys " "co %p" "\n", co);
#line 2480 "trace/trace-block.h"
        }
    }
}

static inline void trace_qcow2_cluster_alloc_phys(void * co)
{
    if (true) {
        _nocheck__trace_qcow2_cluster_alloc_phys(co);
    }
}

#define TRACE_QCOW2_CLUSTER_LINK_L2_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_CLUSTER_LINK_L2) || \
    false)

static inline void _nocheck__trace_qcow2_cluster_link_l2(void * co, int nb_clusters)
{
    if (trace_event_get_state(TRACE_QCOW2_CLUSTER_LINK_L2) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 92 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qcow2_cluster_link_l2 " "co %p nb_clusters %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , co, nb_clusters);
#line 2507 "trace/trace-block.h"
        } else {
#line 92 "../block/trace-events"
            qemu_log("qcow2_cluster_link_l2 " "co %p nb_clusters %d" "\n", co, nb_clusters);
#line 2511 "trace/trace-block.h"
        }
    }
}

static inline void trace_qcow2_cluster_link_l2(void * co, int nb_clusters)
{
    if (true) {
        _nocheck__trace_qcow2_cluster_link_l2(co, nb_clusters);
    }
}

#define TRACE_QCOW2_L2_ALLOCATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_L2_ALLOCATE) || \
    false)

static inline void _nocheck__trace_qcow2_l2_allocate(void * bs, int l1_index)
{
    if (trace_event_get_state(TRACE_QCOW2_L2_ALLOCATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 94 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qcow2_l2_allocate " "bs %p l1_index %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bs, l1_index);
#line 2538 "trace/trace-block.h"
        } else {
#line 94 "../block/trace-events"
            qemu_log("qcow2_l2_allocate " "bs %p l1_index %d" "\n", bs, l1_index);
#line 2542 "trace/trace-block.h"
        }
    }
}

static inline void trace_qcow2_l2_allocate(void * bs, int l1_index)
{
    if (true) {
        _nocheck__trace_qcow2_l2_allocate(bs, l1_index);
    }
}

#define TRACE_QCOW2_L2_ALLOCATE_GET_EMPTY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_L2_ALLOCATE_GET_EMPTY) || \
    false)

static inline void _nocheck__trace_qcow2_l2_allocate_get_empty(void * bs, int l1_index)
{
    if (trace_event_get_state(TRACE_QCOW2_L2_ALLOCATE_GET_EMPTY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 95 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qcow2_l2_allocate_get_empty " "bs %p l1_index %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bs, l1_index);
#line 2569 "trace/trace-block.h"
        } else {
#line 95 "../block/trace-events"
            qemu_log("qcow2_l2_allocate_get_empty " "bs %p l1_index %d" "\n", bs, l1_index);
#line 2573 "trace/trace-block.h"
        }
    }
}

static inline void trace_qcow2_l2_allocate_get_empty(void * bs, int l1_index)
{
    if (true) {
        _nocheck__trace_qcow2_l2_allocate_get_empty(bs, l1_index);
    }
}

#define TRACE_QCOW2_L2_ALLOCATE_WRITE_L2_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_L2_ALLOCATE_WRITE_L2) || \
    false)

static inline void _nocheck__trace_qcow2_l2_allocate_write_l2(void * bs, int l1_index)
{
    if (trace_event_get_state(TRACE_QCOW2_L2_ALLOCATE_WRITE_L2) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 96 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qcow2_l2_allocate_write_l2 " "bs %p l1_index %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bs, l1_index);
#line 2600 "trace/trace-block.h"
        } else {
#line 96 "../block/trace-events"
            qemu_log("qcow2_l2_allocate_write_l2 " "bs %p l1_index %d" "\n", bs, l1_index);
#line 2604 "trace/trace-block.h"
        }
    }
}

static inline void trace_qcow2_l2_allocate_write_l2(void * bs, int l1_index)
{
    if (true) {
        _nocheck__trace_qcow2_l2_allocate_write_l2(bs, l1_index);
    }
}

#define TRACE_QCOW2_L2_ALLOCATE_WRITE_L1_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_L2_ALLOCATE_WRITE_L1) || \
    false)

static inline void _nocheck__trace_qcow2_l2_allocate_write_l1(void * bs, int l1_index)
{
    if (trace_event_get_state(TRACE_QCOW2_L2_ALLOCATE_WRITE_L1) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 97 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qcow2_l2_allocate_write_l1 " "bs %p l1_index %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bs, l1_index);
#line 2631 "trace/trace-block.h"
        } else {
#line 97 "../block/trace-events"
            qemu_log("qcow2_l2_allocate_write_l1 " "bs %p l1_index %d" "\n", bs, l1_index);
#line 2635 "trace/trace-block.h"
        }
    }
}

static inline void trace_qcow2_l2_allocate_write_l1(void * bs, int l1_index)
{
    if (true) {
        _nocheck__trace_qcow2_l2_allocate_write_l1(bs, l1_index);
    }
}

#define TRACE_QCOW2_L2_ALLOCATE_DONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_L2_ALLOCATE_DONE) || \
    false)

static inline void _nocheck__trace_qcow2_l2_allocate_done(void * bs, int l1_index, int ret)
{
    if (trace_event_get_state(TRACE_QCOW2_L2_ALLOCATE_DONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 98 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qcow2_l2_allocate_done " "bs %p l1_index %d ret %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bs, l1_index, ret);
#line 2662 "trace/trace-block.h"
        } else {
#line 98 "../block/trace-events"
            qemu_log("qcow2_l2_allocate_done " "bs %p l1_index %d ret %d" "\n", bs, l1_index, ret);
#line 2666 "trace/trace-block.h"
        }
    }
}

static inline void trace_qcow2_l2_allocate_done(void * bs, int l1_index, int ret)
{
    if (true) {
        _nocheck__trace_qcow2_l2_allocate_done(bs, l1_index, ret);
    }
}

#define TRACE_QCOW2_CACHE_GET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_CACHE_GET) || \
    false)

static inline void _nocheck__trace_qcow2_cache_get(void * co, int c, uint64_t offset, bool read_from_disk)
{
    if (trace_event_get_state(TRACE_QCOW2_CACHE_GET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 101 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qcow2_cache_get " "co %p is_l2_cache %d offset 0x%" PRIx64 " read_from_disk %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , co, c, offset, read_from_disk);
#line 2693 "trace/trace-block.h"
        } else {
#line 101 "../block/trace-events"
            qemu_log("qcow2_cache_get " "co %p is_l2_cache %d offset 0x%" PRIx64 " read_from_disk %d" "\n", co, c, offset, read_from_disk);
#line 2697 "trace/trace-block.h"
        }
    }
}

static inline void trace_qcow2_cache_get(void * co, int c, uint64_t offset, bool read_from_disk)
{
    if (true) {
        _nocheck__trace_qcow2_cache_get(co, c, offset, read_from_disk);
    }
}

#define TRACE_QCOW2_CACHE_GET_REPLACE_ENTRY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_CACHE_GET_REPLACE_ENTRY) || \
    false)

static inline void _nocheck__trace_qcow2_cache_get_replace_entry(void * co, int c, int i)
{
    if (trace_event_get_state(TRACE_QCOW2_CACHE_GET_REPLACE_ENTRY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 102 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qcow2_cache_get_replace_entry " "co %p is_l2_cache %d index %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , co, c, i);
#line 2724 "trace/trace-block.h"
        } else {
#line 102 "../block/trace-events"
            qemu_log("qcow2_cache_get_replace_entry " "co %p is_l2_cache %d index %d" "\n", co, c, i);
#line 2728 "trace/trace-block.h"
        }
    }
}

static inline void trace_qcow2_cache_get_replace_entry(void * co, int c, int i)
{
    if (true) {
        _nocheck__trace_qcow2_cache_get_replace_entry(co, c, i);
    }
}

#define TRACE_QCOW2_CACHE_GET_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_CACHE_GET_READ) || \
    false)

static inline void _nocheck__trace_qcow2_cache_get_read(void * co, int c, int i)
{
    if (trace_event_get_state(TRACE_QCOW2_CACHE_GET_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 103 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qcow2_cache_get_read " "co %p is_l2_cache %d index %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , co, c, i);
#line 2755 "trace/trace-block.h"
        } else {
#line 103 "../block/trace-events"
            qemu_log("qcow2_cache_get_read " "co %p is_l2_cache %d index %d" "\n", co, c, i);
#line 2759 "trace/trace-block.h"
        }
    }
}

static inline void trace_qcow2_cache_get_read(void * co, int c, int i)
{
    if (true) {
        _nocheck__trace_qcow2_cache_get_read(co, c, i);
    }
}

#define TRACE_QCOW2_CACHE_GET_DONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_CACHE_GET_DONE) || \
    false)

static inline void _nocheck__trace_qcow2_cache_get_done(void * co, int c, int i)
{
    if (trace_event_get_state(TRACE_QCOW2_CACHE_GET_DONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 104 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qcow2_cache_get_done " "co %p is_l2_cache %d index %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , co, c, i);
#line 2786 "trace/trace-block.h"
        } else {
#line 104 "../block/trace-events"
            qemu_log("qcow2_cache_get_done " "co %p is_l2_cache %d index %d" "\n", co, c, i);
#line 2790 "trace/trace-block.h"
        }
    }
}

static inline void trace_qcow2_cache_get_done(void * co, int c, int i)
{
    if (true) {
        _nocheck__trace_qcow2_cache_get_done(co, c, i);
    }
}

#define TRACE_QCOW2_CACHE_FLUSH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_CACHE_FLUSH) || \
    false)

static inline void _nocheck__trace_qcow2_cache_flush(void * co, int c)
{
    if (trace_event_get_state(TRACE_QCOW2_CACHE_FLUSH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 105 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qcow2_cache_flush " "co %p is_l2_cache %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , co, c);
#line 2817 "trace/trace-block.h"
        } else {
#line 105 "../block/trace-events"
            qemu_log("qcow2_cache_flush " "co %p is_l2_cache %d" "\n", co, c);
#line 2821 "trace/trace-block.h"
        }
    }
}

static inline void trace_qcow2_cache_flush(void * co, int c)
{
    if (true) {
        _nocheck__trace_qcow2_cache_flush(co, c);
    }
}

#define TRACE_QCOW2_CACHE_ENTRY_FLUSH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_CACHE_ENTRY_FLUSH) || \
    false)

static inline void _nocheck__trace_qcow2_cache_entry_flush(void * co, int c, int i)
{
    if (trace_event_get_state(TRACE_QCOW2_CACHE_ENTRY_FLUSH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 106 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qcow2_cache_entry_flush " "co %p is_l2_cache %d index %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , co, c, i);
#line 2848 "trace/trace-block.h"
        } else {
#line 106 "../block/trace-events"
            qemu_log("qcow2_cache_entry_flush " "co %p is_l2_cache %d index %d" "\n", co, c, i);
#line 2852 "trace/trace-block.h"
        }
    }
}

static inline void trace_qcow2_cache_entry_flush(void * co, int c, int i)
{
    if (true) {
        _nocheck__trace_qcow2_cache_entry_flush(co, c, i);
    }
}

#define TRACE_QCOW2_PROCESS_DISCARDS_FAILED_REGION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_PROCESS_DISCARDS_FAILED_REGION) || \
    false)

static inline void _nocheck__trace_qcow2_process_discards_failed_region(uint64_t offset, uint64_t bytes, int ret)
{
    if (trace_event_get_state(TRACE_QCOW2_PROCESS_DISCARDS_FAILED_REGION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 109 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qcow2_process_discards_failed_region " "offset 0x%" PRIx64 " bytes 0x%" PRIx64 " ret %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, bytes, ret);
#line 2879 "trace/trace-block.h"
        } else {
#line 109 "../block/trace-events"
            qemu_log("qcow2_process_discards_failed_region " "offset 0x%" PRIx64 " bytes 0x%" PRIx64 " ret %d" "\n", offset, bytes, ret);
#line 2883 "trace/trace-block.h"
        }
    }
}

static inline void trace_qcow2_process_discards_failed_region(uint64_t offset, uint64_t bytes, int ret)
{
    if (true) {
        _nocheck__trace_qcow2_process_discards_failed_region(offset, bytes, ret);
    }
}

#define TRACE_QED_ALLOC_L2_CACHE_ENTRY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QED_ALLOC_L2_CACHE_ENTRY) || \
    false)

static inline void _nocheck__trace_qed_alloc_l2_cache_entry(void * l2_cache, void * entry)
{
    if (trace_event_get_state(TRACE_QED_ALLOC_L2_CACHE_ENTRY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 112 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qed_alloc_l2_cache_entry " "l2_cache %p entry %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , l2_cache, entry);
#line 2910 "trace/trace-block.h"
        } else {
#line 112 "../block/trace-events"
            qemu_log("qed_alloc_l2_cache_entry " "l2_cache %p entry %p" "\n", l2_cache, entry);
#line 2914 "trace/trace-block.h"
        }
    }
}

static inline void trace_qed_alloc_l2_cache_entry(void * l2_cache, void * entry)
{
    if (true) {
        _nocheck__trace_qed_alloc_l2_cache_entry(l2_cache, entry);
    }
}

#define TRACE_QED_UNREF_L2_CACHE_ENTRY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QED_UNREF_L2_CACHE_ENTRY) || \
    false)

static inline void _nocheck__trace_qed_unref_l2_cache_entry(void * entry, int ref)
{
    if (trace_event_get_state(TRACE_QED_UNREF_L2_CACHE_ENTRY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 113 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qed_unref_l2_cache_entry " "entry %p ref %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , entry, ref);
#line 2941 "trace/trace-block.h"
        } else {
#line 113 "../block/trace-events"
            qemu_log("qed_unref_l2_cache_entry " "entry %p ref %d" "\n", entry, ref);
#line 2945 "trace/trace-block.h"
        }
    }
}

static inline void trace_qed_unref_l2_cache_entry(void * entry, int ref)
{
    if (true) {
        _nocheck__trace_qed_unref_l2_cache_entry(entry, ref);
    }
}

#define TRACE_QED_FIND_L2_CACHE_ENTRY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QED_FIND_L2_CACHE_ENTRY) || \
    false)

static inline void _nocheck__trace_qed_find_l2_cache_entry(void * l2_cache, void * entry, uint64_t offset, int ref)
{
    if (trace_event_get_state(TRACE_QED_FIND_L2_CACHE_ENTRY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 114 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qed_find_l2_cache_entry " "l2_cache %p entry %p offset %"PRIu64" ref %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , l2_cache, entry, offset, ref);
#line 2972 "trace/trace-block.h"
        } else {
#line 114 "../block/trace-events"
            qemu_log("qed_find_l2_cache_entry " "l2_cache %p entry %p offset %"PRIu64" ref %d" "\n", l2_cache, entry, offset, ref);
#line 2976 "trace/trace-block.h"
        }
    }
}

static inline void trace_qed_find_l2_cache_entry(void * l2_cache, void * entry, uint64_t offset, int ref)
{
    if (true) {
        _nocheck__trace_qed_find_l2_cache_entry(l2_cache, entry, offset, ref);
    }
}

#define TRACE_QED_READ_TABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QED_READ_TABLE) || \
    false)

static inline void _nocheck__trace_qed_read_table(void * s, uint64_t offset, void * table)
{
    if (trace_event_get_state(TRACE_QED_READ_TABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 117 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qed_read_table " "s %p offset %"PRIu64" table %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, offset, table);
#line 3003 "trace/trace-block.h"
        } else {
#line 117 "../block/trace-events"
            qemu_log("qed_read_table " "s %p offset %"PRIu64" table %p" "\n", s, offset, table);
#line 3007 "trace/trace-block.h"
        }
    }
}

static inline void trace_qed_read_table(void * s, uint64_t offset, void * table)
{
    if (true) {
        _nocheck__trace_qed_read_table(s, offset, table);
    }
}

#define TRACE_QED_READ_TABLE_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QED_READ_TABLE_CB) || \
    false)

static inline void _nocheck__trace_qed_read_table_cb(void * s, void * table, int ret)
{
    if (trace_event_get_state(TRACE_QED_READ_TABLE_CB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 118 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qed_read_table_cb " "s %p table %p ret %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, table, ret);
#line 3034 "trace/trace-block.h"
        } else {
#line 118 "../block/trace-events"
            qemu_log("qed_read_table_cb " "s %p table %p ret %d" "\n", s, table, ret);
#line 3038 "trace/trace-block.h"
        }
    }
}

static inline void trace_qed_read_table_cb(void * s, void * table, int ret)
{
    if (true) {
        _nocheck__trace_qed_read_table_cb(s, table, ret);
    }
}

#define TRACE_QED_WRITE_TABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QED_WRITE_TABLE) || \
    false)

static inline void _nocheck__trace_qed_write_table(void * s, uint64_t offset, void * table, unsigned int index, unsigned int n)
{
    if (trace_event_get_state(TRACE_QED_WRITE_TABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 119 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qed_write_table " "s %p offset %"PRIu64" table %p index %u n %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, offset, table, index, n);
#line 3065 "trace/trace-block.h"
        } else {
#line 119 "../block/trace-events"
            qemu_log("qed_write_table " "s %p offset %"PRIu64" table %p index %u n %u" "\n", s, offset, table, index, n);
#line 3069 "trace/trace-block.h"
        }
    }
}

static inline void trace_qed_write_table(void * s, uint64_t offset, void * table, unsigned int index, unsigned int n)
{
    if (true) {
        _nocheck__trace_qed_write_table(s, offset, table, index, n);
    }
}

#define TRACE_QED_WRITE_TABLE_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QED_WRITE_TABLE_CB) || \
    false)

static inline void _nocheck__trace_qed_write_table_cb(void * s, void * table, int flush, int ret)
{
    if (trace_event_get_state(TRACE_QED_WRITE_TABLE_CB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 120 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qed_write_table_cb " "s %p table %p flush %d ret %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, table, flush, ret);
#line 3096 "trace/trace-block.h"
        } else {
#line 120 "../block/trace-events"
            qemu_log("qed_write_table_cb " "s %p table %p flush %d ret %d" "\n", s, table, flush, ret);
#line 3100 "trace/trace-block.h"
        }
    }
}

static inline void trace_qed_write_table_cb(void * s, void * table, int flush, int ret)
{
    if (true) {
        _nocheck__trace_qed_write_table_cb(s, table, flush, ret);
    }
}

#define TRACE_QED_NEED_CHECK_TIMER_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QED_NEED_CHECK_TIMER_CB) || \
    false)

static inline void _nocheck__trace_qed_need_check_timer_cb(void * s)
{
    if (trace_event_get_state(TRACE_QED_NEED_CHECK_TIMER_CB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 123 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qed_need_check_timer_cb " "s %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s);
#line 3127 "trace/trace-block.h"
        } else {
#line 123 "../block/trace-events"
            qemu_log("qed_need_check_timer_cb " "s %p" "\n", s);
#line 3131 "trace/trace-block.h"
        }
    }
}

static inline void trace_qed_need_check_timer_cb(void * s)
{
    if (true) {
        _nocheck__trace_qed_need_check_timer_cb(s);
    }
}

#define TRACE_QED_START_NEED_CHECK_TIMER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QED_START_NEED_CHECK_TIMER) || \
    false)

static inline void _nocheck__trace_qed_start_need_check_timer(void * s)
{
    if (trace_event_get_state(TRACE_QED_START_NEED_CHECK_TIMER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 124 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qed_start_need_check_timer " "s %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s);
#line 3158 "trace/trace-block.h"
        } else {
#line 124 "../block/trace-events"
            qemu_log("qed_start_need_check_timer " "s %p" "\n", s);
#line 3162 "trace/trace-block.h"
        }
    }
}

static inline void trace_qed_start_need_check_timer(void * s)
{
    if (true) {
        _nocheck__trace_qed_start_need_check_timer(s);
    }
}

#define TRACE_QED_CANCEL_NEED_CHECK_TIMER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QED_CANCEL_NEED_CHECK_TIMER) || \
    false)

static inline void _nocheck__trace_qed_cancel_need_check_timer(void * s)
{
    if (trace_event_get_state(TRACE_QED_CANCEL_NEED_CHECK_TIMER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 125 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qed_cancel_need_check_timer " "s %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s);
#line 3189 "trace/trace-block.h"
        } else {
#line 125 "../block/trace-events"
            qemu_log("qed_cancel_need_check_timer " "s %p" "\n", s);
#line 3193 "trace/trace-block.h"
        }
    }
}

static inline void trace_qed_cancel_need_check_timer(void * s)
{
    if (true) {
        _nocheck__trace_qed_cancel_need_check_timer(s);
    }
}

#define TRACE_QED_AIO_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QED_AIO_COMPLETE) || \
    false)

static inline void _nocheck__trace_qed_aio_complete(void * s, void * acb, int ret)
{
    if (trace_event_get_state(TRACE_QED_AIO_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 126 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qed_aio_complete " "s %p acb %p ret %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, acb, ret);
#line 3220 "trace/trace-block.h"
        } else {
#line 126 "../block/trace-events"
            qemu_log("qed_aio_complete " "s %p acb %p ret %d" "\n", s, acb, ret);
#line 3224 "trace/trace-block.h"
        }
    }
}

static inline void trace_qed_aio_complete(void * s, void * acb, int ret)
{
    if (true) {
        _nocheck__trace_qed_aio_complete(s, acb, ret);
    }
}

#define TRACE_QED_AIO_SETUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QED_AIO_SETUP) || \
    false)

static inline void _nocheck__trace_qed_aio_setup(void * s, void * acb, int64_t sector_num, int nb_sectors, void * opaque, int flags)
{
    if (trace_event_get_state(TRACE_QED_AIO_SETUP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 127 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qed_aio_setup " "s %p acb %p sector_num %"PRId64" nb_sectors %d opaque %p flags 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, acb, sector_num, nb_sectors, opaque, flags);
#line 3251 "trace/trace-block.h"
        } else {
#line 127 "../block/trace-events"
            qemu_log("qed_aio_setup " "s %p acb %p sector_num %"PRId64" nb_sectors %d opaque %p flags 0x%x" "\n", s, acb, sector_num, nb_sectors, opaque, flags);
#line 3255 "trace/trace-block.h"
        }
    }
}

static inline void trace_qed_aio_setup(void * s, void * acb, int64_t sector_num, int nb_sectors, void * opaque, int flags)
{
    if (true) {
        _nocheck__trace_qed_aio_setup(s, acb, sector_num, nb_sectors, opaque, flags);
    }
}

#define TRACE_QED_AIO_NEXT_IO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QED_AIO_NEXT_IO) || \
    false)

static inline void _nocheck__trace_qed_aio_next_io(void * s, void * acb, int ret, uint64_t cur_pos)
{
    if (trace_event_get_state(TRACE_QED_AIO_NEXT_IO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 128 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qed_aio_next_io " "s %p acb %p ret %d cur_pos %"PRIu64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, acb, ret, cur_pos);
#line 3282 "trace/trace-block.h"
        } else {
#line 128 "../block/trace-events"
            qemu_log("qed_aio_next_io " "s %p acb %p ret %d cur_pos %"PRIu64 "\n", s, acb, ret, cur_pos);
#line 3286 "trace/trace-block.h"
        }
    }
}

static inline void trace_qed_aio_next_io(void * s, void * acb, int ret, uint64_t cur_pos)
{
    if (true) {
        _nocheck__trace_qed_aio_next_io(s, acb, ret, cur_pos);
    }
}

#define TRACE_QED_AIO_READ_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QED_AIO_READ_DATA) || \
    false)

static inline void _nocheck__trace_qed_aio_read_data(void * s, void * acb, int ret, uint64_t offset, size_t len)
{
    if (trace_event_get_state(TRACE_QED_AIO_READ_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 129 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qed_aio_read_data " "s %p acb %p ret %d offset %"PRIu64" len %zu" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, acb, ret, offset, len);
#line 3313 "trace/trace-block.h"
        } else {
#line 129 "../block/trace-events"
            qemu_log("qed_aio_read_data " "s %p acb %p ret %d offset %"PRIu64" len %zu" "\n", s, acb, ret, offset, len);
#line 3317 "trace/trace-block.h"
        }
    }
}

static inline void trace_qed_aio_read_data(void * s, void * acb, int ret, uint64_t offset, size_t len)
{
    if (true) {
        _nocheck__trace_qed_aio_read_data(s, acb, ret, offset, len);
    }
}

#define TRACE_QED_AIO_WRITE_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QED_AIO_WRITE_DATA) || \
    false)

static inline void _nocheck__trace_qed_aio_write_data(void * s, void * acb, int ret, uint64_t offset, size_t len)
{
    if (trace_event_get_state(TRACE_QED_AIO_WRITE_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 130 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qed_aio_write_data " "s %p acb %p ret %d offset %"PRIu64" len %zu" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, acb, ret, offset, len);
#line 3344 "trace/trace-block.h"
        } else {
#line 130 "../block/trace-events"
            qemu_log("qed_aio_write_data " "s %p acb %p ret %d offset %"PRIu64" len %zu" "\n", s, acb, ret, offset, len);
#line 3348 "trace/trace-block.h"
        }
    }
}

static inline void trace_qed_aio_write_data(void * s, void * acb, int ret, uint64_t offset, size_t len)
{
    if (true) {
        _nocheck__trace_qed_aio_write_data(s, acb, ret, offset, len);
    }
}

#define TRACE_QED_AIO_WRITE_PREFILL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QED_AIO_WRITE_PREFILL) || \
    false)

static inline void _nocheck__trace_qed_aio_write_prefill(void * s, void * acb, uint64_t start, size_t len, uint64_t offset)
{
    if (trace_event_get_state(TRACE_QED_AIO_WRITE_PREFILL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 131 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qed_aio_write_prefill " "s %p acb %p start %"PRIu64" len %zu offset %"PRIu64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, acb, start, len, offset);
#line 3375 "trace/trace-block.h"
        } else {
#line 131 "../block/trace-events"
            qemu_log("qed_aio_write_prefill " "s %p acb %p start %"PRIu64" len %zu offset %"PRIu64 "\n", s, acb, start, len, offset);
#line 3379 "trace/trace-block.h"
        }
    }
}

static inline void trace_qed_aio_write_prefill(void * s, void * acb, uint64_t start, size_t len, uint64_t offset)
{
    if (true) {
        _nocheck__trace_qed_aio_write_prefill(s, acb, start, len, offset);
    }
}

#define TRACE_QED_AIO_WRITE_POSTFILL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QED_AIO_WRITE_POSTFILL) || \
    false)

static inline void _nocheck__trace_qed_aio_write_postfill(void * s, void * acb, uint64_t start, size_t len, uint64_t offset)
{
    if (trace_event_get_state(TRACE_QED_AIO_WRITE_POSTFILL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 132 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qed_aio_write_postfill " "s %p acb %p start %"PRIu64" len %zu offset %"PRIu64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, acb, start, len, offset);
#line 3406 "trace/trace-block.h"
        } else {
#line 132 "../block/trace-events"
            qemu_log("qed_aio_write_postfill " "s %p acb %p start %"PRIu64" len %zu offset %"PRIu64 "\n", s, acb, start, len, offset);
#line 3410 "trace/trace-block.h"
        }
    }
}

static inline void trace_qed_aio_write_postfill(void * s, void * acb, uint64_t start, size_t len, uint64_t offset)
{
    if (true) {
        _nocheck__trace_qed_aio_write_postfill(s, acb, start, len, offset);
    }
}

#define TRACE_QED_AIO_WRITE_MAIN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QED_AIO_WRITE_MAIN) || \
    false)

static inline void _nocheck__trace_qed_aio_write_main(void * s, void * acb, int ret, uint64_t offset, size_t len)
{
    if (trace_event_get_state(TRACE_QED_AIO_WRITE_MAIN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 133 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:qed_aio_write_main " "s %p acb %p ret %d offset %"PRIu64" len %zu" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, acb, ret, offset, len);
#line 3437 "trace/trace-block.h"
        } else {
#line 133 "../block/trace-events"
            qemu_log("qed_aio_write_main " "s %p acb %p ret %d offset %"PRIu64" len %zu" "\n", s, acb, ret, offset, len);
#line 3441 "trace/trace-block.h"
        }
    }
}

static inline void trace_qed_aio_write_main(void * s, void * acb, int ret, uint64_t offset, size_t len)
{
    if (true) {
        _nocheck__trace_qed_aio_write_main(s, acb, ret, offset, len);
    }
}

#define TRACE_NVME_CONTROLLER_CAPABILITY_RAW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_CONTROLLER_CAPABILITY_RAW) || \
    false)

static inline void _nocheck__trace_nvme_controller_capability_raw(uint64_t value)
{
    if (trace_event_get_state(TRACE_NVME_CONTROLLER_CAPABILITY_RAW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 136 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:nvme_controller_capability_raw " "0x%08"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , value);
#line 3468 "trace/trace-block.h"
        } else {
#line 136 "../block/trace-events"
            qemu_log("nvme_controller_capability_raw " "0x%08"PRIx64 "\n", value);
#line 3472 "trace/trace-block.h"
        }
    }
}

static inline void trace_nvme_controller_capability_raw(uint64_t value)
{
    if (true) {
        _nocheck__trace_nvme_controller_capability_raw(value);
    }
}

#define TRACE_NVME_CONTROLLER_CAPABILITY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_CONTROLLER_CAPABILITY) || \
    false)

static inline void _nocheck__trace_nvme_controller_capability(const char * desc, uint64_t value)
{
    if (trace_event_get_state(TRACE_NVME_CONTROLLER_CAPABILITY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 137 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:nvme_controller_capability " "%s: %"PRIu64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , desc, value);
#line 3499 "trace/trace-block.h"
        } else {
#line 137 "../block/trace-events"
            qemu_log("nvme_controller_capability " "%s: %"PRIu64 "\n", desc, value);
#line 3503 "trace/trace-block.h"
        }
    }
}

static inline void trace_nvme_controller_capability(const char * desc, uint64_t value)
{
    if (true) {
        _nocheck__trace_nvme_controller_capability(desc, value);
    }
}

#define TRACE_NVME_CONTROLLER_SPEC_VERSION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_CONTROLLER_SPEC_VERSION) || \
    false)

static inline void _nocheck__trace_nvme_controller_spec_version(uint32_t mjr, uint32_t mnr, uint32_t ter)
{
    if (trace_event_get_state(TRACE_NVME_CONTROLLER_SPEC_VERSION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 138 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:nvme_controller_spec_version " "Specification supported: %u.%u.%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , mjr, mnr, ter);
#line 3530 "trace/trace-block.h"
        } else {
#line 138 "../block/trace-events"
            qemu_log("nvme_controller_spec_version " "Specification supported: %u.%u.%u" "\n", mjr, mnr, ter);
#line 3534 "trace/trace-block.h"
        }
    }
}

static inline void trace_nvme_controller_spec_version(uint32_t mjr, uint32_t mnr, uint32_t ter)
{
    if (true) {
        _nocheck__trace_nvme_controller_spec_version(mjr, mnr, ter);
    }
}

#define TRACE_NVME_KICK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_KICK) || \
    false)

static inline void _nocheck__trace_nvme_kick(void * s, unsigned q_index)
{
    if (trace_event_get_state(TRACE_NVME_KICK) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 139 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:nvme_kick " "s %p q #%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, q_index);
#line 3561 "trace/trace-block.h"
        } else {
#line 139 "../block/trace-events"
            qemu_log("nvme_kick " "s %p q #%u" "\n", s, q_index);
#line 3565 "trace/trace-block.h"
        }
    }
}

static inline void trace_nvme_kick(void * s, unsigned q_index)
{
    if (true) {
        _nocheck__trace_nvme_kick(s, q_index);
    }
}

#define TRACE_NVME_DMA_FLUSH_QUEUE_WAIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_DMA_FLUSH_QUEUE_WAIT) || \
    false)

static inline void _nocheck__trace_nvme_dma_flush_queue_wait(void * s)
{
    if (trace_event_get_state(TRACE_NVME_DMA_FLUSH_QUEUE_WAIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 140 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:nvme_dma_flush_queue_wait " "s %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s);
#line 3592 "trace/trace-block.h"
        } else {
#line 140 "../block/trace-events"
            qemu_log("nvme_dma_flush_queue_wait " "s %p" "\n", s);
#line 3596 "trace/trace-block.h"
        }
    }
}

static inline void trace_nvme_dma_flush_queue_wait(void * s)
{
    if (true) {
        _nocheck__trace_nvme_dma_flush_queue_wait(s);
    }
}

#define TRACE_NVME_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERROR) || \
    false)

static inline void _nocheck__trace_nvme_error(int cmd_specific, int sq_head, int sqid, int cid, int status)
{
    if (trace_event_get_state(TRACE_NVME_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 141 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:nvme_error " "cmd_specific %d sq_head %d sqid %d cid %d status 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd_specific, sq_head, sqid, cid, status);
#line 3623 "trace/trace-block.h"
        } else {
#line 141 "../block/trace-events"
            qemu_log("nvme_error " "cmd_specific %d sq_head %d sqid %d cid %d status 0x%x" "\n", cmd_specific, sq_head, sqid, cid, status);
#line 3627 "trace/trace-block.h"
        }
    }
}

static inline void trace_nvme_error(int cmd_specific, int sq_head, int sqid, int cid, int status)
{
    if (true) {
        _nocheck__trace_nvme_error(cmd_specific, sq_head, sqid, cid, status);
    }
}

#define TRACE_NVME_PROCESS_COMPLETION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_PROCESS_COMPLETION) || \
    false)

static inline void _nocheck__trace_nvme_process_completion(void * s, unsigned q_index, int inflight)
{
    if (trace_event_get_state(TRACE_NVME_PROCESS_COMPLETION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 142 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:nvme_process_completion " "s %p q #%u inflight %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, q_index, inflight);
#line 3654 "trace/trace-block.h"
        } else {
#line 142 "../block/trace-events"
            qemu_log("nvme_process_completion " "s %p q #%u inflight %d" "\n", s, q_index, inflight);
#line 3658 "trace/trace-block.h"
        }
    }
}

static inline void trace_nvme_process_completion(void * s, unsigned q_index, int inflight)
{
    if (true) {
        _nocheck__trace_nvme_process_completion(s, q_index, inflight);
    }
}

#define TRACE_NVME_COMPLETE_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_COMPLETE_COMMAND) || \
    false)

static inline void _nocheck__trace_nvme_complete_command(void * s, unsigned q_index, int cid)
{
    if (trace_event_get_state(TRACE_NVME_COMPLETE_COMMAND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 143 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:nvme_complete_command " "s %p q #%u cid %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, q_index, cid);
#line 3685 "trace/trace-block.h"
        } else {
#line 143 "../block/trace-events"
            qemu_log("nvme_complete_command " "s %p q #%u cid %d" "\n", s, q_index, cid);
#line 3689 "trace/trace-block.h"
        }
    }
}

static inline void trace_nvme_complete_command(void * s, unsigned q_index, int cid)
{
    if (true) {
        _nocheck__trace_nvme_complete_command(s, q_index, cid);
    }
}

#define TRACE_NVME_SUBMIT_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_SUBMIT_COMMAND) || \
    false)

static inline void _nocheck__trace_nvme_submit_command(void * s, unsigned q_index, int cid)
{
    if (trace_event_get_state(TRACE_NVME_SUBMIT_COMMAND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 144 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:nvme_submit_command " "s %p q #%u cid %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, q_index, cid);
#line 3716 "trace/trace-block.h"
        } else {
#line 144 "../block/trace-events"
            qemu_log("nvme_submit_command " "s %p q #%u cid %d" "\n", s, q_index, cid);
#line 3720 "trace/trace-block.h"
        }
    }
}

static inline void trace_nvme_submit_command(void * s, unsigned q_index, int cid)
{
    if (true) {
        _nocheck__trace_nvme_submit_command(s, q_index, cid);
    }
}

#define TRACE_NVME_SUBMIT_COMMAND_RAW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_SUBMIT_COMMAND_RAW) || \
    false)

static inline void _nocheck__trace_nvme_submit_command_raw(int c0, int c1, int c2, int c3, int c4, int c5, int c6, int c7)
{
    if (trace_event_get_state(TRACE_NVME_SUBMIT_COMMAND_RAW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 145 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:nvme_submit_command_raw " "%02x %02x %02x %02x %02x %02x %02x %02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , c0, c1, c2, c3, c4, c5, c6, c7);
#line 3747 "trace/trace-block.h"
        } else {
#line 145 "../block/trace-events"
            qemu_log("nvme_submit_command_raw " "%02x %02x %02x %02x %02x %02x %02x %02x" "\n", c0, c1, c2, c3, c4, c5, c6, c7);
#line 3751 "trace/trace-block.h"
        }
    }
}

static inline void trace_nvme_submit_command_raw(int c0, int c1, int c2, int c3, int c4, int c5, int c6, int c7)
{
    if (true) {
        _nocheck__trace_nvme_submit_command_raw(c0, c1, c2, c3, c4, c5, c6, c7);
    }
}

#define TRACE_NVME_HANDLE_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_HANDLE_EVENT) || \
    false)

static inline void _nocheck__trace_nvme_handle_event(void * s)
{
    if (trace_event_get_state(TRACE_NVME_HANDLE_EVENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 146 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:nvme_handle_event " "s %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s);
#line 3778 "trace/trace-block.h"
        } else {
#line 146 "../block/trace-events"
            qemu_log("nvme_handle_event " "s %p" "\n", s);
#line 3782 "trace/trace-block.h"
        }
    }
}

static inline void trace_nvme_handle_event(void * s)
{
    if (true) {
        _nocheck__trace_nvme_handle_event(s);
    }
}

#define TRACE_NVME_POLL_QUEUE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_POLL_QUEUE) || \
    false)

static inline void _nocheck__trace_nvme_poll_queue(void * s, unsigned q_index)
{
    if (trace_event_get_state(TRACE_NVME_POLL_QUEUE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 147 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:nvme_poll_queue " "s %p q #%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, q_index);
#line 3809 "trace/trace-block.h"
        } else {
#line 147 "../block/trace-events"
            qemu_log("nvme_poll_queue " "s %p q #%u" "\n", s, q_index);
#line 3813 "trace/trace-block.h"
        }
    }
}

static inline void trace_nvme_poll_queue(void * s, unsigned q_index)
{
    if (true) {
        _nocheck__trace_nvme_poll_queue(s, q_index);
    }
}

#define TRACE_NVME_PRW_ALIGNED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_PRW_ALIGNED) || \
    false)

static inline void _nocheck__trace_nvme_prw_aligned(void * s, int is_write, uint64_t offset, uint64_t bytes, int flags, int niov)
{
    if (trace_event_get_state(TRACE_NVME_PRW_ALIGNED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 148 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:nvme_prw_aligned " "s %p is_write %d offset 0x%"PRIx64" bytes %"PRId64" flags %d niov %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, is_write, offset, bytes, flags, niov);
#line 3840 "trace/trace-block.h"
        } else {
#line 148 "../block/trace-events"
            qemu_log("nvme_prw_aligned " "s %p is_write %d offset 0x%"PRIx64" bytes %"PRId64" flags %d niov %d" "\n", s, is_write, offset, bytes, flags, niov);
#line 3844 "trace/trace-block.h"
        }
    }
}

static inline void trace_nvme_prw_aligned(void * s, int is_write, uint64_t offset, uint64_t bytes, int flags, int niov)
{
    if (true) {
        _nocheck__trace_nvme_prw_aligned(s, is_write, offset, bytes, flags, niov);
    }
}

#define TRACE_NVME_WRITE_ZEROES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_WRITE_ZEROES) || \
    false)

static inline void _nocheck__trace_nvme_write_zeroes(void * s, uint64_t offset, uint64_t bytes, int flags)
{
    if (trace_event_get_state(TRACE_NVME_WRITE_ZEROES) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 149 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:nvme_write_zeroes " "s %p offset 0x%"PRIx64" bytes %"PRId64" flags %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, offset, bytes, flags);
#line 3871 "trace/trace-block.h"
        } else {
#line 149 "../block/trace-events"
            qemu_log("nvme_write_zeroes " "s %p offset 0x%"PRIx64" bytes %"PRId64" flags %d" "\n", s, offset, bytes, flags);
#line 3875 "trace/trace-block.h"
        }
    }
}

static inline void trace_nvme_write_zeroes(void * s, uint64_t offset, uint64_t bytes, int flags)
{
    if (true) {
        _nocheck__trace_nvme_write_zeroes(s, offset, bytes, flags);
    }
}

#define TRACE_NVME_QIOV_UNALIGNED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_QIOV_UNALIGNED) || \
    false)

static inline void _nocheck__trace_nvme_qiov_unaligned(const void * qiov, int n, void * base, size_t size, int align)
{
    if (trace_event_get_state(TRACE_NVME_QIOV_UNALIGNED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 150 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:nvme_qiov_unaligned " "qiov %p n %d base %p size 0x%zx align 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qiov, n, base, size, align);
#line 3902 "trace/trace-block.h"
        } else {
#line 150 "../block/trace-events"
            qemu_log("nvme_qiov_unaligned " "qiov %p n %d base %p size 0x%zx align 0x%x" "\n", qiov, n, base, size, align);
#line 3906 "trace/trace-block.h"
        }
    }
}

static inline void trace_nvme_qiov_unaligned(const void * qiov, int n, void * base, size_t size, int align)
{
    if (true) {
        _nocheck__trace_nvme_qiov_unaligned(qiov, n, base, size, align);
    }
}

#define TRACE_NVME_PRW_BUFFERED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_PRW_BUFFERED) || \
    false)

static inline void _nocheck__trace_nvme_prw_buffered(void * s, uint64_t offset, uint64_t bytes, int niov, int is_write)
{
    if (trace_event_get_state(TRACE_NVME_PRW_BUFFERED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 151 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:nvme_prw_buffered " "s %p offset 0x%"PRIx64" bytes %"PRId64" niov %d is_write %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, offset, bytes, niov, is_write);
#line 3933 "trace/trace-block.h"
        } else {
#line 151 "../block/trace-events"
            qemu_log("nvme_prw_buffered " "s %p offset 0x%"PRIx64" bytes %"PRId64" niov %d is_write %d" "\n", s, offset, bytes, niov, is_write);
#line 3937 "trace/trace-block.h"
        }
    }
}

static inline void trace_nvme_prw_buffered(void * s, uint64_t offset, uint64_t bytes, int niov, int is_write)
{
    if (true) {
        _nocheck__trace_nvme_prw_buffered(s, offset, bytes, niov, is_write);
    }
}

#define TRACE_NVME_RW_DONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_RW_DONE) || \
    false)

static inline void _nocheck__trace_nvme_rw_done(void * s, int is_write, uint64_t offset, uint64_t bytes, int ret)
{
    if (trace_event_get_state(TRACE_NVME_RW_DONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 152 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:nvme_rw_done " "s %p is_write %d offset 0x%"PRIx64" bytes %"PRId64" ret %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, is_write, offset, bytes, ret);
#line 3964 "trace/trace-block.h"
        } else {
#line 152 "../block/trace-events"
            qemu_log("nvme_rw_done " "s %p is_write %d offset 0x%"PRIx64" bytes %"PRId64" ret %d" "\n", s, is_write, offset, bytes, ret);
#line 3968 "trace/trace-block.h"
        }
    }
}

static inline void trace_nvme_rw_done(void * s, int is_write, uint64_t offset, uint64_t bytes, int ret)
{
    if (true) {
        _nocheck__trace_nvme_rw_done(s, is_write, offset, bytes, ret);
    }
}

#define TRACE_NVME_DSM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_DSM) || \
    false)

static inline void _nocheck__trace_nvme_dsm(void * s, int64_t offset, int64_t bytes)
{
    if (trace_event_get_state(TRACE_NVME_DSM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 153 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:nvme_dsm " "s %p offset 0x%"PRIx64" bytes %"PRId64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, offset, bytes);
#line 3995 "trace/trace-block.h"
        } else {
#line 153 "../block/trace-events"
            qemu_log("nvme_dsm " "s %p offset 0x%"PRIx64" bytes %"PRId64"" "\n", s, offset, bytes);
#line 3999 "trace/trace-block.h"
        }
    }
}

static inline void trace_nvme_dsm(void * s, int64_t offset, int64_t bytes)
{
    if (true) {
        _nocheck__trace_nvme_dsm(s, offset, bytes);
    }
}

#define TRACE_NVME_DSM_DONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_DSM_DONE) || \
    false)

static inline void _nocheck__trace_nvme_dsm_done(void * s, int64_t offset, int64_t bytes, int ret)
{
    if (trace_event_get_state(TRACE_NVME_DSM_DONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 154 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:nvme_dsm_done " "s %p offset 0x%"PRIx64" bytes %"PRId64" ret %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, offset, bytes, ret);
#line 4026 "trace/trace-block.h"
        } else {
#line 154 "../block/trace-events"
            qemu_log("nvme_dsm_done " "s %p offset 0x%"PRIx64" bytes %"PRId64" ret %d" "\n", s, offset, bytes, ret);
#line 4030 "trace/trace-block.h"
        }
    }
}

static inline void trace_nvme_dsm_done(void * s, int64_t offset, int64_t bytes, int ret)
{
    if (true) {
        _nocheck__trace_nvme_dsm_done(s, offset, bytes, ret);
    }
}

#define TRACE_NVME_DMA_MAP_FLUSH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_DMA_MAP_FLUSH) || \
    false)

static inline void _nocheck__trace_nvme_dma_map_flush(void * s)
{
    if (trace_event_get_state(TRACE_NVME_DMA_MAP_FLUSH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 155 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:nvme_dma_map_flush " "s %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s);
#line 4057 "trace/trace-block.h"
        } else {
#line 155 "../block/trace-events"
            qemu_log("nvme_dma_map_flush " "s %p" "\n", s);
#line 4061 "trace/trace-block.h"
        }
    }
}

static inline void trace_nvme_dma_map_flush(void * s)
{
    if (true) {
        _nocheck__trace_nvme_dma_map_flush(s);
    }
}

#define TRACE_NVME_FREE_REQ_QUEUE_WAIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_FREE_REQ_QUEUE_WAIT) || \
    false)

static inline void _nocheck__trace_nvme_free_req_queue_wait(void * s, unsigned q_index)
{
    if (trace_event_get_state(TRACE_NVME_FREE_REQ_QUEUE_WAIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 156 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:nvme_free_req_queue_wait " "s %p q #%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, q_index);
#line 4088 "trace/trace-block.h"
        } else {
#line 156 "../block/trace-events"
            qemu_log("nvme_free_req_queue_wait " "s %p q #%u" "\n", s, q_index);
#line 4092 "trace/trace-block.h"
        }
    }
}

static inline void trace_nvme_free_req_queue_wait(void * s, unsigned q_index)
{
    if (true) {
        _nocheck__trace_nvme_free_req_queue_wait(s, q_index);
    }
}

#define TRACE_NVME_CREATE_QUEUE_PAIR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_CREATE_QUEUE_PAIR) || \
    false)

static inline void _nocheck__trace_nvme_create_queue_pair(unsigned q_index, void * q, size_t size, void * aio_context, int fd)
{
    if (trace_event_get_state(TRACE_NVME_CREATE_QUEUE_PAIR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 157 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:nvme_create_queue_pair " "index %u q %p size %zu aioctx %p fd %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , q_index, q, size, aio_context, fd);
#line 4119 "trace/trace-block.h"
        } else {
#line 157 "../block/trace-events"
            qemu_log("nvme_create_queue_pair " "index %u q %p size %zu aioctx %p fd %d" "\n", q_index, q, size, aio_context, fd);
#line 4123 "trace/trace-block.h"
        }
    }
}

static inline void trace_nvme_create_queue_pair(unsigned q_index, void * q, size_t size, void * aio_context, int fd)
{
    if (true) {
        _nocheck__trace_nvme_create_queue_pair(q_index, q, size, aio_context, fd);
    }
}

#define TRACE_NVME_FREE_QUEUE_PAIR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_FREE_QUEUE_PAIR) || \
    false)

static inline void _nocheck__trace_nvme_free_queue_pair(unsigned q_index, void * q, void * cq, void * sq)
{
    if (trace_event_get_state(TRACE_NVME_FREE_QUEUE_PAIR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 158 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:nvme_free_queue_pair " "index %u q %p cq %p sq %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , q_index, q, cq, sq);
#line 4150 "trace/trace-block.h"
        } else {
#line 158 "../block/trace-events"
            qemu_log("nvme_free_queue_pair " "index %u q %p cq %p sq %p" "\n", q_index, q, cq, sq);
#line 4154 "trace/trace-block.h"
        }
    }
}

static inline void trace_nvme_free_queue_pair(unsigned q_index, void * q, void * cq, void * sq)
{
    if (true) {
        _nocheck__trace_nvme_free_queue_pair(q_index, q, cq, sq);
    }
}

#define TRACE_NVME_CMD_MAP_QIOV_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_CMD_MAP_QIOV) || \
    false)

static inline void _nocheck__trace_nvme_cmd_map_qiov(void * s, void * cmd, void * req, void * qiov, int entries)
{
    if (trace_event_get_state(TRACE_NVME_CMD_MAP_QIOV) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 159 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:nvme_cmd_map_qiov " "s %p cmd %p req %p qiov %p entries %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, cmd, req, qiov, entries);
#line 4181 "trace/trace-block.h"
        } else {
#line 159 "../block/trace-events"
            qemu_log("nvme_cmd_map_qiov " "s %p cmd %p req %p qiov %p entries %d" "\n", s, cmd, req, qiov, entries);
#line 4185 "trace/trace-block.h"
        }
    }
}

static inline void trace_nvme_cmd_map_qiov(void * s, void * cmd, void * req, void * qiov, int entries)
{
    if (true) {
        _nocheck__trace_nvme_cmd_map_qiov(s, cmd, req, qiov, entries);
    }
}

#define TRACE_NVME_CMD_MAP_QIOV_PAGES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_CMD_MAP_QIOV_PAGES) || \
    false)

static inline void _nocheck__trace_nvme_cmd_map_qiov_pages(void * s, int i, uint64_t page)
{
    if (trace_event_get_state(TRACE_NVME_CMD_MAP_QIOV_PAGES) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 160 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:nvme_cmd_map_qiov_pages " "s %p page[%d] 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, i, page);
#line 4212 "trace/trace-block.h"
        } else {
#line 160 "../block/trace-events"
            qemu_log("nvme_cmd_map_qiov_pages " "s %p page[%d] 0x%"PRIx64 "\n", s, i, page);
#line 4216 "trace/trace-block.h"
        }
    }
}

static inline void trace_nvme_cmd_map_qiov_pages(void * s, int i, uint64_t page)
{
    if (true) {
        _nocheck__trace_nvme_cmd_map_qiov_pages(s, i, page);
    }
}

#define TRACE_NVME_CMD_MAP_QIOV_IOV_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_CMD_MAP_QIOV_IOV) || \
    false)

static inline void _nocheck__trace_nvme_cmd_map_qiov_iov(void * s, int i, void * page, int pages)
{
    if (trace_event_get_state(TRACE_NVME_CMD_MAP_QIOV_IOV) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 161 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:nvme_cmd_map_qiov_iov " "s %p iov[%d] %p pages %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, i, page, pages);
#line 4243 "trace/trace-block.h"
        } else {
#line 161 "../block/trace-events"
            qemu_log("nvme_cmd_map_qiov_iov " "s %p iov[%d] %p pages %d" "\n", s, i, page, pages);
#line 4247 "trace/trace-block.h"
        }
    }
}

static inline void trace_nvme_cmd_map_qiov_iov(void * s, int i, void * page, int pages)
{
    if (true) {
        _nocheck__trace_nvme_cmd_map_qiov_iov(s, i, page, pages);
    }
}

#define TRACE_ISCSI_XCOPY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ISCSI_XCOPY) || \
    false)

static inline void _nocheck__trace_iscsi_xcopy(void * src_lun, uint64_t src_off, void * dst_lun, uint64_t dst_off, uint64_t bytes, int ret)
{
    if (trace_event_get_state(TRACE_ISCSI_XCOPY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 164 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:iscsi_xcopy " "src_lun %p offset %"PRIu64" dst_lun %p offset %"PRIu64" bytes %"PRIu64" ret %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , src_lun, src_off, dst_lun, dst_off, bytes, ret);
#line 4274 "trace/trace-block.h"
        } else {
#line 164 "../block/trace-events"
            qemu_log("iscsi_xcopy " "src_lun %p offset %"PRIu64" dst_lun %p offset %"PRIu64" bytes %"PRIu64" ret %d" "\n", src_lun, src_off, dst_lun, dst_off, bytes, ret);
#line 4278 "trace/trace-block.h"
        }
    }
}

static inline void trace_iscsi_xcopy(void * src_lun, uint64_t src_off, void * dst_lun, uint64_t dst_off, uint64_t bytes, int ret)
{
    if (true) {
        _nocheck__trace_iscsi_xcopy(src_lun, src_off, dst_lun, dst_off, bytes, ret);
    }
}

#define TRACE_NBD_PARSE_BLOCKSTATUS_COMPLIANCE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NBD_PARSE_BLOCKSTATUS_COMPLIANCE) || \
    false)

static inline void _nocheck__trace_nbd_parse_blockstatus_compliance(const char * err)
{
    if (trace_event_get_state(TRACE_NBD_PARSE_BLOCKSTATUS_COMPLIANCE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 167 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:nbd_parse_blockstatus_compliance " "ignoring extra data from non-compliant server: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , err);
#line 4305 "trace/trace-block.h"
        } else {
#line 167 "../block/trace-events"
            qemu_log("nbd_parse_blockstatus_compliance " "ignoring extra data from non-compliant server: %s" "\n", err);
#line 4309 "trace/trace-block.h"
        }
    }
}

static inline void trace_nbd_parse_blockstatus_compliance(const char * err)
{
    if (true) {
        _nocheck__trace_nbd_parse_blockstatus_compliance(err);
    }
}

#define TRACE_NBD_STRUCTURED_READ_COMPLIANCE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NBD_STRUCTURED_READ_COMPLIANCE) || \
    false)

static inline void _nocheck__trace_nbd_structured_read_compliance(const char * type)
{
    if (trace_event_get_state(TRACE_NBD_STRUCTURED_READ_COMPLIANCE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 168 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:nbd_structured_read_compliance " "server sent non-compliant unaligned read %s chunk" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type);
#line 4336 "trace/trace-block.h"
        } else {
#line 168 "../block/trace-events"
            qemu_log("nbd_structured_read_compliance " "server sent non-compliant unaligned read %s chunk" "\n", type);
#line 4340 "trace/trace-block.h"
        }
    }
}

static inline void trace_nbd_structured_read_compliance(const char * type)
{
    if (true) {
        _nocheck__trace_nbd_structured_read_compliance(type);
    }
}

#define TRACE_NBD_EXTENDED_HEADERS_COMPLIANCE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NBD_EXTENDED_HEADERS_COMPLIANCE) || \
    false)

static inline void _nocheck__trace_nbd_extended_headers_compliance(const char * type)
{
    if (trace_event_get_state(TRACE_NBD_EXTENDED_HEADERS_COMPLIANCE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 169 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:nbd_extended_headers_compliance " "server sent non-compliant %s chunk not matching choice of extended headers" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type);
#line 4367 "trace/trace-block.h"
        } else {
#line 169 "../block/trace-events"
            qemu_log("nbd_extended_headers_compliance " "server sent non-compliant %s chunk not matching choice of extended headers" "\n", type);
#line 4371 "trace/trace-block.h"
        }
    }
}

static inline void trace_nbd_extended_headers_compliance(const char * type)
{
    if (true) {
        _nocheck__trace_nbd_extended_headers_compliance(type);
    }
}

#define TRACE_NBD_READ_REPLY_ENTRY_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NBD_READ_REPLY_ENTRY_FAIL) || \
    false)

static inline void _nocheck__trace_nbd_read_reply_entry_fail(int ret, const char * err)
{
    if (trace_event_get_state(TRACE_NBD_READ_REPLY_ENTRY_FAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 170 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:nbd_read_reply_entry_fail " "ret = %d, err: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ret, err);
#line 4398 "trace/trace-block.h"
        } else {
#line 170 "../block/trace-events"
            qemu_log("nbd_read_reply_entry_fail " "ret = %d, err: %s" "\n", ret, err);
#line 4402 "trace/trace-block.h"
        }
    }
}

static inline void trace_nbd_read_reply_entry_fail(int ret, const char * err)
{
    if (true) {
        _nocheck__trace_nbd_read_reply_entry_fail(ret, err);
    }
}

#define TRACE_NBD_CO_REQUEST_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NBD_CO_REQUEST_FAIL) || \
    false)

static inline void _nocheck__trace_nbd_co_request_fail(uint64_t from, uint64_t len, uint64_t handle, uint16_t flags, uint16_t type, const char * name, int ret, const char * err)
{
    if (trace_event_get_state(TRACE_NBD_CO_REQUEST_FAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 171 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:nbd_co_request_fail " "Request failed { .from = %" PRIu64", .len = %" PRIu64 ", .handle = %" PRIu64 ", .flags = 0x%" PRIx16 ", .type = %" PRIu16 " (%s) } ret = %d, err: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , from, len, handle, flags, type, name, ret, err);
#line 4429 "trace/trace-block.h"
        } else {
#line 171 "../block/trace-events"
            qemu_log("nbd_co_request_fail " "Request failed { .from = %" PRIu64", .len = %" PRIu64 ", .handle = %" PRIu64 ", .flags = 0x%" PRIx16 ", .type = %" PRIu16 " (%s) } ret = %d, err: %s" "\n", from, len, handle, flags, type, name, ret, err);
#line 4433 "trace/trace-block.h"
        }
    }
}

static inline void trace_nbd_co_request_fail(uint64_t from, uint64_t len, uint64_t handle, uint16_t flags, uint16_t type, const char * name, int ret, const char * err)
{
    if (true) {
        _nocheck__trace_nbd_co_request_fail(from, len, handle, flags, type, name, ret, err);
    }
}

#define TRACE_NBD_CLIENT_HANDSHAKE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NBD_CLIENT_HANDSHAKE) || \
    false)

static inline void _nocheck__trace_nbd_client_handshake(const char * export_name)
{
    if (trace_event_get_state(TRACE_NBD_CLIENT_HANDSHAKE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 172 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:nbd_client_handshake " "export '%s'" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , export_name);
#line 4460 "trace/trace-block.h"
        } else {
#line 172 "../block/trace-events"
            qemu_log("nbd_client_handshake " "export '%s'" "\n", export_name);
#line 4464 "trace/trace-block.h"
        }
    }
}

static inline void trace_nbd_client_handshake(const char * export_name)
{
    if (true) {
        _nocheck__trace_nbd_client_handshake(export_name);
    }
}

#define TRACE_NBD_CLIENT_HANDSHAKE_SUCCESS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NBD_CLIENT_HANDSHAKE_SUCCESS) || \
    false)

static inline void _nocheck__trace_nbd_client_handshake_success(const char * export_name)
{
    if (trace_event_get_state(TRACE_NBD_CLIENT_HANDSHAKE_SUCCESS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 173 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:nbd_client_handshake_success " "export '%s'" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , export_name);
#line 4491 "trace/trace-block.h"
        } else {
#line 173 "../block/trace-events"
            qemu_log("nbd_client_handshake_success " "export '%s'" "\n", export_name);
#line 4495 "trace/trace-block.h"
        }
    }
}

static inline void trace_nbd_client_handshake_success(const char * export_name)
{
    if (true) {
        _nocheck__trace_nbd_client_handshake_success(export_name);
    }
}

#define TRACE_NBD_RECONNECT_ATTEMPT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NBD_RECONNECT_ATTEMPT) || \
    false)

static inline void _nocheck__trace_nbd_reconnect_attempt(unsigned in_flight)
{
    if (trace_event_get_state(TRACE_NBD_RECONNECT_ATTEMPT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 174 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:nbd_reconnect_attempt " "in_flight %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , in_flight);
#line 4522 "trace/trace-block.h"
        } else {
#line 174 "../block/trace-events"
            qemu_log("nbd_reconnect_attempt " "in_flight %u" "\n", in_flight);
#line 4526 "trace/trace-block.h"
        }
    }
}

static inline void trace_nbd_reconnect_attempt(unsigned in_flight)
{
    if (true) {
        _nocheck__trace_nbd_reconnect_attempt(in_flight);
    }
}

#define TRACE_NBD_RECONNECT_ATTEMPT_RESULT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NBD_RECONNECT_ATTEMPT_RESULT) || \
    false)

static inline void _nocheck__trace_nbd_reconnect_attempt_result(int ret, unsigned in_flight)
{
    if (trace_event_get_state(TRACE_NBD_RECONNECT_ATTEMPT_RESULT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 175 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:nbd_reconnect_attempt_result " "ret %d in_flight %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ret, in_flight);
#line 4553 "trace/trace-block.h"
        } else {
#line 175 "../block/trace-events"
            qemu_log("nbd_reconnect_attempt_result " "ret %d in_flight %u" "\n", ret, in_flight);
#line 4557 "trace/trace-block.h"
        }
    }
}

static inline void trace_nbd_reconnect_attempt_result(int ret, unsigned in_flight)
{
    if (true) {
        _nocheck__trace_nbd_reconnect_attempt_result(ret, in_flight);
    }
}

#define TRACE_SSH_RESTART_COROUTINE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SSH_RESTART_COROUTINE) || \
    false)

static inline void _nocheck__trace_ssh_restart_coroutine(void * co)
{
    if (trace_event_get_state(TRACE_SSH_RESTART_COROUTINE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 178 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:ssh_restart_coroutine " "co=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , co);
#line 4584 "trace/trace-block.h"
        } else {
#line 178 "../block/trace-events"
            qemu_log("ssh_restart_coroutine " "co=%p" "\n", co);
#line 4588 "trace/trace-block.h"
        }
    }
}

static inline void trace_ssh_restart_coroutine(void * co)
{
    if (true) {
        _nocheck__trace_ssh_restart_coroutine(co);
    }
}

#define TRACE_SSH_FLUSH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SSH_FLUSH) || \
    false)

static inline void _nocheck__trace_ssh_flush(void)
{
    if (trace_event_get_state(TRACE_SSH_FLUSH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 179 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:ssh_flush " "fsync" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 4615 "trace/trace-block.h"
        } else {
#line 179 "../block/trace-events"
            qemu_log("ssh_flush " "fsync" "\n");
#line 4619 "trace/trace-block.h"
        }
    }
}

static inline void trace_ssh_flush(void)
{
    if (true) {
        _nocheck__trace_ssh_flush();
    }
}

#define TRACE_SSH_CHECK_HOST_KEY_KNOWNHOSTS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SSH_CHECK_HOST_KEY_KNOWNHOSTS) || \
    false)

static inline void _nocheck__trace_ssh_check_host_key_knownhosts(void)
{
    if (trace_event_get_state(TRACE_SSH_CHECK_HOST_KEY_KNOWNHOSTS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 180 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:ssh_check_host_key_knownhosts " "host key OK" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 4646 "trace/trace-block.h"
        } else {
#line 180 "../block/trace-events"
            qemu_log("ssh_check_host_key_knownhosts " "host key OK" "\n");
#line 4650 "trace/trace-block.h"
        }
    }
}

static inline void trace_ssh_check_host_key_knownhosts(void)
{
    if (true) {
        _nocheck__trace_ssh_check_host_key_knownhosts();
    }
}

#define TRACE_SSH_CONNECT_TO_SSH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SSH_CONNECT_TO_SSH) || \
    false)

static inline void _nocheck__trace_ssh_connect_to_ssh(char * path, int flags, int mode)
{
    if (trace_event_get_state(TRACE_SSH_CONNECT_TO_SSH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 181 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:ssh_connect_to_ssh " "opening file %s flags=0x%x creat_mode=0%o" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , path, flags, mode);
#line 4677 "trace/trace-block.h"
        } else {
#line 181 "../block/trace-events"
            qemu_log("ssh_connect_to_ssh " "opening file %s flags=0x%x creat_mode=0%o" "\n", path, flags, mode);
#line 4681 "trace/trace-block.h"
        }
    }
}

static inline void trace_ssh_connect_to_ssh(char * path, int flags, int mode)
{
    if (true) {
        _nocheck__trace_ssh_connect_to_ssh(path, flags, mode);
    }
}

#define TRACE_SSH_CO_YIELD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SSH_CO_YIELD) || \
    false)

static inline void _nocheck__trace_ssh_co_yield(int sock, void * rd_handler, void * wr_handler)
{
    if (trace_event_get_state(TRACE_SSH_CO_YIELD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 182 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:ssh_co_yield " "s->sock=%d rd_handler=%p wr_handler=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , sock, rd_handler, wr_handler);
#line 4708 "trace/trace-block.h"
        } else {
#line 182 "../block/trace-events"
            qemu_log("ssh_co_yield " "s->sock=%d rd_handler=%p wr_handler=%p" "\n", sock, rd_handler, wr_handler);
#line 4712 "trace/trace-block.h"
        }
    }
}

static inline void trace_ssh_co_yield(int sock, void * rd_handler, void * wr_handler)
{
    if (true) {
        _nocheck__trace_ssh_co_yield(sock, rd_handler, wr_handler);
    }
}

#define TRACE_SSH_CO_YIELD_BACK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SSH_CO_YIELD_BACK) || \
    false)

static inline void _nocheck__trace_ssh_co_yield_back(int sock)
{
    if (trace_event_get_state(TRACE_SSH_CO_YIELD_BACK) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 183 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:ssh_co_yield_back " "s->sock=%d - back" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , sock);
#line 4739 "trace/trace-block.h"
        } else {
#line 183 "../block/trace-events"
            qemu_log("ssh_co_yield_back " "s->sock=%d - back" "\n", sock);
#line 4743 "trace/trace-block.h"
        }
    }
}

static inline void trace_ssh_co_yield_back(int sock)
{
    if (true) {
        _nocheck__trace_ssh_co_yield_back(sock);
    }
}

#define TRACE_SSH_GETLENGTH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SSH_GETLENGTH) || \
    false)

static inline void _nocheck__trace_ssh_getlength(int64_t length)
{
    if (trace_event_get_state(TRACE_SSH_GETLENGTH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 184 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:ssh_getlength " "length=%" PRIi64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , length);
#line 4770 "trace/trace-block.h"
        } else {
#line 184 "../block/trace-events"
            qemu_log("ssh_getlength " "length=%" PRIi64 "\n", length);
#line 4774 "trace/trace-block.h"
        }
    }
}

static inline void trace_ssh_getlength(int64_t length)
{
    if (true) {
        _nocheck__trace_ssh_getlength(length);
    }
}

#define TRACE_SSH_CO_CREATE_OPTS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SSH_CO_CREATE_OPTS) || \
    false)

static inline void _nocheck__trace_ssh_co_create_opts(uint64_t size)
{
    if (trace_event_get_state(TRACE_SSH_CO_CREATE_OPTS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 185 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:ssh_co_create_opts " "total_size=%" PRIu64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , size);
#line 4801 "trace/trace-block.h"
        } else {
#line 185 "../block/trace-events"
            qemu_log("ssh_co_create_opts " "total_size=%" PRIu64 "\n", size);
#line 4805 "trace/trace-block.h"
        }
    }
}

static inline void trace_ssh_co_create_opts(uint64_t size)
{
    if (true) {
        _nocheck__trace_ssh_co_create_opts(size);
    }
}

#define TRACE_SSH_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SSH_READ) || \
    false)

static inline void _nocheck__trace_ssh_read(int64_t offset, size_t size)
{
    if (trace_event_get_state(TRACE_SSH_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 186 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:ssh_read " "offset=%" PRIi64 " size=%zu" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, size);
#line 4832 "trace/trace-block.h"
        } else {
#line 186 "../block/trace-events"
            qemu_log("ssh_read " "offset=%" PRIi64 " size=%zu" "\n", offset, size);
#line 4836 "trace/trace-block.h"
        }
    }
}

static inline void trace_ssh_read(int64_t offset, size_t size)
{
    if (true) {
        _nocheck__trace_ssh_read(offset, size);
    }
}

#define TRACE_SSH_READ_BUF_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SSH_READ_BUF) || \
    false)

static inline void _nocheck__trace_ssh_read_buf(void * buf, size_t size, size_t actual_size)
{
    if (trace_event_get_state(TRACE_SSH_READ_BUF) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 187 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:ssh_read_buf " "sftp_read buf=%p size=%zu (actual size=%zu)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , buf, size, actual_size);
#line 4863 "trace/trace-block.h"
        } else {
#line 187 "../block/trace-events"
            qemu_log("ssh_read_buf " "sftp_read buf=%p size=%zu (actual size=%zu)" "\n", buf, size, actual_size);
#line 4867 "trace/trace-block.h"
        }
    }
}

static inline void trace_ssh_read_buf(void * buf, size_t size, size_t actual_size)
{
    if (true) {
        _nocheck__trace_ssh_read_buf(buf, size, actual_size);
    }
}

#define TRACE_SSH_READ_RETURN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SSH_READ_RETURN) || \
    false)

static inline void _nocheck__trace_ssh_read_return(ssize_t ret, int sftp_err)
{
    if (trace_event_get_state(TRACE_SSH_READ_RETURN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 188 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:ssh_read_return " "sftp_read returned %zd (sftp error=%d)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ret, sftp_err);
#line 4894 "trace/trace-block.h"
        } else {
#line 188 "../block/trace-events"
            qemu_log("ssh_read_return " "sftp_read returned %zd (sftp error=%d)" "\n", ret, sftp_err);
#line 4898 "trace/trace-block.h"
        }
    }
}

static inline void trace_ssh_read_return(ssize_t ret, int sftp_err)
{
    if (true) {
        _nocheck__trace_ssh_read_return(ret, sftp_err);
    }
}

#define TRACE_SSH_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SSH_WRITE) || \
    false)

static inline void _nocheck__trace_ssh_write(int64_t offset, size_t size)
{
    if (trace_event_get_state(TRACE_SSH_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 189 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:ssh_write " "offset=%" PRIi64 " size=%zu" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, size);
#line 4925 "trace/trace-block.h"
        } else {
#line 189 "../block/trace-events"
            qemu_log("ssh_write " "offset=%" PRIi64 " size=%zu" "\n", offset, size);
#line 4929 "trace/trace-block.h"
        }
    }
}

static inline void trace_ssh_write(int64_t offset, size_t size)
{
    if (true) {
        _nocheck__trace_ssh_write(offset, size);
    }
}

#define TRACE_SSH_WRITE_BUF_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SSH_WRITE_BUF) || \
    false)

static inline void _nocheck__trace_ssh_write_buf(void * buf, size_t size, size_t actual_size)
{
    if (trace_event_get_state(TRACE_SSH_WRITE_BUF) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 190 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:ssh_write_buf " "sftp_write buf=%p size=%zu (actual size=%zu)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , buf, size, actual_size);
#line 4956 "trace/trace-block.h"
        } else {
#line 190 "../block/trace-events"
            qemu_log("ssh_write_buf " "sftp_write buf=%p size=%zu (actual size=%zu)" "\n", buf, size, actual_size);
#line 4960 "trace/trace-block.h"
        }
    }
}

static inline void trace_ssh_write_buf(void * buf, size_t size, size_t actual_size)
{
    if (true) {
        _nocheck__trace_ssh_write_buf(buf, size, actual_size);
    }
}

#define TRACE_SSH_WRITE_RETURN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SSH_WRITE_RETURN) || \
    false)

static inline void _nocheck__trace_ssh_write_return(ssize_t ret, int sftp_err)
{
    if (trace_event_get_state(TRACE_SSH_WRITE_RETURN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 191 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:ssh_write_return " "sftp_write returned %zd (sftp error=%d)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ret, sftp_err);
#line 4987 "trace/trace-block.h"
        } else {
#line 191 "../block/trace-events"
            qemu_log("ssh_write_return " "sftp_write returned %zd (sftp error=%d)" "\n", ret, sftp_err);
#line 4991 "trace/trace-block.h"
        }
    }
}

static inline void trace_ssh_write_return(ssize_t ret, int sftp_err)
{
    if (true) {
        _nocheck__trace_ssh_write_return(ret, sftp_err);
    }
}

#define TRACE_SSH_SEEK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SSH_SEEK) || \
    false)

static inline void _nocheck__trace_ssh_seek(int64_t offset)
{
    if (trace_event_get_state(TRACE_SSH_SEEK) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 192 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:ssh_seek " "seeking to offset=%" PRIi64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset);
#line 5018 "trace/trace-block.h"
        } else {
#line 192 "../block/trace-events"
            qemu_log("ssh_seek " "seeking to offset=%" PRIi64 "\n", offset);
#line 5022 "trace/trace-block.h"
        }
    }
}

static inline void trace_ssh_seek(int64_t offset)
{
    if (true) {
        _nocheck__trace_ssh_seek(offset);
    }
}

#define TRACE_SSH_AUTH_METHODS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SSH_AUTH_METHODS) || \
    false)

static inline void _nocheck__trace_ssh_auth_methods(int methods)
{
    if (trace_event_get_state(TRACE_SSH_AUTH_METHODS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 193 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:ssh_auth_methods " "auth methods=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , methods);
#line 5049 "trace/trace-block.h"
        } else {
#line 193 "../block/trace-events"
            qemu_log("ssh_auth_methods " "auth methods=0x%x" "\n", methods);
#line 5053 "trace/trace-block.h"
        }
    }
}

static inline void trace_ssh_auth_methods(int methods)
{
    if (true) {
        _nocheck__trace_ssh_auth_methods(methods);
    }
}

#define TRACE_SSH_SERVER_STATUS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SSH_SERVER_STATUS) || \
    false)

static inline void _nocheck__trace_ssh_server_status(int status)
{
    if (trace_event_get_state(TRACE_SSH_SERVER_STATUS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 194 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:ssh_server_status " "server status=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , status);
#line 5080 "trace/trace-block.h"
        } else {
#line 194 "../block/trace-events"
            qemu_log("ssh_server_status " "server status=%d" "\n", status);
#line 5084 "trace/trace-block.h"
        }
    }
}

static inline void trace_ssh_server_status(int status)
{
    if (true) {
        _nocheck__trace_ssh_server_status(status);
    }
}

#define TRACE_CURL_TIMER_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CURL_TIMER_CB) || \
    false)

static inline void _nocheck__trace_curl_timer_cb(long timeout_ms)
{
    if (trace_event_get_state(TRACE_CURL_TIMER_CB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 197 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:curl_timer_cb " "timer callback timeout_ms %ld" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , timeout_ms);
#line 5111 "trace/trace-block.h"
        } else {
#line 197 "../block/trace-events"
            qemu_log("curl_timer_cb " "timer callback timeout_ms %ld" "\n", timeout_ms);
#line 5115 "trace/trace-block.h"
        }
    }
}

static inline void trace_curl_timer_cb(long timeout_ms)
{
    if (true) {
        _nocheck__trace_curl_timer_cb(timeout_ms);
    }
}

#define TRACE_CURL_SOCK_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CURL_SOCK_CB) || \
    false)

static inline void _nocheck__trace_curl_sock_cb(int action, int fd)
{
    if (trace_event_get_state(TRACE_CURL_SOCK_CB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 198 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:curl_sock_cb " "sock action %d on fd %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , action, fd);
#line 5142 "trace/trace-block.h"
        } else {
#line 198 "../block/trace-events"
            qemu_log("curl_sock_cb " "sock action %d on fd %d" "\n", action, fd);
#line 5146 "trace/trace-block.h"
        }
    }
}

static inline void trace_curl_sock_cb(int action, int fd)
{
    if (true) {
        _nocheck__trace_curl_sock_cb(action, fd);
    }
}

#define TRACE_CURL_READ_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CURL_READ_CB) || \
    false)

static inline void _nocheck__trace_curl_read_cb(size_t realsize)
{
    if (trace_event_get_state(TRACE_CURL_READ_CB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 199 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:curl_read_cb " "just reading %zu bytes" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , realsize);
#line 5173 "trace/trace-block.h"
        } else {
#line 199 "../block/trace-events"
            qemu_log("curl_read_cb " "just reading %zu bytes" "\n", realsize);
#line 5177 "trace/trace-block.h"
        }
    }
}

static inline void trace_curl_read_cb(size_t realsize)
{
    if (true) {
        _nocheck__trace_curl_read_cb(realsize);
    }
}

#define TRACE_CURL_OPEN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CURL_OPEN) || \
    false)

static inline void _nocheck__trace_curl_open(const char * file)
{
    if (trace_event_get_state(TRACE_CURL_OPEN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 200 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:curl_open " "opening %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , file);
#line 5204 "trace/trace-block.h"
        } else {
#line 200 "../block/trace-events"
            qemu_log("curl_open " "opening %s" "\n", file);
#line 5208 "trace/trace-block.h"
        }
    }
}

static inline void trace_curl_open(const char * file)
{
    if (true) {
        _nocheck__trace_curl_open(file);
    }
}

#define TRACE_CURL_OPEN_SIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CURL_OPEN_SIZE) || \
    false)

static inline void _nocheck__trace_curl_open_size(uint64_t size)
{
    if (trace_event_get_state(TRACE_CURL_OPEN_SIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 201 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:curl_open_size " "size = %" PRIu64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , size);
#line 5235 "trace/trace-block.h"
        } else {
#line 201 "../block/trace-events"
            qemu_log("curl_open_size " "size = %" PRIu64 "\n", size);
#line 5239 "trace/trace-block.h"
        }
    }
}

static inline void trace_curl_open_size(uint64_t size)
{
    if (true) {
        _nocheck__trace_curl_open_size(size);
    }
}

#define TRACE_CURL_SETUP_PREADV_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CURL_SETUP_PREADV) || \
    false)

static inline void _nocheck__trace_curl_setup_preadv(uint64_t bytes, uint64_t start, const char * range)
{
    if (trace_event_get_state(TRACE_CURL_SETUP_PREADV) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 202 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:curl_setup_preadv " "reading %" PRIu64 " at %" PRIu64 " (%s)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bytes, start, range);
#line 5266 "trace/trace-block.h"
        } else {
#line 202 "../block/trace-events"
            qemu_log("curl_setup_preadv " "reading %" PRIu64 " at %" PRIu64 " (%s)" "\n", bytes, start, range);
#line 5270 "trace/trace-block.h"
        }
    }
}

static inline void trace_curl_setup_preadv(uint64_t bytes, uint64_t start, const char * range)
{
    if (true) {
        _nocheck__trace_curl_setup_preadv(bytes, start, range);
    }
}

#define TRACE_CURL_CLOSE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CURL_CLOSE) || \
    false)

static inline void _nocheck__trace_curl_close(void)
{
    if (trace_event_get_state(TRACE_CURL_CLOSE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 203 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:curl_close " "close" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 5297 "trace/trace-block.h"
        } else {
#line 203 "../block/trace-events"
            qemu_log("curl_close " "close" "\n");
#line 5301 "trace/trace-block.h"
        }
    }
}

static inline void trace_curl_close(void)
{
    if (true) {
        _nocheck__trace_curl_close();
    }
}

#define TRACE_FILE_COPY_FILE_RANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_FILE_COPY_FILE_RANGE) || \
    false)

static inline void _nocheck__trace_file_copy_file_range(void * bs, int src, int64_t src_off, int dst, int64_t dst_off, int64_t bytes, int flags, int64_t ret)
{
    if (trace_event_get_state(TRACE_FILE_COPY_FILE_RANGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 206 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:file_copy_file_range " "bs %p src_fd %d offset %"PRIu64" dst_fd %d offset %"PRIu64" bytes %"PRIu64" flags %d ret %"PRId64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bs, src, src_off, dst, dst_off, bytes, flags, ret);
#line 5328 "trace/trace-block.h"
        } else {
#line 206 "../block/trace-events"
            qemu_log("file_copy_file_range " "bs %p src_fd %d offset %"PRIu64" dst_fd %d offset %"PRIu64" bytes %"PRIu64" flags %d ret %"PRId64 "\n", bs, src, src_off, dst, dst_off, bytes, flags, ret);
#line 5332 "trace/trace-block.h"
        }
    }
}

static inline void trace_file_copy_file_range(void * bs, int src, int64_t src_off, int dst, int64_t dst_off, int64_t bytes, int flags, int64_t ret)
{
    if (true) {
        _nocheck__trace_file_copy_file_range(bs, src, src_off, dst, dst_off, bytes, flags, ret);
    }
}

#define TRACE_FILE_FINDEJECTABLEOPTICALMEDIA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_FILE_FINDEJECTABLEOPTICALMEDIA) || \
    false)

static inline void _nocheck__trace_file_FindEjectableOpticalMedia(const char * media)
{
    if (trace_event_get_state(TRACE_FILE_FINDEJECTABLEOPTICALMEDIA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 207 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:file_FindEjectableOpticalMedia " "Matching using %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , media);
#line 5359 "trace/trace-block.h"
        } else {
#line 207 "../block/trace-events"
            qemu_log("file_FindEjectableOpticalMedia " "Matching using %s" "\n", media);
#line 5363 "trace/trace-block.h"
        }
    }
}

static inline void trace_file_FindEjectableOpticalMedia(const char * media)
{
    if (true) {
        _nocheck__trace_file_FindEjectableOpticalMedia(media);
    }
}

#define TRACE_FILE_SETUP_CDROM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_FILE_SETUP_CDROM) || \
    false)

static inline void _nocheck__trace_file_setup_cdrom(const char * partition)
{
    if (trace_event_get_state(TRACE_FILE_SETUP_CDROM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 208 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:file_setup_cdrom " "Using %s as optical disc" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , partition);
#line 5390 "trace/trace-block.h"
        } else {
#line 208 "../block/trace-events"
            qemu_log("file_setup_cdrom " "Using %s as optical disc" "\n", partition);
#line 5394 "trace/trace-block.h"
        }
    }
}

static inline void trace_file_setup_cdrom(const char * partition)
{
    if (true) {
        _nocheck__trace_file_setup_cdrom(partition);
    }
}

#define TRACE_FILE_HDEV_IS_SG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_FILE_HDEV_IS_SG) || \
    false)

static inline void _nocheck__trace_file_hdev_is_sg(int type, int version)
{
    if (trace_event_get_state(TRACE_FILE_HDEV_IS_SG) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 209 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:file_hdev_is_sg " "SG device found: type=%d, version=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, version);
#line 5421 "trace/trace-block.h"
        } else {
#line 209 "../block/trace-events"
            qemu_log("file_hdev_is_sg " "SG device found: type=%d, version=%d" "\n", type, version);
#line 5425 "trace/trace-block.h"
        }
    }
}

static inline void trace_file_hdev_is_sg(int type, int version)
{
    if (true) {
        _nocheck__trace_file_hdev_is_sg(type, version);
    }
}

#define TRACE_FILE_FLUSH_FDATASYNC_FAILED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_FILE_FLUSH_FDATASYNC_FAILED) || \
    false)

static inline void _nocheck__trace_file_flush_fdatasync_failed(int err)
{
    if (trace_event_get_state(TRACE_FILE_FLUSH_FDATASYNC_FAILED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 210 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:file_flush_fdatasync_failed " "errno %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , err);
#line 5452 "trace/trace-block.h"
        } else {
#line 210 "../block/trace-events"
            qemu_log("file_flush_fdatasync_failed " "errno %d" "\n", err);
#line 5456 "trace/trace-block.h"
        }
    }
}

static inline void trace_file_flush_fdatasync_failed(int err)
{
    if (true) {
        _nocheck__trace_file_flush_fdatasync_failed(err);
    }
}

#define TRACE_ZBD_ZONE_REPORT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ZBD_ZONE_REPORT) || \
    false)

static inline void _nocheck__trace_zbd_zone_report(void * bs, unsigned int nr_zones, int64_t sector)
{
    if (trace_event_get_state(TRACE_ZBD_ZONE_REPORT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 211 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:zbd_zone_report " "bs %p report %d zones starting at sector offset 0x%" PRIx64 "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bs, nr_zones, sector);
#line 5483 "trace/trace-block.h"
        } else {
#line 211 "../block/trace-events"
            qemu_log("zbd_zone_report " "bs %p report %d zones starting at sector offset 0x%" PRIx64 "" "\n", bs, nr_zones, sector);
#line 5487 "trace/trace-block.h"
        }
    }
}

static inline void trace_zbd_zone_report(void * bs, unsigned int nr_zones, int64_t sector)
{
    if (true) {
        _nocheck__trace_zbd_zone_report(bs, nr_zones, sector);
    }
}

#define TRACE_ZBD_ZONE_MGMT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ZBD_ZONE_MGMT) || \
    false)

static inline void _nocheck__trace_zbd_zone_mgmt(void * bs, const char * op_name, int64_t sector, int64_t len)
{
    if (trace_event_get_state(TRACE_ZBD_ZONE_MGMT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 212 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:zbd_zone_mgmt " "bs %p %s starts at sector offset 0x%" PRIx64 " over a range of 0x%" PRIx64 " sectors" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bs, op_name, sector, len);
#line 5514 "trace/trace-block.h"
        } else {
#line 212 "../block/trace-events"
            qemu_log("zbd_zone_mgmt " "bs %p %s starts at sector offset 0x%" PRIx64 " over a range of 0x%" PRIx64 " sectors" "\n", bs, op_name, sector, len);
#line 5518 "trace/trace-block.h"
        }
    }
}

static inline void trace_zbd_zone_mgmt(void * bs, const char * op_name, int64_t sector, int64_t len)
{
    if (true) {
        _nocheck__trace_zbd_zone_mgmt(bs, op_name, sector, len);
    }
}

#define TRACE_ZBD_ZONE_APPEND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ZBD_ZONE_APPEND) || \
    false)

static inline void _nocheck__trace_zbd_zone_append(void * bs, int64_t sector)
{
    if (trace_event_get_state(TRACE_ZBD_ZONE_APPEND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 213 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:zbd_zone_append " "bs %p append at sector offset 0x%" PRIx64 "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bs, sector);
#line 5545 "trace/trace-block.h"
        } else {
#line 213 "../block/trace-events"
            qemu_log("zbd_zone_append " "bs %p append at sector offset 0x%" PRIx64 "" "\n", bs, sector);
#line 5549 "trace/trace-block.h"
        }
    }
}

static inline void trace_zbd_zone_append(void * bs, int64_t sector)
{
    if (true) {
        _nocheck__trace_zbd_zone_append(bs, sector);
    }
}

#define TRACE_ZBD_ZONE_APPEND_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ZBD_ZONE_APPEND_COMPLETE) || \
    false)

static inline void _nocheck__trace_zbd_zone_append_complete(void * bs, int64_t sector)
{
    if (trace_event_get_state(TRACE_ZBD_ZONE_APPEND_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 214 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:zbd_zone_append_complete " "bs %p returns append sector 0x%" PRIx64 "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bs, sector);
#line 5576 "trace/trace-block.h"
        } else {
#line 214 "../block/trace-events"
            qemu_log("zbd_zone_append_complete " "bs %p returns append sector 0x%" PRIx64 "" "\n", bs, sector);
#line 5580 "trace/trace-block.h"
        }
    }
}

static inline void trace_zbd_zone_append_complete(void * bs, int64_t sector)
{
    if (true) {
        _nocheck__trace_zbd_zone_append_complete(bs, sector);
    }
}

#define TRACE_SFTP_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SFTP_ERROR) || \
    false)

static inline void _nocheck__trace_sftp_error(const char * op, const char * ssh_err, int ssh_err_code, int sftp_err_code)
{
    if (trace_event_get_state(TRACE_SFTP_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 217 "../block/trace-events"
            qemu_log("%d@%zu.%06zu:sftp_error " "%s failed: %s (libssh error code: %d, sftp error code: %d)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , op, ssh_err, ssh_err_code, sftp_err_code);
#line 5607 "trace/trace-block.h"
        } else {
#line 217 "../block/trace-events"
            qemu_log("sftp_error " "%s failed: %s (libssh error code: %d, sftp error code: %d)" "\n", op, ssh_err, ssh_err_code, sftp_err_code);
#line 5611 "trace/trace-block.h"
        }
    }
}

static inline void trace_sftp_error(const char * op, const char * ssh_err, int ssh_err_code, int sftp_err_code)
{
    if (true) {
        _nocheck__trace_sftp_error(op, ssh_err, ssh_err_code, sftp_err_code);
    }
}
#endif /* TRACE_BLOCK_GENERATED_TRACERS_H */
